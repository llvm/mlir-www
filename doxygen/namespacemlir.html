<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">mlir Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Include the generated interface declarations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:acc" id="r_acc"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1acc.html">acc</a></td></tr>
<tr class="memitem:affine" id="r_affine"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html">affine</a></td></tr>
<tr class="memitem:amdgpu" id="r_amdgpu"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1amdgpu.html">amdgpu</a></td></tr>
<tr class="memitem:arith" id="r_arith"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1arith.html">arith</a></td></tr>
<tr class="memitem:arm_5Fneon" id="r_arm_5Fneon"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1arm__neon.html">arm_neon</a></td></tr>
<tr class="memitem:arm_5Fsme" id="r_arm_5Fsme"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1arm__sme.html">arm_sme</a></td></tr>
<tr class="memitem:arm_5Fsve" id="r_arm_5Fsve"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1arm__sve.html">arm_sve</a></td></tr>
<tr class="memitem:async" id="r_async"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1async.html">async</a></td></tr>
<tr class="memitem:AttributeTrait" id="r_AttributeTrait"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1AttributeTrait.html">AttributeTrait</a></td></tr>
<tr class="memdesc:namespacemlir_1_1AttributeTrait"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait is used to determine if an attribute is a dynamic attribute or not; it should only be implemented by dynamic attributes. <br /></td></tr>
<tr class="memitem:bufferization" id="r_bufferization"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html">bufferization</a></td></tr>
<tr class="memitem:builtin" id="r_builtin"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1builtin.html">builtin</a></td></tr>
<tr class="memitem:builtin_5Fdialect_5Fdetail" id="r_builtin_5Fdialect_5Fdetail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1builtin__dialect__detail.html">builtin_dialect_detail</a></td></tr>
<tr class="memitem:bytecode" id="r_bytecode"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bytecode.html">bytecode</a></td></tr>
<tr class="memitem:call_5Finterface_5Fimpl" id="r_call_5Finterface_5Fimpl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1call__interface__impl.html">call_interface_impl</a></td></tr>
<tr class="memitem:cf" id="r_cf"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1cf.html">cf</a></td></tr>
<tr class="memitem:complex" id="r_complex"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1complex.html">complex</a></td></tr>
<tr class="memitem:dataflow" id="r_dataflow"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1dataflow.html">dataflow</a></td></tr>
<tr class="memitem:detail" id="r_detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html">detail</a></td></tr>
<tr class="memdesc:namespacemlir_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1AttrTypeReplacer.html" title="This is an attribute/type replacer that is naively cached.">AttrTypeReplacer</a>. <br /></td></tr>
<tr class="memitem:dialect_5Fextension_5Fdetail" id="r_dialect_5Fextension_5Fdetail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1dialect__extension__detail.html">dialect_extension_detail</a></td></tr>
<tr class="memitem:dlti" id="r_dlti"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1dlti.html">dlti</a></td></tr>
<tr class="memitem:emitc" id="r_emitc"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1emitc.html">emitc</a></td></tr>
<tr class="memitem:func" id="r_func"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1func.html">func</a></td></tr>
<tr class="memitem:function_5Finterface_5Fimpl" id="r_function_5Finterface_5Fimpl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1function__interface__impl.html">function_interface_impl</a></td></tr>
<tr class="memitem:gpu" id="r_gpu"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1gpu.html">gpu</a></td></tr>
<tr class="memitem:impl" id="r_impl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html">impl</a></td></tr>
<tr class="memdesc:namespacemlir_1_1impl"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> collections provide a dictionary-like interface. <br /></td></tr>
<tr class="memitem:index" id="r_index"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1index.html">index</a></td></tr>
<tr class="memitem:intrange" id="r_intrange"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1intrange.html">intrange</a></td></tr>
<tr class="memitem:irdl" id="r_irdl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1irdl.html">irdl</a></td></tr>
<tr class="memitem:khr" id="r_khr"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1khr.html">khr</a></td></tr>
<tr class="memitem:linalg" id="r_linalg"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html">linalg</a></td></tr>
<tr class="memitem:LLVM" id="r_LLVM"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a></td></tr>
<tr class="memitem:lsp" id="r_lsp"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1lsp.html">lsp</a></td></tr>
<tr class="memitem:matchers" id="r_matchers"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1matchers.html">matchers</a></td></tr>
<tr class="memitem:math" id="r_math"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1math.html">math</a></td></tr>
<tr class="memitem:MemoryEffects" id="r_MemoryEffects"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1MemoryEffects.html">MemoryEffects</a></td></tr>
<tr class="memitem:memref" id="r_memref"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html">memref</a></td></tr>
<tr class="memitem:ml_5Fprogram" id="r_ml_5Fprogram"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1ml__program.html">ml_program</a></td></tr>
<tr class="memitem:mpi" id="r_mpi"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1mpi.html">mpi</a></td></tr>
<tr class="memitem:nvgpu" id="r_nvgpu"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1nvgpu.html">nvgpu</a></td></tr>
<tr class="memitem:NVVM" id="r_NVVM"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a></td></tr>
<tr class="memitem:omp" id="r_omp"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1omp.html">omp</a></td></tr>
<tr class="memitem:op_5Fdefinition_5Fimpl" id="r_op_5Fdefinition_5Fimpl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html">op_definition_impl</a></td></tr>
<tr class="memitem:OpTrait" id="r_OpTrait"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait.html">OpTrait</a></td></tr>
<tr class="memitem:pdl" id="r_pdl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1pdl.html">pdl</a></td></tr>
<tr class="memitem:pdl_5Fto_5Fpdl_5Finterp" id="r_pdl_5Fto_5Fpdl_5Finterp"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1pdl__to__pdl__interp.html">pdl_to_pdl_interp</a></td></tr>
<tr class="memitem:pdll" id="r_pdll"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1pdll.html">pdll</a></td></tr>
<tr class="memitem:presburger" id="r_presburger"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1presburger.html">presburger</a></td></tr>
<tr class="memitem:ptr" id="r_ptr"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1ptr.html">ptr</a></td></tr>
<tr class="memitem:python" id="r_python"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1python.html">python</a></td></tr>
<tr class="memitem:quant" id="r_quant"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1quant.html">quant</a></td></tr>
<tr class="memitem:query" id="r_query"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1query.html">query</a></td></tr>
<tr class="memitem:remark" id="r_remark"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1remark.html">remark</a></td></tr>
<tr class="memitem:ROCDL" id="r_ROCDL"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a></td></tr>
<tr class="memitem:runtime" id="r_runtime"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1runtime.html">runtime</a></td></tr>
<tr class="memitem:scf" id="r_scf"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html">scf</a></td></tr>
<tr class="memitem:shape" id="r_shape"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1shape.html">shape</a></td></tr>
<tr class="memitem:shard" id="r_shard"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1shard.html">shard</a></td></tr>
<tr class="memitem:SideEffects" id="r_SideEffects"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1SideEffects.html">SideEffects</a></td></tr>
<tr class="memitem:smt" id="r_smt"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1smt.html">smt</a></td></tr>
<tr class="memitem:sparse_5Ftensor" id="r_sparse_5Ftensor"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html">sparse_tensor</a></td></tr>
<tr class="memitem:Speculation" id="r_Speculation"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1Speculation.html">Speculation</a></td></tr>
<tr class="memitem:spirv" id="r_spirv"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html">spirv</a></td></tr>
<tr class="memitem:tblgen" id="r_tblgen"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tblgen.html">tblgen</a></td></tr>
<tr class="memitem:tensor" id="r_tensor"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html">tensor</a></td></tr>
<tr class="memitem:tosa" id="r_tosa"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tosa.html">tosa</a></td></tr>
<tr class="memitem:tracing" id="r_tracing"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tracing.html">tracing</a></td></tr>
<tr class="memitem:transform" id="r_transform"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1transform.html">transform</a></td></tr>
<tr class="memitem:TypeTrait" id="r_TypeTrait"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1TypeTrait.html">TypeTrait</a></td></tr>
<tr class="memdesc:namespacemlir_1_1TypeTrait"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait is used to determine if a type is a dynamic type or not; it should only be implemented by dynamic types. <br /></td></tr>
<tr class="memitem:ub" id="r_ub"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1ub.html">ub</a></td></tr>
<tr class="memitem:utils" id="r_utils"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1utils.html">utils</a></td></tr>
<tr class="memitem:vector" id="r_vector"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html">vector</a></td></tr>
<tr class="memitem:wasm" id="r_wasm"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1wasm.html">wasm</a></td></tr>
<tr class="memitem:wasmssa" id="r_wasmssa"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1wasmssa.html">wasmssa</a></td></tr>
<tr class="memitem:x86vector" id="r_x86vector"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1x86vector.html">x86vector</a></td></tr>
<tr class="memitem:xegpu" id="r_xegpu"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html">xegpu</a></td></tr>
<tr class="memitem:xevm" id="r_xevm"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xevm.html">xevm</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:AbstractAttribute" id="r_AbstractAttribute"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AbstractAttribute.html">AbstractAttribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the static information common to all instances of a registered <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>.  <a href="classmlir_1_1AbstractAttribute.html#details">More...</a><br /></td></tr>
<tr class="memitem:AbstractType" id="r_AbstractType"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AbstractType.html">AbstractType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the static information common to all instances of a registered <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a>.  <a href="classmlir_1_1AbstractType.html#details">More...</a><br /></td></tr>
<tr class="memitem:AffineBinaryOpExpr" id="r_AffineBinaryOpExpr"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineBinaryOpExpr.html">AffineBinaryOpExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Affine binary operation expression.  <a href="classmlir_1_1AffineBinaryOpExpr.html#details">More...</a><br /></td></tr>
<tr class="memitem:AffineConstantExpr" id="r_AffineConstantExpr"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineConstantExpr.html">AffineConstantExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer constant appearing in affine expression.  <a href="classmlir_1_1AffineConstantExpr.html#details">More...</a><br /></td></tr>
<tr class="memitem:AffineDimExpr" id="r_AffineDimExpr"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDimExpr.html">AffineDimExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimensional identifier appearing in an affine expression.  <a href="classmlir_1_1AffineDimExpr.html#details">More...</a><br /></td></tr>
<tr class="memitem:AffineExpr" id="r_AffineExpr"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for affine expression.  <a href="classmlir_1_1AffineExpr.html#details">More...</a><br /></td></tr>
<tr class="memitem:AffineExprVisitor" id="r_AffineExprVisitor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineExprVisitor.html">AffineExprVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">See documentation for <a class="el" href="classmlir_1_1AffineExprVisitorBase.html" title="Base class for AffineExpr visitors/walkers.">AffineExprVisitorBase</a>.  <a href="classmlir_1_1AffineExprVisitor.html#details">More...</a><br /></td></tr>
<tr class="memitem:AffineExprVisitor_3C_20SubClass_2C_20LogicalResult_20_3E" id="r_AffineExprVisitor_3C_20SubClass_2C_20LogicalResult_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineExprVisitor_3_01SubClass_00_01LogicalResult_01_4.html">AffineExprVisitor&lt; SubClass, LogicalResult &gt;</a></td></tr>
<tr class="memitem:AffineExprVisitorBase" id="r_AffineExprVisitorBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineExprVisitorBase.html">AffineExprVisitorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> visitors/walkers.  <a href="classmlir_1_1AffineExprVisitorBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:AffineMap" id="r_AffineMap"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-dimensional affine map Affine map's are immutable like <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a>'s, and they are uniqued.  <a href="classmlir_1_1AffineMap.html#details">More...</a><br /></td></tr>
<tr class="memitem:AffineSymbolExpr" id="r_AffineSymbolExpr"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineSymbolExpr.html">AffineSymbolExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A symbolic identifier appearing in an affine expression.  <a href="classmlir_1_1AffineSymbolExpr.html#details">More...</a><br /></td></tr>
<tr class="memitem:AliasAnalysis" id="r_AliasAnalysis"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AliasAnalysis.html">AliasAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the main alias analysis interface in MLIR.  <a href="classmlir_1_1AliasAnalysis.html#details">More...</a><br /></td></tr>
<tr class="memitem:AliasResult" id="r_AliasResult"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AliasResult.html">AliasResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible results of an alias query.  <a href="classmlir_1_1AliasResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:AnalysisManager" id="r_AnalysisManager"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AnalysisManager.html">AnalysisManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an analysis manager for a particular operation instance.  <a href="classmlir_1_1AnalysisManager.html#details">More...</a><br /></td></tr>
<tr class="memitem:AnalysisState" id="r_AnalysisState"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AnalysisState.html">AnalysisState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for generic analysis states.  <a href="classmlir_1_1AnalysisState.html#details">More...</a><br /></td></tr>
<tr class="memitem:ApplyPatternAction" id="r_ApplyPatternAction"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ApplyPatternAction.html">ApplyPatternAction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of Action that is dispatched when a pattern is applied.  <a href="classmlir_1_1ApplyPatternAction.html#details">More...</a><br /></td></tr>
<tr class="memitem:ArithBuilder" id="r_ArithBuilder"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ArithBuilder.html">ArithBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct to build simple arithmetic quantities with minimal type inference support.  <a href="structmlir_1_1ArithBuilder.html#details">More...</a><br /></td></tr>
<tr class="memitem:ArithIndexingBuilder" id="r_ArithIndexingBuilder"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ArithIndexingBuilder.html">ArithIndexingBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1ArithBuilder.html" title="Helper struct to build simple arithmetic quantities with minimal type inference support.">ArithBuilder</a> specialized specifically for tensor/memref indexing calculations.  <a href="structmlir_1_1ArithIndexingBuilder.html#details">More...</a><br /></td></tr>
<tr class="memitem:ArithToAMDGPUConversionPassOptions" id="r_ArithToAMDGPUConversionPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ArithToAMDGPUConversionPassOptions.html">ArithToAMDGPUConversionPassOptions</a></td></tr>
<tr class="memitem:ArithToLLVMConversionPassOptions" id="r_ArithToLLVMConversionPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ArithToLLVMConversionPassOptions.html">ArithToLLVMConversionPassOptions</a></td></tr>
<tr class="memitem:ArrayRef" id="r_ArrayRef"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ArrayRef.html">ArrayRef</a></td></tr>
<tr class="memitem:AsmDialectResourceHandle" id="r_AsmDialectResourceHandle"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmDialectResourceHandle.html">AsmDialectResourceHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an opaque handle to a dialect resource entry.  <a href="classmlir_1_1AsmDialectResourceHandle.html#details">More...</a><br /></td></tr>
<tr class="memitem:AsmDialectResourceHandleBase" id="r_AsmDialectResourceHandleBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmDialectResourceHandleBase.html">AsmDialectResourceHandleBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a CRTP base class for dialect resource handles.  <a href="classmlir_1_1AsmDialectResourceHandleBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:AsmParsedResourceEntry" id="r_AsmParsedResourceEntry"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParsedResourceEntry.html">AsmParsedResourceEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a single parsed resource entry.  <a href="classmlir_1_1AsmParsedResourceEntry.html#details">More...</a><br /></td></tr>
<tr class="memitem:AsmParser" id="r_AsmParser"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html">AsmParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This base class exposes generic asm parser hooks, usable across the various derived parsers.  <a href="classmlir_1_1AsmParser.html#details">More...</a><br /></td></tr>
<tr class="memitem:AsmParserCodeCompleteContext" id="r_AsmParserCodeCompleteContext"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParserCodeCompleteContext.html">AsmParserCodeCompleteContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an abstract interface into the parser for hooking in code completion events.  <a href="classmlir_1_1AsmParserCodeCompleteContext.html#details">More...</a><br /></td></tr>
<tr class="memitem:AsmParserState" id="r_AsmParserState"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParserState.html">AsmParserState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents state from a parsed MLIR textual format string.  <a href="classmlir_1_1AsmParserState.html#details">More...</a><br /></td></tr>
<tr class="memitem:AsmPrinter" id="r_AsmPrinter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This base class exposes generic asm printer hooks, usable across the various derived printers.  <a href="classmlir_1_1AsmPrinter.html#details">More...</a><br /></td></tr>
<tr class="memitem:AsmResourceBlob" id="r_AsmResourceBlob"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmResourceBlob.html">AsmResourceBlob</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a processed binary blob of data.  <a href="classmlir_1_1AsmResourceBlob.html#details">More...</a><br /></td></tr>
<tr class="memitem:AsmResourceBuilder" id="r_AsmResourceBuilder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmResourceBuilder.html">AsmResourceBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to build resource entries for use by the printer.  <a href="classmlir_1_1AsmResourceBuilder.html#details">More...</a><br /></td></tr>
<tr class="memitem:AsmResourceParser" id="r_AsmResourceParser"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmResourceParser.html">AsmResourceParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an instance of a resource parser.  <a href="classmlir_1_1AsmResourceParser.html#details">More...</a><br /></td></tr>
<tr class="memitem:AsmResourcePrinter" id="r_AsmResourcePrinter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmResourcePrinter.html">AsmResourcePrinter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an instance of a resource printer.  <a href="classmlir_1_1AsmResourcePrinter.html#details">More...</a><br /></td></tr>
<tr class="memitem:AsmState" id="r_AsmState"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmState.html">AsmState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides management for the lifetime of the state used when printing the IR.  <a href="classmlir_1_1AsmState.html#details">More...</a><br /></td></tr>
<tr class="memitem:AsyncParallelForPassOptions" id="r_AsyncParallelForPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AsyncParallelForPassOptions.html">AsyncParallelForPassOptions</a></td></tr>
<tr class="memitem:AttrConvertPassThrough" id="r_AttrConvertPassThrough"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AttrConvertPassThrough.html">AttrConvertPassThrough</a></td></tr>
<tr class="memitem:Attribute" id="r_Attribute"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes are known-constant values of operations.  <a href="classmlir_1_1Attribute.html#details">More...</a><br /></td></tr>
<tr class="memitem:AttributeInterface" id="r_AttributeInterface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AttributeInterface.html">AttributeInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the base of an attribute interface.  <a href="classmlir_1_1AttributeInterface.html#details">More...</a><br /></td></tr>
<tr class="memitem:AttributeStorage" id="r_AttributeStorage"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AttributeStorage.html">AttributeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base storage class appearing in an attribute.  <a href="classmlir_1_1AttributeStorage.html#details">More...</a><br /></td></tr>
<tr class="memitem:AttrTypeBytecodeReader" id="r_AttrTypeBytecodeReader"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AttrTypeBytecodeReader.html">AttrTypeBytecodeReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to interact with the attributes and types parser when parsing MLIR bytecode.  <a href="classmlir_1_1AttrTypeBytecodeReader.html#details">More...</a><br /></td></tr>
<tr class="memitem:AttrTypeBytecodeWriter" id="r_AttrTypeBytecodeWriter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AttrTypeBytecodeWriter.html">AttrTypeBytecodeWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to interact with the attributes and types printer when emitting MLIR bytecode.  <a href="classmlir_1_1AttrTypeBytecodeWriter.html#details">More...</a><br /></td></tr>
<tr class="memitem:AttrTypeImmediateSubElementWalker" id="r_AttrTypeImmediateSubElementWalker"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AttrTypeImmediateSubElementWalker.html">AttrTypeImmediateSubElementWalker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1AttrTypeSubElementHandler.html" title="This class provides support for interacting with the SubElementInterfaces for different types of para...">AttrTypeSubElementHandler</a>.  <a href="classmlir_1_1AttrTypeImmediateSubElementWalker.html#details">More...</a><br /></td></tr>
<tr class="memitem:AttrTypeReplacer" id="r_AttrTypeReplacer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AttrTypeReplacer.html">AttrTypeReplacer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an attribute/type replacer that is naively cached.  <a href="classmlir_1_1AttrTypeReplacer.html#details">More...</a><br /></td></tr>
<tr class="memitem:AttrTypeSubElementHandler" id="r_AttrTypeSubElementHandler"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AttrTypeSubElementHandler.html">AttrTypeSubElementHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides support for interacting with the SubElementInterfaces for different types of parameters.  <a href="structmlir_1_1AttrTypeSubElementHandler.html#details">More...</a><br /></td></tr>
<tr class="memitem:AttrTypeSubElementHandler_3C_20ArrayRef_3C_20T_20_3E_2C_20std_3A_3Aenable_5Fif_5Ft_3C_20has_5Fsub_5Fattr_5For_5Ftype_5Fv_3C_20T_20_3E_20_3E_20_3E" id="r_AttrTypeSubElementHandler_3C_20ArrayRef_3C_20T_20_3E_2C_20std_3A_3Aenable_5Fif_5Ft_3C_20has_5Fsub_5Fattr_5For_5Ftype_5Fv_3C_20T_20_3E_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AttrTypeSubElementHandler_3_01ArrayRef_3_01T_01_4_00_01std_1_1enable__if__t_3_01ha2f4efb8dddd480d9444418f314b80830.html">AttrTypeSubElementHandler&lt; ArrayRef&lt; T &gt;, std::enable_if_t&lt; has_sub_attr_or_type_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for derived <a class="el" href="classmlir_1_1ArrayRef.html">ArrayRef</a>.  <a href="structmlir_1_1AttrTypeSubElementHandler_3_01ArrayRef_3_01T_01_4_00_01std_1_1enable__if__t_3_01ha2f4efb8dddd480d9444418f314b80830.html#details">More...</a><br /></td></tr>
<tr class="memitem:AttrTypeSubElementHandler_3C_20LLVM_3A_3Adetail_3A_3ALLVMStructTypeStorage_3A_3AKey_20_3E" id="r_AttrTypeSubElementHandler_3C_20LLVM_3A_3Adetail_3A_3ALLVMStructTypeStorage_3A_3AKey_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AttrTypeSubElementHandler_3_01LLVM_1_1detail_1_1LLVMStructTypeStorage_1_1Key_01_4.html">AttrTypeSubElementHandler&lt; LLVM::detail::LLVMStructTypeStorage::Key &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow walking and replacing the subelements of a LLVMStructTypeStorage key.  <a href="structmlir_1_1AttrTypeSubElementHandler_3_01LLVM_1_1detail_1_1LLVMStructTypeStorage_1_1Key_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:AttrTypeSubElementHandler_3C_20Location_20_3E" id="r_AttrTypeSubElementHandler_3C_20Location_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AttrTypeSubElementHandler_3_01Location_01_4.html">AttrTypeSubElementHandler&lt; Location &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable locations to be introspected as sub-elements.  <a href="structmlir_1_1AttrTypeSubElementHandler_3_01Location_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:AttrTypeSubElementHandler_3C_20NamedAttribute_20_3E" id="r_AttrTypeSubElementHandler_3C_20NamedAttribute_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AttrTypeSubElementHandler_3_01NamedAttribute_01_4.html">AttrTypeSubElementHandler&lt; NamedAttribute &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow walking and replacing the subelements of a <a class="el" href="classmlir_1_1NamedAttribute.html" title="NamedAttribute represents a combination of a name and an Attribute value.">NamedAttribute</a>.  <a href="structmlir_1_1AttrTypeSubElementHandler_3_01NamedAttribute_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:AttrTypeSubElementHandler_3C_20std_3A_3Atuple_3C_20Ts_2E_2E_2E_20_3E_2C_20std_3A_3Aenable_5Fif_5Ft_3C_20has_5Fsub_5Fattr_5For_5Ftype_5Fv_3C_20Ts_2E_2E_2E_20_3E_20_3E_20_3E" id="r_AttrTypeSubElementHandler_3C_20std_3A_3Atuple_3C_20Ts_2E_2E_2E_20_3E_2C_20std_3A_3Aenable_5Fif_5Ft_3C_20has_5Fsub_5Fattr_5For_5Ftype_5Fv_3C_20Ts_2E_2E_2E_20_3E_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AttrTypeSubElementHandler_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_00_01std_1_1enable__i69d64aa7e3ec1bb340acfeb6d320e346.html">AttrTypeSubElementHandler&lt; std::tuple&lt; Ts... &gt;, std::enable_if_t&lt; has_sub_attr_or_type_v&lt; Ts... &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for Tuple.  <a href="structmlir_1_1AttrTypeSubElementHandler_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_00_01std_1_1enable__i69d64aa7e3ec1bb340acfeb6d320e346.html#details">More...</a><br /></td></tr>
<tr class="memitem:AttrTypeSubElementHandler_3C_20T_2C_20std_3A_3Aenable_5Fif_5Ft_3C_20std_3A_3Ais_5Fbase_5Fof_5Fv_3C_20Attribute_2C_20T_20_3E_7C_7Cstd_3A_3Ais_5Fbase_5Fof_5Fv_3C_20Type_2C_20T_20_3E_20_3E_20_3E" id="r_AttrTypeSubElementHandler_3C_20T_2C_20std_3A_3Aenable_5Fif_5Ft_3C_20std_3A_3Ais_5Fbase_5Fof_5Fv_3C_20Attribute_2C_20T_20_3E_7C_7Cstd_3A_3Ais_5Fbase_5Fof_5Fv_3C_20Type_2C_20T_20_3E_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AttrTypeSubElementHandler_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is__base__of_ca2937af926ee576a78a661a53d1729d.html">AttrTypeSubElementHandler&lt; T, std::enable_if_t&lt; std::is_base_of_v&lt; Attribute, T &gt;||std::is_base_of_v&lt; Type, T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for derived Attributes and Types.  <a href="structmlir_1_1AttrTypeSubElementHandler_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is__base__of_ca2937af926ee576a78a661a53d1729d.html#details">More...</a><br /></td></tr>
<tr class="memitem:AttrTypeSubElementHandler_3C_20TypeRange_20_3E" id="r_AttrTypeSubElementHandler_3C_20TypeRange_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AttrTypeSubElementHandler_3_01TypeRange_01_4.html">AttrTypeSubElementHandler&lt; TypeRange &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable <a class="el" href="classmlir_1_1TypeRange.html" title="This class provides an abstraction over the various different ranges of value types.">TypeRange</a> to be introspected for sub-elements.  <a href="structmlir_1_1AttrTypeSubElementHandler_3_01TypeRange_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:AttrTypeSubElementReplacements" id="r_AttrTypeSubElementReplacements"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AttrTypeSubElementReplacements.html">AttrTypeSubElementReplacements</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used by <a class="el" href="structmlir_1_1AttrTypeSubElementHandler.html" title="This class provides support for interacting with the SubElementInterfaces for different types of para...">AttrTypeSubElementHandler</a> instances to process sub element replacements.  <a href="classmlir_1_1AttrTypeSubElementReplacements.html#details">More...</a><br /></td></tr>
<tr class="memitem:AttrTypeWalker" id="r_AttrTypeWalker"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AttrTypeWalker.html">AttrTypeWalker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1AttrTypeWalker.html" title="AttrTypeWalker.">AttrTypeWalker</a>.  <a href="classmlir_1_1AttrTypeWalker.html#details">More...</a><br /></td></tr>
<tr class="memitem:BackwardSliceOptions" id="r_BackwardSliceOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1BackwardSliceOptions.html">BackwardSliceOptions</a></td></tr>
<tr class="memitem:BaseMemRefType" id="r_BaseMemRefType"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a shared interface for ranked and unranked memref types.  <a href="classmlir_1_1BaseMemRefType.html#details">More...</a><br /></td></tr>
<tr class="memitem:Block" id="r_Block"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Block.html">Block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="tt"><a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a></span> represents an ordered list of <span class="tt"><a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a></span>s.  <a href="classmlir_1_1Block.html#details">More...</a><br /></td></tr>
<tr class="memitem:BlockArgument" id="r_BlockArgument"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an argument of a <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a>.  <a href="classmlir_1_1BlockArgument.html#details">More...</a><br /></td></tr>
<tr class="memitem:BlockOperand" id="r_BlockOperand"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BlockOperand.html">BlockOperand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A block operand represents an operand that holds a reference to a <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a>, e.g.  <a href="classmlir_1_1BlockOperand.html#details">More...</a><br /></td></tr>
<tr class="memitem:BlockRange" id="r_BlockRange"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BlockRange.html">BlockRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an abstraction over the different types of ranges over Blocks.  <a href="classmlir_1_1BlockRange.html#details">More...</a><br /></td></tr>
<tr class="memitem:BoolAttr" id="r_BoolAttr"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BoolAttr.html">BoolAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special case of IntegerAttr to represent boolean integers, i.e., signless i1 integers.  <a href="classmlir_1_1BoolAttr.html#details">More...</a><br /></td></tr>
<tr class="memitem:BufferOriginAnalysis" id="r_BufferOriginAnalysis"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BufferOriginAnalysis.html">BufferOriginAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An is-same-buffer analysis that checks if two SSA values belong to the same buffer allocation or not.  <a href="classmlir_1_1BufferOriginAnalysis.html#details">More...</a><br /></td></tr>
<tr class="memitem:BufferViewFlowAnalysis" id="r_BufferViewFlowAnalysis"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BufferViewFlowAnalysis.html">BufferViewFlowAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A straight-forward alias analysis which ensures that all dependencies of all values will be determined.  <a href="classmlir_1_1BufferViewFlowAnalysis.html#details">More...</a><br /></td></tr>
<tr class="memitem:Builder" id="r_Builder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html">Builder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a general helper class for creating context-global objects like types, attributes, and affine expressions.  <a href="classmlir_1_1Builder.html#details">More...</a><br /></td></tr>
<tr class="memitem:BytecodeDialectInterface" id="r_BytecodeDialectInterface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BytecodeDialectInterface.html">BytecodeDialectInterface</a></td></tr>
<tr class="memitem:BytecodeReader" id="r_BytecodeReader"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BytecodeReader.html">BytecodeReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classmlir_1_1BytecodeReader.html" title="The BytecodeReader allows to load MLIR bytecode files, while keeping the state explicitly available i...">BytecodeReader</a> allows to load MLIR bytecode files, while keeping the state explicitly available in order to support lazy loading.  <a href="classmlir_1_1BytecodeReader.html#details">More...</a><br /></td></tr>
<tr class="memitem:BytecodeReaderConfig" id="r_BytecodeReaderConfig"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BytecodeReaderConfig.html">BytecodeReaderConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class containing bytecode-specific configurations of the <span class="tt"><a class="el" href="classmlir_1_1ParserConfig.html" title="This class represents a configuration for the MLIR assembly parser.">ParserConfig</a></span>.  <a href="classmlir_1_1BytecodeReaderConfig.html#details">More...</a><br /></td></tr>
<tr class="memitem:BytecodeWriterConfig" id="r_BytecodeWriterConfig"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BytecodeWriterConfig.html">BytecodeWriterConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains the configuration used for the bytecode writer.  <a href="classmlir_1_1BytecodeWriterConfig.html#details">More...</a><br /></td></tr>
<tr class="memitem:CachedCyclicReplacer" id="r_CachedCyclicReplacer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1CachedCyclicReplacer.html">CachedCyclicReplacer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class for cases where the input/output types of the replacer function is identical to the types stored in the cache.  <a href="classmlir_1_1CachedCyclicReplacer.html#details">More...</a><br /></td></tr>
<tr class="memitem:CallGraph" id="r_CallGraph"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1CallGraph.html">CallGraph</a></td></tr>
<tr class="memitem:CallGraphNode" id="r_CallGraphNode"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1CallGraphNode.html">CallGraphNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a single callable in the callgraph.  <a href="classmlir_1_1CallGraphNode.html#details">More...</a><br /></td></tr>
<tr class="memitem:CallInterfaceCallable" id="r_CallInterfaceCallable"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1CallInterfaceCallable.html">CallInterfaceCallable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callable is either a symbol, or an SSA value, that is referenced by a call-like operation.  <a href="structmlir_1_1CallInterfaceCallable.html#details">More...</a><br /></td></tr>
<tr class="memitem:CanonicalizerOptions" id="r_CanonicalizerOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1CanonicalizerOptions.html">CanonicalizerOptions</a></td></tr>
<tr class="memitem:CFGLoop" id="r_CFGLoop"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1CFGLoop.html">CFGLoop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a single loop formed by blocks.  <a href="classmlir_1_1CFGLoop.html#details">More...</a><br /></td></tr>
<tr class="memitem:CFGLoopInfo" id="r_CFGLoopInfo"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1CFGLoopInfo.html">CFGLoopInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> LoopInfo instantiation for MLIR that provides access to CFG loops found in the dominator tree.  <a href="classmlir_1_1CFGLoopInfo.html#details">More...</a><br /></td></tr>
<tr class="memitem:CFGToSCFInterface" id="r_CFGToSCFInterface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1CFGToSCFInterface.html">CFGToSCFInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface that should be implemented by any caller of <span class="tt">transformCFGToSCF</span>.  <a href="classmlir_1_1CFGToSCFInterface.html#details">More...</a><br /></td></tr>
<tr class="memitem:ComplexStructBuilder" id="r_ComplexStructBuilder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ComplexStructBuilder.html">ComplexStructBuilder</a></td></tr>
<tr class="memitem:ComposeCollapseOfExpandOp" id="r_ComposeCollapseOfExpandOp"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ComposeCollapseOfExpandOp.html">ComposeCollapseOfExpandOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common verifier for reshape-like types.  <a href="structmlir_1_1ComposeCollapseOfExpandOp.html#details">More...</a><br /></td></tr>
<tr class="memitem:ComposeExpandOfCollapseOp" id="r_ComposeExpandOfCollapseOp"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ComposeExpandOfCollapseOp.html">ComposeExpandOfCollapseOp</a></td></tr>
<tr class="memitem:CompositeFixedPointPassOptions" id="r_CompositeFixedPointPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1CompositeFixedPointPassOptions.html">CompositeFixedPointPassOptions</a></td></tr>
<tr class="memitem:ConstantIntRanges" id="r_ConstantIntRanges"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConstantIntRanges.html">ConstantIntRanges</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of arbitrary-precision integers representing bounds on a given integer value.  <a href="classmlir_1_1ConstantIntRanges.html#details">More...</a><br /></td></tr>
<tr class="memitem:ControlFlowToSCFTransformation" id="r_ControlFlowToSCFTransformation"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ControlFlowToSCFTransformation.html">ControlFlowToSCFTransformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <span class="tt"><a class="el" href="classmlir_1_1CFGToSCFInterface.html" title="Interface that should be implemented by any caller of transformCFGToSCF.">CFGToSCFInterface</a></span> used to lift Control Flow <a class="el" href="classmlir_1_1Dialect.html" title="Dialects are groups of MLIR operations, types and attributes, as well as behavior associated with the...">Dialect</a> operations to SCF <a class="el" href="classmlir_1_1Dialect.html" title="Dialects are groups of MLIR operations, types and attributes, as well as behavior associated with the...">Dialect</a> operations.  <a href="classmlir_1_1ControlFlowToSCFTransformation.html#details">More...</a><br /></td></tr>
<tr class="memitem:ConvertAffineForToGPUPassOptions" id="r_ConvertAffineForToGPUPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConvertAffineForToGPUPassOptions.html">ConvertAffineForToGPUPassOptions</a></td></tr>
<tr class="memitem:ConvertAMDGPUToROCDLPassOptions" id="r_ConvertAMDGPUToROCDLPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConvertAMDGPUToROCDLPassOptions.html">ConvertAMDGPUToROCDLPassOptions</a></td></tr>
<tr class="memitem:ConvertArithToSPIRVPassOptions" id="r_ConvertArithToSPIRVPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConvertArithToSPIRVPassOptions.html">ConvertArithToSPIRVPassOptions</a></td></tr>
<tr class="memitem:ConvertArmSMEToLLVMOptions" id="r_ConvertArmSMEToLLVMOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConvertArmSMEToLLVMOptions.html">ConvertArmSMEToLLVMOptions</a></td></tr>
<tr class="memitem:ConvertComplexToLLVMPassOptions" id="r_ConvertComplexToLLVMPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConvertComplexToLLVMPassOptions.html">ConvertComplexToLLVMPassOptions</a></td></tr>
<tr class="memitem:ConvertComplexToStandardPassOptions" id="r_ConvertComplexToStandardPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConvertComplexToStandardPassOptions.html">ConvertComplexToStandardPassOptions</a></td></tr>
<tr class="memitem:ConvertControlFlowToLLVMPassOptions" id="r_ConvertControlFlowToLLVMPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConvertControlFlowToLLVMPassOptions.html">ConvertControlFlowToLLVMPassOptions</a></td></tr>
<tr class="memitem:ConvertControlFlowToSPIRVPassOptions" id="r_ConvertControlFlowToSPIRVPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConvertControlFlowToSPIRVPassOptions.html">ConvertControlFlowToSPIRVPassOptions</a></td></tr>
<tr class="memitem:ConvertFuncToLLVMPassOptions" id="r_ConvertFuncToLLVMPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConvertFuncToLLVMPassOptions.html">ConvertFuncToLLVMPassOptions</a></td></tr>
<tr class="memitem:ConvertFuncToSPIRVPassOptions" id="r_ConvertFuncToSPIRVPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConvertFuncToSPIRVPassOptions.html">ConvertFuncToSPIRVPassOptions</a></td></tr>
<tr class="memitem:ConvertGpuOpsToLLVMSPVOpsOptions" id="r_ConvertGpuOpsToLLVMSPVOpsOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConvertGpuOpsToLLVMSPVOpsOptions.html">ConvertGpuOpsToLLVMSPVOpsOptions</a></td></tr>
<tr class="memitem:ConvertGpuOpsToNVVMOpsOptions" id="r_ConvertGpuOpsToNVVMOpsOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConvertGpuOpsToNVVMOpsOptions.html">ConvertGpuOpsToNVVMOpsOptions</a></td></tr>
<tr class="memitem:ConvertGpuOpsToROCDLOpsOptions" id="r_ConvertGpuOpsToROCDLOpsOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConvertGpuOpsToROCDLOpsOptions.html">ConvertGpuOpsToROCDLOpsOptions</a></td></tr>
<tr class="memitem:ConvertGPUToSPIRVOptions" id="r_ConvertGPUToSPIRVOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConvertGPUToSPIRVOptions.html">ConvertGPUToSPIRVOptions</a></td></tr>
<tr class="memitem:ConvertIndexToLLVMPassOptions" id="r_ConvertIndexToLLVMPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConvertIndexToLLVMPassOptions.html">ConvertIndexToLLVMPassOptions</a></td></tr>
<tr class="memitem:ConvertIndexToSPIRVPassOptions" id="r_ConvertIndexToSPIRVPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConvertIndexToSPIRVPassOptions.html">ConvertIndexToSPIRVPassOptions</a></td></tr>
<tr class="memitem:ConvertMathToEmitCOptions" id="r_ConvertMathToEmitCOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConvertMathToEmitCOptions.html">ConvertMathToEmitCOptions</a></td></tr>
<tr class="memitem:ConvertMathToFuncsOptions" id="r_ConvertMathToFuncsOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConvertMathToFuncsOptions.html">ConvertMathToFuncsOptions</a></td></tr>
<tr class="memitem:ConvertMathToLLVMPassOptions" id="r_ConvertMathToLLVMPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConvertMathToLLVMPassOptions.html">ConvertMathToLLVMPassOptions</a></td></tr>
<tr class="memitem:ConvertMathToROCDLOptions" id="r_ConvertMathToROCDLOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConvertMathToROCDLOptions.html">ConvertMathToROCDLOptions</a></td></tr>
<tr class="memitem:ConvertMathToXeVMOptions" id="r_ConvertMathToXeVMOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConvertMathToXeVMOptions.html">ConvertMathToXeVMOptions</a></td></tr>
<tr class="memitem:ConvertMemRefToEmitCOptions" id="r_ConvertMemRefToEmitCOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConvertMemRefToEmitCOptions.html">ConvertMemRefToEmitCOptions</a></td></tr>
<tr class="memitem:ConvertMemRefToSPIRVPassOptions" id="r_ConvertMemRefToSPIRVPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConvertMemRefToSPIRVPassOptions.html">ConvertMemRefToSPIRVPassOptions</a></td></tr>
<tr class="memitem:ConvertOpInterfaceToLLVMPattern" id="r_ConvertOpInterfaceToLLVMPattern"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConvertOpInterfaceToLLVMPattern.html">ConvertOpInterfaceToLLVMPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for operation conversions targeting the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect that allows for matching and rewriting against an instance of an <a class="el" href="classmlir_1_1OpInterface.html" title="This class represents the base of an operation interface.">OpInterface</a> class.  <a href="classmlir_1_1ConvertOpInterfaceToLLVMPattern.html#details">More...</a><br /></td></tr>
<tr class="memitem:ConvertOpToLLVMPattern" id="r_ConvertOpToLLVMPattern"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConvertOpToLLVMPattern.html">ConvertOpToLLVMPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for operation conversions targeting the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect that match exactly one source operation.  <a href="classmlir_1_1ConvertOpToLLVMPattern.html#details">More...</a><br /></td></tr>
<tr class="memitem:ConvertSCFToOpenMPPassOptions" id="r_ConvertSCFToOpenMPPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConvertSCFToOpenMPPassOptions.html">ConvertSCFToOpenMPPassOptions</a></td></tr>
<tr class="memitem:ConvertSPIRVToLLVMPassOptions" id="r_ConvertSPIRVToLLVMPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConvertSPIRVToLLVMPassOptions.html">ConvertSPIRVToLLVMPassOptions</a></td></tr>
<tr class="memitem:ConvertTensorToSPIRVPassOptions" id="r_ConvertTensorToSPIRVPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConvertTensorToSPIRVPassOptions.html">ConvertTensorToSPIRVPassOptions</a></td></tr>
<tr class="memitem:ConvertToEmitCOptions" id="r_ConvertToEmitCOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConvertToEmitCOptions.html">ConvertToEmitCOptions</a></td></tr>
<tr class="memitem:ConvertToEmitCPatternInterface" id="r_ConvertToEmitCPatternInterface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConvertToEmitCPatternInterface.html">ConvertToEmitCPatternInterface</a></td></tr>
<tr class="memitem:ConvertToLLVMPassOptions" id="r_ConvertToLLVMPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConvertToLLVMPassOptions.html">ConvertToLLVMPassOptions</a></td></tr>
<tr class="memitem:ConvertToLLVMPattern" id="r_ConvertToLLVMPattern"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConvertToLLVMPattern.html">ConvertToLLVMPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for operation conversions targeting the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect.  <a href="classmlir_1_1ConvertToLLVMPattern.html#details">More...</a><br /></td></tr>
<tr class="memitem:ConvertToLLVMPatternInterface" id="r_ConvertToLLVMPatternInterface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConvertToLLVMPatternInterface.html">ConvertToLLVMPatternInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1detail_1_1DialectInterfaceBase.html#a8fb069ca452108e8daff12e429db97fd">Base</a> class for dialect interfaces providing translation to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR.  <a href="classmlir_1_1ConvertToLLVMPatternInterface.html#details">More...</a><br /></td></tr>
<tr class="memitem:ConvertVectorToGPUOptions" id="r_ConvertVectorToGPUOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConvertVectorToGPUOptions.html">ConvertVectorToGPUOptions</a></td></tr>
<tr class="memitem:ConvertVectorToLLVMPassOptions" id="r_ConvertVectorToLLVMPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConvertVectorToLLVMPassOptions.html">ConvertVectorToLLVMPassOptions</a></td></tr>
<tr class="memitem:ConvertVectorToSCFOptions" id="r_ConvertVectorToSCFOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConvertVectorToSCFOptions.html">ConvertVectorToSCFOptions</a></td></tr>
<tr class="memitem:CopyOnWriteArrayRef" id="r_CopyOnWriteArrayRef"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1CopyOnWriteArrayRef.html">CopyOnWriteArrayRef</a></td></tr>
<tr class="memitem:CyclicAttrTypeReplacer" id="r_CyclicAttrTypeReplacer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1CyclicAttrTypeReplacer.html">CyclicAttrTypeReplacer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an attribute/type replacer that supports custom handling of cycles in the replacer logic.  <a href="classmlir_1_1CyclicAttrTypeReplacer.html#details">More...</a><br /></td></tr>
<tr class="memitem:CyclicReplacerCache" id="r_CyclicReplacerCache"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1CyclicReplacerCache.html">CyclicReplacerCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cache for replacer-like functions that map values between two domains.  <a href="classmlir_1_1CyclicReplacerCache.html#details">More...</a><br /></td></tr>
<tr class="memitem:DataFlowAnalysis" id="r_DataFlowAnalysis"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DataFlowAnalysis.html">DataFlowAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all data-flow analyses.  <a href="classmlir_1_1DataFlowAnalysis.html#details">More...</a><br /></td></tr>
<tr class="memitem:DataFlowConfig" id="r_DataFlowConfig"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DataFlowConfig.html">DataFlowConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration class for data flow solver and child analyses.  <a href="classmlir_1_1DataFlowConfig.html#details">More...</a><br /></td></tr>
<tr class="memitem:DataFlowSolver" id="r_DataFlowSolver"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DataFlowSolver.html">DataFlowSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The general data-flow analysis solver.  <a href="classmlir_1_1DataFlowSolver.html#details">More...</a><br /></td></tr>
<tr class="memitem:DataLayout" id="r_DataLayout"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main mechanism for performing data layout queries.  <a href="classmlir_1_1DataLayout.html#details">More...</a><br /></td></tr>
<tr class="memitem:DataLayoutAnalysis" id="r_DataLayoutAnalysis"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DataLayoutAnalysis.html">DataLayoutAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores data layout objects for each operation that specifies the data layout above and below the given operation.  <a href="classmlir_1_1DataLayoutAnalysis.html#details">More...</a><br /></td></tr>
<tr class="memitem:DataLayoutDialectInterface" id="r_DataLayoutDialectInterface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DataLayoutDialectInterface.html">DataLayoutDialectInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface to be implemented by dialects that can have identifiers in the data layout specification entries.  <a href="classmlir_1_1DataLayoutDialectInterface.html#details">More...</a><br /></td></tr>
<tr class="memitem:DefaultTimingManager" id="r_DefaultTimingManager"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DefaultTimingManager.html">DefaultTimingManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Facilities for time measurement and report printing to an output stream.  <a href="classmlir_1_1DefaultTimingManager.html#details">More...</a><br /></td></tr>
<tr class="memitem:DenseElementsAttr" id="r_DenseElementsAttr"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that represents a reference to a dense vector or tensor object.  <a href="classmlir_1_1DenseElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="memitem:DenseFPElementsAttr" id="r_DenseFPElementsAttr"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseFPElementsAttr.html">DenseFPElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that represents a reference to a dense float vector or tensor object.  <a href="classmlir_1_1DenseFPElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="memitem:DenseIntElementsAttr" id="r_DenseIntElementsAttr"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that represents a reference to a dense integer vector or tensor object.  <a href="classmlir_1_1DenseIntElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="memitem:DestructurableMemorySlot" id="r_DestructurableMemorySlot"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1DestructurableMemorySlot.html">DestructurableMemorySlot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory slot attached with information about its destructuring procedure.  <a href="structmlir_1_1DestructurableMemorySlot.html#details">More...</a><br /></td></tr>
<tr class="memitem:DiagnosedDefiniteFailure" id="r_DiagnosedDefiniteFailure"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DiagnosedDefiniteFailure.html">DiagnosedDefiniteFailure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compatibility class connecting <span class="tt"><a class="el" href="classmlir_1_1InFlightDiagnostic.html" title="This class represents a diagnostic that is inflight and set to be reported.">InFlightDiagnostic</a></span> to <span class="tt"><a class="el" href="classmlir_1_1DiagnosedSilenceableFailure.html" title="The result of a transform IR operation application.">DiagnosedSilenceableFailure</a></span> while providing an interface similar to the former.  <a href="classmlir_1_1DiagnosedDefiniteFailure.html#details">More...</a><br /></td></tr>
<tr class="memitem:DiagnosedSilenceableFailure" id="r_DiagnosedSilenceableFailure"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DiagnosedSilenceableFailure.html">DiagnosedSilenceableFailure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result of a transform IR operation application.  <a href="classmlir_1_1DiagnosedSilenceableFailure.html#details">More...</a><br /></td></tr>
<tr class="memitem:Diagnostic" id="r_Diagnostic"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Diagnostic.html">Diagnostic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the information necessary to report a diagnostic to the <a class="el" href="classmlir_1_1DiagnosticEngine.html" title="This class is the main interface for diagnostics.">DiagnosticEngine</a>.  <a href="classmlir_1_1Diagnostic.html#details">More...</a><br /></td></tr>
<tr class="memitem:DiagnosticArgument" id="r_DiagnosticArgument"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DiagnosticArgument.html">DiagnosticArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant type that holds a single argument for a diagnostic.  <a href="classmlir_1_1DiagnosticArgument.html#details">More...</a><br /></td></tr>
<tr class="memitem:DiagnosticEngine" id="r_DiagnosticEngine"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DiagnosticEngine.html">DiagnosticEngine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is the main interface for diagnostics.  <a href="classmlir_1_1DiagnosticEngine.html#details">More...</a><br /></td></tr>
<tr class="memitem:Dialect" id="r_Dialect"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Dialect.html">Dialect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dialects are groups of MLIR operations, types and attributes, as well as behavior associated with the entire group.  <a href="classmlir_1_1Dialect.html#details">More...</a><br /></td></tr>
<tr class="memitem:DialectAsmParser" id="r_DialectAsmParser"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectAsmParser.html">DialectAsmParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classmlir_1_1DialectAsmParser.html" title="The DialectAsmParser has methods for interacting with the asm parser when parsing attributes and type...">DialectAsmParser</a> has methods for interacting with the asm parser when parsing attributes and types.  <a href="classmlir_1_1DialectAsmParser.html#details">More...</a><br /></td></tr>
<tr class="memitem:DialectAsmPrinter" id="r_DialectAsmPrinter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a pure-virtual base class that exposes the asmprinter hooks necessary to implement a custom printAttribute/printType() method on a dialect.  <a href="classmlir_1_1DialectAsmPrinter.html#details">More...</a><br /></td></tr>
<tr class="memitem:DialectBytecodeReader" id="r_DialectBytecodeReader"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectBytecodeReader.html">DialectBytecodeReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class defines a virtual interface for reading a bytecode stream, providing hooks into the bytecode reader.  <a href="classmlir_1_1DialectBytecodeReader.html#details">More...</a><br /></td></tr>
<tr class="memitem:DialectBytecodeWriter" id="r_DialectBytecodeWriter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectBytecodeWriter.html">DialectBytecodeWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class defines a virtual interface for writing to a bytecode stream, providing hooks into the bytecode writer.  <a href="classmlir_1_1DialectBytecodeWriter.html#details">More...</a><br /></td></tr>
<tr class="memitem:DialectExtension" id="r_DialectExtension"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectExtension.html">DialectExtension</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a dialect extension anchored on the given set of dialects.  <a href="classmlir_1_1DialectExtension.html#details">More...</a><br /></td></tr>
<tr class="memitem:DialectExtensionBase" id="r_DialectExtensionBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectExtensionBase.html">DialectExtensionBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an opaque dialect extension.  <a href="classmlir_1_1DialectExtensionBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:DialectFoldInterface" id="r_DialectFoldInterface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectFoldInterface.html">DialectFoldInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a fold interface to allow for dialects to control specific aspects of the folding behavior for operations they define.  <a href="classmlir_1_1DialectFoldInterface.html#details">More...</a><br /></td></tr>
<tr class="memitem:DialectInterface" id="r_DialectInterface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectInterface.html">DialectInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an interface overridden for a single dialect.  <a href="classmlir_1_1DialectInterface.html#details">More...</a><br /></td></tr>
<tr class="memitem:DialectInterfaceCollection" id="r_DialectInterfaceCollection"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectInterfaceCollection.html">DialectInterfaceCollection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of dialect interfaces within a context, for a given concrete interface type.  <a href="classmlir_1_1DialectInterfaceCollection.html#details">More...</a><br /></td></tr>
<tr class="memitem:DialectPlugin" id="r_DialectPlugin"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectPlugin.html">DialectPlugin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A loaded dialect plugin.  <a href="classmlir_1_1DialectPlugin.html#details">More...</a><br /></td></tr>
<tr class="memitem:DialectPluginLibraryInfo" id="r_DialectPluginLibraryInfo"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1DialectPluginLibraryInfo.html">DialectPluginLibraryInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the plugin required to load its dialects &amp; passes.  <a href="structmlir_1_1DialectPluginLibraryInfo.html#details">More...</a><br /></td></tr>
<tr class="memitem:DialectReductionPatternInterface" id="r_DialectReductionPatternInterface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectReductionPatternInterface.html">DialectReductionPatternInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to report the reduction patterns for a <a class="el" href="classmlir_1_1Dialect.html" title="Dialects are groups of MLIR operations, types and attributes, as well as behavior associated with the...">Dialect</a>.  <a href="classmlir_1_1DialectReductionPatternInterface.html#details">More...</a><br /></td></tr>
<tr class="memitem:DialectRegistry" id="r_DialectRegistry"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classmlir_1_1DialectRegistry.html" title="The DialectRegistry maps a dialect namespace to a constructor for the matching dialect.">DialectRegistry</a> maps a dialect namespace to a constructor for the matching dialect.  <a href="classmlir_1_1DialectRegistry.html#details">More...</a><br /></td></tr>
<tr class="memitem:DialectResourceBlobHandle" id="r_DialectResourceBlobHandle"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1DialectResourceBlobHandle.html">DialectResourceBlobHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class defines a dialect specific handle to a resource blob.  <a href="structmlir_1_1DialectResourceBlobHandle.html#details">More...</a><br /></td></tr>
<tr class="memitem:DialectResourceBlobManager" id="r_DialectResourceBlobManager"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectResourceBlobManager.html">DialectResourceBlobManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class defines a manager for dialect resource blobs.  <a href="classmlir_1_1DialectResourceBlobManager.html#details">More...</a><br /></td></tr>
<tr class="memitem:DialectVersion" id="r_DialectVersion"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectVersion.html">DialectVersion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to represent the version of a dialect, for the purpose of polymorphic destruction.  <a href="classmlir_1_1DialectVersion.html#details">More...</a><br /></td></tr>
<tr class="memitem:DistinctAttr" id="r_DistinctAttr"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DistinctAttr.html">DistinctAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that associates a referenced attribute with a unique identifier.  <a href="classmlir_1_1DistinctAttr.html#details">More...</a><br /></td></tr>
<tr class="memitem:DominanceInfo" id="r_DominanceInfo"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for computing basic dominance information.  <a href="classmlir_1_1DominanceInfo.html#details">More...</a><br /></td></tr>
<tr class="memitem:DynamicAttr" id="r_DynamicAttr"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DynamicAttr.html">DynamicAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamic attribute instance.  <a href="classmlir_1_1DynamicAttr.html#details">More...</a><br /></td></tr>
<tr class="memitem:DynamicAttrDefinition" id="r_DynamicAttrDefinition"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DynamicAttrDefinition.html">DynamicAttrDefinition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a dynamic attribute.  <a href="classmlir_1_1DynamicAttrDefinition.html#details">More...</a><br /></td></tr>
<tr class="memitem:DynamicDialect" id="r_DynamicDialect"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DynamicDialect.html">DynamicDialect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dialect that can be defined at runtime.  <a href="classmlir_1_1DynamicDialect.html#details">More...</a><br /></td></tr>
<tr class="memitem:DynamicOpDefinition" id="r_DynamicOpDefinition"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DynamicOpDefinition.html">DynamicOpDefinition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a dynamic op.  <a href="classmlir_1_1DynamicOpDefinition.html#details">More...</a><br /></td></tr>
<tr class="memitem:DynamicType" id="r_DynamicType"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DynamicType.html">DynamicType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamic type instance.  <a href="classmlir_1_1DynamicType.html#details">More...</a><br /></td></tr>
<tr class="memitem:DynamicTypeDefinition" id="r_DynamicTypeDefinition"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DynamicTypeDefinition.html">DynamicTypeDefinition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a dynamic type.  <a href="classmlir_1_1DynamicTypeDefinition.html#details">More...</a><br /></td></tr>
<tr class="memitem:EmptyProperties" id="r_EmptyProperties"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1EmptyProperties.html">EmptyProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure used by default as a "marker" when no "Properties" are set on an <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>.  <a href="structmlir_1_1EmptyProperties.html#details">More...</a><br /></td></tr>
<tr class="memitem:EndomorphismSimplification" id="r_EndomorphismSimplification"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1EndomorphismSimplification.html">EndomorphismSimplification</a></td></tr>
<tr class="memitem:ExecutionEngine" id="r_ExecutionEngine"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ExecutionEngine.html">ExecutionEngine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">JIT-backed execution engine for MLIR.  <a href="classmlir_1_1ExecutionEngine.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExecutionEngineOptions" id="r_ExecutionEngineOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ExecutionEngineOptions.html">ExecutionEngineOptions</a></td></tr>
<tr class="memitem:ExtensibleDialect" id="r_ExtensibleDialect"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ExtensibleDialect.html">ExtensibleDialect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dialect that can be extended with new operations/types/attributes at runtime.  <a href="classmlir_1_1ExtensibleDialect.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExternalPass" id="r_ExternalPass"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ExternalPass.html">ExternalPass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This pass class wraps external passes defined in other languages using the MLIR C-interface.  <a href="classmlir_1_1ExternalPass.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExternalRewritePattern" id="r_ExternalRewritePattern"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ExternalRewritePattern.html">ExternalRewritePattern</a></td></tr>
<tr class="memitem:FallbackAsmResourceMap" id="r_FallbackAsmResourceMap"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FallbackAsmResourceMap.html">FallbackAsmResourceMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fallback map containing external resources not explicitly handled by another parser/printer.  <a href="classmlir_1_1FallbackAsmResourceMap.html#details">More...</a><br /></td></tr>
<tr class="memitem:FieldParser" id="r_FieldParser"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser.html">FieldParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a template class that can be specialized by users to dispatch to parsers.  <a href="structmlir_1_1FieldParser.html#details">More...</a><br /></td></tr>
<tr class="memitem:FieldParser_3C_20AffineMap_20_3E" id="r_FieldParser_3C_20AffineMap_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser_3_01AffineMap_01_4.html">FieldParser&lt; AffineMap &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an affine map.  <a href="structmlir_1_1FieldParser_3_01AffineMap_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:FieldParser_3C_20AttributeT_2C_20std_3A_3Aenable_5Fif_5Ft_3C_20std_3A_3Ais_5Fbase_5Fof_3C_20Attribute_2C_20AttributeT_20_3E_3A_3Avalue_2C_20AttributeT_20_3E_20_3E" id="r_FieldParser_3C_20AttributeT_2C_20std_3A_3Aenable_5Fif_5Ft_3C_20std_3A_3Ais_5Fbase_5Fof_3C_20Attribute_2C_20AttributeT_20_3E_3A_3Avalue_2C_20AttributeT_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser_3_01AttributeT_00_01std_1_1enable__if__t_3_01std_1_1is__base__of_3_01Afbf44e752e28f353857b0de6053d0e60.html">FieldParser&lt; AttributeT, std::enable_if_t&lt; std::is_base_of&lt; Attribute, AttributeT &gt;::value, AttributeT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an attribute.  <a href="structmlir_1_1FieldParser_3_01AttributeT_00_01std_1_1enable__if__t_3_01std_1_1is__base__of_3_01Afbf44e752e28f353857b0de6053d0e60.html#details">More...</a><br /></td></tr>
<tr class="memitem:FieldParser_3C_20ContainerT_2C_20std_3A_3Aenable_5Fif_5Ft_3C_20llvm_3A_3Ais_5Fdetected_3C_20detail_3A_3Ahas_5Fpush_5Fback_5Ft_2C_20ContainerT_20_3E_3A_3Avalue_2C_20ContainerT_20_3E_20_3E" id="r_FieldParser_3C_20ContainerT_2C_20std_3A_3Aenable_5Fif_5Ft_3C_20llvm_3A_3Ais_5Fdetected_3C_20detail_3A_3Ahas_5Fpush_5Fback_5Ft_2C_20ContainerT_20_3E_3A_3Avalue_2C_20ContainerT_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser_3_01ContainerT_00_01std_1_1enable__if__t_3_01llvm_1_1is__detected_3_0112cbbc78ed0c7bbf669a3991e3076f4f.html">FieldParser&lt; ContainerT, std::enable_if_t&lt; llvm::is_detected&lt; detail::has_push_back_t, ContainerT &gt;::value, ContainerT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse any container that supports back insertion as a list.  <a href="structmlir_1_1FieldParser_3_01ContainerT_00_01std_1_1enable__if__t_3_01llvm_1_1is__detected_3_0112cbbc78ed0c7bbf669a3991e3076f4f.html#details">More...</a><br /></td></tr>
<tr class="memitem:FieldParser_3C_20IntT_2C_20std_3A_3Aenable_5Fif_5Ft_3C_28std_3A_3Ais_5Fintegral_3C_20IntT_20_3E_3A_3Avalue_7C_7Cstd_3A_3Ais_5Fsame_5Fv_3C_20IntT_2C_20llvm_3A_3AAPInt_20_3E_29_2C_20IntT_20_3E_20_3E" id="r_FieldParser_3C_20IntT_2C_20std_3A_3Aenable_5Fif_5Ft_3C_28std_3A_3Ais_5Fintegral_3C_20IntT_20_3E_3A_3Avalue_7C_7Cstd_3A_3Ais_5Fsame_5Fv_3C_20IntT_2C_20llvm_3A_3AAPInt_20_3E_29_2C_20IntT_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser_3_01IntT_00_01std_1_1enable__if__t_3_07std_1_1is__integral_3_01IntT_01c18236f32496c8597ddeb677ab069a7d.html">FieldParser&lt; IntT, std::enable_if_t&lt;(std::is_integral&lt; IntT &gt;::value||std::is_same_v&lt; IntT, llvm::APInt &gt;), IntT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse any integer.  <a href="structmlir_1_1FieldParser_3_01IntT_00_01std_1_1enable__if__t_3_07std_1_1is__integral_3_01IntT_01c18236f32496c8597ddeb677ab069a7d.html#details">More...</a><br /></td></tr>
<tr class="memitem:FieldParser_3C_20std_3A_3Aoptional_3C_20AttributeT_20_3E_2C_20std_3A_3Aenable_5Fif_5Ft_3C_20std_3A_3Ais_5Fbase_5Fof_3C_20Attribute_2C_20AttributeT_20_3E_3A_3Avalue_2C_20std_3A_3Aoptional_3C_20AttributeT_20_3E_20_3E_20_3E" id="r_FieldParser_3C_20std_3A_3Aoptional_3C_20AttributeT_20_3E_2C_20std_3A_3Aenable_5Fif_5Ft_3C_20std_3A_3Ais_5Fbase_5Fof_3C_20Attribute_2C_20AttributeT_20_3E_3A_3Avalue_2C_20std_3A_3Aoptional_3C_20AttributeT_20_3E_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser_3_01std_1_1optional_3_01AttributeT_01_4_00_01std_1_1enable__if__t_3_01a9544224247644e900417ec0332b0042.html">FieldParser&lt; std::optional&lt; AttributeT &gt;, std::enable_if_t&lt; std::is_base_of&lt; Attribute, AttributeT &gt;::value, std::optional&lt; AttributeT &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an Optional attribute.  <a href="structmlir_1_1FieldParser_3_01std_1_1optional_3_01AttributeT_01_4_00_01std_1_1enable__if__t_3_01a9544224247644e900417ec0332b0042.html#details">More...</a><br /></td></tr>
<tr class="memitem:FieldParser_3C_20std_3A_3Aoptional_3C_20IntT_20_3E_2C_20std_3A_3Aenable_5Fif_5Ft_3C_20std_3A_3Ais_5Fintegral_3C_20IntT_20_3E_3A_3Avalue_2C_20std_3A_3Aoptional_3C_20IntT_20_3E_20_3E_20_3E" id="r_FieldParser_3C_20std_3A_3Aoptional_3C_20IntT_20_3E_2C_20std_3A_3Aenable_5Fif_5Ft_3C_20std_3A_3Ais_5Fintegral_3C_20IntT_20_3E_3A_3Avalue_2C_20std_3A_3Aoptional_3C_20IntT_20_3E_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser_3_01std_1_1optional_3_01IntT_01_4_00_01std_1_1enable__if__t_3_01std_1_6359b16273171b8ce58b2c2f1b4d06a0.html">FieldParser&lt; std::optional&lt; IntT &gt;, std::enable_if_t&lt; std::is_integral&lt; IntT &gt;::value, std::optional&lt; IntT &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an Optional integer.  <a href="structmlir_1_1FieldParser_3_01std_1_1optional_3_01IntT_01_4_00_01std_1_1enable__if__t_3_01std_1_6359b16273171b8ce58b2c2f1b4d06a0.html#details">More...</a><br /></td></tr>
<tr class="memitem:FieldParser_3C_20std_3A_3Astring_20_3E" id="r_FieldParser_3C_20std_3A_3Astring_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser_3_01std_1_1string_01_4.html">FieldParser&lt; std::string &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a string.  <a href="structmlir_1_1FieldParser_3_01std_1_1string_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:FieldParser_3C_20TypeT_2C_20std_3A_3Aenable_5Fif_5Ft_3C_20std_3A_3Ais_5Fbase_5Fof_3C_20Type_2C_20TypeT_20_3E_3A_3Avalue_2C_20TypeT_20_3E_20_3E" id="r_FieldParser_3C_20TypeT_2C_20std_3A_3Aenable_5Fif_5Ft_3C_20std_3A_3Ais_5Fbase_5Fof_3C_20Type_2C_20TypeT_20_3E_3A_3Avalue_2C_20TypeT_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser_3_01TypeT_00_01std_1_1enable__if__t_3_01std_1_1is__base__of_3_01Type_0346a91898fcc3a5091d4a6bb97af4903.html">FieldParser&lt; TypeT, std::enable_if_t&lt; std::is_base_of&lt; Type, TypeT &gt;::value, TypeT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a type.  <a href="structmlir_1_1FieldParser_3_01TypeT_00_01std_1_1enable__if__t_3_01std_1_1is__base__of_3_01Type_0346a91898fcc3a5091d4a6bb97af4903.html#details">More...</a><br /></td></tr>
<tr class="memitem:FileLineColLoc" id="r_FileLineColLoc"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FileLineColLoc.html">FileLineColLoc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An instance of this location represents a tuple of file, line number, and column number.  <a href="classmlir_1_1FileLineColLoc.html#details">More...</a><br /></td></tr>
<tr class="memitem:FinalizeMemRefToLLVMConversionPassOptions" id="r_FinalizeMemRefToLLVMConversionPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FinalizeMemRefToLLVMConversionPassOptions.html">FinalizeMemRefToLLVMConversionPassOptions</a></td></tr>
<tr class="memitem:FixedVectorType" id="r_FixedVectorType"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FixedVectorType.html">FixedVectorType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector type with no scalable dimensions.  <a href="classmlir_1_1FixedVectorType.html#details">More...</a><br /></td></tr>
<tr class="memitem:FlatLinearConstraints" id="r_FlatLinearConstraints"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatLinearConstraints.html">FlatLinearConstraints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1FlatLinearConstraints.html" title="FlatLinearConstraints is an extension of IntegerPolyhedron.">FlatLinearConstraints</a> is an extension of IntegerPolyhedron.  <a href="classmlir_1_1FlatLinearConstraints.html#details">More...</a><br /></td></tr>
<tr class="memitem:FlatLinearValueConstraints" id="r_FlatLinearValueConstraints"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatLinearValueConstraints.html">FlatLinearValueConstraints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1FlatLinearValueConstraints.html" title="FlatLinearValueConstraints represents an extension of FlatLinearConstraints where each non-local vari...">FlatLinearValueConstraints</a> represents an extension of <a class="el" href="classmlir_1_1FlatLinearConstraints.html" title="FlatLinearConstraints is an extension of IntegerPolyhedron.">FlatLinearConstraints</a> where each non-local variable can have an SSA <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> attached to it.  <a href="classmlir_1_1FlatLinearValueConstraints.html#details">More...</a><br /></td></tr>
<tr class="memitem:FlatSymbolRefAttr" id="r_FlatSymbolRefAttr"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatSymbolRefAttr.html">FlatSymbolRefAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A symbol reference with a reference path containing a single element.  <a href="classmlir_1_1FlatSymbolRefAttr.html#details">More...</a><br /></td></tr>
<tr class="memitem:ForwardDominanceIterator" id="r_ForwardDominanceIterator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ForwardDominanceIterator.html">ForwardDominanceIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This iterator enumerates elements according to their dominance relationship.  <a href="structmlir_1_1ForwardDominanceIterator.html#details">More...</a><br /></td></tr>
<tr class="memitem:ForwardIterator" id="r_ForwardIterator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ForwardIterator.html">ForwardIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This iterator enumerates the elements in "forward" order.  <a href="structmlir_1_1ForwardIterator.html#details">More...</a><br /></td></tr>
<tr class="memitem:FrozenRewritePatternSet" id="r_FrozenRewritePatternSet"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a frozen set of patterns that can be processed by a pattern applicator.  <a href="classmlir_1_1FrozenRewritePatternSet.html#details">More...</a><br /></td></tr>
<tr class="memitem:FunctionCallBuilder" id="r_FunctionCallBuilder"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FunctionCallBuilder.html">FunctionCallBuilder</a></td></tr>
<tr class="memitem:FusedLocWith" id="r_FusedLocWith"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FusedLocWith.html">FusedLocWith</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a fused location whose metadata is known to be an instance of the given type.  <a href="classmlir_1_1FusedLocWith.html#details">More...</a><br /></td></tr>
<tr class="memitem:GenerateRuntimeVerificationOptions" id="r_GenerateRuntimeVerificationOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GenerateRuntimeVerificationOptions.html">GenerateRuntimeVerificationOptions</a></td></tr>
<tr class="memitem:GenericLatticeAnchor" id="r_GenericLatticeAnchor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1GenericLatticeAnchor.html">GenericLatticeAnchor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for generic lattice anchor.  <a href="classmlir_1_1GenericLatticeAnchor.html#details">More...</a><br /></td></tr>
<tr class="memitem:GenericLatticeAnchorBase" id="r_GenericLatticeAnchorBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1GenericLatticeAnchorBase.html">GenericLatticeAnchorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1GenericLatticeAnchorBase.html#a15e7bde034530896f6b52856c7757715" title="Alias for the base class.">Base</a> class for generic lattice anchor based on a concrete lattice anchor type and a content key.  <a href="classmlir_1_1GenericLatticeAnchorBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:GenInfo" id="r_GenInfo"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1GenInfo.html">GenInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to group information about a generator (argument to invoke via mlir-tblgen, description, and generator function).  <a href="classmlir_1_1GenInfo.html#details">More...</a><br /></td></tr>
<tr class="memitem:GenNameParser" id="r_GenNameParser"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GenNameParser.html">GenNameParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds command line option for each registered generator.  <a href="structmlir_1_1GenNameParser.html#details">More...</a><br /></td></tr>
<tr class="memitem:GenRegistration" id="r_GenRegistration"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GenRegistration.html">GenRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1GenRegistration.html" title="GenRegistration provides a global initializer that registers a generator function.">GenRegistration</a> provides a global initializer that registers a generator function.  <a href="structmlir_1_1GenRegistration.html#details">More...</a><br /></td></tr>
<tr class="memitem:GPUDynamicSharedMemoryOpLowering" id="r_GPUDynamicSharedMemoryOpLowering"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GPUDynamicSharedMemoryOpLowering.html">GPUDynamicSharedMemoryOpLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowering for gpu.dynamic.shared.memory to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect.  <a href="structmlir_1_1GPUDynamicSharedMemoryOpLowering.html#details">More...</a><br /></td></tr>
<tr class="memitem:GPUFuncOpLowering" id="r_GPUFuncOpLowering"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GPUFuncOpLowering.html">GPUFuncOpLowering</a></td></tr>
<tr class="memitem:GPUFuncOpLoweringOptions" id="r_GPUFuncOpLoweringOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GPUFuncOpLoweringOptions.html">GPUFuncOpLoweringOptions</a></td></tr>
<tr class="memitem:GpuKernelOutliningPassOptions" id="r_GpuKernelOutliningPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GpuKernelOutliningPassOptions.html">GpuKernelOutliningPassOptions</a></td></tr>
<tr class="memitem:GpuMapParallelLoopsPassOptions" id="r_GpuMapParallelLoopsPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GpuMapParallelLoopsPassOptions.html">GpuMapParallelLoopsPassOptions</a></td></tr>
<tr class="memitem:GpuModuleToBinaryPassOptions" id="r_GpuModuleToBinaryPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GpuModuleToBinaryPassOptions.html">GpuModuleToBinaryPassOptions</a></td></tr>
<tr class="memitem:GpuNVVMAttachTargetOptions" id="r_GpuNVVMAttachTargetOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GpuNVVMAttachTargetOptions.html">GpuNVVMAttachTargetOptions</a></td></tr>
<tr class="memitem:GPUPrintfOpToHIPLowering" id="r_GPUPrintfOpToHIPLowering"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GPUPrintfOpToHIPLowering.html">GPUPrintfOpToHIPLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lowering of gpu.printf to a call to HIP hostcalls.  <a href="structmlir_1_1GPUPrintfOpToHIPLowering.html#details">More...</a><br /></td></tr>
<tr class="memitem:GPUPrintfOpToLLVMCallLowering" id="r_GPUPrintfOpToLLVMCallLowering"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GPUPrintfOpToLLVMCallLowering.html">GPUPrintfOpToLLVMCallLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lowering of gpu.printf to a call to an external printf() function.  <a href="structmlir_1_1GPUPrintfOpToLLVMCallLowering.html#details">More...</a><br /></td></tr>
<tr class="memitem:GPUPrintfOpToVPrintfLowering" id="r_GPUPrintfOpToVPrintfLowering"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GPUPrintfOpToVPrintfLowering.html">GPUPrintfOpToVPrintfLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowering of gpu.printf to a vprintf standard library.  <a href="structmlir_1_1GPUPrintfOpToVPrintfLowering.html#details">More...</a><br /></td></tr>
<tr class="memitem:GPUReturnOpLowering" id="r_GPUReturnOpLowering"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GPUReturnOpLowering.html">GPUReturnOpLowering</a></td></tr>
<tr class="memitem:GpuROCDLAttachTargetOptions" id="r_GpuROCDLAttachTargetOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GpuROCDLAttachTargetOptions.html">GpuROCDLAttachTargetOptions</a></td></tr>
<tr class="memitem:GpuSPIRVAttachTargetOptions" id="r_GpuSPIRVAttachTargetOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GpuSPIRVAttachTargetOptions.html">GpuSPIRVAttachTargetOptions</a></td></tr>
<tr class="memitem:GpuToLLVMConversionPassOptions" id="r_GpuToLLVMConversionPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GpuToLLVMConversionPassOptions.html">GpuToLLVMConversionPassOptions</a></td></tr>
<tr class="memitem:GpuXeVMAttachTargetOptions" id="r_GpuXeVMAttachTargetOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GpuXeVMAttachTargetOptions.html">GpuXeVMAttachTargetOptions</a></td></tr>
<tr class="memitem:GreedyRewriteConfig" id="r_GreedyRewriteConfig"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class allows control over how the GreedyPatternRewriteDriver works.  <a href="classmlir_1_1GreedyRewriteConfig.html#details">More...</a><br /></td></tr>
<tr class="memitem:HasDefaultDLTIDataLayout" id="r_HasDefaultDLTIDataLayout"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1HasDefaultDLTIDataLayout.html">HasDefaultDLTIDataLayout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to be used by operations willing to use the implementation of the data layout interfaces provided by the Target dialect.  <a href="classmlir_1_1HasDefaultDLTIDataLayout.html#details">More...</a><br /></td></tr>
<tr class="memitem:HeapAsmResourceBlob" id="r_HeapAsmResourceBlob"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1HeapAsmResourceBlob.html">HeapAsmResourceBlob</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a simple utility wrapper for creating heap allocated AsmResourceBlobs.  <a href="classmlir_1_1HeapAsmResourceBlob.html#details">More...</a><br /></td></tr>
<tr class="memitem:HomomorphismSimplification" id="r_HomomorphismSimplification"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1HomomorphismSimplification.html">HomomorphismSimplification</a></td></tr>
<tr class="memitem:HyperrectangularSlice" id="r_HyperrectangularSlice"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1HyperrectangularSlice.html">HyperrectangularSlice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hyperrectangular slice, represented as a list of offsets, sizes and strides.  <a href="classmlir_1_1HyperrectangularSlice.html#details">More...</a><br /></td></tr>
<tr class="memitem:ImplicitLocOpBuilder" id="r_ImplicitLocOpBuilder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html">ImplicitLocOpBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html" title="ImplicitLocOpBuilder maintains a &#39;current location&#39;, allowing use of the create&lt;&gt; method without spec...">ImplicitLocOpBuilder</a> maintains a 'current location', allowing use of the create&lt;&gt; method without specifying the location.  <a href="classmlir_1_1ImplicitLocOpBuilder.html#details">More...</a><br /></td></tr>
<tr class="memitem:InFlightDiagnostic" id="r_InFlightDiagnostic"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a diagnostic that is inflight and set to be reported.  <a href="classmlir_1_1InFlightDiagnostic.html#details">More...</a><br /></td></tr>
<tr class="memitem:Inliner" id="r_Inliner"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Inliner.html">Inliner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implementation of the inliner that operates bottom up over the Strongly Connected Components(SCCs) of the <a class="el" href="classmlir_1_1CallGraph.html">CallGraph</a>.  <a href="classmlir_1_1Inliner.html#details">More...</a><br /></td></tr>
<tr class="memitem:InlinerConfig" id="r_InlinerConfig"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1InlinerConfig.html">InlinerConfig</a></td></tr>
<tr class="memitem:InlinerInterface" id="r_InlinerInterface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface provides the hooks into the inlining interface.  <a href="classmlir_1_1InlinerInterface.html#details">More...</a><br /></td></tr>
<tr class="memitem:InlinerOptions" id="r_InlinerOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1InlinerOptions.html">InlinerOptions</a></td></tr>
<tr class="memitem:IntegerSet" id="r_IntegerSet"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer set representing a conjunction of one or more affine equalities and inequalities.  <a href="classmlir_1_1IntegerSet.html#details">More...</a><br /></td></tr>
<tr class="memitem:IntegerValueRange" id="r_IntegerValueRange"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerValueRange.html">IntegerValueRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This lattice value represents the integer range of an SSA value.  <a href="classmlir_1_1IntegerValueRange.html#details">More...</a><br /></td></tr>
<tr class="memitem:InterfacePass" id="r_InterfacePass"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1InterfacePass.html">InterfacePass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> to transform an operation that implements the given interface.  <a href="classmlir_1_1InterfacePass.html#details">More...</a><br /></td></tr>
<tr class="memitem:InvocationBounds" id="r_InvocationBounds"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1InvocationBounds.html">InvocationBounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents upper and lower bounds on the number of times a region of a <span class="tt">RegionBranchOpInterface</span> can be invoked.  <a href="classmlir_1_1InvocationBounds.html#details">More...</a><br /></td></tr>
<tr class="memitem:IRMapping" id="r_IRMapping"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a utility class for mapping one set of IR entities to another.  <a href="classmlir_1_1IRMapping.html#details">More...</a><br /></td></tr>
<tr class="memitem:IRObjectWithUseList" id="r_IRObjectWithUseList"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IRObjectWithUseList.html">IRObjectWithUseList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a single IR object that contains a use list.  <a href="classmlir_1_1IRObjectWithUseList.html#details">More...</a><br /></td></tr>
<tr class="memitem:IROperand" id="r_IROperand"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IROperand.html">IROperand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference to a value, suitable for use as an operand of an operation.  <a href="classmlir_1_1IROperand.html#details">More...</a><br /></td></tr>
<tr class="memitem:IRRewriter" id="r_IRRewriter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IRRewriter.html">IRRewriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class coordinates rewriting a piece of IR outside of a pattern rewrite, providing a way to keep track of the mutations made to the IR.  <a href="classmlir_1_1IRRewriter.html#details">More...</a><br /></td></tr>
<tr class="memitem:IRUnit" id="r_IRUnit"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IRUnit.html">IRUnit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1IRUnit.html" title="IRUnit is a union of the different types of IR objects that constitute the IR structure (other than T...">IRUnit</a> is a union of the different types of IR objects that constitute the IR structure (other than <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> and <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>), that is <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>, <a class="el" href="classmlir_1_1Region.html" title="This class contains a list of basic blocks and a link to the parent operation it is attached to.">Region</a>, and <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a>.  <a href="classmlir_1_1IRUnit.html#details">More...</a><br /></td></tr>
<tr class="memitem:iterator_5Frange" id="r_iterator_5Frange"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1iterator__range.html">iterator_range</a></td></tr>
<tr class="memitem:JamBlockGatherer" id="r_JamBlockGatherer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1JamBlockGatherer.html">JamBlockGatherer</a></td></tr>
<tr class="memitem:JitRunnerConfig" id="r_JitRunnerConfig"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1JitRunnerConfig.html">JitRunnerConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration to override functionality of the JitRunner.  <a href="structmlir_1_1JitRunnerConfig.html#details">More...</a><br /></td></tr>
<tr class="memitem:JitRunnerOptions" id="r_JitRunnerOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1JitRunnerOptions.html">JitRunnerOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">JitRunner command line options used by <a class="el" href="structmlir_1_1JitRunnerConfig.html" title="Configuration to override functionality of the JitRunner.">JitRunnerConfig</a> methods.  <a href="structmlir_1_1JitRunnerOptions.html#details">More...</a><br /></td></tr>
<tr class="memitem:LatticeAnchor" id="r_LatticeAnchor"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1LatticeAnchor.html">LatticeAnchor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fundamental IR components are supported as first-class lattice anchor.  <a href="structmlir_1_1LatticeAnchor.html#details">More...</a><br /></td></tr>
<tr class="memitem:Lexer" id="r_Lexer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Lexer.html">Lexer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class breaks up the current file into a token stream.  <a href="classmlir_1_1Lexer.html#details">More...</a><br /></td></tr>
<tr class="memitem:LinalgBlockPackMatmulOptions" id="r_LinalgBlockPackMatmulOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1LinalgBlockPackMatmulOptions.html">LinalgBlockPackMatmulOptions</a></td></tr>
<tr class="memitem:LinalgDetensorizePassOptions" id="r_LinalgDetensorizePassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1LinalgDetensorizePassOptions.html">LinalgDetensorizePassOptions</a></td></tr>
<tr class="memitem:LinalgFoldUnitExtentDimsPassOptions" id="r_LinalgFoldUnitExtentDimsPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1LinalgFoldUnitExtentDimsPassOptions.html">LinalgFoldUnitExtentDimsPassOptions</a></td></tr>
<tr class="memitem:LinalgMorphOpsPassOptions" id="r_LinalgMorphOpsPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1LinalgMorphOpsPassOptions.html">LinalgMorphOpsPassOptions</a></td></tr>
<tr class="memitem:Liveness" id="r_Liveness"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Liveness.html">Liveness</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an analysis for computing liveness information from a given top-level operation.  <a href="classmlir_1_1Liveness.html#details">More...</a><br /></td></tr>
<tr class="memitem:LivenessBlockInfo" id="r_LivenessBlockInfo"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LivenessBlockInfo.html">LivenessBlockInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents liveness information on block level.  <a href="classmlir_1_1LivenessBlockInfo.html#details">More...</a><br /></td></tr>
<tr class="memitem:LLVMConversionTarget" id="r_LLVMConversionTarget"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMConversionTarget.html">LLVMConversionTarget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class that automatically populates legalization information for different <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> ops.  <a href="classmlir_1_1LLVMConversionTarget.html#details">More...</a><br /></td></tr>
<tr class="memitem:LLVMImportDialectInterface" id="r_LLVMImportDialectInterface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMImportDialectInterface.html">LLVMImportDialectInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1detail_1_1DialectInterfaceBase.html#a8fb069ca452108e8daff12e429db97fd">Base</a> class for dialect interfaces used to import <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR.  <a href="classmlir_1_1LLVMImportDialectInterface.html#details">More...</a><br /></td></tr>
<tr class="memitem:LLVMImportInterface" id="r_LLVMImportInterface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMImportInterface.html">LLVMImportInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface collection for the import of <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR that dispatches to a concrete dialect interface implementation.  <a href="classmlir_1_1LLVMImportInterface.html#details">More...</a><br /></td></tr>
<tr class="memitem:LLVMTranslationDialectInterface" id="r_LLVMTranslationDialectInterface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTranslationDialectInterface.html">LLVMTranslationDialectInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1detail_1_1DialectInterfaceBase.html#a8fb069ca452108e8daff12e429db97fd">Base</a> class for dialect interfaces providing translation to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR.  <a href="classmlir_1_1LLVMTranslationDialectInterface.html#details">More...</a><br /></td></tr>
<tr class="memitem:LLVMTranslationInterface" id="r_LLVMTranslationInterface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTranslationInterface.html">LLVMTranslationInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface collection for translation to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR, dispatches to a concrete interface implementation based on the dialect to which the given op belongs.  <a href="classmlir_1_1LLVMTranslationInterface.html#details">More...</a><br /></td></tr>
<tr class="memitem:LLVMTypeConverter" id="r_LLVMTypeConverter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion from types to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect.  <a href="classmlir_1_1LLVMTypeConverter.html#details">More...</a><br /></td></tr>
<tr class="memitem:LocalAliasAnalysis" id="r_LocalAliasAnalysis"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LocalAliasAnalysis.html">LocalAliasAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a local form of alias analysis that tries to identify the underlying values addressed by each value and performs a few basic checks to see if they alias.  <a href="classmlir_1_1LocalAliasAnalysis.html#details">More...</a><br /></td></tr>
<tr class="memitem:Location" id="r_Location"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Location.html">Location</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around a <a class="el" href="classmlir_1_1LocationAttr.html" title="Location objects represent source locations information in MLIR.">LocationAttr</a>.  <a href="classmlir_1_1Location.html#details">More...</a><br /></td></tr>
<tr class="memitem:LocationAttr" id="r_LocationAttr"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Location.html" title="This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...">Location</a> objects represent source locations information in MLIR.  <a href="classmlir_1_1LocationAttr.html#details">More...</a><br /></td></tr>
<tr class="memitem:LocationSnapshotOptions" id="r_LocationSnapshotOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1LocationSnapshotOptions.html">LocationSnapshotOptions</a></td></tr>
<tr class="memitem:LockedSymbolTableCollection" id="r_LockedSymbolTableCollection"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LockedSymbolTableCollection.html">LockedSymbolTableCollection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a lock-based shared wrapper around a symbol table collection that allows shared access to the collection of symbol tables.  <a href="classmlir_1_1LockedSymbolTableCollection.html#details">More...</a><br /></td></tr>
<tr class="memitem:LowerSparseOpsToForeachOptions" id="r_LowerSparseOpsToForeachOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1LowerSparseOpsToForeachOptions.html">LowerSparseOpsToForeachOptions</a></td></tr>
<tr class="memitem:LowerToLLVMOptions" id="r_LowerToLLVMOptions"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LowerToLLVMOptions.html">LowerToLLVMOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to control the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> lowering.  <a href="classmlir_1_1LowerToLLVMOptions.html#details">More...</a><br /></td></tr>
<tr class="memitem:MapMemRefStorageClassOptions" id="r_MapMemRefStorageClassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MapMemRefStorageClassOptions.html">MapMemRefStorageClassOptions</a></td></tr>
<tr class="memitem:MathPolynomialApproximationOptions" id="r_MathPolynomialApproximationOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MathPolynomialApproximationOptions.html">MathPolynomialApproximationOptions</a></td></tr>
<tr class="memitem:Mem2RegOptions" id="r_Mem2RegOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1Mem2RegOptions.html">Mem2RegOptions</a></td></tr>
<tr class="memitem:Mem2RegStatistics" id="r_Mem2RegStatistics"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1Mem2RegStatistics.html">Mem2RegStatistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics collected while applying mem2reg.  <a href="structmlir_1_1Mem2RegStatistics.html#details">More...</a><br /></td></tr>
<tr class="memitem:MemorySlot" id="r_MemorySlot"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemorySlot.html">MemorySlot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a slot in memory.  <a href="structmlir_1_1MemorySlot.html#details">More...</a><br /></td></tr>
<tr class="memitem:MemRefDescriptor" id="r_MemRefDescriptor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MemRefDescriptor.html">MemRefDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to produce <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect operations extracting or inserting elements of a MemRef descriptor.  <a href="classmlir_1_1MemRefDescriptor.html#details">More...</a><br /></td></tr>
<tr class="memitem:MemRefDescriptorView" id="r_MemRefDescriptorView"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MemRefDescriptorView.html">MemRefDescriptorView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class allowing the user to access a range of Values that correspond to an unpacked memref descriptor using named accessors.  <a href="classmlir_1_1MemRefDescriptorView.html#details">More...</a><br /></td></tr>
<tr class="memitem:MergeResult" id="r_MergeResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MergeResult.html">MergeResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for the result of merge operation of tiling.  <a href="structmlir_1_1MergeResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:MLIRContext" id="r_MLIRContext"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a> is the top-level object for a collection of MLIR operations.  <a href="classmlir_1_1MLIRContext.html#details">More...</a><br /></td></tr>
<tr class="memitem:MLIRContextImpl" id="r_MLIRContextImpl"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MLIRContextImpl.html">MLIRContextImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the implementation of the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a> class, using the pImpl idiom.  <a href="classmlir_1_1MLIRContextImpl.html#details">More...</a><br /></td></tr>
<tr class="memitem:MlirOptMainConfig" id="r_MlirOptMainConfig"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MlirOptMainConfig.html">MlirOptMainConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration options for the mlir-opt tool.  <a href="classmlir_1_1MlirOptMainConfig.html#details">More...</a><br /></td></tr>
<tr class="memitem:ModRefResult" id="r_ModRefResult"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ModRefResult.html">ModRefResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible results of whether a memory access modifies or references a memory location.  <a href="classmlir_1_1ModRefResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:ModuleAnalysisManager" id="r_ModuleAnalysisManager"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ModuleAnalysisManager.html">ModuleAnalysisManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An analysis manager class specifically for the top-level operation.  <a href="classmlir_1_1ModuleAnalysisManager.html#details">More...</a><br /></td></tr>
<tr class="memitem:MutableAffineMap" id="r_MutableAffineMap"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MutableAffineMap.html">MutableAffineMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutable affine map. Its affine expressions are however unique.  <a href="structmlir_1_1MutableAffineMap.html#details">More...</a><br /></td></tr>
<tr class="memitem:MutableArrayRef" id="r_MutableArrayRef"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MutableArrayRef.html">MutableArrayRef</a></td></tr>
<tr class="memitem:MutableOperandRange" id="r_MutableOperandRange"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MutableOperandRange.html">MutableOperandRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a mutable adaptor for a range of operands.  <a href="classmlir_1_1MutableOperandRange.html#details">More...</a><br /></td></tr>
<tr class="memitem:MutableOperandRangeRange" id="r_MutableOperandRangeRange"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MutableOperandRangeRange.html">MutableOperandRangeRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a contiguous range of mutable operand ranges, e.g.  <a href="classmlir_1_1MutableOperandRangeRange.html#details">More...</a><br /></td></tr>
<tr class="memitem:NamedAttribute" id="r_NamedAttribute"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1NamedAttribute.html" title="NamedAttribute represents a combination of a name and an Attribute value.">NamedAttribute</a> represents a combination of a name and an <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> value.  <a href="classmlir_1_1NamedAttribute.html#details">More...</a><br /></td></tr>
<tr class="memitem:NamedAttrList" id="r_NamedAttrList"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1NamedAttrList.html">NamedAttrList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1NamedAttrList.html" title="NamedAttrList is array of NamedAttributes that tracks whether it is sorted and does some basic work t...">NamedAttrList</a> is array of NamedAttributes that tracks whether it is sorted and does some basic work to remain sorted.  <a href="classmlir_1_1NamedAttrList.html#details">More...</a><br /></td></tr>
<tr class="memitem:Namespace" id="r_Namespace"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Namespace.html">Namespace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A namespace that is used to store existing names and generate new names in some scope within the IR.  <a href="classmlir_1_1Namespace.html#details">More...</a><br /></td></tr>
<tr class="memitem:OneToOneConvertToLLVMPattern" id="r_OneToOneConvertToLLVMPattern"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OneToOneConvertToLLVMPattern.html">OneToOneConvertToLLVMPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic implementation of one-to-one conversion from "SourceOp" to "TargetOp" where the latter belongs to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect or an equivalent.  <a href="classmlir_1_1OneToOneConvertToLLVMPattern.html#details">More...</a><br /></td></tr>
<tr class="memitem:Op" id="r_Op"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html">Op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides public APIs that all operations should have.  <a href="classmlir_1_1Op.html#details">More...</a><br /></td></tr>
<tr class="memitem:OpaqueProperties" id="r_OpaqueProperties"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpaqueProperties.html">OpaqueProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple wrapper around a void* in order to express generically how to pass in op properties through APIs.  <a href="classmlir_1_1OpaqueProperties.html#details">More...</a><br /></td></tr>
<tr class="memitem:OpAsmDialectInterface" id="r_OpAsmDialectInterface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmDialectInterface.html">OpAsmDialectInterface</a></td></tr>
<tr class="memitem:OpAsmParser" id="r_OpAsmParser"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classmlir_1_1OpAsmParser.html" title="The OpAsmParser has methods for interacting with the asm parser: parsing things from it,...">OpAsmParser</a> has methods for interacting with the asm parser: parsing things from it, emitting errors etc.  <a href="classmlir_1_1OpAsmParser.html#details">More...</a><br /></td></tr>
<tr class="memitem:OpAsmPrinter" id="r_OpAsmPrinter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a pure-virtual base class that exposes the asmprinter hooks necessary to implement a custom <a class="el" href="SPIRVAttributes_8cpp.html#ab9c11536098442a052918c34cb6e4864">print()</a> method.  <a href="classmlir_1_1OpAsmPrinter.html#details">More...</a><br /></td></tr>
<tr class="memitem:OpBuilder" id="r_OpBuilder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class helps build Operations.  <a href="classmlir_1_1OpBuilder.html#details">More...</a><br /></td></tr>
<tr class="memitem:OperandElementTypeIterator" id="r_OperandElementTypeIterator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperandElementTypeIterator.html">OperandElementTypeIterator</a></td></tr>
<tr class="memitem:OperandRange" id="r_OperandRange"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperandRange.html">OperandRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the operand iterators for the <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> class.  <a href="classmlir_1_1OperandRange.html#details">More...</a><br /></td></tr>
<tr class="memitem:OperandRangeRange" id="r_OperandRangeRange"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperandRangeRange.html">OperandRangeRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a contiguous range of operand ranges, e.g.  <a href="classmlir_1_1OperandRangeRange.html#details">More...</a><br /></td></tr>
<tr class="memitem:Operation" id="r_Operation"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Operation.html">Operation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> is the basic unit of execution within MLIR.  <a href="classmlir_1_1Operation.html#details">More...</a><br /></td></tr>
<tr class="memitem:OperationConverter" id="r_OperationConverter"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OperationConverter.html">OperationConverter</a></td></tr>
<tr class="memitem:OperationEquivalence" id="r_OperationEquivalence"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OperationEquivalence.html">OperationEquivalence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides utilities for computing if two operations are equivalent.  <a href="structmlir_1_1OperationEquivalence.html#details">More...</a><br /></td></tr>
<tr class="memitem:OperationFingerPrint" id="r_OperationFingerPrint"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperationFingerPrint.html">OperationFingerPrint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unique fingerprint for a specific operation, and all of it's internal operations (if <span class="tt">includeNested</span> is set).  <a href="classmlir_1_1OperationFingerPrint.html#details">More...</a><br /></td></tr>
<tr class="memitem:OperationFolder" id="r_OperationFolder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperationFolder.html">OperationFolder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class for folding operations, and unifying duplicated constants generated along the way.  <a href="classmlir_1_1OperationFolder.html#details">More...</a><br /></td></tr>
<tr class="memitem:OperationName" id="r_OperationName"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperationName.html">OperationName</a></td></tr>
<tr class="memitem:OperationPass" id="r_OperationPass"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> to transform an operation of a specific type.  <a href="classmlir_1_1OperationPass.html#details">More...</a><br /></td></tr>
<tr class="memitem:OperationPass_3C_20void_20_3E" id="r_OperationPass_3C_20void_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperationPass_3_01void_01_4.html">OperationPass&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> to transform an operation.  <a href="classmlir_1_1OperationPass_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:OperationState" id="r_OperationState"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This represents an operation in an abstracted form, suitable for use with the builder APIs.  <a href="structmlir_1_1OperationState.html#details">More...</a><br /></td></tr>
<tr class="memitem:OpFoldResult" id="r_OpFoldResult"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a single result from folding an operation.  <a href="classmlir_1_1OpFoldResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:OpInterface" id="r_OpInterface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpInterface.html">OpInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the base of an operation interface.  <a href="classmlir_1_1OpInterface.html#details">More...</a><br /></td></tr>
<tr class="memitem:OpInterfaceRewritePattern" id="r_OpInterfaceRewritePattern"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpInterfaceRewritePattern.html">OpInterfaceRewritePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1OpInterfaceRewritePattern.html" title="OpInterfaceRewritePattern is a wrapper around RewritePattern that allows for matching and rewriting a...">OpInterfaceRewritePattern</a> is a wrapper around <a class="el" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements.">RewritePattern</a> that allows for matching and rewriting against an instance of an operation interface instead of a raw <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>.  <a href="structmlir_1_1OpInterfaceRewritePattern.html#details">More...</a><br /></td></tr>
<tr class="memitem:OpOperand" id="r_OpOperand"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an operand of an operation.  <a href="classmlir_1_1OpOperand.html#details">More...</a><br /></td></tr>
<tr class="memitem:OpPassManager" id="r_OpPassManager"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a pass manager that runs passes on either a specific operation type, or any isolated operation.  <a href="classmlir_1_1OpPassManager.html#details">More...</a><br /></td></tr>
<tr class="memitem:OpPrintingFlags" id="r_OpPrintingFlags"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of flags used to control the behavior of the various IR print methods (e.g.  <a href="classmlir_1_1OpPrintingFlags.html#details">More...</a><br /></td></tr>
<tr class="memitem:OpResult" id="r_OpResult"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a value defined by a result of an operation.  <a href="classmlir_1_1OpResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:OpRewritePattern" id="r_OpRewritePattern"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpRewritePattern.html">OpRewritePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1OpRewritePattern.html" title="OpRewritePattern is a wrapper around RewritePattern that allows for matching and rewriting against an...">OpRewritePattern</a> is a wrapper around <a class="el" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements.">RewritePattern</a> that allows for matching and rewriting against an instance of a derived operation class as opposed to a raw <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>.  <a href="structmlir_1_1OpRewritePattern.html#details">More...</a><br /></td></tr>
<tr class="memitem:OpState" id="r_OpState"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html">OpState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the concrete base class that holds the operation pointer and has non-generic methods that only depend on State (to avoid having them instantiated on template types that don't affect them.  <a href="classmlir_1_1OpState.html#details">More...</a><br /></td></tr>
<tr class="memitem:OptionalParseResult" id="r_OptionalParseResult"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements <span class="tt">Optional</span> functionality for ParseResult.  <a href="classmlir_1_1OptionalParseResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:OptionValue_3C_20mlir_3A_3AOpPassManager_20_3E" id="r_OptionValue_3C_20mlir_3A_3AOpPassManager_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OptionValue_3_01mlir_1_1OpPassManager_01_4.html">OptionValue&lt; mlir::OpPassManager &gt;</a></td></tr>
<tr class="memitem:OpToFuncCallLowering" id="r_OpToFuncCallLowering"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpToFuncCallLowering.html">OpToFuncCallLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewriting that replaces SourceOp with a CallOp to <span class="tt">f32Func</span> or <span class="tt">f64Func</span> or <span class="tt">f32ApproxFunc</span> or <span class="tt">f16Func</span> or <span class="tt">i32Type</span> depending on the element type and the fastMathFlag of that <a class="el" href="classmlir_1_1Op.html" title="This provides public APIs that all operations should have.">Op</a>, if present.  <a href="structmlir_1_1OpToFuncCallLowering.html#details">More...</a><br /></td></tr>
<tr class="memitem:OpTraitRewritePattern" id="r_OpTraitRewritePattern"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTraitRewritePattern.html">OpTraitRewritePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1OpTraitRewritePattern.html" title="OpTraitRewritePattern is a wrapper around RewritePattern that allows for matching and rewriting again...">OpTraitRewritePattern</a> is a wrapper around <a class="el" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements.">RewritePattern</a> that allows for matching and rewriting against instances of an operation that possess a given trait.  <a href="classmlir_1_1OpTraitRewritePattern.html#details">More...</a><br /></td></tr>
<tr class="memitem:OptReductionPassOptions" id="r_OptReductionPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OptReductionPassOptions.html">OptReductionPassOptions</a></td></tr>
<tr class="memitem:OpWithFlags" id="r_OpWithFlags"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpWithFlags.html">OpWithFlags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper class that allows for printing an operation with a set of flags, useful to act as a "stream modifier" to customize printing an operation with a stream using the operator&lt;&lt; overload, e.g.: llvm::dbgs() &lt;&lt; <a class="el" href="classmlir_1_1OpWithFlags.html" title="A wrapper class that allows for printing an operation with a set of flags, useful to act as a &quot;stream...">OpWithFlags</a>(op, OpPrintingFlags().skipRegions()); This always prints the operation with the local scope, to avoid introducing spurious newlines in the stream.  <a href="classmlir_1_1OpWithFlags.html#details">More...</a><br /></td></tr>
<tr class="memitem:OpWithOffsetSizesAndStridesConstantArgumentFolder" id="r_OpWithOffsetSizesAndStridesConstantArgumentFolder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpWithOffsetSizesAndStridesConstantArgumentFolder.html">OpWithOffsetSizesAndStridesConstantArgumentFolder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to rewrite dynamic offsets/sizes/strides of view/slice-like ops as constant arguments.  <a href="classmlir_1_1OpWithOffsetSizesAndStridesConstantArgumentFolder.html#details">More...</a><br /></td></tr>
<tr class="memitem:OpWithState" id="r_OpWithState"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpWithState.html">OpWithState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper class that allows for printing an operation with a custom <a class="el" href="classmlir_1_1AsmState.html" title="This class provides management for the lifetime of the state used when printing the IR.">AsmState</a>, useful to act as a "stream modifier" to customize printing an operation with a stream using the operator&lt;&lt; overload, e.g.: llvm::dbgs() &lt;&lt; <a class="el" href="classmlir_1_1OpWithState.html" title="A wrapper class that allows for printing an operation with a custom AsmState, useful to act as a &quot;str...">OpWithState</a>(op, OpPrintingFlags().skipRegions());.  <a href="classmlir_1_1OpWithState.html#details">More...</a><br /></td></tr>
<tr class="memitem:OutputStrategy" id="r_OutputStrategy"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OutputStrategy.html">OutputStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Facilities for printing timing reports to various output formats.  <a href="classmlir_1_1OutputStrategy.html#details">More...</a><br /></td></tr>
<tr class="memitem:OwningMemRef" id="r_OwningMemRef"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OwningMemRef.html">OwningMemRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Owning MemRef type that abstracts over the runtime type for ranked strided memref.  <a href="classmlir_1_1OwningMemRef.html#details">More...</a><br /></td></tr>
<tr class="memitem:OwningOpRef" id="r_OwningOpRef"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class acts as an owning reference to an op, and will automatically destroy the held op on destruction if the held op is valid.  <a href="classmlir_1_1OwningOpRef.html#details">More...</a><br /></td></tr>
<tr class="memitem:ParallelDiagnosticHandler" id="r_ParallelDiagnosticHandler"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ParallelDiagnosticHandler.html">ParallelDiagnosticHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a utility diagnostic handler for use when multi-threading some part of the compiler where diagnostics may be emitted.  <a href="classmlir_1_1ParallelDiagnosticHandler.html#details">More...</a><br /></td></tr>
<tr class="memitem:parser_3C_20mlir_3A_3AOpPassManager_20_3E" id="r_parser_3C_20mlir_3A_3AOpPassManager_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1parser_3_01mlir_1_1OpPassManager_01_4.html">parser&lt; mlir::OpPassManager &gt;</a></td></tr>
<tr class="memitem:parser_3C_20SmallVector_3C_20T_2C_20N_20_3E_20_3E" id="r_parser_3C_20SmallVector_3C_20T_2C_20N_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1parser_3_01SmallVector_3_01T_00_01N_01_4_01_4.html">parser&lt; SmallVector&lt; T, N &gt; &gt;</a></td></tr>
<tr class="memitem:parser_3C_20std_3A_3Avector_3C_20T_20_3E_20_3E" id="r_parser_3C_20std_3A_3Avector_3C_20T_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1parser_3_01std_1_1vector_3_01T_01_4_01_4.html">parser&lt; std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="memitem:ParserConfig" id="r_ParserConfig"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a configuration for the MLIR assembly parser.  <a href="classmlir_1_1ParserConfig.html#details">More...</a><br /></td></tr>
<tr class="memitem:Pass" id="r_Pass"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Pass.html">Pass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract base pass class.  <a href="classmlir_1_1Pass.html#details">More...</a><br /></td></tr>
<tr class="memitem:PassExecutionAction" id="r_PassExecutionAction"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassExecutionAction.html">PassExecutionAction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class encapsulates the "action" of executing a single pass.  <a href="classmlir_1_1PassExecutionAction.html#details">More...</a><br /></td></tr>
<tr class="memitem:PassInfo" id="r_PassInfo"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassInfo.html">PassInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure to represent the information for a derived pass class.  <a href="classmlir_1_1PassInfo.html#details">More...</a><br /></td></tr>
<tr class="memitem:PassInstrumentation" id="r_PassInstrumentation"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassInstrumentation.html">PassInstrumentation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1PassInstrumentation.html" title="PassInstrumentation provides several entry points into the pass manager infrastructure.">PassInstrumentation</a> provides several entry points into the pass manager infrastructure.  <a href="classmlir_1_1PassInstrumentation.html#details">More...</a><br /></td></tr>
<tr class="memitem:PassInstrumentor" id="r_PassInstrumentor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassInstrumentor.html">PassInstrumentor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class holds a collection of <a class="el" href="classmlir_1_1PassInstrumentation.html" title="PassInstrumentation provides several entry points into the pass manager infrastructure.">PassInstrumentation</a> objects, and invokes their respective call backs.  <a href="classmlir_1_1PassInstrumentor.html#details">More...</a><br /></td></tr>
<tr class="memitem:PassManager" id="r_PassManager"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassManager.html">PassManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main pass manager and pipeline builder.  <a href="classmlir_1_1PassManager.html#details">More...</a><br /></td></tr>
<tr class="memitem:PassNameCLParser" id="r_PassNameCLParser"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassNameCLParser.html">PassNameCLParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a command-line parser specifically for MLIR pass names.  <a href="classmlir_1_1PassNameCLParser.html#details">More...</a><br /></td></tr>
<tr class="memitem:PassPipelineCLParser" id="r_PassPipelineCLParser"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassPipelineCLParser.html">PassPipelineCLParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a command-line parser for MLIR passes.  <a href="classmlir_1_1PassPipelineCLParser.html#details">More...</a><br /></td></tr>
<tr class="memitem:PassPipelineInfo" id="r_PassPipelineInfo"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassPipelineInfo.html">PassPipelineInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure to represent the information of a registered pass pipeline.  <a href="classmlir_1_1PassPipelineInfo.html#details">More...</a><br /></td></tr>
<tr class="memitem:PassPipelineRegistration" id="r_PassPipelineRegistration"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PassPipelineRegistration.html">PassPipelineRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1PassPipelineRegistration.html" title="PassPipelineRegistration provides a global initializer that registers a Pass pipeline builder routine...">PassPipelineRegistration</a> provides a global initializer that registers a <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> pipeline builder routine.  <a href="structmlir_1_1PassPipelineRegistration.html#details">More...</a><br /></td></tr>
<tr class="memitem:PassPipelineRegistration_3C_20EmptyPipelineOptions_20_3E" id="r_PassPipelineRegistration_3C_20EmptyPipelineOptions_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PassPipelineRegistration_3_01EmptyPipelineOptions_01_4.html">PassPipelineRegistration&lt; EmptyPipelineOptions &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience specialization of <a class="el" href="structmlir_1_1PassPipelineRegistration.html" title="PassPipelineRegistration provides a global initializer that registers a Pass pipeline builder routine...">PassPipelineRegistration</a> for EmptyPassOptions that does not pass an empty options struct to the pass builder function.  <a href="structmlir_1_1PassPipelineRegistration_3_01EmptyPipelineOptions_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:PassPlugin" id="r_PassPlugin"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassPlugin.html">PassPlugin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A loaded pass plugin.  <a href="classmlir_1_1PassPlugin.html#details">More...</a><br /></td></tr>
<tr class="memitem:PassPluginLibraryInfo" id="r_PassPluginLibraryInfo"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PassPluginLibraryInfo.html">PassPluginLibraryInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the plugin required to load its passes.  <a href="structmlir_1_1PassPluginLibraryInfo.html#details">More...</a><br /></td></tr>
<tr class="memitem:PassRegistration" id="r_PassRegistration"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PassRegistration.html">PassRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1PassRegistration.html" title="PassRegistration provides a global initializer that registers a Pass allocation routine for a concret...">PassRegistration</a> provides a global initializer that registers a <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> allocation routine for a concrete pass instance.  <a href="structmlir_1_1PassRegistration.html#details">More...</a><br /></td></tr>
<tr class="memitem:PassRegistryEntry" id="r_PassRegistryEntry"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassRegistryEntry.html">PassRegistryEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to group information about a passes and pass pipelines (argument to invoke via mlir-opt, description, pass pipeline builder).  <a href="classmlir_1_1PassRegistryEntry.html#details">More...</a><br /></td></tr>
<tr class="memitem:PassReproducerOptions" id="r_PassReproducerOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PassReproducerOptions.html">PassReproducerOptions</a></td></tr>
<tr class="memitem:PassWrapper" id="r_PassWrapper"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassWrapper.html">PassWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a CRTP wrapper around a base pass class to define several necessary utility methods.  <a href="classmlir_1_1PassWrapper.html#details">More...</a><br /></td></tr>
<tr class="memitem:Pattern" id="r_Pattern"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Pattern.html">Pattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the data related to a pattern, but does not contain any methods or logic for the actual matching.  <a href="classmlir_1_1Pattern.html#details">More...</a><br /></td></tr>
<tr class="memitem:PatternApplicator" id="r_PatternApplicator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PatternApplicator.html">PatternApplicator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class manages the application of a group of rewrite patterns, with a user-provided cost model.  <a href="classmlir_1_1PatternApplicator.html#details">More...</a><br /></td></tr>
<tr class="memitem:PatternBenefit" id="r_PatternBenefit"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the benefit of a pattern match in a unitless scheme that ranges from 0 (very little benefit) to 65K.  <a href="classmlir_1_1PatternBenefit.html#details">More...</a><br /></td></tr>
<tr class="memitem:PatternRewriter" id="r_PatternRewriter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special type of <span class="tt"><a class="el" href="classmlir_1_1RewriterBase.html" title="This class coordinates the application of a rewrite on a set of IR, providing a way for clients to tr...">RewriterBase</a></span> that coordinates the application of a rewrite pattern on the current IR being matched, providing a way to keep track of any mutations made.  <a href="classmlir_1_1PatternRewriter.html#details">More...</a><br /></td></tr>
<tr class="memitem:PointerUnion" id="r_PointerUnion"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PointerUnion.html">PointerUnion</a></td></tr>
<tr class="memitem:PostDominanceInfo" id="r_PostDominanceInfo"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PostDominanceInfo.html">PostDominanceInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for computing basic postdominance information.  <a href="classmlir_1_1PostDominanceInfo.html#details">More...</a><br /></td></tr>
<tr class="memitem:PredecessorIterator" id="r_PredecessorIterator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PredecessorIterator.html">PredecessorIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement a predecessor iterator for blocks.  <a href="classmlir_1_1PredecessorIterator.html#details">More...</a><br /></td></tr>
<tr class="memitem:PrintIRPassOptions" id="r_PrintIRPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PrintIRPassOptions.html">PrintIRPassOptions</a></td></tr>
<tr class="memitem:PrintOpStatsOptions" id="r_PrintOpStatsOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PrintOpStatsOptions.html">PrintOpStatsOptions</a></td></tr>
<tr class="memitem:ProgramPoint" id="r_ProgramPoint"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ProgramPoint.html">ProgramPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program point represents a specific location in the execution of a program.  <a href="structmlir_1_1ProgramPoint.html#details">More...</a><br /></td></tr>
<tr class="memitem:PropertiesSelector" id="r_PropertiesSelector"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PropertiesSelector.html">PropertiesSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits to detect whether an <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> defined a <span class="tt">Properties</span> type, otherwise it'll default to <span class="tt"><a class="el" href="structmlir_1_1EmptyProperties.html" title="Structure used by default as a &quot;marker&quot; when no &quot;Properties&quot; are set on an Operation.">EmptyProperties</a></span>.  <a href="structmlir_1_1PropertiesSelector.html#details">More...</a><br /></td></tr>
<tr class="memitem:PropertiesSelector_3C_20Op_2C_20std_3A_3Avoid_5Ft_3C_20typename_20Op_3A_3AProperties_20_3E_20_3E" id="r_PropertiesSelector_3C_20Op_2C_20std_3A_3Avoid_5Ft_3C_20typename_20Op_3A_3AProperties_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PropertiesSelector_3_01Op_00_01std_1_1void__t_3_01typename_01Op_1_1Properties_01_4_01_4.html">PropertiesSelector&lt; Op, std::void_t&lt; typename Op::Properties &gt; &gt;</a></td></tr>
<tr class="memitem:PyFileAccumulator" id="r_PyFileAccumulator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PyFileAccumulator.html">PyFileAccumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulates into a file, either writing text (default) or binary.  <a href="classmlir_1_1PyFileAccumulator.html#details">More...</a><br /></td></tr>
<tr class="memitem:PyPrintAccumulator" id="r_PyPrintAccumulator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PyPrintAccumulator.html">PyPrintAccumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulates into a python string from a method that accepts an <a class="el" href="mlir-c_2Support_8h.html#aee1640ae9c91f2e92391f42bfc633bbb" title="A callback for returning string references.">MlirStringCallback</a>.  <a href="structmlir_1_1PyPrintAccumulator.html#details">More...</a><br /></td></tr>
<tr class="memitem:PyShapedType" id="r_PyShapedType"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PyShapedType.html">PyShapedType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shaped <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> Interface - ShapedType.  <a href="classmlir_1_1PyShapedType.html#details">More...</a><br /></td></tr>
<tr class="memitem:PySinglePartStringAccumulator" id="r_PySinglePartStringAccumulator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PySinglePartStringAccumulator.html">PySinglePartStringAccumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulates into a python string from a method that is expected to make one (no more, no less) call to the callback (asserts internally on violation).  <a href="structmlir_1_1PySinglePartStringAccumulator.html#details">More...</a><br /></td></tr>
<tr class="memitem:RaggedArray" id="r_RaggedArray"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RaggedArray.html">RaggedArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2D array where each row may have different length.  <a href="classmlir_1_1RaggedArray.html#details">More...</a><br /></td></tr>
<tr class="memitem:Range" id="r_Range"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1Range.html">Range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a range (offset, size, and stride) where each element of the triple may be dynamic or static.  <a href="structmlir_1_1Range.html#details">More...</a><br /></td></tr>
<tr class="memitem:raw_5Findented_5Fostream" id="r_raw_5Findented_5Fostream"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1raw__indented__ostream.html">raw_indented_ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1raw__ostream.html">raw_ostream</a> subclass that simplifies indention a sequence of code.  <a href="classmlir_1_1raw__indented__ostream.html#details">More...</a><br /></td></tr>
<tr class="memitem:raw_5Fostream" id="r_raw_5Fostream"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1raw__ostream.html">raw_ostream</a></td></tr>
<tr class="memitem:ReductionNode" id="r_ReductionNode"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ReductionNode.html">ReductionNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReductionTreePass will build a reduction tree during module reduction and the <a class="el" href="classmlir_1_1ReductionNode.html" title="ReductionTreePass will build a reduction tree during module reduction and the ReductionNode represent...">ReductionNode</a> represents the vertex of the tree.  <a href="classmlir_1_1ReductionNode.html#details">More...</a><br /></td></tr>
<tr class="memitem:ReductionTreePassOptions" id="r_ReductionTreePassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ReductionTreePassOptions.html">ReductionTreePassOptions</a></td></tr>
<tr class="memitem:Region" id="r_Region"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Region.html">Region</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains a list of basic blocks and a link to the parent operation it is attached to.  <a href="classmlir_1_1Region.html#details">More...</a><br /></td></tr>
<tr class="memitem:RegionBranchPoint" id="r_RegionBranchPoint"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RegionBranchPoint.html">RegionBranchPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a point being branched from in the methods of the <span class="tt">RegionBranchOpInterface</span>.  <a href="classmlir_1_1RegionBranchPoint.html#details">More...</a><br /></td></tr>
<tr class="memitem:RegionRange" id="r_RegionRange"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RegionRange.html">RegionRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an abstraction over the different types of ranges over Regions.  <a href="classmlir_1_1RegionRange.html#details">More...</a><br /></td></tr>
<tr class="memitem:RegionSuccessor" id="r_RegionSuccessor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RegionSuccessor.html">RegionSuccessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a successor of a region.  <a href="classmlir_1_1RegionSuccessor.html#details">More...</a><br /></td></tr>
<tr class="memitem:RegisteredOperationName" id="r_RegisteredOperationName"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RegisteredOperationName.html">RegisteredOperationName</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a "type erased" representation of a registered operation.  <a href="classmlir_1_1RegisteredOperationName.html#details">More...</a><br /></td></tr>
<tr class="memitem:ReproducerStream" id="r_ReproducerStream"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ReproducerStream.html">ReproducerStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streams on which to output crash reproducer.  <a href="structmlir_1_1ReproducerStream.html#details">More...</a><br /></td></tr>
<tr class="memitem:ResourceBlobManagerDialectInterface" id="r_ResourceBlobManagerDialectInterface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ResourceBlobManagerDialectInterface.html">ResourceBlobManagerDialectInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a dialect interface that provides common functionality for interacting with a resource blob manager.  <a href="classmlir_1_1ResourceBlobManagerDialectInterface.html#details">More...</a><br /></td></tr>
<tr class="memitem:ResourceBlobManagerDialectInterfaceBase" id="r_ResourceBlobManagerDialectInterfaceBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ResourceBlobManagerDialectInterfaceBase.html">ResourceBlobManagerDialectInterfaceBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a base class for dialects implementing the resource blob interface.  <a href="classmlir_1_1ResourceBlobManagerDialectInterfaceBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:ResultElementTypeIterator" id="r_ResultElementTypeIterator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ResultElementTypeIterator.html">ResultElementTypeIterator</a></td></tr>
<tr class="memitem:ResultRange" id="r_ResultRange"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ResultRange.html">ResultRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the result iterators for the <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> class.  <a href="classmlir_1_1ResultRange.html#details">More...</a><br /></td></tr>
<tr class="memitem:ReverseDominanceIterator" id="r_ReverseDominanceIterator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ReverseDominanceIterator.html">ReverseDominanceIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This iterator enumerates elements according to their reverse dominance relationship.  <a href="structmlir_1_1ReverseDominanceIterator.html#details">More...</a><br /></td></tr>
<tr class="memitem:ReverseIterator" id="r_ReverseIterator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ReverseIterator.html">ReverseIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This iterator enumerates elements in "reverse" order.  <a href="structmlir_1_1ReverseIterator.html#details">More...</a><br /></td></tr>
<tr class="memitem:RewritePattern" id="r_RewritePattern"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewritePattern.html">RewritePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements.">RewritePattern</a> is the common base class for all DAG to DAG replacements.  <a href="classmlir_1_1RewritePattern.html#details">More...</a><br /></td></tr>
<tr class="memitem:RewritePatternSet" id="r_RewritePatternSet"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a></td></tr>
<tr class="memitem:RewriterBase" id="r_RewriterBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class coordinates the application of a rewrite on a set of IR, providing a way for clients to track mutations and create new operations.  <a href="classmlir_1_1RewriterBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:SaturatedInteger" id="r_SaturatedInteger"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SaturatedInteger.html">SaturatedInteger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Idiomatic saturated operations on values like offsets, sizes, and strides.  <a href="structmlir_1_1SaturatedInteger.html#details">More...</a><br /></td></tr>
<tr class="memitem:SaveStateStack" id="r_SaveStateStack"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SaveStateStack.html">SaveStateStack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII object calling stackPush/stackPop on construction/destruction.  <a href="structmlir_1_1SaveStateStack.html#details">More...</a><br /></td></tr>
<tr class="memitem:ScalableVectorType" id="r_ScalableVectorType"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ScalableVectorType.html">ScalableVectorType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector type containing at least one scalable dimension.  <a href="classmlir_1_1ScalableVectorType.html#details">More...</a><br /></td></tr>
<tr class="memitem:ScalarizeVectorOpLowering" id="r_ScalarizeVectorOpLowering"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ScalarizeVectorOpLowering.html">ScalarizeVectorOpLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls SourceOp to array/vector elements.  <a href="structmlir_1_1ScalarizeVectorOpLowering.html#details">More...</a><br /></td></tr>
<tr class="memitem:SCFForLoopPeelingOptions" id="r_SCFForLoopPeelingOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SCFForLoopPeelingOptions.html">SCFForLoopPeelingOptions</a></td></tr>
<tr class="memitem:SCFParallelLoopTilingOptions" id="r_SCFParallelLoopTilingOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SCFParallelLoopTilingOptions.html">SCFParallelLoopTilingOptions</a></td></tr>
<tr class="memitem:SCFToControlFlowPassOptions" id="r_SCFToControlFlowPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SCFToControlFlowPassOptions.html">SCFToControlFlowPassOptions</a></td></tr>
<tr class="memitem:ScfToSPIRVContext" id="r_ScfToSPIRVContext"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ScfToSPIRVContext.html">ScfToSPIRVContext</a></td></tr>
<tr class="memitem:ScfToSPIRVContextImpl" id="r_ScfToSPIRVContextImpl"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ScfToSPIRVContextImpl.html">ScfToSPIRVContextImpl</a></td></tr>
<tr class="memitem:ScopedDiagnosticHandler" id="r_ScopedDiagnosticHandler"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ScopedDiagnosticHandler.html">ScopedDiagnosticHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This diagnostic handler is a simple RAII class that registers and erases a diagnostic handler on a given context.  <a href="classmlir_1_1ScopedDiagnosticHandler.html#details">More...</a><br /></td></tr>
<tr class="memitem:SelfOwningTypeID" id="r_SelfOwningTypeID"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SelfOwningTypeID.html">SelfOwningTypeID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type.">TypeID</a> for each instance of this class by using a pointer to the instance.  <a href="classmlir_1_1SelfOwningTypeID.html#details">More...</a><br /></td></tr>
<tr class="memitem:SetLLVMModuleDataLayoutPassOptions" id="r_SetLLVMModuleDataLayoutPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SetLLVMModuleDataLayoutPassOptions.html">SetLLVMModuleDataLayoutPassOptions</a></td></tr>
<tr class="memitem:ShapeAdaptor" id="r_ShapeAdaptor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ShapeAdaptor.html">ShapeAdaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor class to abstract the differences between whether value is from a ShapedType or <a class="el" href="classmlir_1_1ShapedTypeComponents.html" title="ShapedTypeComponents that represents the components of a ShapedType.">ShapedTypeComponents</a> or DenseIntElementsAttribute.  <a href="classmlir_1_1ShapeAdaptor.html#details">More...</a><br /></td></tr>
<tr class="memitem:ShapedTypeComponents" id="r_ShapedTypeComponents"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ShapedTypeComponents.html">ShapedTypeComponents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1ShapedTypeComponents.html" title="ShapedTypeComponents that represents the components of a ShapedType.">ShapedTypeComponents</a> that represents the components of a ShapedType.  <a href="classmlir_1_1ShapedTypeComponents.html#details">More...</a><br /></td></tr>
<tr class="memitem:SimpleAffineExprFlattener" id="r_SimpleAffineExprFlattener"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SimpleAffineExprFlattener.html">SimpleAffineExprFlattener</a></td></tr>
<tr class="memitem:SimpleObjectCache" id="r_SimpleObjectCache"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SimpleObjectCache.html">SimpleObjectCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple object cache following Lang's LLJITWithObjectCache example.  <a href="classmlir_1_1SimpleObjectCache.html#details">More...</a><br /></td></tr>
<tr class="memitem:Sliceable" id="r_Sliceable"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Sliceable.html">Sliceable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A CRTP base class for pseudo-containers willing to support Python-type slicing access on top of indexed access.  <a href="classmlir_1_1Sliceable.html#details">More...</a><br /></td></tr>
<tr class="memitem:SliceBoundsVerificationResult" id="r_SliceBoundsVerificationResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SliceBoundsVerificationResult.html">SliceBoundsVerificationResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result for slice bounds verification;.  <a href="structmlir_1_1SliceBoundsVerificationResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:SliceOptions" id="r_SliceOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SliceOptions.html">SliceOptions</a></td></tr>
<tr class="memitem:SmallPtrSet" id="r_SmallPtrSet"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SmallPtrSet.html">SmallPtrSet</a></td></tr>
<tr class="memitem:SmallPtrSetImpl" id="r_SmallPtrSetImpl"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SmallPtrSetImpl.html">SmallPtrSetImpl</a></td></tr>
<tr class="memitem:SmallString" id="r_SmallString"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SmallString.html">SmallString</a></td></tr>
<tr class="memitem:SmallVector" id="r_SmallVector"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SmallVector.html">SmallVector</a></td></tr>
<tr class="memitem:SmallVectorImpl" id="r_SmallVectorImpl"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SmallVectorImpl.html">SmallVectorImpl</a></td></tr>
<tr class="memitem:SourceMgrDiagnosticHandler" id="r_SourceMgrDiagnosticHandler"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SourceMgrDiagnosticHandler.html">SourceMgrDiagnosticHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a utility diagnostic handler for use with llvm::SourceMgr.  <a href="classmlir_1_1SourceMgrDiagnosticHandler.html#details">More...</a><br /></td></tr>
<tr class="memitem:SourceMgrDiagnosticVerifierHandler" id="r_SourceMgrDiagnosticVerifierHandler"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SourceMgrDiagnosticVerifierHandler.html">SourceMgrDiagnosticVerifierHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a utility diagnostic handler for use with llvm::SourceMgr that verifies that emitted diagnostics match 'expected-*' lines on the corresponding line of the source file.  <a href="classmlir_1_1SourceMgrDiagnosticVerifierHandler.html#details">More...</a><br /></td></tr>
<tr class="memitem:SparseAssemblerOptions" id="r_SparseAssemblerOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SparseAssemblerOptions.html">SparseAssemblerOptions</a></td></tr>
<tr class="memitem:SparseBufferRewriteOptions" id="r_SparseBufferRewriteOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SparseBufferRewriteOptions.html">SparseBufferRewriteOptions</a></td></tr>
<tr class="memitem:SparseGPUCodegenOptions" id="r_SparseGPUCodegenOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SparseGPUCodegenOptions.html">SparseGPUCodegenOptions</a></td></tr>
<tr class="memitem:SparseIterationTypeConverter" id="r_SparseIterationTypeConverter"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SparseIterationTypeConverter.html">SparseIterationTypeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> converter for iter_space and iterator.  <a href="structmlir_1_1SparseIterationTypeConverter.html#details">More...</a><br /></td></tr>
<tr class="memitem:SparseReinterpretMapOptions" id="r_SparseReinterpretMapOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SparseReinterpretMapOptions.html">SparseReinterpretMapOptions</a></td></tr>
<tr class="memitem:SparseTensorCodegenOptions" id="r_SparseTensorCodegenOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SparseTensorCodegenOptions.html">SparseTensorCodegenOptions</a></td></tr>
<tr class="memitem:SparseTensorTypeToBufferConverter" id="r_SparseTensorTypeToBufferConverter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SparseTensorTypeToBufferConverter.html">SparseTensorTypeToBufferConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse tensor type converter into an actual buffer.  <a href="classmlir_1_1SparseTensorTypeToBufferConverter.html#details">More...</a><br /></td></tr>
<tr class="memitem:SparseTensorTypeToPtrConverter" id="r_SparseTensorTypeToPtrConverter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SparseTensorTypeToPtrConverter.html">SparseTensorTypeToPtrConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse tensor type converter into an opaque pointer.  <a href="classmlir_1_1SparseTensorTypeToPtrConverter.html#details">More...</a><br /></td></tr>
<tr class="memitem:SparseVectorizationOptions" id="r_SparseVectorizationOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SparseVectorizationOptions.html">SparseVectorizationOptions</a></td></tr>
<tr class="memitem:SparsificationAndBufferizationOptions" id="r_SparsificationAndBufferizationOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SparsificationAndBufferizationOptions.html">SparsificationAndBufferizationOptions</a></td></tr>
<tr class="memitem:SparsificationOptions" id="r_SparsificationOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for the Sparsification pass.  <a href="structmlir_1_1SparsificationOptions.html#details">More...</a><br /></td></tr>
<tr class="memitem:SparsificationPassOptions" id="r_SparsificationPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SparsificationPassOptions.html">SparsificationPassOptions</a></td></tr>
<tr class="memitem:SPIRVConversionOptions" id="r_SPIRVConversionOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SPIRVConversionOptions.html">SPIRVConversionOptions</a></td></tr>
<tr class="memitem:SPIRVConversionTarget" id="r_SPIRVConversionTarget"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SPIRVConversionTarget.html">SPIRVConversionTarget</a></td></tr>
<tr class="memitem:SPIRVToLLVMConversion" id="r_SPIRVToLLVMConversion"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SPIRVToLLVMConversion.html">SPIRVToLLVMConversion</a></td></tr>
<tr class="memitem:SPIRVTypeConverter" id="r_SPIRVTypeConverter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> conversion from builtin types to SPIR-V types for shader interface.  <a href="classmlir_1_1SPIRVTypeConverter.html#details">More...</a><br /></td></tr>
<tr class="memitem:SplatElementsAttr" id="r_SplatElementsAttr"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SplatElementsAttr.html">SplatElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that represents a reference to a splat vector or tensor constant, meaning all of the elements have the same value.  <a href="classmlir_1_1SplatElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="memitem:SROAStatistics" id="r_SROAStatistics"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SROAStatistics.html">SROAStatistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics collected while applying SROA.  <a href="structmlir_1_1SROAStatistics.html#details">More...</a><br /></td></tr>
<tr class="memitem:StateStack" id="r_StateStack"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StateStack.html">StateStack</a></td></tr>
<tr class="memitem:StateStackFrame" id="r_StateStackFrame"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StateStackFrame.html">StateStackFrame</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common CRTP base class for <a class="el" href="classmlir_1_1StateStack.html">StateStack</a> frames.  <a href="classmlir_1_1StateStackFrame.html#details">More...</a><br /></td></tr>
<tr class="memitem:StateStackFrameBase" id="r_StateStackFrameBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StateStackFrameBase.html">StateStackFrameBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete CRTP base class for <a class="el" href="classmlir_1_1StateStack.html">StateStack</a> frames.  <a href="classmlir_1_1StateStackFrameBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:StaticTileOffsetRange" id="r_StaticTileOffsetRange"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StaticTileOffsetRange.html">StaticTileOffsetRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range-style iterator that allows for iterating over the offsets of all potential tiles of size <span class="tt">tileShape</span> within the larger shape <span class="tt">shape</span>, using an ordering specified by <span class="tt">loopOrder</span>.  <a href="classmlir_1_1StaticTileOffsetRange.html#details">More...</a><br /></td></tr>
<tr class="memitem:StorageSpecifierToLLVMTypeConverter" id="r_StorageSpecifierToLLVMTypeConverter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageSpecifierToLLVMTypeConverter.html">StorageSpecifierToLLVMTypeConverter</a></td></tr>
<tr class="memitem:StorageUniquer" id="r_StorageUniquer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer.html">StorageUniquer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class to get or create instances of "storage classes".  <a href="classmlir_1_1StorageUniquer.html#details">More...</a><br /></td></tr>
<tr class="memitem:StridedMetadataRange" id="r_StridedMetadataRange"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StridedMetadataRange.html">StridedMetadataRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents the strided metadata range information, including offsets, sizes, and strides as integer ranges.  <a href="classmlir_1_1StridedMetadataRange.html#details">More...</a><br /></td></tr>
<tr class="memitem:StructBuilder" id="r_StructBuilder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StructBuilder.html">StructBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to produce <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect operations extracting or inserting values to a struct.  <a href="classmlir_1_1StructBuilder.html#details">More...</a><br /></td></tr>
<tr class="memitem:StructuredGenerator" id="r_StructuredGenerator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StructuredGenerator.html">StructuredGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper <a class="el" href="classmlir_1_1StructuredGenerator.html" title="Helper StructuredGenerator class to manipulate and rewrite ops with StructuredOpInterface.">StructuredGenerator</a> class to manipulate and rewrite ops with <span class="tt">StructuredOpInterface</span>.  <a href="classmlir_1_1StructuredGenerator.html#details">More...</a><br /></td></tr>
<tr class="memitem:SuccessorOperands" id="r_SuccessorOperands"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SuccessorOperands.html">SuccessorOperands</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class models how operands are forwarded to block arguments in control flow.  <a href="classmlir_1_1SuccessorOperands.html#details">More...</a><br /></td></tr>
<tr class="memitem:SuccessorRange" id="r_SuccessorRange"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SuccessorRange.html">SuccessorRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the successor iterators for <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a>.  <a href="classmlir_1_1SuccessorRange.html#details">More...</a><br /></td></tr>
<tr class="memitem:SymbolCache" id="r_SymbolCache"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SymbolCache.html">SymbolCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default symbol cache implementation; stores associations between names (StringAttr's) to <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">mlir::Operation</a>'s.  <a href="classmlir_1_1SymbolCache.html#details">More...</a><br /></td></tr>
<tr class="memitem:SymbolCacheBase" id="r_SymbolCacheBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SymbolCacheBase.html">SymbolCacheBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base symbol cache class to allow for cache lookup through a pointer to some abstract cache.  <a href="classmlir_1_1SymbolCacheBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:SymbolPrivatizeOptions" id="r_SymbolPrivatizeOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SymbolPrivatizeOptions.html">SymbolPrivatizeOptions</a></td></tr>
<tr class="memitem:SymbolTable" id="r_SymbolTable"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SymbolTable.html">SymbolTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class allows for representing and managing the symbol table used by operations with the '<a class="el" href="classmlir_1_1SymbolTable.html" title="This class allows for representing and managing the symbol table used by operations with the &#39;SymbolT...">SymbolTable</a>' trait.  <a href="classmlir_1_1SymbolTable.html#details">More...</a><br /></td></tr>
<tr class="memitem:SymbolTableAnalysis" id="r_SymbolTableAnalysis"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SymbolTableAnalysis.html">SymbolTableAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a simple analysis that contains a symbol table collection and, for simplicity, a reference to the top-level symbol table.  <a href="classmlir_1_1SymbolTableAnalysis.html#details">More...</a><br /></td></tr>
<tr class="memitem:SymbolTableCollection" id="r_SymbolTableCollection"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SymbolTableCollection.html">SymbolTableCollection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a collection of <span class="tt"><a class="el" href="classmlir_1_1SymbolTable.html" title="This class allows for representing and managing the symbol table used by operations with the &#39;SymbolT...">SymbolTable</a></span>s.  <a href="classmlir_1_1SymbolTableCollection.html#details">More...</a><br /></td></tr>
<tr class="memitem:SymbolUserMap" id="r_SymbolUserMap"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SymbolUserMap.html">SymbolUserMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a map of symbols to users, and provides efficient implementations of symbol queries related to users; such as collecting the users of a symbol, replacing all uses, etc.  <a href="classmlir_1_1SymbolUserMap.html#details">More...</a><br /></td></tr>
<tr class="memitem:TensorType" id="r_TensorType"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TensorType.html">TensorType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensor types represent multi-dimensional arrays, and have two variants: RankedTensorType and UnrankedTensorType.  <a href="classmlir_1_1TensorType.html#details">More...</a><br /></td></tr>
<tr class="memitem:Tester" id="r_Tester"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Tester.html">Tester</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to keep track of the testing environment of the tool.  <a href="classmlir_1_1Tester.html#details">More...</a><br /></td></tr>
<tr class="memitem:TestSCFParallelLoopCollapsingOptions" id="r_TestSCFParallelLoopCollapsingOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TestSCFParallelLoopCollapsingOptions.html">TestSCFParallelLoopCollapsingOptions</a></td></tr>
<tr class="memitem:ThreadLocalCache" id="r_ThreadLocalCache"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ThreadLocalCache.html">ThreadLocalCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides support for defining a thread local object with non static storage duration.  <a href="classmlir_1_1ThreadLocalCache.html#details">More...</a><br /></td></tr>
<tr class="memitem:TilingResult" id="r_TilingResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TilingResult.html">TilingResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for result values of tiling.  <a href="structmlir_1_1TilingResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:Timer" id="r_Timer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle for a timer in a <span class="tt"><a class="el" href="classmlir_1_1TimingManager.html" title="This class represents facilities to measure execution time.">TimingManager</a></span>.  <a href="classmlir_1_1Timer.html#details">More...</a><br /></td></tr>
<tr class="memitem:TimeRecord" id="r_TimeRecord"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TimeRecord.html">TimeRecord</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple record class to record timing information.  <a href="structmlir_1_1TimeRecord.html#details">More...</a><br /></td></tr>
<tr class="memitem:TimingIdentifier" id="r_TimingIdentifier"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TimingIdentifier.html">TimingIdentifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represesents a uniqued string owned by a <span class="tt"><a class="el" href="classmlir_1_1TimingManager.html" title="This class represents facilities to measure execution time.">TimingManager</a></span>.  <a href="classmlir_1_1TimingIdentifier.html#details">More...</a><br /></td></tr>
<tr class="memitem:TimingManager" id="r_TimingManager"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TimingManager.html">TimingManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents facilities to measure execution time.  <a href="classmlir_1_1TimingManager.html#details">More...</a><br /></td></tr>
<tr class="memitem:TimingScope" id="r_TimingScope"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TimingScope.html">TimingScope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An RAII-style wrapper around a timer that ensures the timer is properly started and stopped.  <a href="classmlir_1_1TimingScope.html#details">More...</a><br /></td></tr>
<tr class="memitem:TinyPtrVector" id="r_TinyPtrVector"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TinyPtrVector.html">TinyPtrVector</a></td></tr>
<tr class="memitem:Token" id="r_Token"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Token.html">Token</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This represents a token in the MLIR syntax.  <a href="classmlir_1_1Token.html#details">More...</a><br /></td></tr>
<tr class="memitem:TosaToArithPassOptions" id="r_TosaToArithPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TosaToArithPassOptions.html">TosaToArithPassOptions</a></td></tr>
<tr class="memitem:TosaToLinalgNamedOptions" id="r_TosaToLinalgNamedOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TosaToLinalgNamedOptions.html">TosaToLinalgNamedOptions</a></td></tr>
<tr class="memitem:TosaToLinalgOptions" id="r_TosaToLinalgOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TosaToLinalgOptions.html">TosaToLinalgOptions</a></td></tr>
<tr class="memitem:TranslateFromMLIRRegistration" id="r_TranslateFromMLIRRegistration"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TranslateFromMLIRRegistration.html">TranslateFromMLIRRegistration</a></td></tr>
<tr class="memitem:TranslateRegistration" id="r_TranslateRegistration"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TranslateRegistration.html">TranslateRegistration</a></td></tr>
<tr class="memitem:TranslateToMLIRRegistration" id="r_TranslateToMLIRRegistration"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TranslateToMLIRRegistration.html">TranslateToMLIRRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Translate[ToMLIR|FromMLIR]Registration as an initializer that registers a function and associates it with name.  <a href="structmlir_1_1TranslateToMLIRRegistration.html#details">More...</a><br /></td></tr>
<tr class="memitem:Translation" id="r_Translation"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Translation.html">Translation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the components necessary for performing a translation.  <a href="classmlir_1_1Translation.html#details">More...</a><br /></td></tr>
<tr class="memitem:TranslationParser" id="r_TranslationParser"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TranslationParser.html">TranslationParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A command line parser for translation functions.  <a href="structmlir_1_1TranslationParser.html#details">More...</a><br /></td></tr>
<tr class="memitem:Type" id="r_Type"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html">Type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instances of the <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> class are uniqued, have an immutable identifier and an optional mutable component.  <a href="classmlir_1_1Type.html#details">More...</a><br /></td></tr>
<tr class="memitem:TypeID" id="r_TypeID"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an efficient unique identifier for a specific C++ type.  <a href="classmlir_1_1TypeID.html#details">More...</a><br /></td></tr>
<tr class="memitem:TypeIDAllocator" id="r_TypeIDAllocator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeIDAllocator.html">TypeIDAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a way to define new TypeIDs at runtime.  <a href="classmlir_1_1TypeIDAllocator.html#details">More...</a><br /></td></tr>
<tr class="memitem:TypeInterface" id="r_TypeInterface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeInterface.html">TypeInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the base of a type interface.  <a href="classmlir_1_1TypeInterface.html#details">More...</a><br /></td></tr>
<tr class="memitem:TypeRange" id="r_TypeRange"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an abstraction over the various different ranges of value types.  <a href="classmlir_1_1TypeRange.html#details">More...</a><br /></td></tr>
<tr class="memitem:TypeRangeRange" id="r_TypeRangeRange"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeRangeRange.html">TypeRangeRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an abstraction for a range of <a class="el" href="classmlir_1_1TypeRange.html" title="This class provides an abstraction over the various different ranges of value types.">TypeRange</a>.  <a href="classmlir_1_1TypeRangeRange.html#details">More...</a><br /></td></tr>
<tr class="memitem:TypeStorage" id="r_TypeStorage"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeStorage.html">TypeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base storage class appearing in a <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a>.  <a href="classmlir_1_1TypeStorage.html#details">More...</a><br /></td></tr>
<tr class="memitem:UBToLLVMConversionPassOptions" id="r_UBToLLVMConversionPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1UBToLLVMConversionPassOptions.html">UBToLLVMConversionPassOptions</a></td></tr>
<tr class="memitem:UnmanagedAsmResourceBlob" id="r_UnmanagedAsmResourceBlob"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1UnmanagedAsmResourceBlob.html">UnmanagedAsmResourceBlob</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a simple utility wrapper for creating "unmanaged" AsmResourceBlobs.  <a href="classmlir_1_1UnmanagedAsmResourceBlob.html#details">More...</a><br /></td></tr>
<tr class="memitem:UnrankedMemRefDescriptor" id="r_UnrankedMemRefDescriptor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1UnrankedMemRefDescriptor.html">UnrankedMemRefDescriptor</a></td></tr>
<tr class="memitem:UnrolledLoopInfo" id="r_UnrolledLoopInfo"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1UnrolledLoopInfo.html">UnrolledLoopInfo</a></td></tr>
<tr class="memitem:Value" id="r_Value"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Value.html">Value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an instance of an SSA value in the MLIR system, representing a computable value that has a type and a set of users.  <a href="classmlir_1_1Value.html#details">More...</a><br /></td></tr>
<tr class="memitem:ValueBoundsConstraintSet" id="r_ValueBoundsConstraintSet"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html">ValueBoundsConstraintSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to be used with <span class="tt">ValueBoundsOpInterface</span>.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#details">More...</a><br /></td></tr>
<tr class="memitem:ValueRange" id="r_ValueRange"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an abstraction over the different types of ranges over Values.  <a href="classmlir_1_1ValueRange.html#details">More...</a><br /></td></tr>
<tr class="memitem:ValueSemantics" id="r_ValueSemantics"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueSemantics.html">ValueSemantics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> trait indicating that the type has value semantics.  <a href="classmlir_1_1ValueSemantics.html#details">More...</a><br /></td></tr>
<tr class="memitem:ValueShapeRange" id="r_ValueShapeRange"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueShapeRange.html">ValueShapeRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1Range.html" title="Represents a range (offset, size, and stride) where each element of the triple may be dynamic or stat...">Range</a> of values and shapes (corresponding effectively to Shapes dialect's ValueShape type concept).  <a href="classmlir_1_1ValueShapeRange.html#details">More...</a><br /></td></tr>
<tr class="memitem:ValueTypeIterator" id="r_ValueTypeIterator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueTypeIterator.html">ValueTypeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements iteration on the types of a given range of values.  <a href="classmlir_1_1ValueTypeIterator.html#details">More...</a><br /></td></tr>
<tr class="memitem:ValueTypeRange" id="r_ValueTypeRange"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueTypeRange.html">ValueTypeRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements iteration on the types of a given range of values.  <a href="classmlir_1_1ValueTypeRange.html#details">More...</a><br /></td></tr>
<tr class="memitem:ValueUseIterator" id="r_ValueUseIterator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueUseIterator.html">ValueUseIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator class that allows for iterating over the uses of an IR operand type.  <a href="classmlir_1_1ValueUseIterator.html#details">More...</a><br /></td></tr>
<tr class="memitem:ValueUserIterator" id="r_ValueUserIterator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueUserIterator.html">ValueUserIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator over the users of an IRObject.  <a href="classmlir_1_1ValueUserIterator.html#details">More...</a><br /></td></tr>
<tr class="memitem:VectorConvertToLLVMPattern" id="r_VectorConvertToLLVMPattern"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1VectorConvertToLLVMPattern.html">VectorConvertToLLVMPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic lowering implementation to rewrite Ops with just one result to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> <a class="el" href="classmlir_1_1Dialect.html" title="Dialects are groups of MLIR operations, types and attributes, as well as behavior associated with the...">Dialect</a>.  <a href="classmlir_1_1VectorConvertToLLVMPattern.html#details">More...</a><br /></td></tr>
<tr class="memitem:VectorTransferToSCFOptions" id="r_VectorTransferToSCFOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">When lowering an N-d vector transfer op to an (N-1)-d vector transfer op, a temporary buffer is created through which individual (N-1)-d vector are staged.  <a href="structmlir_1_1VectorTransferToSCFOptions.html#details">More...</a><br /></td></tr>
<tr class="memitem:ViewOpGraphOptions" id="r_ViewOpGraphOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ViewOpGraphOptions.html">ViewOpGraphOptions</a></td></tr>
<tr class="memitem:VulkanLayoutUtils" id="r_VulkanLayoutUtils"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1VulkanLayoutUtils.html">VulkanLayoutUtils</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">According to the Vulkan spec "15.6.4. Offset and Stride Assignment": "There are different alignment requirements depending on the specific resources and on the features enabled on the device.  <a href="classmlir_1_1VulkanLayoutUtils.html#details">More...</a><br /></td></tr>
<tr class="memitem:WalkContinuation" id="r_WalkContinuation"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1WalkContinuation.html">WalkContinuation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to signal how to proceed with the walk of the backward slice:  <a href="classmlir_1_1WalkContinuation.html#details">More...</a><br /></td></tr>
<tr class="memitem:WalkResult" id="r_WalkResult"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility result that is used to signal how to proceed with an ongoing walk:  <a href="classmlir_1_1WalkResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:WalkStage" id="r_WalkStage"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1WalkStage.html">WalkStage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class to encode the current walk stage for "generic" walkers.  <a href="classmlir_1_1WalkStage.html#details">More...</a><br /></td></tr>
<tr class="memitem:WasmBinaryEncoding" id="r_WasmBinaryEncoding"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1WasmBinaryEncoding.html">WasmBinaryEncoding</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9a2a446f58dd14edfbb77bb2f0ea8818" id="r_a9a2a446f58dd14edfbb77bb2f0ea8818"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a2a446f58dd14edfbb77bb2f0ea8818">TransitiveFilter</a> = <a class="el" href="structmlir_1_1SliceOptions.html#a667b0cbe189fd8ce9af2f0475a14b602">SliceOptions::TransitiveFilter</a></td></tr>
<tr class="memitem:a73be93fbd86b265d1dafe07fe73e807e" id="r_a73be93fbd86b265d1dafe07fe73e807e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73be93fbd86b265d1dafe07fe73e807e">ForwardSliceOptions</a> = <a class="el" href="structmlir_1_1SliceOptions.html">SliceOptions</a></td></tr>
<tr class="memitem:abd3021a9a0e882a2cd1061b4312a1698" id="r_abd3021a9a0e882a2cd1061b4312a1698"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd3021a9a0e882a2cd1061b4312a1698">WalkCallback</a> = <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">mlir::function_ref</a>&lt;<a class="el" href="classmlir_1_1WalkContinuation.html">WalkContinuation</a>(<a class="el" href="classmlir_1_1Value.html">mlir::Value</a>)&gt;</td></tr>
<tr class="memdesc:abd3021a9a0e882a2cd1061b4312a1698"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback that is invoked for each value encountered during the walk of the slice.  <br /></td></tr>
<tr class="memitem:a5981724f7c36485103689d762a0b168b" id="r_a5981724f7c36485103689d762a0b168b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5981724f7c36485103689d762a0b168b">LoweringCallback</a></td></tr>
<tr class="memitem:a7a0b25e7052411f56f063eca0b73e8a2" id="r_a7a0b25e7052411f56f063eca0b73e8a2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a0b25e7052411f56f063eca0b73e8a2">MemorySpaceMapping</a> = std::function&lt;<a class="el" href="classunsigned.html">unsigned</a>(gpu::AddressSpace)&gt;</td></tr>
<tr class="memdesc:a7a0b25e7052411f56f063eca0b73e8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that maps a MemorySpace enum to a target-specific integer value.  <br /></td></tr>
<tr class="memitem:ad3cda368514f1e456981bd339ef6bc92" id="r_ad3cda368514f1e456981bd339ef6bc92"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classint64__t.html">int64_t</a>, 2&gt;</td></tr>
<tr class="memitem:a92e239e8ecf7770f9cbdc4cdb0ccd0f6" id="r_a92e239e8ecf7770f9cbdc4cdb0ccd0f6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92e239e8ecf7770f9cbdc4cdb0ccd0f6">MemrefValue</a> = <a class="el" href="#a864cb5eb1fea4a548c28cda535ba7213">TypedValue</a>&lt;<a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a>&gt;</td></tr>
<tr class="memdesc:a92e239e8ecf7770f9cbdc4cdb0ccd0f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A value with a memref type.  <br /></td></tr>
<tr class="memitem:aed48aeaaa3484827b729cced4fb0dfb6" id="r_aed48aeaaa3484827b729cced4fb0dfb6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed48aeaaa3484827b729cced4fb0dfb6">Loops</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;scf::ForOp, 8&gt;</td></tr>
<tr class="memdesc:aed48aeaaa3484827b729cced4fb0dfb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile a nest of standard for loops rooted at <span class="tt">rootForOp</span> by finding such parametric tile sizes that the outer loops have a fixed number of iterations as defined in <span class="tt">sizes</span>.  <br /></td></tr>
<tr class="memitem:a5510ab947817d6f0bf6617e367113963" id="r_a5510ab947817d6f0bf6617e367113963"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5510ab947817d6f0bf6617e367113963">TileLoops</a> = std::pair&lt;<a class="el" href="#aed48aeaaa3484827b729cced4fb0dfb6">Loops</a>, <a class="el" href="#aed48aeaaa3484827b729cced4fb0dfb6">Loops</a>&gt;</td></tr>
<tr class="memitem:a11a02d1f78682e704d9aa4a6ef3cb364" id="r_a11a02d1f78682e704d9aa4a6ef3cb364"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11a02d1f78682e704d9aa4a6ef3cb364">ReassociationIndicesRef</a> = <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classint64__t.html">int64_t</a>&gt;</td></tr>
<tr class="memitem:a9d60419b09330b78865818c679695080" id="r_a9d60419b09330b78865818c679695080"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d60419b09330b78865818c679695080">ReassociationExprs</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 2&gt;</td></tr>
<tr class="memitem:a044e19a45e06290430f27c9c818bf71a" id="r_a044e19a45e06290430f27c9c818bf71a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a044e19a45e06290430f27c9c818bf71a">AllocFunType</a> = <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt;<a class="el" href="classvoid.html">void</a> *(size_t)&gt;</td></tr>
<tr class="memitem:a5cfab90925243f984f819e6f38a7c218" id="r_a5cfab90925243f984f819e6f38a7c218"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a5cfab90925243f984f819e6f38a7c218 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5cfab90925243f984f819e6f38a7c218">ElementWiseVisitor</a> = <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt;<a class="el" href="classvoid.html">void</a>(T &amp;ptr, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classint64__t.html">int64_t</a>&gt;)&gt;</td></tr>
<tr class="memdesc:a5cfab90925243f984f819e6f38a7c218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient callback to "visit" a memref element by element.  <br /></td></tr>
<tr class="memitem:a2b41a15774356d85c622215d017ac254" id="r_a2b41a15774356d85c622215d017ac254"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b41a15774356d85c622215d017ac254">DataLayoutEntryKey</a> = <a class="el" href="classllvm_1_1PointerUnion.html">llvm::PointerUnion</a>&lt;<a class="el" href="classmlir_1_1Type.html">Type</a>, StringAttr&gt;</td></tr>
<tr class="memitem:a17d2b8b3bf4e818da2900efa145bd05b" id="r_a17d2b8b3bf4e818da2900efa145bd05b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17d2b8b3bf4e818da2900efa145bd05b">DataLayoutEntryList</a> = <a class="el" href="classllvm_1_1SmallVector.html">llvm::SmallVector</a>&lt;DataLayoutEntryInterface, 4&gt;</td></tr>
<tr class="memitem:aca03ba5e554abcffe4c1d89c53424982" id="r_aca03ba5e554abcffe4c1d89c53424982"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca03ba5e554abcffe4c1d89c53424982">DataLayoutEntryListRef</a> = <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt;DataLayoutEntryInterface&gt;</td></tr>
<tr class="memitem:a4bd203358eecf2493ba5344cd392aa65" id="r_a4bd203358eecf2493ba5344cd392aa65"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bd203358eecf2493ba5344cd392aa65">TargetDeviceSpecListRef</a> = <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt;TargetDeviceSpecInterface&gt;</td></tr>
<tr class="memitem:a4a31a056e44563d0c877ae435b5cf51c" id="r_a4a31a056e44563d0c877ae435b5cf51c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a31a056e44563d0c877ae435b5cf51c">TargetDeviceSpecEntry</a> = std::pair&lt;StringAttr, TargetDeviceSpecInterface&gt;</td></tr>
<tr class="memitem:a5dc0778d8b69de79a256dfcfe7664956" id="r_a5dc0778d8b69de79a256dfcfe7664956"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5dc0778d8b69de79a256dfcfe7664956">DataLayoutIdentifiedEntryMap</a></td></tr>
<tr class="memitem:a288fe47d4f5d1342fd68f6a877a23046" id="r_a288fe47d4f5d1342fd68f6a877a23046"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a288fe47d4f5d1342fd68f6a877a23046">SetIntRangeFn</a></td></tr>
<tr class="memdesc:a288fe47d4f5d1342fd68f6a877a23046"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the <span class="tt">setResultRanges</span> callback provided to ops implementing InferIntRangeInterface.  <br /></td></tr>
<tr class="memitem:a2acdab8c5c09e069909b8e887f0b31ea" id="r_a2acdab8c5c09e069909b8e887f0b31ea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2acdab8c5c09e069909b8e887f0b31ea">SetIntLatticeFn</a></td></tr>
<tr class="memdesc:a2acdab8c5c09e069909b8e887f0b31ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="#a288fe47d4f5d1342fd68f6a877a23046" title="The type of the setResultRanges callback provided to ops implementing InferIntRangeInterface.">SetIntRangeFn</a>, but operating on <a class="el" href="classmlir_1_1IntegerValueRange.html" title="This lattice value represents the integer range of an SSA value.">IntegerValueRange</a> lattice values.  <br /></td></tr>
<tr class="memitem:afbe7bd7ebed80ba2be13ab5e9387f3fe" id="r_afbe7bd7ebed80ba2be13ab5e9387f3fe"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbe7bd7ebed80ba2be13ab5e9387f3fe">GetIntRangeFn</a> = <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt;<a class="el" href="classmlir_1_1IntegerValueRange.html">IntegerValueRange</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;</td></tr>
<tr class="memdesc:afbe7bd7ebed80ba2be13ab5e9387f3fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper callback type to get the integer range of a value.  <br /></td></tr>
<tr class="memitem:ac60ebc0849fbf18245acaee5a6bc7b5b" id="r_ac60ebc0849fbf18245acaee5a6bc7b5b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac60ebc0849fbf18245acaee5a6bc7b5b">SetStridedMetadataRangeFn</a></td></tr>
<tr class="memdesc:ac60ebc0849fbf18245acaee5a6bc7b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type for setting the strided metadata of a value.  <br /></td></tr>
<tr class="memitem:a676bc3fbf14bd5dba33f962b259d2034" id="r_a676bc3fbf14bd5dba33f962b259d2034"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a676bc3fbf14bd5dba33f962b259d2034">ReifiedRankedShapedTypeDims</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt;&gt;</td></tr>
<tr class="memitem:a22fb6c3afa264f1726b430274179e011" id="r_a22fb6c3afa264f1726b430274179e011"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22fb6c3afa264f1726b430274179e011">NewYieldValuesFn</a></td></tr>
<tr class="memdesc:a22fb6c3afa264f1726b430274179e011"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that returns the additional yielded values during <span class="tt">replaceWithAdditionalYields</span>.  <br /></td></tr>
<tr class="memitem:ae781cb86d98ed62093c16c9e8819799b" id="r_ae781cb86d98ed62093c16c9e8819799b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae781cb86d98ed62093c16c9e8819799b">ValueDimList</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;std::pair&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>, std::optional&lt;<a class="el" href="classint64__t.html">int64_t</a>&gt;&gt;&gt;</td></tr>
<tr class="memitem:afb0f7ff64a84622f6ab30510c2225795" id="r_afb0f7ff64a84622f6ab30510c2225795"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb0f7ff64a84622f6ab30510c2225795">DefaultAttributeStorage</a> = <a class="el" href="classmlir_1_1AttributeStorage.html">AttributeStorage</a></td></tr>
<tr class="memdesc:afb0f7ff64a84622f6ab30510c2225795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default storage type for attributes that require no additional initialization or storage.  <br /></td></tr>
<tr class="memitem:a5bf01d72562fd4631776bb74fa4efe47" id="r_a5bf01d72562fd4631776bb74fa4efe47"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bf01d72562fd4631776bb74fa4efe47">AttributeStorageAllocator</a> = <a class="el" href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html">StorageUniquer::StorageAllocator</a></td></tr>
<tr class="memitem:a5ba7e9a69eabd40dd01927f0185517f7" id="r_a5ba7e9a69eabd40dd01927f0185517f7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ba7e9a69eabd40dd01927f0185517f7">AttrSubElementReplacements</a> = <a class="el" href="classmlir_1_1AttrTypeSubElementReplacements.html">AttrTypeSubElementReplacements</a>&lt;<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&gt;</td></tr>
<tr class="memitem:af8f67951552f6246ef1d9cfb21bf4cc5" id="r_af8f67951552f6246ef1d9cfb21bf4cc5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8f67951552f6246ef1d9cfb21bf4cc5">TypeSubElementReplacements</a> = <a class="el" href="classmlir_1_1AttrTypeSubElementReplacements.html">AttrTypeSubElementReplacements</a>&lt;<a class="el" href="classmlir_1_1Type.html">Type</a>&gt;</td></tr>
<tr class="memitem:a47d2df4a0e350ac0c7fe9c87c76a0188" id="r_a47d2df4a0e350ac0c7fe9c87c76a0188"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47d2df4a0e350ac0c7fe9c87c76a0188">DenseResourceElementsHandle</a> = <a class="el" href="structmlir_1_1DialectResourceBlobHandle.html">DialectResourceBlobHandle</a>&lt;BuiltinDialect&gt;</td></tr>
<tr class="memitem:abac17268f4f35fc764ae9f810faad3df" id="r_abac17268f4f35fc764ae9f810faad3df"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abac17268f4f35fc764ae9f810faad3df">DenseBoolArrayAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt;<a class="el" href="classbool.html">bool</a>&gt;</td></tr>
<tr class="memitem:a3d68b629669b4329d85248453c29f2b4" id="r_a3d68b629669b4329d85248453c29f2b4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d68b629669b4329d85248453c29f2b4">DenseI8ArrayAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt;int8_t&gt;</td></tr>
<tr class="memitem:ae10aae53e540089fe9ad4fc6ed8aecb0" id="r_ae10aae53e540089fe9ad4fc6ed8aecb0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae10aae53e540089fe9ad4fc6ed8aecb0">DenseI16ArrayAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt;int16_t&gt;</td></tr>
<tr class="memitem:a8810f74ec6699911bda66ad210693ab9" id="r_a8810f74ec6699911bda66ad210693ab9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8810f74ec6699911bda66ad210693ab9">DenseI32ArrayAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt;int32_t&gt;</td></tr>
<tr class="memitem:a12cd3f8e7b8c9f2cac6f17ff1dd80cd8" id="r_a12cd3f8e7b8c9f2cac6f17ff1dd80cd8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12cd3f8e7b8c9f2cac6f17ff1dd80cd8">DenseI64ArrayAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt;<a class="el" href="classint64__t.html">int64_t</a>&gt;</td></tr>
<tr class="memitem:ad0d3ebf4f71f1220646aba6d1a805672" id="r_ad0d3ebf4f71f1220646aba6d1a805672"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0d3ebf4f71f1220646aba6d1a805672">DenseF32ArrayAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt;float&gt;</td></tr>
<tr class="memitem:ab56db522421522a641e396eafaffbc72" id="r_ab56db522421522a641e396eafaffbc72"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab56db522421522a641e396eafaffbc72">DenseF64ArrayAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt;double&gt;</td></tr>
<tr class="memitem:a5df7b76c5b37ebb08dd8ee485555287a" id="r_a5df7b76c5b37ebb08dd8ee485555287a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5df7b76c5b37ebb08dd8ee485555287a">DenseBoolResourceElementsAttr</a></td></tr>
<tr class="memitem:abd8c55aab8498932190dd8014d1a445c" id="r_abd8c55aab8498932190dd8014d1a445c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd8c55aab8498932190dd8014d1a445c">DenseI8ResourceElementsAttr</a></td></tr>
<tr class="memitem:a6c662950241aa2f480b1d68ab64164c7" id="r_a6c662950241aa2f480b1d68ab64164c7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c662950241aa2f480b1d68ab64164c7">DenseI16ResourceElementsAttr</a></td></tr>
<tr class="memitem:a3064aa49ad102963ff202e9903385bdc" id="r_a3064aa49ad102963ff202e9903385bdc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3064aa49ad102963ff202e9903385bdc">DenseI32ResourceElementsAttr</a></td></tr>
<tr class="memitem:a85932b40fda20f471041793c35ab742a" id="r_a85932b40fda20f471041793c35ab742a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85932b40fda20f471041793c35ab742a">DenseI64ResourceElementsAttr</a></td></tr>
<tr class="memitem:adfbe9b27a834264f1cf1bc56f9a36c3a" id="r_adfbe9b27a834264f1cf1bc56f9a36c3a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfbe9b27a834264f1cf1bc56f9a36c3a">DenseUI8ResourceElementsAttr</a></td></tr>
<tr class="memitem:a88c45efc3c82e10f4e49696b1baaa40b" id="r_a88c45efc3c82e10f4e49696b1baaa40b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88c45efc3c82e10f4e49696b1baaa40b">DenseUI16ResourceElementsAttr</a></td></tr>
<tr class="memitem:a373f31c5e81954deaccebf02fd177040" id="r_a373f31c5e81954deaccebf02fd177040"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a373f31c5e81954deaccebf02fd177040">DenseUI32ResourceElementsAttr</a></td></tr>
<tr class="memitem:a2077156a5dc77393da6566434fb15aa6" id="r_a2077156a5dc77393da6566434fb15aa6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2077156a5dc77393da6566434fb15aa6">DenseUI64ResourceElementsAttr</a></td></tr>
<tr class="memitem:a5233c3052f050497e318bd0b91bf0ee8" id="r_a5233c3052f050497e318bd0b91bf0ee8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5233c3052f050497e318bd0b91bf0ee8">DenseF32ResourceElementsAttr</a></td></tr>
<tr class="memitem:aecf75b79ba339133a7c1aa0880b54a70" id="r_aecf75b79ba339133a7c1aa0880b54a70"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecf75b79ba339133a7c1aa0880b54a70">DenseF64ResourceElementsAttr</a></td></tr>
<tr class="memitem:aadc2250b56aebea7d22d222929a86dd9" id="r_aadc2250b56aebea7d22d222929a86dd9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aadc2250b56aebea7d22d222929a86dd9">DialectAllocatorFunction</a> = std::function&lt;<a class="el" href="classmlir_1_1Dialect.html">Dialect</a> *(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td></tr>
<tr class="memitem:ac2ab3da480d1cc6d3104dd423086fa7c" id="r_ac2ab3da480d1cc6d3104dd423086fa7c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2ab3da480d1cc6d3104dd423086fa7c">DialectAllocatorFunctionRef</a> = <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt;<a class="el" href="classmlir_1_1Dialect.html">Dialect</a> *(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td></tr>
<tr class="memitem:adb076aced6798f0c7d41487f4d4b228e" id="r_adb076aced6798f0c7d41487f4d4b228e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb076aced6798f0c7d41487f4d4b228e">DynamicDialectPopulationFunction</a></td></tr>
<tr class="memitem:a76b4b70c990b486e0e1c005e13d6e204" id="r_a76b4b70c990b486e0e1c005e13d6e204"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76b4b70c990b486e0e1c005e13d6e204">DominanceInfoNode</a> = llvm::DomTreeNodeBase&lt;<a class="el" href="classmlir_1_1Block.html">Block</a>&gt;</td></tr>
<tr class="memitem:aab1e861818e2f0fd512d7269a9c95a1d" id="r_aab1e861818e2f0fd512d7269a9c95a1d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab1e861818e2f0fd512d7269a9c95a1d">OpAsmSetNameFn</a> = <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt;<a class="el" href="classvoid.html">void</a>(StringRef)&gt;</td></tr>
<tr class="memdesc:aab1e861818e2f0fd512d7269a9c95a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor used to set the name of the result.  <br /></td></tr>
<tr class="memitem:a1732950cbc518fd5656351ecc1f3dcea" id="r_a1732950cbc518fd5656351ecc1f3dcea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1732950cbc518fd5656351ecc1f3dcea">OpAsmSetValueNameFn</a> = <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt;<a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, StringRef)&gt;</td></tr>
<tr class="memdesc:a1732950cbc518fd5656351ecc1f3dcea"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor used to set the name of the start of a result group of an operation.  <br /></td></tr>
<tr class="memitem:afe0f321b0342e2d3b005627d85baa5ad" id="r_afe0f321b0342e2d3b005627d85baa5ad"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe0f321b0342e2d3b005627d85baa5ad">OpAsmSetBlockNameFn</a> = <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt;<a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Block.html">Block</a> *, StringRef)&gt;</td></tr>
<tr class="memdesc:afe0f321b0342e2d3b005627d85baa5ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor used to set the name of blocks in regions directly nested under an operation.  <br /></td></tr>
<tr class="memitem:a5a72cd6bb5511a9aacec43a0e40452c9" id="r_a5a72cd6bb5511a9aacec43a0e40452c9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a72cd6bb5511a9aacec43a0e40452c9">TypeRangeRangeIterator</a></td></tr>
<tr class="memitem:a4f291a678314f33c164a2bb33d32f8f5" id="r_a4f291a678314f33c164a2bb33d32f8f5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f291a678314f33c164a2bb33d32f8f5">DefaultTypeStorage</a> = <a class="el" href="classmlir_1_1TypeStorage.html">TypeStorage</a></td></tr>
<tr class="memdesc:a4f291a678314f33c164a2bb33d32f8f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default storage type for types that require no additional initialization or storage.  <br /></td></tr>
<tr class="memitem:a07820b1b64d9c34cc7055479eb3951aa" id="r_a07820b1b64d9c34cc7055479eb3951aa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07820b1b64d9c34cc7055479eb3951aa">TypeStorageAllocator</a> = <a class="el" href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html">StorageUniquer::StorageAllocator</a></td></tr>
<tr class="memdesc:a07820b1b64d9c34cc7055479eb3951aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a utility allocator used to allocate memory for instances of derived Types.  <br /></td></tr>
<tr class="memitem:a2fea733fc78ca9f48e6d1e5003350fe2" id="r_a2fea733fc78ca9f48e6d1e5003350fe2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fea733fc78ca9f48e6d1e5003350fe2">OperandElementTypeRange</a> = <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt;<a class="el" href="classmlir_1_1OperandElementTypeIterator.html">OperandElementTypeIterator</a>&gt;</td></tr>
<tr class="memitem:a4b1e38ec88915ae4091502043a3a81f3" id="r_a4b1e38ec88915ae4091502043a3a81f3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b1e38ec88915ae4091502043a3a81f3">ResultElementTypeRange</a> = <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt;<a class="el" href="classmlir_1_1ResultElementTypeIterator.html">ResultElementTypeIterator</a>&gt;</td></tr>
<tr class="memitem:a864cb5eb1fea4a548c28cda535ba7213" id="r_a864cb5eb1fea4a548c28cda535ba7213"><td class="memTemplParams" colspan="2">template&lt;typename Ty, typename <a class="el" href="classmlir_1_1Value.html">Value</a> = mlir::Value&gt; </td></tr>
<tr class="memitem:a864cb5eb1fea4a548c28cda535ba7213 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a864cb5eb1fea4a548c28cda535ba7213">TypedValue</a></td></tr>
<tr class="memdesc:a864cb5eb1fea4a548c28cda535ba7213"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Ty is <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">mlir::Type</a> this will select <span class="tt"><a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a></span> instead of having a wrapper around it.  <br /></td></tr>
<tr class="memitem:ab2bd7f43571b8a966760c237e15e282d" id="r_ab2bd7f43571b8a966760c237e15e282d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2bd7f43571b8a966760c237e15e282d">ReproducerStreamFactory</a></td></tr>
<tr class="memdesc:ab2bd7f43571b8a966760c237e15e282d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method type for constructing <a class="el" href="structmlir_1_1ReproducerStream.html" title="Streams on which to output crash reproducer.">ReproducerStream</a>.  <br /></td></tr>
<tr class="memitem:a1eb8eb86939076c1bf86f544e23aef0e" id="r_a1eb8eb86939076c1bf86f544e23aef0e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1eb8eb86939076c1bf86f544e23aef0e">PassRegistryFunction</a></td></tr>
<tr class="memdesc:a1eb8eb86939076c1bf86f544e23aef0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A registry function that adds passes to the given pass manager.  <br /></td></tr>
<tr class="memitem:a13509926eab92d24bb5729fef49bdf37" id="r_a13509926eab92d24bb5729fef49bdf37"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13509926eab92d24bb5729fef49bdf37">PassAllocatorFunction</a> = std::function&lt;std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">Pass</a>&gt;()&gt;</td></tr>
<tr class="memitem:a0fe2f804c3b5ffdbebdae95e127ce987" id="r_a0fe2f804c3b5ffdbebdae95e127ce987"><td class="memTemplParams" colspan="2">template&lt;typename T, typename Enable = void&gt; </td></tr>
<tr class="memitem:a0fe2f804c3b5ffdbebdae95e127ce987 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fe2f804c3b5ffdbebdae95e127ce987">DenseMapInfo</a> = <a class="el" href="structllvm_1_1DenseMapInfo.html">llvm::DenseMapInfo</a>&lt;T, Enable&gt;</td></tr>
<tr class="memitem:abde461319ad5039ddbf5b4e70f47618b" id="r_abde461319ad5039ddbf5b4e70f47618b"><td class="memTemplParams" colspan="2">template&lt;typename KeyT, typename ValueT, typename KeyInfoT = DenseMapInfo&lt;KeyT&gt;, typename BucketT = llvm::detail::DenseMapPair&lt;KeyT, ValueT&gt;&gt; </td></tr>
<tr class="memitem:abde461319ad5039ddbf5b4e70f47618b template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abde461319ad5039ddbf5b4e70f47618b">DenseMap</a> = <a class="el" href="classllvm_1_1DenseMap.html">llvm::DenseMap</a>&lt;KeyT, ValueT, KeyInfoT, BucketT&gt;</td></tr>
<tr class="memitem:a4aa33aa05f4fcff8a40613b43fb06f01" id="r_a4aa33aa05f4fcff8a40613b43fb06f01"><td class="memTemplParams" colspan="2">template&lt;typename ValueT, typename ValueInfoT = DenseMapInfo&lt;ValueT&gt;&gt; </td></tr>
<tr class="memitem:a4aa33aa05f4fcff8a40613b43fb06f01 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4aa33aa05f4fcff8a40613b43fb06f01">DenseSet</a> = <a class="el" href="classllvm_1_1DenseSet.html">llvm::DenseSet</a>&lt;ValueT, ValueInfoT&gt;</td></tr>
<tr class="memitem:a70f70d8c0fc9767c6d18b1592cd9a7ee" id="r_a70f70d8c0fc9767c6d18b1592cd9a7ee"><td class="memTemplParams" colspan="2">template&lt;typename T, typename <a class="el" href="structVector.html">Vector</a> = llvm::SmallVector&lt;T, 0&gt;, typename Set = DenseSet&lt;T&gt;, <a class="el" href="classunsigned.html">unsigned</a> N = 0&gt; </td></tr>
<tr class="memitem:a70f70d8c0fc9767c6d18b1592cd9a7ee template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a> = <a class="el" href="classllvm_1_1SetVector.html">llvm::SetVector</a>&lt;T, <a class="el" href="structVector.html">Vector</a>, Set, N&gt;</td></tr>
<tr class="memitem:a84d105d34b85fe809ec98a1391e35811" id="r_a84d105d34b85fe809ec98a1391e35811"><td class="memTemplParams" colspan="2">template&lt;typename AllocatorTy = llvm::MallocAllocator&gt; </td></tr>
<tr class="memitem:a84d105d34b85fe809ec98a1391e35811 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84d105d34b85fe809ec98a1391e35811">StringSet</a> = <a class="el" href="classllvm_1_1StringSet.html">llvm::StringSet</a>&lt;AllocatorTy&gt;</td></tr>
<tr class="memitem:ada84f277868519ebf68fe9fbfc70c4a9" id="r_ada84f277868519ebf68fe9fbfc70c4a9"><td class="memTemplParams" colspan="2">template&lt;typename T, typename R = T&gt; </td></tr>
<tr class="memitem:ada84f277868519ebf68fe9fbfc70c4a9 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada84f277868519ebf68fe9fbfc70c4a9">StringSwitch</a> = <a class="el" href="classllvm_1_1StringSwitch.html">llvm::StringSwitch</a>&lt;T, R&gt;</td></tr>
<tr class="memitem:a9eabc3974d2131e15fad199b34b2eaa0" id="r_a9eabc3974d2131e15fad199b34b2eaa0"><td class="memTemplParams" colspan="2">template&lt;typename T, typename ResultT = void&gt; </td></tr>
<tr class="memitem:a9eabc3974d2131e15fad199b34b2eaa0 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9eabc3974d2131e15fad199b34b2eaa0">TypeSwitch</a> = <a class="el" href="classllvm_1_1TypeSwitch.html">llvm::TypeSwitch</a>&lt;T, ResultT&gt;</td></tr>
<tr class="memitem:aeb139bbbd94ce3525f61d508772f5d69" id="r_aeb139bbbd94ce3525f61d508772f5d69"><td class="memTemplParams" colspan="2">template&lt;typename Fn&gt; </td></tr>
<tr class="memitem:aeb139bbbd94ce3525f61d508772f5d69 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a> = <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt;Fn&gt;</td></tr>
<tr class="memitem:a9676bd96b41f931d8a8919d5bbb52e78" id="r_a9676bd96b41f931d8a8919d5bbb52e78"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9676bd96b41f931d8a8919d5bbb52e78">ChunkBufferHandler</a></td></tr>
<tr class="memitem:a8abaf89ab4e6fae5aca7471295fba915" id="r_a8abaf89ab4e6fae5aca7471295fba915"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8abaf89ab4e6fae5aca7471295fba915">NoSourceChunkBufferHandler</a></td></tr>
<tr class="memitem:ae92775d7a7fdc64390df6978badf5615" id="r_ae92775d7a7fdc64390df6978badf5615"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae92775d7a7fdc64390df6978badf5615">GenFunction</a></td></tr>
<tr class="memdesc:ae92775d7a7fdc64390df6978badf5615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generator function to invoke.  <br /></td></tr>
<tr class="memitem:a6aad297ee60ea11aca22b19fba8f27ac" id="r_a6aad297ee60ea11aca22b19fba8f27ac"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6aad297ee60ea11aca22b19fba8f27ac">PassPipelineFn</a> = <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt;LogicalResult(<a class="el" href="classmlir_1_1PassManager.html">PassManager</a> &amp;pm)&gt;</td></tr>
<tr class="memdesc:a6aad297ee60ea11aca22b19fba8f27ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This defines the function type used to setup the pass manager.  <br /></td></tr>
<tr class="memitem:ade33612496c16d3570c85668b8c39d2b" id="r_ade33612496c16d3570c85668b8c39d2b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade33612496c16d3570c85668b8c39d2b">TranslateSourceMgrToMLIRFunction</a></td></tr>
<tr class="memdesc:ade33612496c16d3570c85668b8c39d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the function that translates the sources managed by <span class="tt">sourceMgr</span> to MLIR.  <br /></td></tr>
<tr class="memitem:a1075794620a8bc0580df8e315cc9e7b3" id="r_a1075794620a8bc0580df8e315cc9e7b3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1075794620a8bc0580df8e315cc9e7b3">TranslateRawSourceMgrToMLIRFunction</a></td></tr>
<tr class="memitem:ac98f5f6364a5cc66f4186b6335feb388" id="r_ac98f5f6364a5cc66f4186b6335feb388"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac98f5f6364a5cc66f4186b6335feb388">TranslateStringRefToMLIRFunction</a></td></tr>
<tr class="memdesc:ac98f5f6364a5cc66f4186b6335feb388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the function that translates the given string to MLIR.  <br /></td></tr>
<tr class="memitem:a0892a7feafdcb8ef1cfd6ff43b596325" id="r_a0892a7feafdcb8ef1cfd6ff43b596325"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0892a7feafdcb8ef1cfd6ff43b596325">TranslateFromMLIRFunction</a></td></tr>
<tr class="memdesc:a0892a7feafdcb8ef1cfd6ff43b596325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the function that translates MLIR to a different format and outputs the result to a stream.  <br /></td></tr>
<tr class="memitem:a70ee1a2d7a5a045a5b96a81e3de5950c" id="r_a70ee1a2d7a5a045a5b96a81e3de5950c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70ee1a2d7a5a045a5b96a81e3de5950c">TranslateFunction</a></td></tr>
<tr class="memdesc:a70ee1a2d7a5a045a5b96a81e3de5950c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the function that performs file-to-file translation involving MLIR.  <br /></td></tr>
<tr class="memitem:a466f8ff5b3af6b8eae74d1bbef9e0c0c" id="r_a466f8ff5b3af6b8eae74d1bbef9e0c0c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a466f8ff5b3af6b8eae74d1bbef9e0c0c">DialectRegistrationFunction</a> = std::function&lt;<a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a466f8ff5b3af6b8eae74d1bbef9e0c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the function that adds all dialects and dialect extensions used for the translation to the given <a class="el" href="classmlir_1_1DialectRegistry.html" title="The DialectRegistry maps a dialect namespace to a constructor for the matching dialect.">DialectRegistry</a>.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2c02a386e5ba59c4c88f83ac471f999d" id="r_a2c02a386e5ba59c4c88f83ac471f999d"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> { <a class="el" href="#a2c02a386e5ba59c4c88f83ac471f999da4bac8cdf0a968472b519b3b295d0d48b">NoChange</a>
, <a class="el" href="#a2c02a386e5ba59c4c88f83ac471f999daf4ec5f57bd4d31b803312d873be40da9">Change</a>
 }</td></tr>
<tr class="memdesc:a2c02a386e5ba59c4c88f83ac471f999d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A result type used to indicate if a change happened.  <a href="#a2c02a386e5ba59c4c88f83ac471f999d">More...</a><br /></td></tr>
<tr class="memitem:a6e07796c43d9bdf22c519ff44150daaf" id="r_a6e07796c43d9bdf22c519ff44150daaf"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e07796c43d9bdf22c519ff44150daaf">HoistingKind</a> : uint8_t { <a class="el" href="#a6e07796c43d9bdf22c519ff44150daafa6adf97f83acf6453d4a6a4b1070f3754">None</a> = 0
, <a class="el" href="#a6e07796c43d9bdf22c519ff44150daafa89d7b10cb4238977d2b523dfd9ea7745">Loop</a> = 1 &lt;&lt; 0
, <a class="el" href="#a6e07796c43d9bdf22c519ff44150daafae1e4c8c9ccd9fc39c391da4bcd093fb2">Block</a> = 1 &lt;&lt; 1
 }</td></tr>
<tr class="memitem:a781474aef998ccce168b69ae973cd832" id="r_a781474aef998ccce168b69ae973cd832"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a781474aef998ccce168b69ae973cd832">SparseParallelizationStrategy</a> { <br />
&#160;&#160;<a class="el" href="#a781474aef998ccce168b69ae973cd832a35c3ace1970663a16e5c65baa5941b13">kNone</a>
, <a class="el" href="#a781474aef998ccce168b69ae973cd832a09e4a3d1c3e70c9426528f102480e6e7">kDenseOuterLoop</a>
, <a class="el" href="#a781474aef998ccce168b69ae973cd832afe3590ad05890d8754eef93504f9b7af">kAnyStorageOuterLoop</a>
, <a class="el" href="#a781474aef998ccce168b69ae973cd832a0d7778373362fd80feddcb9b38a354b8">kDenseAnyLoop</a>
, <br />
&#160;&#160;<a class="el" href="#a781474aef998ccce168b69ae973cd832a3b1257bf6747bc07f90c215e9aafd4a7">kAnyStorageAnyLoop</a>
<br />
 }</td></tr>
<tr class="memdesc:a781474aef998ccce168b69ae973cd832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a parallelization strategy.  <a href="#a781474aef998ccce168b69ae973cd832">More...</a><br /></td></tr>
<tr class="memitem:a855a7d93430958efaaf3a6f69e3dac1c" id="r_a855a7d93430958efaaf3a6f69e3dac1c"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a855a7d93430958efaaf3a6f69e3dac1c">ReinterpretMapScope</a> { <a class="el" href="#a855a7d93430958efaaf3a6f69e3dac1ca34bdbffdb1c0e1b603f58fc0d49548b6">kAll</a>
, <a class="el" href="#a855a7d93430958efaaf3a6f69e3dac1cafb396f5b35d10c817b375435e3432d4b">kGenericOnly</a>
, <a class="el" href="#a855a7d93430958efaaf3a6f69e3dac1ca301ae8b60ff2983a1038cc11eb53089b">kExceptGeneric</a>
 }</td></tr>
<tr class="memdesc:a855a7d93430958efaaf3a6f69e3dac1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a scope for reinterpret map pass.  <a href="#a855a7d93430958efaaf3a6f69e3dac1c">More...</a><br /></td></tr>
<tr class="memitem:a90f3feaa61d2ade78f26489cc92061c9" id="r_a90f3feaa61d2ade78f26489cc92061c9"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90f3feaa61d2ade78f26489cc92061c9">SparseEmitStrategy</a> { <a class="el" href="#a90f3feaa61d2ade78f26489cc92061c9a2396498c3d09ffee6d390b4dc4939025">kFunctional</a>
, <a class="el" href="#a90f3feaa61d2ade78f26489cc92061c9a6a8bfeffa090dea6b9365e13b07de8f5">kSparseIterator</a>
, <a class="el" href="#a90f3feaa61d2ade78f26489cc92061c9a1f8ee8266ac6831bf04f91a30d755554">kDebugInterface</a>
 }</td></tr>
<tr class="memdesc:a90f3feaa61d2ade78f26489cc92061c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a scope for reinterpret map pass.  <a href="#a90f3feaa61d2ade78f26489cc92061c9">More...</a><br /></td></tr>
<tr class="memitem:a399e164b35d18e1a77053d39719844de" id="r_a399e164b35d18e1a77053d39719844de"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a399e164b35d18e1a77053d39719844de">SPIRVSubByteTypeStorage</a> { <a class="el" href="#a399e164b35d18e1a77053d39719844deaa1977c3f68d4d3bbfe14d0e51a575482">Packed</a>
 }</td></tr>
<tr class="memdesc:a399e164b35d18e1a77053d39719844de"><td class="mdescLeft">&#160;</td><td class="mdescRight">How sub-byte values are storaged in memory.  <a href="#a399e164b35d18e1a77053d39719844de">More...</a><br /></td></tr>
<tr class="memitem:a98b49fcd2b613b6c30ffc13f35b8675c" id="r_a98b49fcd2b613b6c30ffc13f35b8675c"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98b49fcd2b613b6c30ffc13f35b8675c">DeletionKind</a> { <a class="el" href="#a98b49fcd2b613b6c30ffc13f35b8675ca02bce93bff905887ad2233110bf9c49e">Keep</a>
, <a class="el" href="#a98b49fcd2b613b6c30ffc13f35b8675caf2a6c498fb90ee345d997f888fce3b18">Delete</a>
 }</td></tr>
<tr class="memdesc:a98b49fcd2b613b6c30ffc13f35b8675c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returned by operation promotion logic requesting the deletion of an operation.  <a href="#a98b49fcd2b613b6c30ffc13f35b8675c">More...</a><br /></td></tr>
<tr class="memitem:a0bb57d9710216d3da4406e58e4cbdfd9" id="r_a0bb57d9710216d3da4406e58e4cbdfd9"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0bb57d9710216d3da4406e58e4cbdfd9">ReductionTilingStrategy</a> { <a class="el" href="#a0bb57d9710216d3da4406e58e4cbdfd9abe3b9ba476420bd7d98de1a4560c2e3d">FullReduction</a>
, <a class="el" href="#a0bb57d9710216d3da4406e58e4cbdfd9ad958073d66382f63955875a66feb4d79">PartialReductionOuterReduction</a>
, <a class="el" href="#a0bb57d9710216d3da4406e58e4cbdfd9af8276115b49533f51a75db6c8e920131">PartialReductionOuterParallel</a>
 }</td></tr>
<tr class="memdesc:a0bb57d9710216d3da4406e58e4cbdfd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tiling can be thought of as splitting a dimension into 2 and materializing the outer dimension as a loop:  <a href="#a0bb57d9710216d3da4406e58e4cbdfd9">More...</a><br /></td></tr>
<tr class="memitem:a6d3b7fd763c24274db6c115579084133" id="r_a6d3b7fd763c24274db6c115579084133"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d3b7fd763c24274db6c115579084133">AffineExprKind</a> { <br />
&#160;&#160;<a class="el" href="#a6d3b7fd763c24274db6c115579084133aec211f7c20af43e742bf2570c3cb84f9">Add</a>
, <a class="el" href="#a6d3b7fd763c24274db6c115579084133a62b6d55816cf737bfc6f42e60df1a3f2">Mul</a>
, <a class="el" href="#a6d3b7fd763c24274db6c115579084133a7aeb0277500c86e4aa6bd23f9a737942">Mod</a>
, <a class="el" href="#a6d3b7fd763c24274db6c115579084133abaa422535e7ce48b442cc07089e64e7a">FloorDiv</a>
, <br />
&#160;&#160;<a class="el" href="#a6d3b7fd763c24274db6c115579084133a30c212eb3184a5ed41f01a25c8124e8a">CeilDiv</a>
, <a class="el" href="#a6d3b7fd763c24274db6c115579084133a4be6ccd8c4af006587a76a5fd3e7dc24">LAST_AFFINE_BINARY_OP</a> = CeilDiv
, <a class="el" href="#a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255">Constant</a>
, <a class="el" href="#a6d3b7fd763c24274db6c115579084133ab49b848e4bb608f4d5650e4b2817c641">DimId</a>
, <br />
&#160;&#160;<a class="el" href="#a6d3b7fd763c24274db6c115579084133aea00d3c6059a4ff11d351696747fc7ff">SymbolId</a>
<br />
 }</td></tr>
<tr class="memitem:ac84871bcca0aaa0176d43dbdbffe9a6c" id="r_ac84871bcca0aaa0176d43dbdbffe9a6c"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac84871bcca0aaa0176d43dbdbffe9a6c">AsmResourceEntryKind</a> { <a class="el" href="#ac84871bcca0aaa0176d43dbdbffe9a6cae8016c85ada38bdc5fac616ec1318047">Blob</a>
, <a class="el" href="#ac84871bcca0aaa0176d43dbdbffe9a6cac26f15e86e3de4c398a8273272aba034">Bool</a>
, <a class="el" href="#ac84871bcca0aaa0176d43dbdbffe9a6ca27118326006d3829667a400ad23d5d98">String</a>
 }</td></tr>
<tr class="memdesc:ac84871bcca0aaa0176d43dbdbffe9a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This enum represents the different kinds of resource values.  <a href="#ac84871bcca0aaa0176d43dbdbffe9a6c">More...</a><br /></td></tr>
<tr class="memitem:a11353e6611651b85531ad95629c57d75" id="r_a11353e6611651b85531ad95629c57d75"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11353e6611651b85531ad95629c57d75">SliceVerificationResult</a> { <br />
&#160;&#160;<a class="el" href="#a11353e6611651b85531ad95629c57d75a505a83f220c02df2f85c3810cd9ceb38">Success</a>
, <a class="el" href="#a11353e6611651b85531ad95629c57d75a780dd32ee9af184442cea3f2a2a75271">RankTooLarge</a>
, <a class="el" href="#a11353e6611651b85531ad95629c57d75a87c69361ccd090c9c844e19d08432a26">SizeMismatch</a>
, <a class="el" href="#a11353e6611651b85531ad95629c57d75a6341e1bfc09d56fa49bb1b9400459d8e">ElemTypeMismatch</a>
, <br />
&#160;&#160;<a class="el" href="#a11353e6611651b85531ad95629c57d75a36a2220daadd84aaba239b031cf4cd23">MemSpaceMismatch</a>
, <a class="el" href="#a11353e6611651b85531ad95629c57d75a36297823a9892f9936fba1805a1c52ca">LayoutMismatch</a>
<br />
 }</td></tr>
<tr class="memdesc:a11353e6611651b85531ad95629c57d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum that captures information related to verifier error conditions on slice insert/extract type of ops.  <a href="#a11353e6611651b85531ad95629c57d75">More...</a><br /></td></tr>
<tr class="memitem:a247bc9a6d1f1577f2d876cb55e2ea752" id="r_a247bc9a6d1f1577f2d876cb55e2ea752"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a247bc9a6d1f1577f2d876cb55e2ea752">DiagnosticSeverity</a> { <a class="el" href="#a247bc9a6d1f1577f2d876cb55e2ea752a3b0649c72650c313a357338dcdfb64ec">Note</a>
, <a class="el" href="#a247bc9a6d1f1577f2d876cb55e2ea752a0eaadb4fcb48a0a0ed7bc9868be9fbaa">Warning</a>
, <a class="el" href="#a247bc9a6d1f1577f2d876cb55e2ea752a902b0d55fddef6f8d651fe1035b7d4bd">Error</a>
, <a class="el" href="#a247bc9a6d1f1577f2d876cb55e2ea752a91921ada405fd6ba65dff028df047cb6">Remark</a>
 }</td></tr>
<tr class="memdesc:a247bc9a6d1f1577f2d876cb55e2ea752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the different supported severity of a diagnostic.  <a href="#a247bc9a6d1f1577f2d876cb55e2ea752">More...</a><br /></td></tr>
<tr class="memitem:a55d1372af4dad8c3d157071fd4dac5b9" id="r_a55d1372af4dad8c3d157071fd4dac5b9"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55d1372af4dad8c3d157071fd4dac5b9">OpAsmAliasResult</a> { <a class="el" href="#a55d1372af4dad8c3d157071fd4dac5b9a92ce3d03f1b110bfae63c081b030b8f7">NoAlias</a>
, <a class="el" href="#a55d1372af4dad8c3d157071fd4dac5b9aa221ad4ed0fa4d0ef5a74117e307cee3">OverridableAlias</a>
, <a class="el" href="#a55d1372af4dad8c3d157071fd4dac5b9a4c9f84774db087a01403961ca633e818">FinalAlias</a>
 }</td></tr>
<tr class="memdesc:a55d1372af4dad8c3d157071fd4dac5b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the result of <span class="tt">OpAsm{Dialect,Attr,Type}Interface::getAlias</span> hook call.  <a href="#a55d1372af4dad8c3d157071fd4dac5b9">More...</a><br /></td></tr>
<tr class="memitem:abeb30aa1b062bf437bf3ea2b843a2ae1" id="r_abeb30aa1b062bf437bf3ea2b843a2ae1"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abeb30aa1b062bf437bf3ea2b843a2ae1">RegionKind</a> { <a class="el" href="#abeb30aa1b062bf437bf3ea2b843a2ae1abfd486e5c2cad6a0ba13ec4e1951815b">SSACFG</a>
, <a class="el" href="#abeb30aa1b062bf437bf3ea2b843a2ae1a4cdbd2bafa8193091ba09509cedf94fd">Graph</a>
 }</td></tr>
<tr class="memdesc:abeb30aa1b062bf437bf3ea2b843a2ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The kinds of regions contained in an operation.  <a href="#abeb30aa1b062bf437bf3ea2b843a2ae1">More...</a><br /></td></tr>
<tr class="memitem:a59fa9dd53c74f1ca73aa7ef263c94adc" id="r_a59fa9dd53c74f1ca73aa7ef263c94adc"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> { <a class="el" href="#a59fa9dd53c74f1ca73aa7ef263c94adca622a0c108b4c33e1cc5ed8a22db11cbc">PreOrder</a>
, <a class="el" href="#a59fa9dd53c74f1ca73aa7ef263c94adca22e80e4e88a340d28d3f27ee3d9d7163">PostOrder</a>
 }</td></tr>
<tr class="memdesc:a59fa9dd53c74f1ca73aa7ef263c94adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traversal order for region, block and operation walk utilities.  <a href="#a59fa9dd53c74f1ca73aa7ef263c94adc">More...</a><br /></td></tr>
<tr class="memitem:ab64460ede39d8480e398fd2e6810d95b" id="r_ab64460ede39d8480e398fd2e6810d95b"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab64460ede39d8480e398fd2e6810d95b">PassDisplayMode</a> { <a class="el" href="#ab64460ede39d8480e398fd2e6810d95ba4ee29ca12c7d126654bd0e5275de6135">List</a>
, <a class="el" href="#ab64460ede39d8480e398fd2e6810d95baaeaeaec51b4e6b88122f10ad96a8de72">Pipeline</a>
 }</td></tr>
<tr class="memdesc:ab64460ede39d8480e398fd2e6810d95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enum describing the different display modes for the information within the pass manager.  <a href="#ab64460ede39d8480e398fd2e6810d95b">More...</a><br /></td></tr>
<tr class="memitem:a9e4d5a3d224089fd8a2ebc3e933d08b5" id="r_a9e4d5a3d224089fd8a2ebc3e933d08b5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e4d5a3d224089fd8a2ebc3e933d08b5">TraversalMode</a> { <a class="el" href="#a9e4d5a3d224089fd8a2ebc3e933d08b5ab8166871d66f03feaa6948b3f5727c96">SinglePath</a>
, <a class="el" href="#a9e4d5a3d224089fd8a2ebc3e933d08b5ad4f6ed581fb2f9d06c062711e30c13e1">Backtrack</a>
, <a class="el" href="#a9e4d5a3d224089fd8a2ebc3e933d08b5a9addc7d66f740728689b7f9abde66593">MultiPath</a>
 }</td></tr>
<tr class="memdesc:a9e4d5a3d224089fd8a2ebc3e933d08b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the traversal method options to be used in the reduction tree traversal.  <a href="#a9e4d5a3d224089fd8a2ebc3e933d08b5">More...</a><br /></td></tr>
<tr class="memitem:adb385bc41aa87d4559359aa7efec524f" id="r_adb385bc41aa87d4559359aa7efec524f"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb385bc41aa87d4559359aa7efec524f">VerbosityLevel</a> { <a class="el" href="#adb385bc41aa87d4559359aa7efec524fae0a1284706116eec7a83a489235a9ef8">ErrorsOnly</a> = 0
, <a class="el" href="#adb385bc41aa87d4559359aa7efec524fac166edba58858c1730219873adabaf12">ErrorsAndWarnings</a>
, <a class="el" href="#adb385bc41aa87d4559359aa7efec524faaae8c58527eab9879bef2accec35ce55">ErrorsWarningsAndRemarks</a>
 }</td></tr>
<tr class="memdesc:adb385bc41aa87d4559359aa7efec524f"><td class="mdescLeft">&#160;</td><td class="mdescRight">enum class to indicate the verbosity level of the diagnostic filter.  <a href="#adb385bc41aa87d4559359aa7efec524f">More...</a><br /></td></tr>
<tr class="memitem:ad02690ebf6873c0066aac73d59d62223" id="r_ad02690ebf6873c0066aac73d59d62223"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad02690ebf6873c0066aac73d59d62223">RemarkFormat</a> { <a class="el" href="#ad02690ebf6873c0066aac73d59d62223a8ea6f3827ed0a34fa051c86ca01e8bf9">REMARK_FORMAT_STDOUT</a>
, <a class="el" href="#ad02690ebf6873c0066aac73d59d62223a3df5f81f68717fe4c2b0053225ec049b">REMARK_FORMAT_YAML</a>
, <a class="el" href="#ad02690ebf6873c0066aac73d59d62223afc3f17fe7a2d838c21158e7dc92e2255">REMARK_FORMAT_BITSTREAM</a>
 }</td></tr>
<tr class="memitem:a9802f6b43ebc64a739e08653d0983fae" id="r_a9802f6b43ebc64a739e08653d0983fae"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9802f6b43ebc64a739e08653d0983fae">RemarkPolicy</a> { <a class="el" href="#a9802f6b43ebc64a739e08653d0983faea7a094fd32a6ba8c813c99a0f2e108cda">REMARK_POLICY_ALL</a>
, <a class="el" href="#a9802f6b43ebc64a739e08653d0983faea7fbcdd9fcd7740580ba374f06a947818">REMARK_POLICY_FINAL</a>
 }</td></tr>
<tr class="memitem:acbb0dcd5ae75936e3c6f177223c9d5eb" id="r_acbb0dcd5ae75936e3c6f177223c9d5eb"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbb0dcd5ae75936e3c6f177223c9d5eb">GreedyRewriteStrictness</a> { <a class="el" href="#acbb0dcd5ae75936e3c6f177223c9d5eba97d3def284d4e3d3bef99205c339fceb">AnyOp</a>
, <a class="el" href="#acbb0dcd5ae75936e3c6f177223c9d5eba8fc95fc7cfbd316cce7d887ab38f6120">ExistingAndNewOps</a>
, <a class="el" href="#acbb0dcd5ae75936e3c6f177223c9d5eba475f4ba4004dc37c3764009114b6e69b">ExistingOps</a>
 }</td></tr>
<tr class="memdesc:acbb0dcd5ae75936e3c6f177223c9d5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This enum controls which ops are put on the worklist during a greedy pattern rewrite.  <a href="#acbb0dcd5ae75936e3c6f177223c9d5eb">More...</a><br /></td></tr>
<tr class="memitem:a2aef2e1e7dac5cf18273429ca58e3f4f" id="r_a2aef2e1e7dac5cf18273429ca58e3f4f"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2aef2e1e7dac5cf18273429ca58e3f4f">GreedySimplifyRegionLevel</a> { <a class="el" href="#a2aef2e1e7dac5cf18273429ca58e3f4fab9f5c797ebbf55adccdd8539a65a0241">Disabled</a>
, <a class="el" href="#a2aef2e1e7dac5cf18273429ca58e3f4fa960b44c579bc2f6818d2daaf9e4c16f0">Normal</a>
, <a class="el" href="#a2aef2e1e7dac5cf18273429ca58e3f4fa389a96d0d9b3feb46b8c9d941566a4ae">Aggressive</a>
 }</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a28d8b08d9561c09e1c96244503e2de51" id="r_a28d8b08d9561c09e1c96244503e2de51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28d8b08d9561c09e1c96244503e2de51">operator&lt;&lt;</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, const <a class="el" href="classmlir_1_1AliasResult.html">AliasResult</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a>)</td></tr>
<tr class="memitem:a61082d1d6689e96ddb09eff087188676" id="r_a61082d1d6689e96ddb09eff087188676"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61082d1d6689e96ddb09eff087188676">operator&lt;&lt;</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, const <a class="el" href="classmlir_1_1ModRefResult.html">ModRefResult</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a>)</td></tr>
<tr class="memitem:a609ab9ceb7a2ad554864c86fc7ece4fd" id="r_a609ab9ceb7a2ad554864c86fc7ece4fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a609ab9ceb7a2ad554864c86fc7ece4fd">operator|</a> (<a class="el" href="#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> <a class="el" href="IR_2AffineExpr_8cpp.html#a204f446339af7929852f44df41484be5">lhs</a>, <a class="el" href="#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> <a class="el" href="VectorTransforms_8cpp.html#a611c177776150f2e11f15c1cec5764c1">rhs</a>)</td></tr>
<tr class="memitem:aff732a72842f5442e81cce4ac2679355" id="r_aff732a72842f5442e81cce4ac2679355"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff732a72842f5442e81cce4ac2679355">operator|=</a> (<a class="el" href="#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> &amp;<a class="el" href="IR_2AffineExpr_8cpp.html#a204f446339af7929852f44df41484be5">lhs</a>, <a class="el" href="#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> <a class="el" href="VectorTransforms_8cpp.html#a611c177776150f2e11f15c1cec5764c1">rhs</a>)</td></tr>
<tr class="memitem:a4f5d450d84010aaf140c9cccddf00804" id="r_a4f5d450d84010aaf140c9cccddf00804"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f5d450d84010aaf140c9cccddf00804">operator&amp;</a> (<a class="el" href="#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> <a class="el" href="IR_2AffineExpr_8cpp.html#a204f446339af7929852f44df41484be5">lhs</a>, <a class="el" href="#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> <a class="el" href="VectorTransforms_8cpp.html#a611c177776150f2e11f15c1cec5764c1">rhs</a>)</td></tr>
<tr class="memitem:ad29d63a43cfe388d03a96a02a5538186" id="r_ad29d63a43cfe388d03a96a02a5538186"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad29d63a43cfe388d03a96a02a5538186">operator&lt;&lt;</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, const <a class="el" href="structmlir_1_1ProgramPoint.html">ProgramPoint</a> &amp;point)</td></tr>
<tr class="memitem:a942e7952bc6a382ba284b8dee6295f9c" id="r_a942e7952bc6a382ba284b8dee6295f9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a942e7952bc6a382ba284b8dee6295f9c">operator&lt;&lt;</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, const <a class="el" href="classmlir_1_1AnalysisState.html">AnalysisState</a> &amp;state)</td></tr>
<tr class="memitem:ad8348a1e9094397a47c0fb1caa89c325" id="r_ad8348a1e9094397a47c0fb1caa89c325"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8348a1e9094397a47c0fb1caa89c325">operator&lt;&lt;</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, const <a class="el" href="structmlir_1_1LatticeAnchor.html">LatticeAnchor</a> &amp;anchor)</td></tr>
<tr class="memitem:ac0e1219853f339da1b9caa57a9503c5c" id="r_ac0e1219853f339da1b9caa57a9503c5c"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0e1219853f339da1b9caa57a9503c5c">getFlattenedAffineExpr</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr, <a class="el" href="classunsigned.html">unsigned</a> numDims, <a class="el" href="classunsigned.html">unsigned</a> numSymbols, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *flattenedExpr, <a class="el" href="classmlir_1_1FlatLinearConstraints.html">FlatLinearConstraints</a> *cst=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>, <a class="el" href="classbool.html">bool</a> addConservativeSemiAffineBounds=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:ac0e1219853f339da1b9caa57a9503c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens 'expr' into 'flattenedExpr', which contains the coefficients of the dimensions, symbols, and additional variables that represent floor divisions of dimensions, symbols, and in turn other floor divisions.  <br /></td></tr>
<tr class="memitem:ab7adf1265cb39d0279d643deeacdc6f2" id="r_ab7adf1265cb39d0279d643deeacdc6f2"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7adf1265cb39d0279d643deeacdc6f2">getFlattenedAffineExprs</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a>, 8 &gt; &gt; *flattenedExprs, <a class="el" href="classmlir_1_1FlatLinearConstraints.html">FlatLinearConstraints</a> *cst=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>, <a class="el" href="classbool.html">bool</a> addConservativeSemiAffineBounds=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:ab7adf1265cb39d0279d643deeacdc6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens the result expressions of the map to their corresponding flattened forms and set in 'flattenedExprs'.  <br /></td></tr>
<tr class="memitem:a1110cddfcdc3f16a8fa36ef974b58b29" id="r_a1110cddfcdc3f16a8fa36ef974b58b29"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1110cddfcdc3f16a8fa36ef974b58b29">getFlattenedAffineExprs</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> set, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a>, 8 &gt; &gt; *flattenedExprs, <a class="el" href="classmlir_1_1FlatLinearConstraints.html">FlatLinearConstraints</a> *cst=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memitem:aeb248e9fd529c9528e4e235a52941e67" id="r_aeb248e9fd529c9528e4e235a52941e67"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb248e9fd529c9528e4e235a52941e67">getMultiAffineFunctionFromMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classmlir_1_1presburger_1_1MultiAffineFunction.html">presburger::MultiAffineFunction</a> &amp;multiAff)</td></tr>
<tr class="memitem:a5bcc9dc786aa8f64a60f1d51cdad3361" id="r_a5bcc9dc786aa8f64a60f1d51cdad3361"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bcc9dc786aa8f64a60f1d51cdad3361">alignAffineMapWithValues</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> dims, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> syms, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *newSyms=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a5bcc9dc786aa8f64a60f1d51cdad3361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-indexes the dimensions and symbols of an affine map with given <span class="tt">operands</span> values to align with <span class="tt">dims</span> and <span class="tt">syms</span> values.  <br /></td></tr>
<tr class="memitem:afffe695e75923a7c364bceee778826a9" id="r_afffe695e75923a7c364bceee778826a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afffe695e75923a7c364bceee778826a9">getForwardSlice</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *forwardSlice, const <a class="el" href="#a73be93fbd86b265d1dafe07fe73e807e">ForwardSliceOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>={})</td></tr>
<tr class="memdesc:afffe695e75923a7c364bceee778826a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills <span class="tt">forwardSlice</span> with the computed forward slice (i.e.  <br /></td></tr>
<tr class="memitem:a54d503b65f87b6cab0452ff97122cbff" id="r_a54d503b65f87b6cab0452ff97122cbff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54d503b65f87b6cab0452ff97122cbff">getForwardSlice</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> root, <a class="el" href="#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *forwardSlice, const <a class="el" href="#a73be93fbd86b265d1dafe07fe73e807e">ForwardSliceOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>={})</td></tr>
<tr class="memdesc:a54d503b65f87b6cab0452ff97122cbff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value-rooted version of <span class="tt">getForwardSlice</span>.  <br /></td></tr>
<tr class="memitem:a1735b1e89665db98941b6b483419b739" id="r_a1735b1e89665db98941b6b483419b739"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1735b1e89665db98941b6b483419b739">getBackwardSlice</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *backwardSlice, const <a class="el" href="structmlir_1_1BackwardSliceOptions.html">BackwardSliceOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>={})</td></tr>
<tr class="memdesc:a1735b1e89665db98941b6b483419b739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills <span class="tt">backwardSlice</span> with the computed backward slice (i.e.  <br /></td></tr>
<tr class="memitem:a07959f71ddade1e05fae69aadfc54be6" id="r_a07959f71ddade1e05fae69aadfc54be6"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07959f71ddade1e05fae69aadfc54be6">getBackwardSlice</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> root, <a class="el" href="#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *backwardSlice, const <a class="el" href="structmlir_1_1BackwardSliceOptions.html">BackwardSliceOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>={})</td></tr>
<tr class="memdesc:a07959f71ddade1e05fae69aadfc54be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value-rooted version of <span class="tt">getBackwardSlice</span>.  <br /></td></tr>
<tr class="memitem:acd9f91ff576a4cb961289ea2f9e3dd0f" id="r_acd9f91ff576a4cb961289ea2f9e3dd0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd9f91ff576a4cb961289ea2f9e3dd0f">getSlice</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="structmlir_1_1BackwardSliceOptions.html">BackwardSliceOptions</a> &amp;backwardSliceOptions={}, const <a class="el" href="#a73be93fbd86b265d1dafe07fe73e807e">ForwardSliceOptions</a> &amp;forwardSliceOptions={})</td></tr>
<tr class="memdesc:acd9f91ff576a4cb961289ea2f9e3dd0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratively computes backward slices and forward slices until a fixed point is reached.  <br /></td></tr>
<tr class="memitem:a6bc751bc8f30d71ad4cb771c0fcc788b" id="r_a6bc751bc8f30d71ad4cb771c0fcc788b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bc751bc8f30d71ad4cb771c0fcc788b">matchReduction</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a> &gt; iterCarriedArgs, <a class="el" href="classunsigned.html">unsigned</a> redPos, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;combinerOps)</td></tr>
<tr class="memdesc:a6bc751bc8f30d71ad4cb771c0fcc788b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to match a generic reduction given a list of iteration-carried arguments, <span class="tt">iterCarriedArgs</span> and the position of the potential reduction argument within the list, <span class="tt">redPos</span>.  <br /></td></tr>
<tr class="memitem:a95bf64684e4364416fb8d648c251d41b" id="r_a95bf64684e4364416fb8d648c251d41b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1WalkContinuation.html">WalkContinuation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95bf64684e4364416fb8d648c251d41b">walkSlice</a> (<a class="el" href="classmlir_1_1ValueRange.html">mlir::ValueRange</a> rootValues, <a class="el" href="#abd3021a9a0e882a2cd1061b4312a1698">WalkCallback</a> walkCallback)</td></tr>
<tr class="memdesc:a95bf64684e4364416fb8d648c251d41b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walks the slice starting from the <span class="tt">rootValues</span> using a depth-first traversal.  <br /></td></tr>
<tr class="memitem:a20b466301e036ddc2e72c55838139324" id="r_a20b466301e036ddc2e72c55838139324"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20b466301e036ddc2e72c55838139324">getControlFlowPredecessors</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:a20b466301e036ddc2e72c55838139324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a vector of all control predecessors of <span class="tt">value</span>.  <br /></td></tr>
<tr class="memitem:adb95f9dc749d6a604340f83fd16b19f9" id="r_adb95f9dc749d6a604340f83fd16b19f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb95f9dc749d6a604340f83fd16b19f9">sortTopologically</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> &gt; ops, <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; isOperandReady=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:adb95f9dc749d6a604340f83fd16b19f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a block, sort a range operations in said block in topological order.  <br /></td></tr>
<tr class="memitem:a35009cf90a73229f64f9090d4e5aa2b7" id="r_a35009cf90a73229f64f9090d4e5aa2b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35009cf90a73229f64f9090d4e5aa2b7">sortTopologically</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; isOperandReady=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a35009cf90a73229f64f9090d4e5aa2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a block, sort its operations in topological order, excluding its terminator if it has one.  <br /></td></tr>
<tr class="memitem:a28129a93d39ade2d40077f25a09eb389" id="r_a28129a93d39ade2d40077f25a09eb389"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28129a93d39ade2d40077f25a09eb389">computeTopologicalSorting</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; ops, <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; isOperandReady=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a28129a93d39ade2d40077f25a09eb389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a topological ordering of the given ops.  <br /></td></tr>
<tr class="memitem:a1ee8e54b17fecc4eaad55779facd0068" id="r_a1ee8e54b17fecc4eaad55779facd0068"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classmlir_1_1Block.html">Block</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ee8e54b17fecc4eaad55779facd0068">getBlocksSortedByDominance</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region)</td></tr>
<tr class="memdesc:a1ee8e54b17fecc4eaad55779facd0068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a list of blocks that is sorted according to dominance.  <br /></td></tr>
<tr class="memitem:afbb30909b4006046e7b4248b8d5a5a26" id="r_afbb30909b4006046e7b4248b8d5a5a26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbb30909b4006046e7b4248b8d5a5a26">topologicalSort</a> (const <a class="el" href="#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;toSort)</td></tr>
<tr class="memdesc:afbb30909b4006046e7b4248b8d5a5a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts all operations in <span class="tt">toSort</span> topologically while also considering region semantics.  <br /></td></tr>
<tr class="memitem:a2ce4d766139754b57d04b314aefacea5" id="r_a2ce4d766139754b57d04b314aefacea5"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ce4d766139754b57d04b314aefacea5">parseAsmSourceFile</a> (const llvm::SourceMgr &amp;sourceMgr, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;<a class="el" href="#a3ecea12db18ed347ea11d1d999237b24">config</a>, <a class="el" href="classmlir_1_1AsmParserState.html">AsmParserState</a> *asmState=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>, <a class="el" href="classmlir_1_1AsmParserCodeCompleteContext.html">AsmParserCodeCompleteContext</a> *codeCompleteContext=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a2ce4d766139754b57d04b314aefacea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated SourceMgr and appends parsed operations to the given block.  <br /></td></tr>
<tr class="memitem:a6658f887276425945e0ebe6fcc194c23" id="r_a6658f887276425945e0ebe6fcc194c23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6658f887276425945e0ebe6fcc194c23">parseAttribute</a> (llvm::StringRef attrStr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1Type.html">Type</a> type={}, size_t *numRead=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>, <a class="el" href="classbool.html">bool</a> isKnownNullTerminated=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a6658f887276425945e0ebe6fcc194c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses a single MLIR attribute to an MLIR context if it was valid.  <br /></td></tr>
<tr class="memitem:abab8375de28e1d1916659a658e7ad318" id="r_abab8375de28e1d1916659a658e7ad318"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abab8375de28e1d1916659a658e7ad318">parseType</a> (llvm::StringRef typeStr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, size_t *numRead=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>, <a class="el" href="classbool.html">bool</a> isKnownNullTerminated=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:abab8375de28e1d1916659a658e7ad318"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses a single MLIR type to an MLIR context if it was valid.  <br /></td></tr>
<tr class="memitem:a351183b9c1036310349dea952c1f2d5a" id="r_a351183b9c1036310349dea952c1f2d5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a351183b9c1036310349dea952c1f2d5a">parseAffineMap</a> (llvm::StringRef str, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a351183b9c1036310349dea952c1f2d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses a single IntegerSet/AffineMap to an MLIR context if it was valid.  <br /></td></tr>
<tr class="memitem:acda383f3d69ddb866ea67abc7ba9e75e" id="r_acda383f3d69ddb866ea67abc7ba9e75e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acda383f3d69ddb866ea67abc7ba9e75e">parseIntegerSet</a> (llvm::StringRef str, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memitem:a2ef4c7804d8356c0813ce04f87b2b1ff" id="r_a2ef4c7804d8356c0813ce04f87b2b1ff"><td class="memTemplParams" colspan="2">template&lt;typename T, typename... Ts&gt; </td></tr>
<tr class="memitem:a2ef4c7804d8356c0813ce04f87b2b1ff template"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ef4c7804d8356c0813ce04f87b2b1ff">readResourceHandle</a> (<a class="el" href="classmlir_1_1DialectBytecodeReader.html">DialectBytecodeReader</a> &amp;reader, FailureOr&lt; T &gt; &amp;value, Ts &amp;&amp;...params)</td></tr>
<tr class="memdesc:a2ef4c7804d8356c0813ce04f87b2b1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for resource handle reading that returns LogicalResult.  <br /></td></tr>
<tr class="memitem:ab4871db68c59a176135e0e35a3625e73" id="r_ab4871db68c59a176135e0e35a3625e73"><td class="memTemplParams" colspan="2">template&lt;typename T, typename... Ts&gt; </td></tr>
<tr class="memitem:ab4871db68c59a176135e0e35a3625e73 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4871db68c59a176135e0e35a3625e73">get</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, Ts &amp;&amp;...params)</td></tr>
<tr class="memdesc:ab4871db68c59a176135e0e35a3625e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method that injects context only if needed, this helps unify some of the attribute construction methods.  <br /></td></tr>
<tr class="memitem:a336eaa1f1417cbe1468e56b34ce866a1" id="r_a336eaa1f1417cbe1468e56b34ce866a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a336eaa1f1417cbe1468e56b34ce866a1">isBytecode</a> (llvm::MemoryBufferRef buffer)</td></tr>
<tr class="memdesc:a336eaa1f1417cbe1468e56b34ce866a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given buffer starts with the magic bytes that signal MLIR bytecode.  <br /></td></tr>
<tr class="memitem:ad3b71d67f0d7fe035e455a121e826f08" id="r_ad3b71d67f0d7fe035e455a121e826f08"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3b71d67f0d7fe035e455a121e826f08">readBytecodeFile</a> (llvm::MemoryBufferRef buffer, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;<a class="el" href="#a3ecea12db18ed347ea11d1d999237b24">config</a>)</td></tr>
<tr class="memdesc:ad3b71d67f0d7fe035e455a121e826f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the operations defined within the given memory buffer, containing MLIR bytecode, into the provided block.  <br /></td></tr>
<tr class="memitem:af98f1102c5f82e37f4e4cf21be1736f8" id="r_af98f1102c5f82e37f4e4cf21be1736f8"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af98f1102c5f82e37f4e4cf21be1736f8">readBytecodeFile</a> (const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;sourceMgr, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;<a class="el" href="#a3ecea12db18ed347ea11d1d999237b24">config</a>)</td></tr>
<tr class="memdesc:af98f1102c5f82e37f4e4cf21be1736f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overload with a source manager whose main file buffer is used for parsing.  <br /></td></tr>
<tr class="memitem:ae17b909cf0c32c717226432e6a65f61e" id="r_ae17b909cf0c32c717226432e6a65f61e"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae17b909cf0c32c717226432e6a65f61e">writeBytecodeToFile</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, const <a class="el" href="classmlir_1_1BytecodeWriterConfig.html">BytecodeWriterConfig</a> &amp;<a class="el" href="#a3ecea12db18ed347ea11d1d999237b24">config</a>={})</td></tr>
<tr class="memdesc:ae17b909cf0c32c717226432e6a65f61e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the bytecode for the given operation to the provided output stream.  <br /></td></tr>
<tr class="memitem:a7c0757d46861a68cf91c622169d1d598" id="r_a7c0757d46861a68cf91c622169d1d598"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c0757d46861a68cf91c622169d1d598">createLowerAffinePass</a> ()</td></tr>
<tr class="memitem:aee7856a3b7ff811204524bbc9959c8c9" id="r_aee7856a3b7ff811204524bbc9959c8c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee7856a3b7ff811204524bbc9959c8c9">populateAffineToStdConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:aee7856a3b7ff811204524bbc9959c8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the Affine dialect to the Standard dialect, in particular convert structured affine control flow into CFG branch-based control flow.  <br /></td></tr>
<tr class="memitem:ad6a984b6da6b0bf690f727bd2e20dd31" id="r_ad6a984b6da6b0bf690f727bd2e20dd31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6a984b6da6b0bf690f727bd2e20dd31">populateAffineToVectorConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:ad6a984b6da6b0bf690f727bd2e20dd31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert vector-related Affine ops to the <a class="el" href="structVector.html">Vector</a> dialect.  <br /></td></tr>
<tr class="memitem:af4cd463c8738400fd147e2f040e89948" id="r_af4cd463c8738400fd147e2f040e89948"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4cd463c8738400fd147e2f040e89948">lowerAffineLowerBound</a> (affine::AffineForOp op, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="memdesc:af4cd463c8738400fd147e2f040e89948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit code that computes the lower bound of the given affine loop using standard arithmetic operations.  <br /></td></tr>
<tr class="memitem:a59b670d3c5d9075cd52ef9d183168708" id="r_a59b670d3c5d9075cd52ef9d183168708"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59b670d3c5d9075cd52ef9d183168708">lowerAffineUpperBound</a> (affine::AffineForOp op, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="memdesc:a59b670d3c5d9075cd52ef9d183168708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit code that computes the upper bound of the given affine loop using standard arithmetic operations.  <br /></td></tr>
<tr class="memitem:aa083993aa21f3e0bf1bb1ab0bb8635ab" id="r_aa083993aa21f3e0bf1bb1ab0bb8635ab"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa083993aa21f3e0bf1bb1ab0bb8635ab">createConvertAMDGPUToROCDLPass</a> ()</td></tr>
<tr class="memitem:a4017e5cc455b5d82071989ef4f2f6c3c" id="r_a4017e5cc455b5d82071989ef4f2f6c3c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4017e5cc455b5d82071989ef4f2f6c3c">createConvertAMDGPUToROCDLPass</a> (<a class="el" href="structmlir_1_1ConvertAMDGPUToROCDLPassOptions.html">ConvertAMDGPUToROCDLPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a9dca6cbddde02ebb60f3f7d61835e63a" id="r_a9dca6cbddde02ebb60f3f7d61835e63a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9dca6cbddde02ebb60f3f7d61835e63a">populateAMDGPUToROCDLConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="structmlir_1_1amdgpu_1_1Chipset.html">amdgpu::Chipset</a> chipset)</td></tr>
<tr class="memdesc:a9dca6cbddde02ebb60f3f7d61835e63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Note: This function will also add conversions for the AMDGPU-specific address spaces and types, but those can be added separately using <a class="el" href="#ad98c9bd5dd17f663af91020fad13f0c9" title="Remap AMDGPU memory spaces to LLVM address spaces by mapping amdgpu::AddressSpace::fat_raw_buffer to ...">populateAMDGPUTypeAndAttributeConversions()</a>.  <br /></td></tr>
<tr class="memitem:ad0a585f7a2f3592bdc05659e34adc79d" id="r_ad0a585f7a2f3592bdc05659e34adc79d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0a585f7a2f3592bdc05659e34adc79d">populateCommonAMDGPUTypeAndAttributeConversions</a> (<a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;typeConverter)</td></tr>
<tr class="memdesc:ad0a585f7a2f3592bdc05659e34adc79d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap common GPU memory spaces (Workgroup, Private, etc) to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> address spaces.  <br /></td></tr>
<tr class="memitem:ad98c9bd5dd17f663af91020fad13f0c9" id="r_ad98c9bd5dd17f663af91020fad13f0c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad98c9bd5dd17f663af91020fad13f0c9">populateAMDGPUTypeAndAttributeConversions</a> (<a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;typeConverter)</td></tr>
<tr class="memdesc:ad98c9bd5dd17f663af91020fad13f0c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap AMDGPU memory spaces to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> address spaces by mapping amdgpu::AddressSpace::fat_raw_buffer to ptr addrspace(7), amdgpu::AddressSpace::buffer_rsrc to ptr addrspace(8), and amdgpu::AddressSpace::fat_strided_buffer to ptr addrspace(9).  <br /></td></tr>
<tr class="memitem:a9ea4e1449757972b16f5c9d9ebf06f7e" id="r_a9ea4e1449757972b16f5c9d9ebf06f7e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ea4e1449757972b16f5c9d9ebf06f7e">createArithToAMDGPUConversionPass</a> ()</td></tr>
<tr class="memitem:a475550aae81e6526c54a362053611b6d" id="r_a475550aae81e6526c54a362053611b6d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a475550aae81e6526c54a362053611b6d">createArithToAMDGPUConversionPass</a> (<a class="el" href="structmlir_1_1ArithToAMDGPUConversionPassOptions.html">ArithToAMDGPUConversionPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:af8b017eb711247a3aedcfd840058d6b0" id="r_af8b017eb711247a3aedcfd840058d6b0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8b017eb711247a3aedcfd840058d6b0">createArithToAPFloatConversionPass</a> ()</td></tr>
<tr class="memitem:af6d2519a4b195cb45c67a4066656a7cd" id="r_af6d2519a4b195cb45c67a4066656a7cd"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6d2519a4b195cb45c67a4066656a7cd">createArithToArmSMEConversionPass</a> ()</td></tr>
<tr class="memitem:adc52e1e0b9c1d604f07abeb1c33cd6eb" id="r_adc52e1e0b9c1d604f07abeb1c33cd6eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc52e1e0b9c1d604f07abeb1c33cd6eb">populateArithToEmitCPatterns</a> (<a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memitem:a2a5c53b69971e5f369ff40d87dad5ae6" id="r_a2a5c53b69971e5f369ff40d87dad5ae6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a5c53b69971e5f369ff40d87dad5ae6">registerConvertArithToEmitCInterface</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:ae9e5f085e5bf7b4d6bea4a0eb03eda2b" id="r_ae9e5f085e5bf7b4d6bea4a0eb03eda2b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9e5f085e5bf7b4d6bea4a0eb03eda2b">createConvertArithToEmitC</a> ()</td></tr>
<tr class="memitem:a507fcb8184a7ab0f5bfdaf63ee18a046" id="r_a507fcb8184a7ab0f5bfdaf63ee18a046"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a507fcb8184a7ab0f5bfdaf63ee18a046">createArithToLLVMConversionPass</a> ()</td></tr>
<tr class="memitem:a869453b3961a97d0a4c8d8dc00c73ce5" id="r_a869453b3961a97d0a4c8d8dc00c73ce5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a869453b3961a97d0a4c8d8dc00c73ce5">createArithToLLVMConversionPass</a> (<a class="el" href="structmlir_1_1ArithToLLVMConversionPassOptions.html">ArithToLLVMConversionPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:ad4e9ed69e63947b5506617f4f1063f6d" id="r_ad4e9ed69e63947b5506617f4f1063f6d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4e9ed69e63947b5506617f4f1063f6d">createConvertArithToSPIRVPass</a> ()</td></tr>
<tr class="memitem:ad3c1232b682090989b5a5d80a3a919e1" id="r_ad3c1232b682090989b5a5d80a3a919e1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3c1232b682090989b5a5d80a3a919e1">createConvertArithToSPIRVPass</a> (<a class="el" href="structmlir_1_1ConvertArithToSPIRVPassOptions.html">ConvertArithToSPIRVPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:aeada37b101a8a8f4b5b5975caef23708" id="r_aeada37b101a8a8f4b5b5975caef23708"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeada37b101a8a8f4b5b5975caef23708">createConvertArmNeon2dToIntrPass</a> ()</td></tr>
<tr class="memitem:a45f6113274b77800e7c3b22dd83771e0" id="r_a45f6113274b77800e7c3b22dd83771e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45f6113274b77800e7c3b22dd83771e0">populateConvertArmNeon2dToIntrPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a45f6113274b77800e7c3b22dd83771e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns for the lowering of Arm NEON 2D ops to intrinsics.  <br /></td></tr>
<tr class="memitem:a3bc08d7b0eaa1c93ac0e4fcedea40cc3" id="r_a3bc08d7b0eaa1c93ac0e4fcedea40cc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bc08d7b0eaa1c93ac0e4fcedea40cc3">registerArithToAMDGPUConversionPass</a> ()</td></tr>
<tr class="memitem:ad34f9f83677ca5c21f29cc3c0a89e5db" id="r_ad34f9f83677ca5c21f29cc3c0a89e5db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad34f9f83677ca5c21f29cc3c0a89e5db">registerArithToAMDGPUConversionPassPass</a> ()</td></tr>
<tr class="memitem:a056aaeb346564df161bb90cb462b4685" id="r_a056aaeb346564df161bb90cb462b4685"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a056aaeb346564df161bb90cb462b4685">registerArithToAPFloatConversionPass</a> ()</td></tr>
<tr class="memitem:abfaf41ca3dd406c4332f3fc714636bee" id="r_abfaf41ca3dd406c4332f3fc714636bee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfaf41ca3dd406c4332f3fc714636bee">registerArithToAPFloatConversionPassPass</a> ()</td></tr>
<tr class="memitem:aaf3998463d154760d77efff830547a66" id="r_aaf3998463d154760d77efff830547a66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf3998463d154760d77efff830547a66">registerArithToArmSMEConversionPass</a> ()</td></tr>
<tr class="memitem:ab1adf1404cc5a0c0ad17b327b10b6d4d" id="r_ab1adf1404cc5a0c0ad17b327b10b6d4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1adf1404cc5a0c0ad17b327b10b6d4d">registerArithToArmSMEConversionPassPass</a> ()</td></tr>
<tr class="memitem:ac7080efcc2ac4c70b3c9bea83ed82cc8" id="r_ac7080efcc2ac4c70b3c9bea83ed82cc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7080efcc2ac4c70b3c9bea83ed82cc8">registerArithToLLVMConversionPass</a> ()</td></tr>
<tr class="memitem:aa6f0bf41be503dfcf553db915615a30e" id="r_aa6f0bf41be503dfcf553db915615a30e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6f0bf41be503dfcf553db915615a30e">registerArithToLLVMConversionPassPass</a> ()</td></tr>
<tr class="memitem:ac6a235ea76890419e01a2851b0e59df7" id="r_ac6a235ea76890419e01a2851b0e59df7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6a235ea76890419e01a2851b0e59df7">registerConvertAMDGPUToROCDLPass</a> ()</td></tr>
<tr class="memitem:ae1a2f81e3ffecca8a4968441f4b0acec" id="r_ae1a2f81e3ffecca8a4968441f4b0acec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1a2f81e3ffecca8a4968441f4b0acec">registerConvertAMDGPUToROCDLPassPass</a> ()</td></tr>
<tr class="memitem:afbb7c0b603fc418cb9707ec45405c6f4" id="r_afbb7c0b603fc418cb9707ec45405c6f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbb7c0b603fc418cb9707ec45405c6f4">registerConvertAffineForToGPUPass</a> ()</td></tr>
<tr class="memitem:a447cf32c2a42d229a1821787e59702ab" id="r_a447cf32c2a42d229a1821787e59702ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a447cf32c2a42d229a1821787e59702ab">registerConvertAffineForToGPUPassPass</a> ()</td></tr>
<tr class="memitem:ae273168b90db2508abf673b9ce3b5e55" id="r_ae273168b90db2508abf673b9ce3b5e55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae273168b90db2508abf673b9ce3b5e55">registerConvertArithToEmitC</a> ()</td></tr>
<tr class="memitem:af1131cca58445b83bb3c753349c3df0c" id="r_af1131cca58445b83bb3c753349c3df0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1131cca58445b83bb3c753349c3df0c">registerConvertArithToEmitCPass</a> ()</td></tr>
<tr class="memitem:abc1f775553f1cae09516c4ae935ade21" id="r_abc1f775553f1cae09516c4ae935ade21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc1f775553f1cae09516c4ae935ade21">registerConvertArithToSPIRVPass</a> ()</td></tr>
<tr class="memitem:a7bd392715db6eeda94e3fa57acc18c7c" id="r_a7bd392715db6eeda94e3fa57acc18c7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bd392715db6eeda94e3fa57acc18c7c">registerConvertArithToSPIRVPassPass</a> ()</td></tr>
<tr class="memitem:a096c35c0bb5c57129ec240bf897b8869" id="r_a096c35c0bb5c57129ec240bf897b8869"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a096c35c0bb5c57129ec240bf897b8869">registerConvertArmNeon2dToIntrPass</a> ()</td></tr>
<tr class="memitem:a4ea564237cf4f63a31e847b2919ff221" id="r_a4ea564237cf4f63a31e847b2919ff221"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ea564237cf4f63a31e847b2919ff221">registerConvertArmNeon2dToIntrPassPass</a> ()</td></tr>
<tr class="memitem:acdf0da5aa36162bf1a7815e5d1bbfab9" id="r_acdf0da5aa36162bf1a7815e5d1bbfab9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdf0da5aa36162bf1a7815e5d1bbfab9">registerConvertArmSMEToLLVM</a> ()</td></tr>
<tr class="memitem:af606ec9b83dca6c0b0a6f5a461258608" id="r_af606ec9b83dca6c0b0a6f5a461258608"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af606ec9b83dca6c0b0a6f5a461258608">registerConvertArmSMEToLLVMPass</a> ()</td></tr>
<tr class="memitem:abb7b6f0e17e5a3a248b6e4240f2df839" id="r_abb7b6f0e17e5a3a248b6e4240f2df839"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb7b6f0e17e5a3a248b6e4240f2df839">registerConvertArmSMEToSCFPass</a> ()</td></tr>
<tr class="memitem:a14efda6bd02c823b92f5d5cd7c7df71b" id="r_a14efda6bd02c823b92f5d5cd7c7df71b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14efda6bd02c823b92f5d5cd7c7df71b">registerConvertArmSMEToSCFPassPass</a> ()</td></tr>
<tr class="memitem:ac96f3cd4d54d71f87d88cf1631ee9ee9" id="r_ac96f3cd4d54d71f87d88cf1631ee9ee9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac96f3cd4d54d71f87d88cf1631ee9ee9">registerConvertAsyncToLLVMPass</a> ()</td></tr>
<tr class="memitem:aec88cd051b19b819706cce6c4dfc32f7" id="r_aec88cd051b19b819706cce6c4dfc32f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec88cd051b19b819706cce6c4dfc32f7">registerConvertAsyncToLLVMPassPass</a> ()</td></tr>
<tr class="memitem:a13f5ad2dec8c53a92d9c90348b7fcf41" id="r_a13f5ad2dec8c53a92d9c90348b7fcf41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13f5ad2dec8c53a92d9c90348b7fcf41">registerConvertBufferizationToMemRefPass</a> ()</td></tr>
<tr class="memitem:ae517e0cf89db75d522c3615bc42fac3b" id="r_ae517e0cf89db75d522c3615bc42fac3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae517e0cf89db75d522c3615bc42fac3b">registerConvertBufferizationToMemRefPassPass</a> ()</td></tr>
<tr class="memitem:a08b3972ec8b405b85435fb59a734771b" id="r_a08b3972ec8b405b85435fb59a734771b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08b3972ec8b405b85435fb59a734771b">registerConvertComplexToLLVMPass</a> ()</td></tr>
<tr class="memitem:a1f887fb2c432aca14c8c8d04d52dadd3" id="r_a1f887fb2c432aca14c8c8d04d52dadd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f887fb2c432aca14c8c8d04d52dadd3">registerConvertComplexToLLVMPassPass</a> ()</td></tr>
<tr class="memitem:af41e471bf4af49a441d1e5fd42d85643" id="r_af41e471bf4af49a441d1e5fd42d85643"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af41e471bf4af49a441d1e5fd42d85643">registerConvertComplexToLibm</a> ()</td></tr>
<tr class="memitem:a1afa5471b029cd428b00ac8ae9286ee3" id="r_a1afa5471b029cd428b00ac8ae9286ee3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1afa5471b029cd428b00ac8ae9286ee3">registerConvertComplexToLibmPass</a> ()</td></tr>
<tr class="memitem:acad00d6f9627aa3ae61e21e0575fde82" id="r_acad00d6f9627aa3ae61e21e0575fde82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acad00d6f9627aa3ae61e21e0575fde82">registerConvertComplexToROCDLLibraryCalls</a> ()</td></tr>
<tr class="memitem:a239ff38899672de9d46c4aed87b79f09" id="r_a239ff38899672de9d46c4aed87b79f09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a239ff38899672de9d46c4aed87b79f09">registerConvertComplexToROCDLLibraryCallsPass</a> ()</td></tr>
<tr class="memitem:a70fcc1bf94340796720cc5d49514c692" id="r_a70fcc1bf94340796720cc5d49514c692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70fcc1bf94340796720cc5d49514c692">registerConvertComplexToSPIRVPass</a> ()</td></tr>
<tr class="memitem:a5fbfba94a43afe1a073a4395e08f4ce4" id="r_a5fbfba94a43afe1a073a4395e08f4ce4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fbfba94a43afe1a073a4395e08f4ce4">registerConvertComplexToSPIRVPassPass</a> ()</td></tr>
<tr class="memitem:a83fdadd1f296a62f0b8fc3e88c4fc654" id="r_a83fdadd1f296a62f0b8fc3e88c4fc654"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83fdadd1f296a62f0b8fc3e88c4fc654">registerConvertComplexToStandardPass</a> ()</td></tr>
<tr class="memitem:a42e0b4c5dba0ecc9593d9416113b1988" id="r_a42e0b4c5dba0ecc9593d9416113b1988"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42e0b4c5dba0ecc9593d9416113b1988">registerConvertComplexToStandardPassPass</a> ()</td></tr>
<tr class="memitem:a3a34f1d50818a63109bf766f5059f05c" id="r_a3a34f1d50818a63109bf766f5059f05c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a34f1d50818a63109bf766f5059f05c">registerConvertControlFlowToLLVMPass</a> ()</td></tr>
<tr class="memitem:a26c1e663a347bc3df793ebc52925aecd" id="r_a26c1e663a347bc3df793ebc52925aecd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26c1e663a347bc3df793ebc52925aecd">registerConvertControlFlowToLLVMPassPass</a> ()</td></tr>
<tr class="memitem:a1df50c4590e8fc48e97d1392e1ef2111" id="r_a1df50c4590e8fc48e97d1392e1ef2111"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1df50c4590e8fc48e97d1392e1ef2111">registerConvertControlFlowToSPIRVPass</a> ()</td></tr>
<tr class="memitem:a97f7e225951d979e1b87d433c66b2eb4" id="r_a97f7e225951d979e1b87d433c66b2eb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97f7e225951d979e1b87d433c66b2eb4">registerConvertControlFlowToSPIRVPassPass</a> ()</td></tr>
<tr class="memitem:a9b8d2b48540530c69aa46dc3e7fb4722" id="r_a9b8d2b48540530c69aa46dc3e7fb4722"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b8d2b48540530c69aa46dc3e7fb4722">registerConvertFuncToEmitC</a> ()</td></tr>
<tr class="memitem:a2d3378a9e1423dc524c700a3e16cbd4d" id="r_a2d3378a9e1423dc524c700a3e16cbd4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d3378a9e1423dc524c700a3e16cbd4d">registerConvertFuncToEmitCPass</a> ()</td></tr>
<tr class="memitem:aaa56c74ad73df4db14579a9db513ea84" id="r_aaa56c74ad73df4db14579a9db513ea84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa56c74ad73df4db14579a9db513ea84">registerConvertFuncToLLVMPass</a> ()</td></tr>
<tr class="memitem:a6426aff071af118e2b0761b52b59008f" id="r_a6426aff071af118e2b0761b52b59008f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6426aff071af118e2b0761b52b59008f">registerConvertFuncToLLVMPassPass</a> ()</td></tr>
<tr class="memitem:a4fe00d6aa4a619a172579db999588d55" id="r_a4fe00d6aa4a619a172579db999588d55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fe00d6aa4a619a172579db999588d55">registerConvertFuncToSPIRVPass</a> ()</td></tr>
<tr class="memitem:a0429d4efb3cb6879e1221903a4051ba5" id="r_a0429d4efb3cb6879e1221903a4051ba5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0429d4efb3cb6879e1221903a4051ba5">registerConvertFuncToSPIRVPassPass</a> ()</td></tr>
<tr class="memitem:a98d8447a460fe33514ad2a682c4c260b" id="r_a98d8447a460fe33514ad2a682c4c260b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98d8447a460fe33514ad2a682c4c260b">registerConvertGPUToSPIRV</a> ()</td></tr>
<tr class="memitem:ae2dec8e1013fa8cd1b069ab9fd453b6b" id="r_ae2dec8e1013fa8cd1b069ab9fd453b6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2dec8e1013fa8cd1b069ab9fd453b6b">registerConvertGPUToSPIRVPass</a> ()</td></tr>
<tr class="memitem:aa533454713753a1869bdee8487b9cea1" id="r_aa533454713753a1869bdee8487b9cea1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa533454713753a1869bdee8487b9cea1">registerConvertGpuOpsToLLVMSPVOps</a> ()</td></tr>
<tr class="memitem:ab65a7ef5b143f5b71f4982d84b8b491c" id="r_ab65a7ef5b143f5b71f4982d84b8b491c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab65a7ef5b143f5b71f4982d84b8b491c">registerConvertGpuOpsToLLVMSPVOpsPass</a> ()</td></tr>
<tr class="memitem:a5fe97a463dee4a7f271148603e71eb03" id="r_a5fe97a463dee4a7f271148603e71eb03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fe97a463dee4a7f271148603e71eb03">registerConvertGpuOpsToNVVMOps</a> ()</td></tr>
<tr class="memitem:ab1ff1f03eea98a83f4806fbcfaa288c3" id="r_ab1ff1f03eea98a83f4806fbcfaa288c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1ff1f03eea98a83f4806fbcfaa288c3">registerConvertGpuOpsToNVVMOpsPass</a> ()</td></tr>
<tr class="memitem:ac3c83ba1ea1b6aad3c929cfc10b6a9d3" id="r_ac3c83ba1ea1b6aad3c929cfc10b6a9d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3c83ba1ea1b6aad3c929cfc10b6a9d3">registerConvertGpuOpsToROCDLOps</a> ()</td></tr>
<tr class="memitem:a67f6a28bbf36114e571565d0eb14f67a" id="r_a67f6a28bbf36114e571565d0eb14f67a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67f6a28bbf36114e571565d0eb14f67a">registerConvertGpuOpsToROCDLOpsPass</a> ()</td></tr>
<tr class="memitem:a77b741faf49eadf990dedaeddf645bcc" id="r_a77b741faf49eadf990dedaeddf645bcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77b741faf49eadf990dedaeddf645bcc">registerConvertIndexToLLVMPass</a> ()</td></tr>
<tr class="memitem:a41ac6b01d7ddef0b8c79e0beff125690" id="r_a41ac6b01d7ddef0b8c79e0beff125690"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41ac6b01d7ddef0b8c79e0beff125690">registerConvertIndexToLLVMPassPass</a> ()</td></tr>
<tr class="memitem:a01e88214a5b39e49e9b8a7ef281fdf91" id="r_a01e88214a5b39e49e9b8a7ef281fdf91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01e88214a5b39e49e9b8a7ef281fdf91">registerConvertIndexToSPIRVPass</a> ()</td></tr>
<tr class="memitem:a403edeed2c1f7e7220320101f48c0cb8" id="r_a403edeed2c1f7e7220320101f48c0cb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a403edeed2c1f7e7220320101f48c0cb8">registerConvertIndexToSPIRVPassPass</a> ()</td></tr>
<tr class="memitem:adac78b8ab184ea2d53f6ed67c21a79e9" id="r_adac78b8ab184ea2d53f6ed67c21a79e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adac78b8ab184ea2d53f6ed67c21a79e9">registerConvertLinalgToStandardPass</a> ()</td></tr>
<tr class="memitem:ada22f2f1588019fe9bc27b0e2c5c1b41" id="r_ada22f2f1588019fe9bc27b0e2c5c1b41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada22f2f1588019fe9bc27b0e2c5c1b41">registerConvertLinalgToStandardPassPass</a> ()</td></tr>
<tr class="memitem:a74a8d45f5b63e8c9f4c5a2d68cfa1648" id="r_a74a8d45f5b63e8c9f4c5a2d68cfa1648"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74a8d45f5b63e8c9f4c5a2d68cfa1648">registerConvertMathToEmitC</a> ()</td></tr>
<tr class="memitem:a2d80facd0960d765dcb0965f81819552" id="r_a2d80facd0960d765dcb0965f81819552"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d80facd0960d765dcb0965f81819552">registerConvertMathToEmitCPass</a> ()</td></tr>
<tr class="memitem:a955d7db1808a814477b698a4f54f4672" id="r_a955d7db1808a814477b698a4f54f4672"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a955d7db1808a814477b698a4f54f4672">registerConvertMathToFuncs</a> ()</td></tr>
<tr class="memitem:a0daa4e194f223bd7d5e54da8c93101e6" id="r_a0daa4e194f223bd7d5e54da8c93101e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0daa4e194f223bd7d5e54da8c93101e6">registerConvertMathToFuncsPass</a> ()</td></tr>
<tr class="memitem:a2b5a3362c22d62221aafa898df03ed3a" id="r_a2b5a3362c22d62221aafa898df03ed3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b5a3362c22d62221aafa898df03ed3a">registerConvertMathToLLVMPass</a> ()</td></tr>
<tr class="memitem:a3bedfaa457b9b21f4f4b9ac4753c08a0" id="r_a3bedfaa457b9b21f4f4b9ac4753c08a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bedfaa457b9b21f4f4b9ac4753c08a0">registerConvertMathToLLVMPassPass</a> ()</td></tr>
<tr class="memitem:a05ad997ce786384fa6de9d231cede8f4" id="r_a05ad997ce786384fa6de9d231cede8f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05ad997ce786384fa6de9d231cede8f4">registerConvertMathToLibmPass</a> ()</td></tr>
<tr class="memitem:acdcae51bb6c39818c80dedf983e03a0a" id="r_acdcae51bb6c39818c80dedf983e03a0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdcae51bb6c39818c80dedf983e03a0a">registerConvertMathToLibmPassPass</a> ()</td></tr>
<tr class="memitem:ac22e493d74b2890eab2c9e454a555640" id="r_ac22e493d74b2890eab2c9e454a555640"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac22e493d74b2890eab2c9e454a555640">registerConvertMathToROCDL</a> ()</td></tr>
<tr class="memitem:a8685ca4e2f4ac3647ce5c8b8ccb654f3" id="r_a8685ca4e2f4ac3647ce5c8b8ccb654f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8685ca4e2f4ac3647ce5c8b8ccb654f3">registerConvertMathToROCDLPass</a> ()</td></tr>
<tr class="memitem:ae755de1424ff83fb901a3b971d768eee" id="r_ae755de1424ff83fb901a3b971d768eee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae755de1424ff83fb901a3b971d768eee">registerConvertMathToSPIRVPass</a> ()</td></tr>
<tr class="memitem:a714e5f7d4f059693d2188eac88ee8866" id="r_a714e5f7d4f059693d2188eac88ee8866"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a714e5f7d4f059693d2188eac88ee8866">registerConvertMathToSPIRVPassPass</a> ()</td></tr>
<tr class="memitem:a58bd4dcc53d4ebb6154d48f888c5efa0" id="r_a58bd4dcc53d4ebb6154d48f888c5efa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58bd4dcc53d4ebb6154d48f888c5efa0">registerConvertMathToXeVM</a> ()</td></tr>
<tr class="memitem:ac71fff89df678ad07954e37abb9ebaa9" id="r_ac71fff89df678ad07954e37abb9ebaa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac71fff89df678ad07954e37abb9ebaa9">registerConvertMathToXeVMPass</a> ()</td></tr>
<tr class="memitem:a28235ac41da20e947abbf1dd68cfb51d" id="r_a28235ac41da20e947abbf1dd68cfb51d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28235ac41da20e947abbf1dd68cfb51d">registerConvertMemRefToEmitC</a> ()</td></tr>
<tr class="memitem:afb9003909e29980a18e71163798eee2f" id="r_afb9003909e29980a18e71163798eee2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb9003909e29980a18e71163798eee2f">registerConvertMemRefToEmitCPass</a> ()</td></tr>
<tr class="memitem:adfd3e376d7363c56fcd1c38fbb525975" id="r_adfd3e376d7363c56fcd1c38fbb525975"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfd3e376d7363c56fcd1c38fbb525975">registerConvertMemRefToSPIRVPass</a> ()</td></tr>
<tr class="memitem:a82b85ec8db2d59274700dff89ef24b57" id="r_a82b85ec8db2d59274700dff89ef24b57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82b85ec8db2d59274700dff89ef24b57">registerConvertMemRefToSPIRVPassPass</a> ()</td></tr>
<tr class="memitem:af828fcfc7ee34b625d6e567eff925137" id="r_af828fcfc7ee34b625d6e567eff925137"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af828fcfc7ee34b625d6e567eff925137">registerConvertNVGPUToNVVMPass</a> ()</td></tr>
<tr class="memitem:a4fe1e5909f8de3e5efd29841ffa39a10" id="r_a4fe1e5909f8de3e5efd29841ffa39a10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fe1e5909f8de3e5efd29841ffa39a10">registerConvertNVGPUToNVVMPassPass</a> ()</td></tr>
<tr class="memitem:a0a5f4a512e94f6e26be843062d08b2a0" id="r_a0a5f4a512e94f6e26be843062d08b2a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a5f4a512e94f6e26be843062d08b2a0">registerConvertNVVMToLLVMPass</a> ()</td></tr>
<tr class="memitem:a3b7b560cdea4650e6f03095d7d9ec250" id="r_a3b7b560cdea4650e6f03095d7d9ec250"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b7b560cdea4650e6f03095d7d9ec250">registerConvertNVVMToLLVMPassPass</a> ()</td></tr>
<tr class="memitem:a1c8228d0f0062162b8f212d5144ec732" id="r_a1c8228d0f0062162b8f212d5144ec732"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c8228d0f0062162b8f212d5144ec732">registerConvertOpenACCToSCFPass</a> ()</td></tr>
<tr class="memitem:a092d35a544220080021640b92b0ecaf3" id="r_a092d35a544220080021640b92b0ecaf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a092d35a544220080021640b92b0ecaf3">registerConvertOpenACCToSCFPassPass</a> ()</td></tr>
<tr class="memitem:aa93576417f08fc54a7f749ed00fb259f" id="r_aa93576417f08fc54a7f749ed00fb259f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa93576417f08fc54a7f749ed00fb259f">registerConvertOpenMPToLLVMPass</a> ()</td></tr>
<tr class="memitem:aa67a8bd5615e06b3392ad8969b98784a" id="r_aa67a8bd5615e06b3392ad8969b98784a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa67a8bd5615e06b3392ad8969b98784a">registerConvertOpenMPToLLVMPassPass</a> ()</td></tr>
<tr class="memitem:a23d6284ece03f6e1ae72d12319c400a9" id="r_a23d6284ece03f6e1ae72d12319c400a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23d6284ece03f6e1ae72d12319c400a9">registerConvertPDLToPDLInterpPass</a> ()</td></tr>
<tr class="memitem:a18bce95ff8e1a0a62306f63bda735860" id="r_a18bce95ff8e1a0a62306f63bda735860"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18bce95ff8e1a0a62306f63bda735860">registerConvertPDLToPDLInterpPassPass</a> ()</td></tr>
<tr class="memitem:a6a45c6f078c2cdbad9653d35890d0759" id="r_a6a45c6f078c2cdbad9653d35890d0759"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a45c6f078c2cdbad9653d35890d0759">registerConvertParallelLoopToGpuPass</a> ()</td></tr>
<tr class="memitem:a4268cf392670a65eaeeae3312655d0e0" id="r_a4268cf392670a65eaeeae3312655d0e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4268cf392670a65eaeeae3312655d0e0">registerConvertParallelLoopToGpuPassPass</a> ()</td></tr>
<tr class="memitem:ace96ba003051f7ae2e860099fff8eb54" id="r_ace96ba003051f7ae2e860099fff8eb54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace96ba003051f7ae2e860099fff8eb54">registerConvertSCFToOpenMPPass</a> ()</td></tr>
<tr class="memitem:a498e68e79bd3a59a8cabb5fb07cacfc6" id="r_a498e68e79bd3a59a8cabb5fb07cacfc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a498e68e79bd3a59a8cabb5fb07cacfc6">registerConvertSCFToOpenMPPassPass</a> ()</td></tr>
<tr class="memitem:ae25172e615beb064bb98f9360544b8ba" id="r_ae25172e615beb064bb98f9360544b8ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae25172e615beb064bb98f9360544b8ba">registerConvertSPIRVToLLVMPass</a> ()</td></tr>
<tr class="memitem:a06df0397211ca1c4d17742cdbab32359" id="r_a06df0397211ca1c4d17742cdbab32359"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06df0397211ca1c4d17742cdbab32359">registerConvertSPIRVToLLVMPassPass</a> ()</td></tr>
<tr class="memitem:a2e122955bd1cb3fc15caca18e578824d" id="r_a2e122955bd1cb3fc15caca18e578824d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e122955bd1cb3fc15caca18e578824d">registerConvertShapeConstraintsPass</a> ()</td></tr>
<tr class="memitem:ab797f6ccf53b0a78e3e2091c35a93326" id="r_ab797f6ccf53b0a78e3e2091c35a93326"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab797f6ccf53b0a78e3e2091c35a93326">registerConvertShapeConstraintsPassPass</a> ()</td></tr>
<tr class="memitem:a018bbbb3bf2e2240e0ced0591293e270" id="r_a018bbbb3bf2e2240e0ced0591293e270"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a018bbbb3bf2e2240e0ced0591293e270">registerConvertShapeToStandardPass</a> ()</td></tr>
<tr class="memitem:ac71a6b227ff2c7cce202ec727eb4db2d" id="r_ac71a6b227ff2c7cce202ec727eb4db2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac71a6b227ff2c7cce202ec727eb4db2d">registerConvertShapeToStandardPassPass</a> ()</td></tr>
<tr class="memitem:affed47fe766b7a67b16b374cf142f7a6" id="r_affed47fe766b7a67b16b374cf142f7a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affed47fe766b7a67b16b374cf142f7a6">registerConvertShardToMPIPass</a> ()</td></tr>
<tr class="memitem:ab4f6f592e30fe755bcd8c2b139c0c80d" id="r_ab4f6f592e30fe755bcd8c2b139c0c80d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4f6f592e30fe755bcd8c2b139c0c80d">registerConvertShardToMPIPassPass</a> ()</td></tr>
<tr class="memitem:a24ef9c83cb2a7fa5663e8424d2dce59f" id="r_a24ef9c83cb2a7fa5663e8424d2dce59f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24ef9c83cb2a7fa5663e8424d2dce59f">registerConvertTensorToLinalgPass</a> ()</td></tr>
<tr class="memitem:a3687115274750178610d98170f65b433" id="r_a3687115274750178610d98170f65b433"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3687115274750178610d98170f65b433">registerConvertTensorToLinalgPassPass</a> ()</td></tr>
<tr class="memitem:adc97378058439c5c33f40c9d035cafcc" id="r_adc97378058439c5c33f40c9d035cafcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc97378058439c5c33f40c9d035cafcc">registerConvertTensorToSPIRVPass</a> ()</td></tr>
<tr class="memitem:ae22928ff9f5899f9449f40d4916a36e9" id="r_ae22928ff9f5899f9449f40d4916a36e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae22928ff9f5899f9449f40d4916a36e9">registerConvertTensorToSPIRVPassPass</a> ()</td></tr>
<tr class="memitem:a496aecce1f6215e7ecdbeb01a4838205" id="r_a496aecce1f6215e7ecdbeb01a4838205"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a496aecce1f6215e7ecdbeb01a4838205">registerConvertToEmitC</a> ()</td></tr>
<tr class="memitem:aecbdc91e0bc4654fc64d94e6e905371c" id="r_aecbdc91e0bc4654fc64d94e6e905371c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecbdc91e0bc4654fc64d94e6e905371c">registerConvertToEmitCPass</a> ()</td></tr>
<tr class="memitem:aaf798b81989fc7a91ab9cb45ddea9d92" id="r_aaf798b81989fc7a91ab9cb45ddea9d92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf798b81989fc7a91ab9cb45ddea9d92">registerConvertToLLVMPass</a> ()</td></tr>
<tr class="memitem:a12f2c035753f98113ca6eb28723b3468" id="r_a12f2c035753f98113ca6eb28723b3468"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12f2c035753f98113ca6eb28723b3468">registerConvertToLLVMPassPass</a> ()</td></tr>
<tr class="memitem:a940f6293d3c34b746f269bdb00bbed8b" id="r_a940f6293d3c34b746f269bdb00bbed8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a940f6293d3c34b746f269bdb00bbed8b">registerConvertVectorToAMX</a> ()</td></tr>
<tr class="memitem:a450bdfd2a67f89c6ffb5b8379de695d5" id="r_a450bdfd2a67f89c6ffb5b8379de695d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a450bdfd2a67f89c6ffb5b8379de695d5">registerConvertVectorToAMXPass</a> ()</td></tr>
<tr class="memitem:a63630b09ed01fdbd642f0b5f0b873788" id="r_a63630b09ed01fdbd642f0b5f0b873788"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63630b09ed01fdbd642f0b5f0b873788">registerConvertVectorToArmSMEPass</a> ()</td></tr>
<tr class="memitem:a2904dd1841ecb5b156a5ddd148733b87" id="r_a2904dd1841ecb5b156a5ddd148733b87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2904dd1841ecb5b156a5ddd148733b87">registerConvertVectorToArmSMEPassPass</a> ()</td></tr>
<tr class="memitem:a82139faad591d2e9c0833e784c16a6cb" id="r_a82139faad591d2e9c0833e784c16a6cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82139faad591d2e9c0833e784c16a6cb">registerConvertVectorToGPU</a> ()</td></tr>
<tr class="memitem:aafebcaff3cb7aa01852f42d834957f59" id="r_aafebcaff3cb7aa01852f42d834957f59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafebcaff3cb7aa01852f42d834957f59">registerConvertVectorToGPUPass</a> ()</td></tr>
<tr class="memitem:a7ca10302ef110f08a9e86e80a35aec6d" id="r_a7ca10302ef110f08a9e86e80a35aec6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ca10302ef110f08a9e86e80a35aec6d">registerConvertVectorToLLVMPass</a> ()</td></tr>
<tr class="memitem:a06b8dbf318f98d66fc4f5cc77c4c5e04" id="r_a06b8dbf318f98d66fc4f5cc77c4c5e04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06b8dbf318f98d66fc4f5cc77c4c5e04">registerConvertVectorToLLVMPassPass</a> ()</td></tr>
<tr class="memitem:a3200d7de5f20d50156567878a0d47d68" id="r_a3200d7de5f20d50156567878a0d47d68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3200d7de5f20d50156567878a0d47d68">registerConvertVectorToSCF</a> ()</td></tr>
<tr class="memitem:a6f940fb0c1ebaf03baedc31693730b93" id="r_a6f940fb0c1ebaf03baedc31693730b93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f940fb0c1ebaf03baedc31693730b93">registerConvertVectorToSCFPass</a> ()</td></tr>
<tr class="memitem:aa81ef468496bbfa2e5992df33a9863cc" id="r_aa81ef468496bbfa2e5992df33a9863cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa81ef468496bbfa2e5992df33a9863cc">registerConvertVectorToSPIRVPass</a> ()</td></tr>
<tr class="memitem:ac65fdd900df5950cd9d108160da0bb3f" id="r_ac65fdd900df5950cd9d108160da0bb3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac65fdd900df5950cd9d108160da0bb3f">registerConvertVectorToSPIRVPassPass</a> ()</td></tr>
<tr class="memitem:a64587fd9b69341014852e6fd3b240d62" id="r_a64587fd9b69341014852e6fd3b240d62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64587fd9b69341014852e6fd3b240d62">registerConvertVectorToXeGPU</a> ()</td></tr>
<tr class="memitem:a9abc9a63245a446e2482485f9c9c8073" id="r_a9abc9a63245a446e2482485f9c9c8073"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9abc9a63245a446e2482485f9c9c8073">registerConvertVectorToXeGPUPass</a> ()</td></tr>
<tr class="memitem:a4e4f840142b66345b8c042d741b8fd2d" id="r_a4e4f840142b66345b8c042d741b8fd2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e4f840142b66345b8c042d741b8fd2d">registerConvertXeGPUToXeVMPass</a> ()</td></tr>
<tr class="memitem:af3de8f4d0eda4229e2d32c11bafbf1d9" id="r_af3de8f4d0eda4229e2d32c11bafbf1d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3de8f4d0eda4229e2d32c11bafbf1d9">registerConvertXeGPUToXeVMPassPass</a> ()</td></tr>
<tr class="memitem:a4e9d168096f37dd1020f4f8d7fb75978" id="r_a4e9d168096f37dd1020f4f8d7fb75978"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e9d168096f37dd1020f4f8d7fb75978">registerConvertXeVMToLLVMPass</a> ()</td></tr>
<tr class="memitem:a677ef761a7ebdd80cd44a4ce2d5be126" id="r_a677ef761a7ebdd80cd44a4ce2d5be126"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a677ef761a7ebdd80cd44a4ce2d5be126">registerConvertXeVMToLLVMPassPass</a> ()</td></tr>
<tr class="memitem:a1392b2f88011768f84d961981ba9930f" id="r_a1392b2f88011768f84d961981ba9930f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1392b2f88011768f84d961981ba9930f">registerFinalizeMemRefToLLVMConversionPass</a> ()</td></tr>
<tr class="memitem:a3b4b1062768de0de574f533f2a908ccf" id="r_a3b4b1062768de0de574f533f2a908ccf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b4b1062768de0de574f533f2a908ccf">registerFinalizeMemRefToLLVMConversionPassPass</a> ()</td></tr>
<tr class="memitem:ad27d757550250daa79dbd4308346dcd1" id="r_ad27d757550250daa79dbd4308346dcd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad27d757550250daa79dbd4308346dcd1">registerGpuToLLVMConversionPass</a> ()</td></tr>
<tr class="memitem:aed92f27e122e47df5f504c4127295bc2" id="r_aed92f27e122e47df5f504c4127295bc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed92f27e122e47df5f504c4127295bc2">registerGpuToLLVMConversionPassPass</a> ()</td></tr>
<tr class="memitem:a9a05d23e835ca674cc81003a6648fe9a" id="r_a9a05d23e835ca674cc81003a6648fe9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a05d23e835ca674cc81003a6648fe9a">registerLiftControlFlowToSCFPass</a> ()</td></tr>
<tr class="memitem:a65d236b5f016cce5a04aa091696c69f4" id="r_a65d236b5f016cce5a04aa091696c69f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65d236b5f016cce5a04aa091696c69f4">registerLiftControlFlowToSCFPassPass</a> ()</td></tr>
<tr class="memitem:ae61157414c88115eadab54125624e489" id="r_ae61157414c88115eadab54125624e489"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae61157414c88115eadab54125624e489">registerLowerAffinePass</a> ()</td></tr>
<tr class="memitem:a983602355d61e58201f7a5285591023f" id="r_a983602355d61e58201f7a5285591023f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a983602355d61e58201f7a5285591023f">registerLowerAffinePassPass</a> ()</td></tr>
<tr class="memitem:a6eb139f97446e699b0d348b936414c7d" id="r_a6eb139f97446e699b0d348b936414c7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6eb139f97446e699b0d348b936414c7d">registerLowerHostCodeToLLVMPass</a> ()</td></tr>
<tr class="memitem:a3a7ad7fb79e045b2b624696b1c2af1f6" id="r_a3a7ad7fb79e045b2b624696b1c2af1f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a7ad7fb79e045b2b624696b1c2af1f6">registerLowerHostCodeToLLVMPassPass</a> ()</td></tr>
<tr class="memitem:a69cd02c9adb6f20ea81d2eb2040a303d" id="r_a69cd02c9adb6f20ea81d2eb2040a303d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69cd02c9adb6f20ea81d2eb2040a303d">registerMapMemRefStorageClass</a> ()</td></tr>
<tr class="memitem:a9351f27a62f3b696c923d394281a2d73" id="r_a9351f27a62f3b696c923d394281a2d73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9351f27a62f3b696c923d394281a2d73">registerMapMemRefStorageClassPass</a> ()</td></tr>
<tr class="memitem:a51b56078ab20126d7494d9cb3253bf99" id="r_a51b56078ab20126d7494d9cb3253bf99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51b56078ab20126d7494d9cb3253bf99">registerReconcileUnrealizedCastsPass</a> ()</td></tr>
<tr class="memitem:aee2d165dc396c1fbf281924660297755" id="r_aee2d165dc396c1fbf281924660297755"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee2d165dc396c1fbf281924660297755">registerReconcileUnrealizedCastsPassPass</a> ()</td></tr>
<tr class="memitem:ae945c21b80b9190f9f3f850f41f5f14e" id="r_ae945c21b80b9190f9f3f850f41f5f14e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae945c21b80b9190f9f3f850f41f5f14e">registerSCFToControlFlowPass</a> ()</td></tr>
<tr class="memitem:a944419934975e4300d1695f67c73c047" id="r_a944419934975e4300d1695f67c73c047"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a944419934975e4300d1695f67c73c047">registerSCFToControlFlowPassPass</a> ()</td></tr>
<tr class="memitem:a34938d52c0c48307739e60d76aa7b614" id="r_a34938d52c0c48307739e60d76aa7b614"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34938d52c0c48307739e60d76aa7b614">registerSCFToEmitC</a> ()</td></tr>
<tr class="memitem:ad6df13af469a80f6506a82f581b07001" id="r_ad6df13af469a80f6506a82f581b07001"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6df13af469a80f6506a82f581b07001">registerSCFToEmitCPass</a> ()</td></tr>
<tr class="memitem:a3b0c54a3034fdf9257f7c63d8e2ddc07" id="r_a3b0c54a3034fdf9257f7c63d8e2ddc07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b0c54a3034fdf9257f7c63d8e2ddc07">registerSCFToSPIRV</a> ()</td></tr>
<tr class="memitem:a9fe51fa1f6536e02502fb6aa6c777598" id="r_a9fe51fa1f6536e02502fb6aa6c777598"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fe51fa1f6536e02502fb6aa6c777598">registerSCFToSPIRVPass</a> ()</td></tr>
<tr class="memitem:a3922ea8af887e683fe8537c3b41ae929" id="r_a3922ea8af887e683fe8537c3b41ae929"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3922ea8af887e683fe8537c3b41ae929">registerSetLLVMModuleDataLayoutPass</a> ()</td></tr>
<tr class="memitem:a29f6610cbedfe3730853c8105ba6151c" id="r_a29f6610cbedfe3730853c8105ba6151c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29f6610cbedfe3730853c8105ba6151c">registerSetLLVMModuleDataLayoutPassPass</a> ()</td></tr>
<tr class="memitem:a15b21db2ca02c947bb2f9ede2c57372f" id="r_a15b21db2ca02c947bb2f9ede2c57372f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15b21db2ca02c947bb2f9ede2c57372f">registerTosaToArithPass</a> ()</td></tr>
<tr class="memitem:abce41ada8e974a54209f8ea2fc239427" id="r_abce41ada8e974a54209f8ea2fc239427"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abce41ada8e974a54209f8ea2fc239427">registerTosaToArithPassPass</a> ()</td></tr>
<tr class="memitem:a9583d40078499f2902dfab04892f79b2" id="r_a9583d40078499f2902dfab04892f79b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9583d40078499f2902dfab04892f79b2">registerTosaToLinalg</a> ()</td></tr>
<tr class="memitem:a38533581f768d495b197c5736b2a849f" id="r_a38533581f768d495b197c5736b2a849f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38533581f768d495b197c5736b2a849f">registerTosaToLinalgPass</a> ()</td></tr>
<tr class="memitem:ab991646e791f5ff68cca890be759b008" id="r_ab991646e791f5ff68cca890be759b008"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab991646e791f5ff68cca890be759b008">registerTosaToLinalgNamed</a> ()</td></tr>
<tr class="memitem:ae75ba1f975f7221c78757b9d7755e145" id="r_ae75ba1f975f7221c78757b9d7755e145"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae75ba1f975f7221c78757b9d7755e145">registerTosaToLinalgNamedPass</a> ()</td></tr>
<tr class="memitem:a2d25ca88f527ec8fe530bf4723470411" id="r_a2d25ca88f527ec8fe530bf4723470411"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d25ca88f527ec8fe530bf4723470411">registerTosaToMLProgram</a> ()</td></tr>
<tr class="memitem:afb94c162c525c572d6d3c1ea76ced0a2" id="r_afb94c162c525c572d6d3c1ea76ced0a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb94c162c525c572d6d3c1ea76ced0a2">registerTosaToMLProgramPass</a> ()</td></tr>
<tr class="memitem:a7e38cf638e9703a021cc635f9af19f5b" id="r_a7e38cf638e9703a021cc635f9af19f5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e38cf638e9703a021cc635f9af19f5b">registerTosaToSCFPass</a> ()</td></tr>
<tr class="memitem:aff772f2f6af356796cf1fef01e585d43" id="r_aff772f2f6af356796cf1fef01e585d43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff772f2f6af356796cf1fef01e585d43">registerTosaToSCFPassPass</a> ()</td></tr>
<tr class="memitem:a7a539c2f41d67490719345dd74689ea7" id="r_a7a539c2f41d67490719345dd74689ea7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a539c2f41d67490719345dd74689ea7">registerTosaToTensorPass</a> ()</td></tr>
<tr class="memitem:a19fbeea61ad689edadedb9078ba59592" id="r_a19fbeea61ad689edadedb9078ba59592"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19fbeea61ad689edadedb9078ba59592">registerTosaToTensorPassPass</a> ()</td></tr>
<tr class="memitem:a8c9b5f6af3d36238abb3ed7bbfeed717" id="r_a8c9b5f6af3d36238abb3ed7bbfeed717"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c9b5f6af3d36238abb3ed7bbfeed717">registerUBToLLVMConversionPass</a> ()</td></tr>
<tr class="memitem:a6c84fe5f1725615d8600cff4accaf9b0" id="r_a6c84fe5f1725615d8600cff4accaf9b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c84fe5f1725615d8600cff4accaf9b0">registerUBToLLVMConversionPassPass</a> ()</td></tr>
<tr class="memitem:a88d1bdd28e28441cbbc55096672e6406" id="r_a88d1bdd28e28441cbbc55096672e6406"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88d1bdd28e28441cbbc55096672e6406">registerUBToSPIRVConversionPass</a> ()</td></tr>
<tr class="memitem:a77368a0a2df5fa0348d0be45225f75dd" id="r_a77368a0a2df5fa0348d0be45225f75dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77368a0a2df5fa0348d0be45225f75dd">registerUBToSPIRVConversionPassPass</a> ()</td></tr>
<tr class="memitem:a506139ca4a3a8a66d0fe6a9e2531a5c9" id="r_a506139ca4a3a8a66d0fe6a9e2531a5c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a506139ca4a3a8a66d0fe6a9e2531a5c9">registerConversionPasses</a> ()</td></tr>
<tr class="memitem:a0d03e883b6465225cf16db9093a723a4" id="r_a0d03e883b6465225cf16db9093a723a4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d03e883b6465225cf16db9093a723a4">createConvertArmSMEToLLVMPass</a> (<a class="el" href="classbool.html">bool</a> dumpTileLiveRanges=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a0d03e883b6465225cf16db9093a723a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert from the ArmSME dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <br /></td></tr>
<tr class="memitem:ac5fc9cf7db1e6fcc78850ac4ab89742c" id="r_ac5fc9cf7db1e6fcc78850ac4ab89742c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5fc9cf7db1e6fcc78850ac4ab89742c">configureArmSMEToLLVMConversionLegality</a> (<a class="el" href="classConversionTarget.html">ConversionTarget</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a5d2c023108742a1ce78ba9823c06ea35">target</a>)</td></tr>
<tr class="memdesc:ac5fc9cf7db1e6fcc78850ac4ab89742c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure target to convert from the ArmSME dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <br /></td></tr>
<tr class="memitem:afe2a83e0a6a467d1838b6dd39f65fb6d" id="r_afe2a83e0a6a467d1838b6dd39f65fb6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe2a83e0a6a467d1838b6dd39f65fb6d">populateArmSMEToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:afe2a83e0a6a467d1838b6dd39f65fb6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from the ArmSME dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <br /></td></tr>
<tr class="memitem:aac12f43746d5385a542cd23d12ccb57f" id="r_aac12f43746d5385a542cd23d12ccb57f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac12f43746d5385a542cd23d12ccb57f">createConvertArmSMEToSCFPass</a> ()</td></tr>
<tr class="memitem:a726da53640cac549a26c8eb0396fb0e6" id="r_a726da53640cac549a26c8eb0396fb0e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a726da53640cac549a26c8eb0396fb0e6">populateArmSMEToSCFConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a726da53640cac549a26c8eb0396fb0e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the ArmSME dialect to SCF.  <br /></td></tr>
<tr class="memitem:a38c75607baf7328ba37ae32a08f9e009" id="r_a38c75607baf7328ba37ae32a08f9e009"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38c75607baf7328ba37ae32a08f9e009">createConvertAsyncToLLVMPass</a> ()</td></tr>
<tr class="memitem:a9659670212051d0795efd99cf38772ed" id="r_a9659670212051d0795efd99cf38772ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9659670212051d0795efd99cf38772ed">populateAsyncStructuralTypeConversionsAndLegality</a> (<a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classConversionTarget.html">ConversionTarget</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a5d2c023108742a1ce78ba9823c06ea35">target</a>)</td></tr>
<tr class="memdesc:a9659670212051d0795efd99cf38772ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns for async structural type conversions.  <br /></td></tr>
<tr class="memitem:ade3763de82d4fba131f0010992126621" id="r_ade3763de82d4fba131f0010992126621"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade3763de82d4fba131f0010992126621">createConvertBufferizationToMemRefPass</a> ()</td></tr>
<tr class="memitem:a61fda0d5c3eb200116f60053d59e5528" id="r_a61fda0d5c3eb200116f60053d59e5528"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61fda0d5c3eb200116f60053d59e5528">createConvertComplexToLibm</a> ()</td></tr>
<tr class="memitem:af655a0b587c08462a963b23b6c656ca5" id="r_af655a0b587c08462a963b23b6c656ca5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af655a0b587c08462a963b23b6c656ca5">populateComplexToLibmConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit)</td></tr>
<tr class="memdesc:af655a0b587c08462a963b23b6c656ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from Complex to Libm calls.  <br /></td></tr>
<tr class="memitem:ac4779d7d240bcf47cd9247db82bade76" id="r_ac4779d7d240bcf47cd9247db82bade76"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4779d7d240bcf47cd9247db82bade76">createConvertComplexToLLVMPass</a> ()</td></tr>
<tr class="memitem:af53ae6c99a55d97eacebe9bdc552719e" id="r_af53ae6c99a55d97eacebe9bdc552719e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af53ae6c99a55d97eacebe9bdc552719e">createConvertComplexToLLVMPass</a> (<a class="el" href="structmlir_1_1ConvertComplexToLLVMPassOptions.html">ConvertComplexToLLVMPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a2587dd2d601cb5613d673f9eae76b615" id="r_a2587dd2d601cb5613d673f9eae76b615"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2587dd2d601cb5613d673f9eae76b615">populateComplexToLLVMConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, mlir::complex::ComplexRangeFlags complexRange=mlir::complex::ComplexRangeFlags::basic)</td></tr>
<tr class="memdesc:a2587dd2d601cb5613d673f9eae76b615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from Complex to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <br /></td></tr>
<tr class="memitem:a92e3131ae05feac332799cb2de81be2f" id="r_a92e3131ae05feac332799cb2de81be2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92e3131ae05feac332799cb2de81be2f">registerConvertComplexToLLVMInterface</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:a8ba495abfca808b741f66ce7c705d555" id="r_a8ba495abfca808b741f66ce7c705d555"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ba495abfca808b741f66ce7c705d555">createConvertComplexToROCDLLibraryCalls</a> ()</td></tr>
<tr class="memitem:a1103f8e89a3e08ffd4fbd3d1bab0ee90" id="r_a1103f8e89a3e08ffd4fbd3d1bab0ee90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1103f8e89a3e08ffd4fbd3d1bab0ee90">populateComplexToROCDLLibraryCallsConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a1103f8e89a3e08ffd4fbd3d1bab0ee90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from Complex to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> calls.  <br /></td></tr>
<tr class="memitem:ac59f15aca5e1be49c639ee5b12e611f2" id="r_ac59f15aca5e1be49c639ee5b12e611f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac59f15aca5e1be49c639ee5b12e611f2">populateComplexToSPIRVPatterns</a> (const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:ac59f15aca5e1be49c639ee5b12e611f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating Complex ops to SPIR-V ops.  <br /></td></tr>
<tr class="memitem:a3e83041b29f7ab74ae4b3e9f46eed21b" id="r_a3e83041b29f7ab74ae4b3e9f46eed21b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e83041b29f7ab74ae4b3e9f46eed21b">createConvertComplexToSPIRVPass</a> ()</td></tr>
<tr class="memitem:af646df22dbb01422dd0b5a4049d6f4e8" id="r_af646df22dbb01422dd0b5a4049d6f4e8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af646df22dbb01422dd0b5a4049d6f4e8">createConvertComplexToStandardPass</a> ()</td></tr>
<tr class="memitem:a75048af68744f1331c991bdfa8fb34d0" id="r_a75048af68744f1331c991bdfa8fb34d0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75048af68744f1331c991bdfa8fb34d0">createConvertComplexToStandardPass</a> (<a class="el" href="structmlir_1_1ConvertComplexToStandardPassOptions.html">ConvertComplexToStandardPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a7561db931b79277cde554d85e85f2bc6" id="r_a7561db931b79277cde554d85e85f2bc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7561db931b79277cde554d85e85f2bc6">populateComplexToStandardConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, mlir::complex::ComplexRangeFlags complexRange=mlir::complex::ComplexRangeFlags::improved)</td></tr>
<tr class="memdesc:a7561db931b79277cde554d85e85f2bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from Complex to Standard.  <br /></td></tr>
<tr class="memitem:a186d55a9e0ad2211dd27698e79de89cb" id="r_a186d55a9e0ad2211dd27698e79de89cb"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a186d55a9e0ad2211dd27698e79de89cb">createConvertControlFlowToLLVMPass</a> ()</td></tr>
<tr class="memitem:aed27a49008e48ed98d7bbf0067906b33" id="r_aed27a49008e48ed98d7bbf0067906b33"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed27a49008e48ed98d7bbf0067906b33">createConvertControlFlowToLLVMPass</a> (<a class="el" href="structmlir_1_1ConvertControlFlowToLLVMPassOptions.html">ConvertControlFlowToLLVMPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a4dde99c58353877e9c1c659bfb65753e" id="r_a4dde99c58353877e9c1c659bfb65753e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4dde99c58353877e9c1c659bfb65753e">createLiftControlFlowToSCFPass</a> ()</td></tr>
<tr class="memitem:abf1498f0d073cb4c49e5a763b9c3c55f" id="r_abf1498f0d073cb4c49e5a763b9c3c55f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf1498f0d073cb4c49e5a763b9c3c55f">createConvertControlFlowToSPIRVPass</a> ()</td></tr>
<tr class="memitem:ac7c0885f10a7457c587e44c684886a5b" id="r_ac7c0885f10a7457c587e44c684886a5b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7c0885f10a7457c587e44c684886a5b">createConvertControlFlowToSPIRVPass</a> (<a class="el" href="structmlir_1_1ConvertControlFlowToSPIRVPassOptions.html">ConvertControlFlowToSPIRVPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a8b9fc340e94e7b3e50d093c709ac2844" id="r_a8b9fc340e94e7b3e50d093c709ac2844"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b9fc340e94e7b3e50d093c709ac2844">createConvertToEmitC</a> ()</td></tr>
<tr class="memitem:a5448d3f1cb655745c6f05c2102e03bed" id="r_a5448d3f1cb655745c6f05c2102e03bed"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5448d3f1cb655745c6f05c2102e03bed">createConvertToEmitC</a> (<a class="el" href="structmlir_1_1ConvertToEmitCOptions.html">ConvertToEmitCOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a93264171f98ba147ce9b57df5866b96a" id="r_a93264171f98ba147ce9b57df5866b96a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93264171f98ba147ce9b57df5866b96a">populateConversionTargetFromOperation</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classConversionTarget.html">ConversionTarget</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a5d2c023108742a1ce78ba9823c06ea35">target</a>, <a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a93264171f98ba147ce9b57df5866b96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively walk the IR and collect all dialects implementing the interface, and populate the conversion patterns.  <br /></td></tr>
<tr class="memitem:a1bd3c63a12bd65ca2208a6353dbc9186" id="r_a1bd3c63a12bd65ca2208a6353dbc9186"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bd3c63a12bd65ca2208a6353dbc9186">populateConversionTargetFromOperation</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classConversionTarget.html">ConversionTarget</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a5d2c023108742a1ce78ba9823c06ea35">target</a>, <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a1bd3c63a12bd65ca2208a6353dbc9186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively walk the IR and collect all dialects implementing the interface, and populate the conversion patterns.  <br /></td></tr>
<tr class="memitem:ac47aae037a21122571a70f95533c0152" id="r_ac47aae037a21122571a70f95533c0152"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac47aae037a21122571a70f95533c0152">populateOpConvertToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classConversionTarget.html">ConversionTarget</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a5d2c023108742a1ce78ba9823c06ea35">target</a>, <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:ac47aae037a21122571a70f95533c0152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for populating <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> conversion patterns.  <br /></td></tr>
<tr class="memitem:a1a6c9896483080d15f6d5612342989e0" id="r_a1a6c9896483080d15f6d5612342989e0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a6c9896483080d15f6d5612342989e0">createConvertToLLVMPass</a> ()</td></tr>
<tr class="memitem:ae0d44395c549de4fd3db08bed63c481b" id="r_ae0d44395c549de4fd3db08bed63c481b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0d44395c549de4fd3db08bed63c481b">createConvertToLLVMPass</a> (<a class="el" href="structmlir_1_1ConvertToLLVMPassOptions.html">ConvertToLLVMPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a8a1cfd257150164208f96531454b4d59" id="r_a8a1cfd257150164208f96531454b4d59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a1cfd257150164208f96531454b4d59">registerConvertToLLVMDependentDialectLoading</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a8a1cfd257150164208f96531454b4d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the extension that will load dependent dialects for <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> conversion.  <br /></td></tr>
<tr class="memitem:aefad2b8a321c6af909b8c1096784d004" id="r_aefad2b8a321c6af909b8c1096784d004"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefad2b8a321c6af909b8c1096784d004">populateFuncToEmitCPatterns</a> (const <a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memitem:a25d03114d3fbc5d75805750ddac07d71" id="r_a25d03114d3fbc5d75805750ddac07d71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25d03114d3fbc5d75805750ddac07d71">registerConvertFuncToEmitCInterface</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:a50d94c02c41915a9b99d745c504ab2a3" id="r_a50d94c02c41915a9b99d745c504ab2a3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50d94c02c41915a9b99d745c504ab2a3">createConvertFuncToEmitC</a> ()</td></tr>
<tr class="memitem:ad3e3642b2d41a31bfc58b6ac09b1b7f1" id="r_ad3e3642b2d41a31bfc58b6ac09b1b7f1"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; LLVM::LLVMFuncOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3e3642b2d41a31bfc58b6ac09b1b7f1">convertFuncOpToLLVMFuncOp</a> (FunctionOpInterface funcOp, ConversionPatternRewriter &amp;rewriter, const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1SymbolTableCollection.html">SymbolTableCollection</a> *symbolTables=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:ad3e3642b2d41a31bfc58b6ac09b1b7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert input FunctionOpInterface operation to LLVMFuncOp by using the provided <a class="el" href="classmlir_1_1LLVMTypeConverter.html" title="Conversion from types to the LLVM IR dialect.">LLVMTypeConverter</a>.  <br /></td></tr>
<tr class="memitem:a5c1bfb234358ffd9f600fe167863be2b" id="r_a5c1bfb234358ffd9f600fe167863be2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c1bfb234358ffd9f600fe167863be2b">populateFuncToLLVMFuncOpConversionPattern</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1SymbolTableCollection.html">SymbolTableCollection</a> *symbolTables=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a5c1bfb234358ffd9f600fe167863be2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the default pattern to convert a FuncOp to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect.  <br /></td></tr>
<tr class="memitem:a51d060144ae5b7843e2eb3142c685f47" id="r_a51d060144ae5b7843e2eb3142c685f47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51d060144ae5b7843e2eb3142c685f47">populateFuncToLLVMConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1SymbolTableCollection.html">SymbolTableCollection</a> *symbolTables=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a51d060144ae5b7843e2eb3142c685f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the patterns to convert from the Func dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <br /></td></tr>
<tr class="memitem:a4cd7b1431f65dc7d952407a7e062e63f" id="r_a4cd7b1431f65dc7d952407a7e062e63f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cd7b1431f65dc7d952407a7e062e63f">registerConvertFuncToLLVMInterface</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:a3cd85763bbf05717c6013952a6369f2b" id="r_a3cd85763bbf05717c6013952a6369f2b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3cd85763bbf05717c6013952a6369f2b">createConvertFuncToLLVMPass</a> ()</td></tr>
<tr class="memitem:a7ada9b98e2e5412609e62b930fd273e0" id="r_a7ada9b98e2e5412609e62b930fd273e0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ada9b98e2e5412609e62b930fd273e0">createConvertFuncToLLVMPass</a> (<a class="el" href="structmlir_1_1ConvertFuncToLLVMPassOptions.html">ConvertFuncToLLVMPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:aa5869d9c7c1c0f38587ea9c7c3f17abd" id="r_aa5869d9c7c1c0f38587ea9c7c3f17abd"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5869d9c7c1c0f38587ea9c7c3f17abd">createSetLLVMModuleDataLayoutPass</a> ()</td></tr>
<tr class="memitem:a0cd888dc1fe162499039e04fb50a808d" id="r_a0cd888dc1fe162499039e04fb50a808d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cd888dc1fe162499039e04fb50a808d">createSetLLVMModuleDataLayoutPass</a> (<a class="el" href="structmlir_1_1SetLLVMModuleDataLayoutPassOptions.html">SetLLVMModuleDataLayoutPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a62bf9368c68fc8006128f4ff2f1c5001" id="r_a62bf9368c68fc8006128f4ff2f1c5001"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62bf9368c68fc8006128f4ff2f1c5001">populateFuncToSPIRVPatterns</a> (const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a62bf9368c68fc8006128f4ff2f1c5001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating Func ops to SPIR-V ops.  <br /></td></tr>
<tr class="memitem:acba6fd5ddcaf2a0d3b0e45b107806a02" id="r_acba6fd5ddcaf2a0d3b0e45b107806a02"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acba6fd5ddcaf2a0d3b0e45b107806a02">createConvertFuncToSPIRVPass</a> ()</td></tr>
<tr class="memitem:a8b5b53cb421dcd6a0dc062b212608465" id="r_a8b5b53cb421dcd6a0dc062b212608465"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b5b53cb421dcd6a0dc062b212608465">createConvertFuncToSPIRVPass</a> (<a class="el" href="structmlir_1_1ConvertFuncToSPIRVPassOptions.html">ConvertFuncToSPIRVPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a51a6eaafe741bc1b5aaef4e3e188e868" id="r_a51a6eaafe741bc1b5aaef4e3e188e868"><td class="memItemLeft" align="right" valign="top">spirv::StorageClass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51a6eaafe741bc1b5aaef4e3e188e868">addressSpaceToStorageClass</a> (gpu::AddressSpace addressSpace)</td></tr>
<tr class="memitem:ab713f3ebdfd529788867c3b1d7d94f7b" id="r_ab713f3ebdfd529788867c3b1d7d94f7b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab713f3ebdfd529788867c3b1d7d94f7b">createGpuToLLVMConversionPass</a> ()</td></tr>
<tr class="memitem:ace1669c25cb81206ee3dd3c36998c0b3" id="r_ace1669c25cb81206ee3dd3c36998c0b3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace1669c25cb81206ee3dd3c36998c0b3">createGpuToLLVMConversionPass</a> (<a class="el" href="structmlir_1_1GpuToLLVMConversionPassOptions.html">GpuToLLVMConversionPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a8613a6ab11e19c2d24255fff3a3b2c87" id="r_a8613a6ab11e19c2d24255fff3a3b2c87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8613a6ab11e19c2d24255fff3a3b2c87">populateGpuToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classbool.html">bool</a> kernelBarePtrCallConv=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>, <a class="el" href="classbool.html">bool</a> kernelIntersperseSizeCallConv=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a8613a6ab11e19c2d24255fff3a3b2c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> and populate converter for gpu types.  <br /></td></tr>
<tr class="memitem:a9a64af4be39c0a24e5cf7dd18d7f619f" id="r_a9a64af4be39c0a24e5cf7dd18d7f619f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a64af4be39c0a24e5cf7dd18d7f619f">populateGpuMemorySpaceAttributeConversions</a> (<a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;typeConverter, const <a class="el" href="#a7a0b25e7052411f56f063eca0b73e8a2">MemorySpaceMapping</a> &amp;mapping)</td></tr>
<tr class="memdesc:a9a64af4be39c0a24e5cf7dd18d7f619f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates memory space attribute conversion rules for lowering gpu.address_space to integer values.  <br /></td></tr>
<tr class="memitem:a376a66b8b08ee5a3b605beff24e374c7" id="r_a376a66b8b08ee5a3b605beff24e374c7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a376a66b8b08ee5a3b605beff24e374c7">createConvertGpuOpsToLLVMSPVOps</a> ()</td></tr>
<tr class="memitem:a9ad74b2b5a93c7958c4ae4fd1525e293" id="r_a9ad74b2b5a93c7958c4ae4fd1525e293"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ad74b2b5a93c7958c4ae4fd1525e293">createConvertGpuOpsToLLVMSPVOps</a> (<a class="el" href="structmlir_1_1ConvertGpuOpsToLLVMSPVOpsOptions.html">ConvertGpuOpsToLLVMSPVOpsOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a15d3286013eff75a1bf8168b7f569308" id="r_a15d3286013eff75a1bf8168b7f569308"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15d3286013eff75a1bf8168b7f569308">populateGpuToLLVMSPVConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memitem:a07982150babf881946ef966e4d7842e0" id="r_a07982150babf881946ef966e4d7842e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07982150babf881946ef966e4d7842e0">populateGpuMemorySpaceAttributeConversions</a> (<a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;typeConverter)</td></tr>
<tr class="memdesc:a07982150babf881946ef966e4d7842e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates memory space attribute conversion rules for lowering gpu.address_space to integer values.  <br /></td></tr>
<tr class="memitem:a7b94a230d24902eee1e12901c6c7d73c" id="r_a7b94a230d24902eee1e12901c6c7d73c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b94a230d24902eee1e12901c6c7d73c">createConvertGpuOpsToNVVMOps</a> ()</td></tr>
<tr class="memitem:abf833dbc1ed830908b1219a3a5493d1b" id="r_abf833dbc1ed830908b1219a3a5493d1b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf833dbc1ed830908b1219a3a5493d1b">createConvertGpuOpsToNVVMOps</a> (<a class="el" href="structmlir_1_1ConvertGpuOpsToNVVMOpsOptions.html">ConvertGpuOpsToNVVMOpsOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a5f35c4dea09716bdfb53830c5291b4bb" id="r_a5f35c4dea09716bdfb53830c5291b4bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f35c4dea09716bdfb53830c5291b4bb">convertMMAToLLVMType</a> (<a class="el" href="classmlir_1_1gpu_1_1MMAMatrixType.html">gpu::MMAMatrixType</a> type)</td></tr>
<tr class="memdesc:a5f35c4dea09716bdfb53830c5291b4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the LLVMStructureType corresponding to the MMAMatrixType <span class="tt">type</span>.  <br /></td></tr>
<tr class="memitem:a7fa896c9229c786edc4a7970b960b208" id="r_a7fa896c9229c786edc4a7970b960b208"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fa896c9229c786edc4a7970b960b208">configureGpuToNVVMConversionLegality</a> (<a class="el" href="classConversionTarget.html">ConversionTarget</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a5d2c023108742a1ce78ba9823c06ea35">target</a>)</td></tr>
<tr class="memdesc:a7fa896c9229c786edc4a7970b960b208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure target to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>.  <br /></td></tr>
<tr class="memitem:a779a8acdc0bf58163f34a058382fbc75" id="r_a779a8acdc0bf58163f34a058382fbc75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a779a8acdc0bf58163f34a058382fbc75">configureGpuToNVVMTypeConverter</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter)</td></tr>
<tr class="memdesc:a779a8acdc0bf58163f34a058382fbc75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> type convert to convert types and address spaces from the GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>.  <br /></td></tr>
<tr class="memitem:af8bcc32e84f5710bd6e288f171d4178b" id="r_af8bcc32e84f5710bd6e288f171d4178b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8bcc32e84f5710bd6e288f171d4178b">populateLibDeviceConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:af8bcc32e84f5710bd6e288f171d4178b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns that lower certain arith and math dialect ops to libdevice calls.  <br /></td></tr>
<tr class="memitem:a994285c8f7cd14dbbb4d8776179a48ea" id="r_a994285c8f7cd14dbbb4d8776179a48ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a994285c8f7cd14dbbb4d8776179a48ea">populateGpuToNVVMConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a994285c8f7cd14dbbb4d8776179a48ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>.  <br /></td></tr>
<tr class="memitem:a8df7e4388da5d61f0a3831f7e84559e2" id="r_a8df7e4388da5d61f0a3831f7e84559e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8df7e4388da5d61f0a3831f7e84559e2">populateGpuSubgroupReduceOpLoweringPattern</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a8df7e4388da5d61f0a3831f7e84559e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate GpuSubgroupReduce pattern to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>.  <br /></td></tr>
<tr class="memitem:aff8142e6ea13c807b37d7352283aeda9" id="r_aff8142e6ea13c807b37d7352283aeda9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff8142e6ea13c807b37d7352283aeda9">populateGpuWMMAToNVVMConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:aff8142e6ea13c807b37d7352283aeda9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert WMMA ops from GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>.  <br /></td></tr>
<tr class="memitem:a97b88c9831e2b5cd3173dd64fd52bc0b" id="r_a97b88c9831e2b5cd3173dd64fd52bc0b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97b88c9831e2b5cd3173dd64fd52bc0b">createConvertGpuOpsToROCDLOps</a> ()</td></tr>
<tr class="memitem:a8e949f5ac36d161612dc0a5143e6e2ca" id="r_a8e949f5ac36d161612dc0a5143e6e2ca"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e949f5ac36d161612dc0a5143e6e2ca">createConvertGpuOpsToROCDLOps</a> (<a class="el" href="structmlir_1_1ConvertGpuOpsToROCDLOpsOptions.html">ConvertGpuOpsToROCDLOpsOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a0ae71be7fe03174473e044b1e6db32e7" id="r_a0ae71be7fe03174473e044b1e6db32e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ae71be7fe03174473e044b1e6db32e7">populateGpuToROCDLConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="namespacemlir_1_1gpu_1_1amd.html#a8637afbd01b984be30dbd1cdb78ae45f">gpu::amd::Runtime</a> runtime, <a class="el" href="structmlir_1_1amdgpu_1_1Chipset.html">amdgpu::Chipset</a> chipset)</td></tr>
<tr class="memdesc:a0ae71be7fe03174473e044b1e6db32e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a>.  <br /></td></tr>
<tr class="memitem:a65c490624b02da7c5cb78aa071e0aa2a" id="r_a65c490624b02da7c5cb78aa071e0aa2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65c490624b02da7c5cb78aa071e0aa2a">configureGpuToROCDLConversionLegality</a> (<a class="el" href="classConversionTarget.html">ConversionTarget</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a5d2c023108742a1ce78ba9823c06ea35">target</a>)</td></tr>
<tr class="memdesc:a65c490624b02da7c5cb78aa071e0aa2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure target to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a>.  <br /></td></tr>
<tr class="memitem:aa38792a214e31cdbf60cb4b3f859767d" id="r_aa38792a214e31cdbf60cb4b3f859767d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa38792a214e31cdbf60cb4b3f859767d">populateGPUToSPIRVPatterns</a> (const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:aa38792a214e31cdbf60cb4b3f859767d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating GPU Ops to SPIR-V ops.  <br /></td></tr>
<tr class="memitem:a875bfbc01fd879b9697d28ef7856b4f7" id="r_a875bfbc01fd879b9697d28ef7856b4f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a875bfbc01fd879b9697d28ef7856b4f7">populateGpuWMMAToSPIRVCoopMatrixKHRConversionPatterns</a> (const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a875bfbc01fd879b9697d28ef7856b4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert WMMA ops from GPU dialect to SPIRV, using the KHR Cooperative Matrix extension.  <br /></td></tr>
<tr class="memitem:ab2ca5cbf58aa081676683b5b8111cc50" id="r_ab2ca5cbf58aa081676683b5b8111cc50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2ca5cbf58aa081676683b5b8111cc50">populateMMAToSPIRVCoopMatrixTypeConversion</a> (<a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter)</td></tr>
<tr class="memdesc:ab2ca5cbf58aa081676683b5b8111cc50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <span class="tt">MMAMatrixType</span> conversions to SPIR-V cooperative matrix KHR type conversion to the type converter.  <br /></td></tr>
<tr class="memitem:a112698688acfebc3284b59e6ffa4d155" id="r_a112698688acfebc3284b59e6ffa4d155"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a112698688acfebc3284b59e6ffa4d155">createConvertGPUToSPIRVPass</a> (<a class="el" href="classbool.html">bool</a> mapMemorySpace=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:a112698688acfebc3284b59e6ffa4d155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert GPU kernel ops to corresponding SPIR-V ops.  <br /></td></tr>
<tr class="memitem:a3f76629f036b1d575042d01a4f1d0de3" id="r_a3f76629f036b1d575042d01a4f1d0de3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f76629f036b1d575042d01a4f1d0de3">createConvertIndexToLLVMPass</a> ()</td></tr>
<tr class="memitem:a7125b727c78c0f4da39fd87400420893" id="r_a7125b727c78c0f4da39fd87400420893"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7125b727c78c0f4da39fd87400420893">createConvertIndexToLLVMPass</a> (<a class="el" href="structmlir_1_1ConvertIndexToLLVMPassOptions.html">ConvertIndexToLLVMPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a5fd0d8a04f6db022c24e51e8d85a35d7" id="r_a5fd0d8a04f6db022c24e51e8d85a35d7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fd0d8a04f6db022c24e51e8d85a35d7">createConvertIndexToSPIRVPass</a> ()</td></tr>
<tr class="memitem:a64ad1652971668791e6f5ba89c909e46" id="r_a64ad1652971668791e6f5ba89c909e46"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64ad1652971668791e6f5ba89c909e46">createConvertIndexToSPIRVPass</a> (<a class="el" href="structmlir_1_1ConvertIndexToSPIRVPassOptions.html">ConvertIndexToSPIRVPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:aa411ac3594c82f6156e8a0184a9dec33" id="r_aa411ac3594c82f6156e8a0184a9dec33"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa411ac3594c82f6156e8a0184a9dec33">createConvertLinalgToStandardPass</a> ()</td></tr>
<tr class="memitem:a528c0559f393f6206d80cdb29394fa1c" id="r_a528c0559f393f6206d80cdb29394fa1c"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a528c0559f393f6206d80cdb29394fa1c">structFuncArgTypeConverter</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1Type.html">Type</a> type, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a>)</td></tr>
<tr class="memdesc:a528c0559f393f6206d80cdb29394fa1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to convert function argument types.  <br /></td></tr>
<tr class="memitem:a0b57be921931a80cdd8e7b0f96fc6e9f" id="r_a0b57be921931a80cdd8e7b0f96fc6e9f"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b57be921931a80cdd8e7b0f96fc6e9f">barePtrFuncArgTypeConverter</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1Type.html">Type</a> type, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a>)</td></tr>
<tr class="memdesc:a0b57be921931a80cdd8e7b0f96fc6e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to convert function argument types.  <br /></td></tr>
<tr class="memitem:a7848cf7b0f5c06cc25a460eaeaa07aec" id="r_a7848cf7b0f5c06cc25a460eaeaa07aec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7848cf7b0f5c06cc25a460eaeaa07aec">populateConvertMathToEmitCPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="namespacemlir_1_1emitc.html#a0ad3720c07467edc248a23dbc84d6cf4">emitc::LanguageTarget</a> languageTarget)</td></tr>
<tr class="memitem:a9382090f3dedaf4324ac78b2acaf61b6" id="r_a9382090f3dedaf4324ac78b2acaf61b6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9382090f3dedaf4324ac78b2acaf61b6">createConvertMathToEmitC</a> ()</td></tr>
<tr class="memitem:aefc28a755eb90665e204d8a5101a1b97" id="r_aefc28a755eb90665e204d8a5101a1b97"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefc28a755eb90665e204d8a5101a1b97">createConvertMathToEmitC</a> (<a class="el" href="structmlir_1_1ConvertMathToEmitCOptions.html">ConvertMathToEmitCOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:af9f4a684326a0b7e9176f9389522d56c" id="r_af9f4a684326a0b7e9176f9389522d56c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9f4a684326a0b7e9176f9389522d56c">createConvertMathToFuncs</a> ()</td></tr>
<tr class="memitem:a5cc3bd8947eb1c45ca1d9f0f463d3521" id="r_a5cc3bd8947eb1c45ca1d9f0f463d3521"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5cc3bd8947eb1c45ca1d9f0f463d3521">createConvertMathToFuncs</a> (<a class="el" href="structmlir_1_1ConvertMathToFuncsOptions.html">ConvertMathToFuncsOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a81462a9b7179f12733bf70e3fdbb18f5" id="r_a81462a9b7179f12733bf70e3fdbb18f5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81462a9b7179f12733bf70e3fdbb18f5">createConvertMathToLibmPass</a> ()</td></tr>
<tr class="memitem:a040f9de8ca0ac669f74c26f01f8c139d" id="r_a040f9de8ca0ac669f74c26f01f8c139d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a040f9de8ca0ac669f74c26f01f8c139d">populateMathToLibmConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a040f9de8ca0ac669f74c26f01f8c139d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from Math to Libm calls.  <br /></td></tr>
<tr class="memitem:a20c6992fa94a95d8940091b1ad3e6a84" id="r_a20c6992fa94a95d8940091b1ad3e6a84"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20c6992fa94a95d8940091b1ad3e6a84">createConvertMathToLLVMPass</a> ()</td></tr>
<tr class="memitem:a62c0746839de489fca70914299d3fb8b" id="r_a62c0746839de489fca70914299d3fb8b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62c0746839de489fca70914299d3fb8b">createConvertMathToLLVMPass</a> (<a class="el" href="structmlir_1_1ConvertMathToLLVMPassOptions.html">ConvertMathToLLVMPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a498c981e702899dd3494491f2f001a9d" id="r_a498c981e702899dd3494491f2f001a9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a498c981e702899dd3494491f2f001a9d">populateMathToLLVMConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classbool.html">bool</a> approximateLog1p=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memitem:af524bd5bb2e7831529a737536dee9e63" id="r_af524bd5bb2e7831529a737536dee9e63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af524bd5bb2e7831529a737536dee9e63">registerConvertMathToLLVMInterface</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:afeb08f0c6ed2eeff505cd7f1c0108ff9" id="r_afeb08f0c6ed2eeff505cd7f1c0108ff9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afeb08f0c6ed2eeff505cd7f1c0108ff9">createConvertMathToROCDL</a> ()</td></tr>
<tr class="memitem:ac17d7f9f4357dd23c8f47b9c50b52452" id="r_ac17d7f9f4357dd23c8f47b9c50b52452"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac17d7f9f4357dd23c8f47b9c50b52452">createConvertMathToROCDL</a> (<a class="el" href="structmlir_1_1ConvertMathToROCDLOptions.html">ConvertMathToROCDLOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a122c10e64cb8e8527ba75c5db4235740" id="r_a122c10e64cb8e8527ba75c5db4235740"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a122c10e64cb8e8527ba75c5db4235740">populateMathToROCDLConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, std::optional&lt; <a class="el" href="structmlir_1_1amdgpu_1_1Chipset.html">amdgpu::Chipset</a> &gt; chipset)</td></tr>
<tr class="memdesc:a122c10e64cb8e8527ba75c5db4235740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from Math to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> calls.  <br /></td></tr>
<tr class="memitem:a6c5cdff8faeb322f48015571f5f4aae2" id="r_a6c5cdff8faeb322f48015571f5f4aae2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c5cdff8faeb322f48015571f5f4aae2">populateMathToSPIRVPatterns</a> (const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a6c5cdff8faeb322f48015571f5f4aae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating Math ops to SPIR-V ops.  <br /></td></tr>
<tr class="memitem:a86aacb673b7337d20c260608d32bb0cc" id="r_a86aacb673b7337d20c260608d32bb0cc"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86aacb673b7337d20c260608d32bb0cc">createConvertMathToSPIRVPass</a> ()</td></tr>
<tr class="memitem:aad4c0e02f0f005e3b081ee3b87994e6f" id="r_aad4c0e02f0f005e3b081ee3b87994e6f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad4c0e02f0f005e3b081ee3b87994e6f">createConvertMathToXeVM</a> ()</td></tr>
<tr class="memitem:a555029f09987c02ffba665df2c413d5e" id="r_a555029f09987c02ffba665df2c413d5e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a555029f09987c02ffba665df2c413d5e">createConvertMathToXeVM</a> (<a class="el" href="structmlir_1_1ConvertMathToXeVMOptions.html">ConvertMathToXeVMOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a110b276b38744134d9934f9f9ec6acd1" id="r_a110b276b38744134d9934f9f9ec6acd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a110b276b38744134d9934f9f9ec6acd1">populateMathToXeVMConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classbool.html">bool</a> convertArith)</td></tr>
<tr class="memdesc:a110b276b38744134d9934f9f9ec6acd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from Math to XeVM calls.  <br /></td></tr>
<tr class="memitem:a58637750147b089cca80eec8603b220f" id="r_a58637750147b089cca80eec8603b220f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58637750147b089cca80eec8603b220f">populateMemRefToEmitCTypeConversion</a> (<a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;typeConverter)</td></tr>
<tr class="memitem:a99266ebe2b3be9d39e425ef361013656" id="r_a99266ebe2b3be9d39e425ef361013656"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99266ebe2b3be9d39e425ef361013656">populateMemRefToEmitCConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;converter)</td></tr>
<tr class="memitem:ae8f146555b8c6c254ef00a1807de953d" id="r_ae8f146555b8c6c254ef00a1807de953d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8f146555b8c6c254ef00a1807de953d">registerConvertMemRefToEmitCInterface</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:a289a1a3d1f32d2d642f37fb063962cfe" id="r_a289a1a3d1f32d2d642f37fb063962cfe"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a289a1a3d1f32d2d642f37fb063962cfe">createConvertMemRefToEmitC</a> ()</td></tr>
<tr class="memitem:a5ed1c375934742418ad52b06b791ad2a" id="r_a5ed1c375934742418ad52b06b791ad2a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ed1c375934742418ad52b06b791ad2a">createConvertMemRefToEmitC</a> (<a class="el" href="structmlir_1_1ConvertMemRefToEmitCOptions.html">ConvertMemRefToEmitCOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:aa5473e3f81c5179664339b3ee0ecd719" id="r_aa5473e3f81c5179664339b3ee0ecd719"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5473e3f81c5179664339b3ee0ecd719">createFinalizeMemRefToLLVMConversionPass</a> ()</td></tr>
<tr class="memitem:a0a7aed2191eed4b1afa5cffb19cbbc2c" id="r_a0a7aed2191eed4b1afa5cffb19cbbc2c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a7aed2191eed4b1afa5cffb19cbbc2c">createFinalizeMemRefToLLVMConversionPass</a> (<a class="el" href="structmlir_1_1FinalizeMemRefToLLVMConversionPassOptions.html">FinalizeMemRefToLLVMConversionPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a7706b8ce246435dbbe7e1191938d2f1c" id="r_a7706b8ce246435dbbe7e1191938d2f1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7706b8ce246435dbbe7e1191938d2f1c">populateFinalizeMemRefToLLVMConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1SymbolTableCollection.html">SymbolTableCollection</a> *symbolTables=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a7706b8ce246435dbbe7e1191938d2f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert memory-related operations from the MemRef dialect to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect.  <br /></td></tr>
<tr class="memitem:a064361570e348faf435496fbf4d5db7d" id="r_a064361570e348faf435496fbf4d5db7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a064361570e348faf435496fbf4d5db7d">registerConvertMemRefToLLVMInterface</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:ad19383f60ade82f3ca68e0cabda60d42" id="r_ad19383f60ade82f3ca68e0cabda60d42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad19383f60ade82f3ca68e0cabda60d42">populateMemRefToSPIRVPatterns</a> (const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:ad19383f60ade82f3ca68e0cabda60d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating MemRef ops to SPIR-V ops.  <br /></td></tr>
<tr class="memitem:aa6db3aed9de7791d0da0aa2e4f627e9b" id="r_aa6db3aed9de7791d0da0aa2e4f627e9b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6db3aed9de7791d0da0aa2e4f627e9b">createConvertMemRefToSPIRVPass</a> ()</td></tr>
<tr class="memitem:a296abbfcc8d594fa36e27896fbd2bf04" id="r_a296abbfcc8d594fa36e27896fbd2bf04"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a296abbfcc8d594fa36e27896fbd2bf04">createConvertMemRefToSPIRVPass</a> (<a class="el" href="structmlir_1_1ConvertMemRefToSPIRVPassOptions.html">ConvertMemRefToSPIRVPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a0c5b68602e237b1c1c3209ae71184cd2" id="r_a0c5b68602e237b1c1c3209ae71184cd2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c5b68602e237b1c1c3209ae71184cd2">createMapMemRefStorageClassPass</a> ()</td></tr>
<tr class="memdesc:a0c5b68602e237b1c1c3209ae71184cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to map numeric MemRef memory spaces to symbolic SPIR-V storage classes.  <br /></td></tr>
<tr class="memitem:a57ee6b8b9dd79187b2d9986cd37985a5" id="r_a57ee6b8b9dd79187b2d9986cd37985a5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57ee6b8b9dd79187b2d9986cd37985a5">createConvertNVGPUToNVVMPass</a> ()</td></tr>
<tr class="memitem:a77bc264eaa4a13001177aa530bcd2313" id="r_a77bc264eaa4a13001177aa530bcd2313"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77bc264eaa4a13001177aa530bcd2313">populateNVGPUToNVVMConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memitem:a76fa8e989ba0f8abf1c504b7c084652d" id="r_a76fa8e989ba0f8abf1c504b7c084652d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76fa8e989ba0f8abf1c504b7c084652d">createConvertNVVMToLLVMPass</a> ()</td></tr>
<tr class="memitem:a35eb3329af0ae57e8a63db9abeaf88e5" id="r_a35eb3329af0ae57e8a63db9abeaf88e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35eb3329af0ae57e8a63db9abeaf88e5">populateNVVMToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memitem:af5ef9c68e63c5458b7258ecb9b48b8bf" id="r_af5ef9c68e63c5458b7258ecb9b48b8bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5ef9c68e63c5458b7258ecb9b48b8bf">registerConvertNVVMToLLVMInterface</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:a9058475349363ddfda744bc75829260d" id="r_a9058475349363ddfda744bc75829260d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9058475349363ddfda744bc75829260d">createConvertOpenACCToSCFPass</a> ()</td></tr>
<tr class="memitem:a725b3caed685f9615fba2027124f359f" id="r_a725b3caed685f9615fba2027124f359f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a725b3caed685f9615fba2027124f359f">populateOpenACCToSCFConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a725b3caed685f9615fba2027124f359f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the patterns to convert from the OpenACC dialect to OpenACC with SCF dialect.  <br /></td></tr>
<tr class="memitem:a30ec3c126d199afce9a94aebff5145a9" id="r_a30ec3c126d199afce9a94aebff5145a9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30ec3c126d199afce9a94aebff5145a9">createConvertOpenMPToLLVMPass</a> ()</td></tr>
<tr class="memitem:ab3aae89781697b10e37f29e112251443" id="r_ab3aae89781697b10e37f29e112251443"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3aae89781697b10e37f29e112251443">configureOpenMPToLLVMConversionLegality</a> (<a class="el" href="classConversionTarget.html">ConversionTarget</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a5d2c023108742a1ce78ba9823c06ea35">target</a>, const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;typeConverter)</td></tr>
<tr class="memdesc:ab3aae89781697b10e37f29e112251443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure dynamic conversion legality of regionless operations from OpenMP to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <br /></td></tr>
<tr class="memitem:a1111bfc29c10d7cd2ebba33996e38509" id="r_a1111bfc29c10d7cd2ebba33996e38509"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1111bfc29c10d7cd2ebba33996e38509">populateOpenMPToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a1111bfc29c10d7cd2ebba33996e38509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from OpenMP to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <br /></td></tr>
<tr class="memitem:a9410008d1bd500f1e43c258e655caf51" id="r_a9410008d1bd500f1e43c258e655caf51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9410008d1bd500f1e43c258e655caf51">registerConvertOpenMPToLLVMInterface</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a9410008d1bd500f1e43c258e655caf51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the <span class="tt"><a class="el" href="classmlir_1_1ConvertToLLVMPatternInterface.html" title="Base class for dialect interfaces providing translation to LLVM IR.">ConvertToLLVMPatternInterface</a></span> interface in the <span class="tt">OpenMP</span> dialect.  <br /></td></tr>
<tr class="memitem:a65e0082a0c034149c2dc108c8c3a35d5" id="r_a65e0082a0c034149c2dc108c8c3a35d5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65e0082a0c034149c2dc108c8c3a35d5">createConvertAffineForToGPUPass</a> ()</td></tr>
<tr class="memitem:a2a918000f7a6ce2a1c73a01b3c9da53b" id="r_a2a918000f7a6ce2a1c73a01b3c9da53b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a918000f7a6ce2a1c73a01b3c9da53b">createConvertAffineForToGPUPass</a> (<a class="el" href="structmlir_1_1ConvertAffineForToGPUPassOptions.html">ConvertAffineForToGPUPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:acda0a7cd5241463af7837d1e4936c235" id="r_acda0a7cd5241463af7837d1e4936c235"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acda0a7cd5241463af7837d1e4936c235">createConvertPDLToPDLInterpPass</a> ()</td></tr>
<tr class="memitem:a35d80ba8973702e9b7f806ebd262aa23" id="r_a35d80ba8973702e9b7f806ebd262aa23"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35d80ba8973702e9b7f806ebd262aa23">createConvertParallelLoopToGpuPass</a> ()</td></tr>
<tr class="memitem:a8d70e3a58d98d19afe19bff5cfaa0869" id="r_a8d70e3a58d98d19afe19bff5cfaa0869"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d70e3a58d98d19afe19bff5cfaa0869">createConvertSCFToOpenMPPass</a> ()</td></tr>
<tr class="memitem:a3b89b5ca382d3c5fce0e73dd44376d48" id="r_a3b89b5ca382d3c5fce0e73dd44376d48"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b89b5ca382d3c5fce0e73dd44376d48">createConvertSCFToOpenMPPass</a> (<a class="el" href="structmlir_1_1ConvertSCFToOpenMPPassOptions.html">ConvertSCFToOpenMPPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a451cd8ae03097ce35de8b5b75c82c5f3" id="r_a451cd8ae03097ce35de8b5b75c82c5f3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a451cd8ae03097ce35de8b5b75c82c5f3">createConvertSPIRVToLLVMPass</a> ()</td></tr>
<tr class="memitem:a8740a7a0efd3f81919fb62a6a549e5ba" id="r_a8740a7a0efd3f81919fb62a6a549e5ba"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8740a7a0efd3f81919fb62a6a549e5ba">createConvertSPIRVToLLVMPass</a> (<a class="el" href="structmlir_1_1ConvertSPIRVToLLVMPassOptions.html">ConvertSPIRVToLLVMPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:aef895a2d27d70f7defd52693777fdb75" id="r_aef895a2d27d70f7defd52693777fdb75"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef895a2d27d70f7defd52693777fdb75">createConvertShapeConstraintsPass</a> ()</td></tr>
<tr class="memitem:a47b87d6362d7fb801d72e60f2803855a" id="r_a47b87d6362d7fb801d72e60f2803855a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47b87d6362d7fb801d72e60f2803855a">createConvertShapeToStandardPass</a> ()</td></tr>
<tr class="memitem:acd00732d75c96e7fc11bed6aae04fa0d" id="r_acd00732d75c96e7fc11bed6aae04fa0d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd00732d75c96e7fc11bed6aae04fa0d">createConvertShardToMPIPass</a> ()</td></tr>
<tr class="memitem:ae883c3b90eacd7478cb5930c83ffc3cb" id="r_ae883c3b90eacd7478cb5930c83ffc3cb"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae883c3b90eacd7478cb5930c83ffc3cb">createConvertTensorToLinalgPass</a> ()</td></tr>
<tr class="memitem:a861fc585debe3765517a0260aa6916ca" id="r_a861fc585debe3765517a0260aa6916ca"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a861fc585debe3765517a0260aa6916ca">createConvertTensorToSPIRVPass</a> ()</td></tr>
<tr class="memitem:a86c1f41dd07b43b24de016cfc52fa5dc" id="r_a86c1f41dd07b43b24de016cfc52fa5dc"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86c1f41dd07b43b24de016cfc52fa5dc">createConvertTensorToSPIRVPass</a> (<a class="el" href="structmlir_1_1ConvertTensorToSPIRVPassOptions.html">ConvertTensorToSPIRVPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:ac252f2fe32faedf77083947e2050c011" id="r_ac252f2fe32faedf77083947e2050c011"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac252f2fe32faedf77083947e2050c011">createConvertVectorToAMX</a> ()</td></tr>
<tr class="memitem:a439b223f6baa77288a25ac79053cef08" id="r_a439b223f6baa77288a25ac79053cef08"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a439b223f6baa77288a25ac79053cef08">createConvertVectorToArmSMEPass</a> ()</td></tr>
<tr class="memitem:a4b8cfccc4312bcc74422c9de79a954a0" id="r_a4b8cfccc4312bcc74422c9de79a954a0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b8cfccc4312bcc74422c9de79a954a0">createConvertVectorToLLVMPass</a> ()</td></tr>
<tr class="memitem:ab6b01c628a160f0063c9508358fb6d78" id="r_ab6b01c628a160f0063c9508358fb6d78"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6b01c628a160f0063c9508358fb6d78">createConvertVectorToLLVMPass</a> (<a class="el" href="structmlir_1_1ConvertVectorToLLVMPassOptions.html">ConvertVectorToLLVMPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a0b613bd52abde0fb5a56991828a9821c" id="r_a0b613bd52abde0fb5a56991828a9821c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b613bd52abde0fb5a56991828a9821c">createConvertVectorToSPIRVPass</a> ()</td></tr>
<tr class="memitem:a97be68bd81a51548109db1fb737dd7d2" id="r_a97be68bd81a51548109db1fb737dd7d2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97be68bd81a51548109db1fb737dd7d2">createConvertVectorToXeGPU</a> ()</td></tr>
<tr class="memitem:a69cb1b43ebb68e7cc8f2262da0e872f5" id="r_a69cb1b43ebb68e7cc8f2262da0e872f5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69cb1b43ebb68e7cc8f2262da0e872f5">createConvertXeGPUToXeVMPass</a> ()</td></tr>
<tr class="memitem:ace0bd65d05252efbfe03d52ac07f4558" id="r_ace0bd65d05252efbfe03d52ac07f4558"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace0bd65d05252efbfe03d52ac07f4558">createConvertXeVMToLLVMPass</a> ()</td></tr>
<tr class="memitem:a102fc0d70d243e6feb2490715c31ffe0" id="r_a102fc0d70d243e6feb2490715c31ffe0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a102fc0d70d243e6feb2490715c31ffe0">createLowerHostCodeToLLVMPass</a> ()</td></tr>
<tr class="memitem:a45af0d9851224c09391b386d5fef60c2" id="r_a45af0d9851224c09391b386d5fef60c2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45af0d9851224c09391b386d5fef60c2">createReconcileUnrealizedCastsPass</a> ()</td></tr>
<tr class="memitem:a1bda9f9dfebc7056b41f414d91593372" id="r_a1bda9f9dfebc7056b41f414d91593372"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bda9f9dfebc7056b41f414d91593372">createSCFToControlFlowPass</a> ()</td></tr>
<tr class="memitem:a4e7b85b406277d3cf5ee6e4f3049e9c4" id="r_a4e7b85b406277d3cf5ee6e4f3049e9c4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e7b85b406277d3cf5ee6e4f3049e9c4">createSCFToControlFlowPass</a> (<a class="el" href="structmlir_1_1SCFToControlFlowPassOptions.html">SCFToControlFlowPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:ab9c9a79ce37e1b1c3a2938ddb659b888" id="r_ab9c9a79ce37e1b1c3a2938ddb659b888"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9c9a79ce37e1b1c3a2938ddb659b888">createSCFToEmitC</a> ()</td></tr>
<tr class="memitem:a3123bb0bda65317a1439fa33a0f511ca" id="r_a3123bb0bda65317a1439fa33a0f511ca"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3123bb0bda65317a1439fa33a0f511ca">createSCFToSPIRV</a> ()</td></tr>
<tr class="memitem:a708574e1a513815d1dddafdcbfd75582" id="r_a708574e1a513815d1dddafdcbfd75582"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a708574e1a513815d1dddafdcbfd75582">createTosaToArithPass</a> ()</td></tr>
<tr class="memitem:a6fbe05fcf9d84a4d747a1c049385907f" id="r_a6fbe05fcf9d84a4d747a1c049385907f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fbe05fcf9d84a4d747a1c049385907f">createTosaToArithPass</a> (<a class="el" href="structmlir_1_1TosaToArithPassOptions.html">TosaToArithPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a4cd1a0721d00a16eadd381ead335654d" id="r_a4cd1a0721d00a16eadd381ead335654d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cd1a0721d00a16eadd381ead335654d">createTosaToMLProgram</a> ()</td></tr>
<tr class="memitem:abf02e342480b3a71ea8b0e92a1b5f630" id="r_abf02e342480b3a71ea8b0e92a1b5f630"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf02e342480b3a71ea8b0e92a1b5f630">createTosaToSCFPass</a> ()</td></tr>
<tr class="memitem:a192401f191b85e709a050ea54d730182" id="r_a192401f191b85e709a050ea54d730182"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a192401f191b85e709a050ea54d730182">createTosaToTensorPass</a> ()</td></tr>
<tr class="memitem:a637be7379cf3e49297cb8b1c64c982ab" id="r_a637be7379cf3e49297cb8b1c64c982ab"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a637be7379cf3e49297cb8b1c64c982ab">createUBToLLVMConversionPass</a> ()</td></tr>
<tr class="memitem:a3d860247511080f9c387ccbc9c588f65" id="r_a3d860247511080f9c387ccbc9c588f65"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d860247511080f9c387ccbc9c588f65">createUBToLLVMConversionPass</a> (<a class="el" href="structmlir_1_1UBToLLVMConversionPassOptions.html">UBToLLVMConversionPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a0f5e8bfd97c09cfa3b16ff9ab7c37860" id="r_a0f5e8bfd97c09cfa3b16ff9ab7c37860"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f5e8bfd97c09cfa3b16ff9ab7c37860">createUBToSPIRVConversionPass</a> ()</td></tr>
<tr class="memitem:a3c5ca7d3759b292e4ef08fa8359f88e4" id="r_a3c5ca7d3759b292e4ef08fa8359f88e4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c5ca7d3759b292e4ef08fa8359f88e4">createConvertPDLToPDLInterpPass</a> (<a class="el" href="#abde461319ad5039ddbf5b4e70f47618b">DenseMap</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, PDLPatternConfigSet * &gt; &amp;configMap)</td></tr>
<tr class="memdesc:a3c5ca7d3759b292e4ef08fa8359f88e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a pass to convert PDL ops to PDL interpreter ops.  <br /></td></tr>
<tr class="memitem:a9fc663ae01ea2b6384c3f6ce299be3b0" id="r_a9fc663ae01ea2b6384c3f6ce299be3b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fc663ae01ea2b6384c3f6ce299be3b0">populateSCFToControlFlowConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a9fc663ae01ea2b6384c3f6ce299be3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert SCF operations to CFG branch-based operations within the ControlFlow dialect.  <br /></td></tr>
<tr class="memitem:a601f437fd236d61c80f964d231b881cb" id="r_a601f437fd236d61c80f964d231b881cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a601f437fd236d61c80f964d231b881cb">populateSCFToEmitCConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;typeConverter)</td></tr>
<tr class="memdesc:a601f437fd236d61c80f964d231b881cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert SCF operations to the EmitC dialect.  <br /></td></tr>
<tr class="memitem:afbb6023aa80095813fe9d2a05b501603" id="r_afbb6023aa80095813fe9d2a05b501603"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbb6023aa80095813fe9d2a05b501603">registerConvertSCFToEmitCInterface</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:a4e36f1b7aaec9319e5ba11077079aa4e" id="r_a4e36f1b7aaec9319e5ba11077079aa4e"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e36f1b7aaec9319e5ba11077079aa4e">convertAffineLoopNestToGPULaunch</a> (affine::AffineForOp forOp, <a class="el" href="classunsigned.html">unsigned</a> numBlockDims, <a class="el" href="classunsigned.html">unsigned</a> numThreadDims)</td></tr>
<tr class="memdesc:a4e36f1b7aaec9319e5ba11077079aa4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a perfect affine loop nest with the outermost loop identified by <span class="tt">forOp</span> into a gpu::Launch operation.  <br /></td></tr>
<tr class="memitem:a1727b1783cbf671c6ee60cc2a5c2f132" id="r_a1727b1783cbf671c6ee60cc2a5c2f132"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1727b1783cbf671c6ee60cc2a5c2f132">populateParallelLoopToGPUPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a1727b1783cbf671c6ee60cc2a5c2f132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the conversion pattern from <span class="tt">scf.parallel</span> to <span class="tt">gpu.launch</span> to the provided pattern list.  <br /></td></tr>
<tr class="memitem:af01d59b73ef695a82338e96055101c16" id="r_af01d59b73ef695a82338e96055101c16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af01d59b73ef695a82338e96055101c16">configureParallelLoopToGPULegality</a> (<a class="el" href="classConversionTarget.html">ConversionTarget</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a5d2c023108742a1ce78ba9823c06ea35">target</a>)</td></tr>
<tr class="memdesc:af01d59b73ef695a82338e96055101c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the rewrite target such that only <span class="tt">scf.parallel</span> operations that are not rewritten by the provided patterns are legal.  <br /></td></tr>
<tr class="memitem:a04b8cb2bfcf870fb9909b4805c0aad13" id="r_a04b8cb2bfcf870fb9909b4805c0aad13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04b8cb2bfcf870fb9909b4805c0aad13">finalizeParallelLoopToGPUConversion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a04b8cb2bfcf870fb9909b4805c0aad13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up after applyPartialConversion/applyFullConversion call.  <br /></td></tr>
<tr class="memitem:a8ca1349510877edff1b6a3fe7249226c" id="r_a8ca1349510877edff1b6a3fe7249226c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ca1349510877edff1b6a3fe7249226c">populateSCFToSPIRVPatterns</a> (const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="structmlir_1_1ScfToSPIRVContext.html">ScfToSPIRVContext</a> &amp;scfToSPIRVContext, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a8ca1349510877edff1b6a3fe7249226c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects a set of patterns to lower from scf.for, scf.if, and loop.terminator to CFG operations within the SPIR-V dialect.  <br /></td></tr>
<tr class="memitem:a6f1a31b691eb03bce755f599963d47c4" id="r_a6f1a31b691eb03bce755f599963d47c4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f1a31b691eb03bce755f599963d47c4">createConvertSCFToSPIRVPass</a> ()</td></tr>
<tr class="memdesc:a6f1a31b691eb03bce755f599963d47c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert SCF ops into SPIR-V ops.  <br /></td></tr>
<tr class="memitem:a9d32c331310df6a35924ac128fa789f3" id="r_a9d32c331310df6a35924ac128fa789f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d32c331310df6a35924ac128fa789f3">populateShapeToStandardConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memitem:ae6e66615eb7e50976ed8c89b2bb05adc" id="r_ae6e66615eb7e50976ed8c89b2bb05adc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6e66615eb7e50976ed8c89b2bb05adc">populateConvertShapeConstraintsConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memitem:a1053fc52d14c30b033f053dd93383659" id="r_a1053fc52d14c30b033f053dd93383659"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1053fc52d14c30b033f053dd93383659">storageClassToAddressSpace</a> (spirv::ClientAPI clientAPI, spirv::StorageClass storageClass)</td></tr>
<tr class="memitem:ab8075944125730fed529e3b93dcfed5b" id="r_ab8075944125730fed529e3b93dcfed5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8075944125730fed529e3b93dcfed5b">encodeBindAttribute</a> (ModuleOp module)</td></tr>
<tr class="memdesc:ab8075944125730fed529e3b93dcfed5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes global variable's descriptor set and binding into its name if they both exist.  <br /></td></tr>
<tr class="memitem:a35333950f5d30c0990ebca7da9dd882c" id="r_a35333950f5d30c0990ebca7da9dd882c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35333950f5d30c0990ebca7da9dd882c">populateSPIRVToLLVMTypeConversion</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;typeConverter, spirv::ClientAPI clientAPIForAddressSpaceMapping=spirv::ClientAPI::Unknown)</td></tr>
<tr class="memdesc:a35333950f5d30c0990ebca7da9dd882c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates type conversions with additional SPIR-V types.  <br /></td></tr>
<tr class="memitem:aa47a30210dfc5deae1daa2e2c8840d8f" id="r_aa47a30210dfc5deae1daa2e2c8840d8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa47a30210dfc5deae1daa2e2c8840d8f">populateSPIRVToLLVMConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, spirv::ClientAPI clientAPIForAddressSpaceMapping=spirv::ClientAPI::Unknown)</td></tr>
<tr class="memdesc:aa47a30210dfc5deae1daa2e2c8840d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the given list with patterns that convert from SPIR-V to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <br /></td></tr>
<tr class="memitem:a6ee4e0b9121971b2ca8fcc16640d457f" id="r_a6ee4e0b9121971b2ca8fcc16640d457f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ee4e0b9121971b2ca8fcc16640d457f">populateSPIRVToLLVMFunctionConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a6ee4e0b9121971b2ca8fcc16640d457f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the given list with patterns for function conversion from SPIR-V to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <br /></td></tr>
<tr class="memitem:abe47840c56acca273d219c5fc82b179d" id="r_abe47840c56acca273d219c5fc82b179d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe47840c56acca273d219c5fc82b179d">populateSPIRVToLLVMModuleConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:abe47840c56acca273d219c5fc82b179d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the given patterns for module conversion from SPIR-V to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <br /></td></tr>
<tr class="memitem:a5b8ecf548ab4c5b21eddf5ee62e618e8" id="r_a5b8ecf548ab4c5b21eddf5ee62e618e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b8ecf548ab4c5b21eddf5ee62e618e8">populateTensorToLinalgPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a5b8ecf548ab4c5b21eddf5ee62e618e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating tensor ops to Linalg ops.  <br /></td></tr>
<tr class="memitem:a0ba8a125094bd28e1f1db4858eb5ff52" id="r_a0ba8a125094bd28e1f1db4858eb5ff52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ba8a125094bd28e1f1db4858eb5ff52">populateTensorToSPIRVPatterns</a> (const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classint64__t.html">int64_t</a> byteCountThreshold, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a0ba8a125094bd28e1f1db4858eb5ff52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating tensor ops to SPIR-V ops.  <br /></td></tr>
<tr class="memitem:a2cbeef3e897ac11eb895c16b9cdb9a2c" id="r_a2cbeef3e897ac11eb895c16b9cdb9a2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cbeef3e897ac11eb895c16b9cdb9a2c">populateVectorToAMXConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a2cbeef3e897ac11eb895c16b9cdb9a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the vector to AMX ops.  <br /></td></tr>
<tr class="memitem:ae512bcd2d0e2cc4f8ddb82e2922ccc8b" id="r_ae512bcd2d0e2cc4f8ddb82e2922ccc8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae512bcd2d0e2cc4f8ddb82e2922ccc8b">populateVectorToArmSMEPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;ctx)</td></tr>
<tr class="memdesc:ae512bcd2d0e2cc4f8ddb82e2922ccc8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to lower <a class="el" href="structVector.html">Vector</a> ops to ArmSME ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <br /></td></tr>
<tr class="memitem:a10daa5ecf515d29ea9079368f9b9b08d" id="r_a10daa5ecf515d29ea9079368f9b9b08d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10daa5ecf515d29ea9079368f9b9b08d">populatePrepareVectorToMMAPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classbool.html">bool</a> useNvGpu=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a10daa5ecf515d29ea9079368f9b9b08d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to transform vector ops into a canonical form to convert to MMA matrix operations.  <br /></td></tr>
<tr class="memitem:af7d71d5f26ac7f264365e6fb7a6aadff" id="r_af7d71d5f26ac7f264365e6fb7a6aadff"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7d71d5f26ac7f264365e6fb7a6aadff">convertVectorToMMAOps</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *rootOp)</td></tr>
<tr class="memdesc:af7d71d5f26ac7f264365e6fb7a6aadff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert vector ops to MMA matrix operations nested under <span class="tt">rootOp</span>.  <br /></td></tr>
<tr class="memitem:a8d66f364335bd7ca0a98bb53f82f0a77" id="r_a8d66f364335bd7ca0a98bb53f82f0a77"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d66f364335bd7ca0a98bb53f82f0a77">convertVectorToNVVMCompatibleMMASync</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *rootOp)</td></tr>
<tr class="memdesc:a8d66f364335bd7ca0a98bb53f82f0a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert vector ops ops nested under <span class="tt">rootOp</span> to vector and GPU operaitons compatible with the <span class="tt">nvvm.mma.sync</span> lowering path.  <br /></td></tr>
<tr class="memitem:ad3e64d4460362ea3cdb2edc8b746396c" id="r_ad3e64d4460362ea3cdb2edc8b746396c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3e64d4460362ea3cdb2edc8b746396c">createConvertVectorToGPUPass</a> (<a class="el" href="classbool.html">bool</a> useNvGpu=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:ad3e64d4460362ea3cdb2edc8b746396c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from vector to GPU ops.  <br /></td></tr>
<tr class="memitem:a9e2a9c17c36e972e2c9b81bee3a58a7d" id="r_a9e2a9c17c36e972e2c9b81bee3a58a7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e2a9c17c36e972e2c9b81bee3a58a7d">populateVectorToLLVMConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classbool.html">bool</a> reassociateFPReductions=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>, <a class="el" href="classbool.html">bool</a> force32BitVectorIndices=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>, <a class="el" href="classbool.html">bool</a> useVectorAlignment=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a9e2a9c17c36e972e2c9b81bee3a58a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the <a class="el" href="structVector.html">Vector</a> dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <br /></td></tr>
<tr class="memitem:a96c6c9c53e199da9b2def6f5e62eec02" id="r_a96c6c9c53e199da9b2def6f5e62eec02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96c6c9c53e199da9b2def6f5e62eec02">populateVectorToSCFConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>=<a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a>())</td></tr>
<tr class="memdesc:a96c6c9c53e199da9b2def6f5e62eec02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the <a class="el" href="structVector.html">Vector</a> dialect to SCF + func.  <br /></td></tr>
<tr class="memitem:ac5c71e471d7d8cdda288a27d1ae75642" id="r_ac5c71e471d7d8cdda288a27d1ae75642"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5c71e471d7d8cdda288a27d1ae75642">createConvertVectorToSCFPass</a> (const <a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>=<a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a>())</td></tr>
<tr class="memdesc:ac5c71e471d7d8cdda288a27d1ae75642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert a subset of vector ops to SCF.  <br /></td></tr>
<tr class="memitem:aff2bafba6c8ae1b85a1abadc386f22a3" id="r_aff2bafba6c8ae1b85a1abadc386f22a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff2bafba6c8ae1b85a1abadc386f22a3">populateVectorToSPIRVPatterns</a> (const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:aff2bafba6c8ae1b85a1abadc386f22a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating <a class="el" href="structVector.html">Vector</a> Ops to SPIR-V ops.  <br /></td></tr>
<tr class="memitem:a7fdbf57d9d955aea59286a07c5c3c03a" id="r_a7fdbf57d9d955aea59286a07c5c3c03a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fdbf57d9d955aea59286a07c5c3c03a">populateVectorReductionToSPIRVDotProductPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a7fdbf57d9d955aea59286a07c5c3c03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns to convert vector reduction of the form:  <br /></td></tr>
<tr class="memitem:a94a6fd23ac57182bebb5185f7013e2fa" id="r_a94a6fd23ac57182bebb5185f7013e2fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94a6fd23ac57182bebb5185f7013e2fa">populateVectorToXeGPUConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a94a6fd23ac57182bebb5185f7013e2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the vector to XeGPU ops.  <br /></td></tr>
<tr class="memitem:a9516463b940e7c464ca9398d327558cc" id="r_a9516463b940e7c464ca9398d327558cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9516463b940e7c464ca9398d327558cc">populateXeGPUToXeVMConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memitem:a5fab7f1dcbf00d2ed28e6800debf00cc" id="r_a5fab7f1dcbf00d2ed28e6800debf00cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fab7f1dcbf00d2ed28e6800debf00cc">populateXeVMToLLVMConversionPatterns</a> (<a class="el" href="classConversionTarget.html">ConversionTarget</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a5d2c023108742a1ce78ba9823c06ea35">target</a>, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memitem:afb1dd0bcae45a7ab0015246b4c8104b8" id="r_afb1dd0bcae45a7ab0015246b4c8104b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb1dd0bcae45a7ab0015246b4c8104b8">registerConvertXeVMToLLVMInterface</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:a37afe16f80bc8bacb6914dd6f0b869c0" id="r_a37afe16f80bc8bacb6914dd6f0b869c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37afe16f80bc8bacb6914dd6f0b869c0">setupDebuggerExecutionContextHook</a> (<a class="el" href="classmlir_1_1tracing_1_1ExecutionContext.html">tracing::ExecutionContext</a> &amp;executionContext)</td></tr>
<tr class="memitem:a996cc8b761f1373132a5d77b16d2076a" id="r_a996cc8b761f1373132a5d77b16d2076a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a996cc8b761f1373132a5d77b16d2076a">populateAMXLegalizeForLLVMExportPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a996cc8b761f1373132a5d77b16d2076a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to lower AMX ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <br /></td></tr>
<tr class="memitem:acc3c1de7f45b21ef1f9deddb22b03655" id="r_acc3c1de7f45b21ef1f9deddb22b03655"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc3c1de7f45b21ef1f9deddb22b03655">configureAMXLegalizeForExportTarget</a> (<a class="el" href="classmlir_1_1LLVMConversionTarget.html">LLVMConversionTarget</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a5d2c023108742a1ce78ba9823c06ea35">target</a>)</td></tr>
<tr class="memdesc:acc3c1de7f45b21ef1f9deddb22b03655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the target to support lowering AMX ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <br /></td></tr>
<tr class="memitem:aefb5027d679a969e98b2cd7b83b31079" id="r_aefb5027d679a969e98b2cd7b83b31079"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefb5027d679a969e98b2cd7b83b31079">registerConvertAMXToLLVMInterface</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:aefb5027d679a969e98b2cd7b83b31079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> conversion interface for AMX dialect.  <br /></td></tr>
<tr class="memitem:aa23862ef78a8ff63b4f6a3c344448e16" id="r_aa23862ef78a8ff63b4f6a3c344448e16"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa23862ef78a8ff63b4f6a3c344448e16">inferExpandShapeOutputShape</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, ShapedType expandedType, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt; reassociation, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; inputShape)</td></tr>
<tr class="memdesc:aa23862ef78a8ff63b4f6a3c344448e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the output shape for a {memref|tensor}.expand_shape when it is possible to do so.  <br /></td></tr>
<tr class="memitem:ac7736bcb70dbd9f242cd5182dd443031" id="r_ac7736bcb70dbd9f242cd5182dd443031"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1op__matcher.html">detail::op_matcher</a>&lt; <a class="el" href="classmlir_1_1arith_1_1ConstantIndexOp.html">arith::ConstantIndexOp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7736bcb70dbd9f242cd5182dd443031">matchConstantIndex</a> ()</td></tr>
<tr class="memdesc:ac7736bcb70dbd9f242cd5182dd443031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a ConstantIndexOp.  <br /></td></tr>
<tr class="memitem:ac1bdf7e87740dbe0f603efdbc83c0a68" id="r_ac1bdf7e87740dbe0f603efdbc83c0a68"><td class="memItemLeft" align="right" valign="top">llvm::SmallBitVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1bdf7e87740dbe0f603efdbc83c0a68">getPositionsOfShapeOne</a> (<a class="el" href="classunsigned.html">unsigned</a> rank, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; shape)</td></tr>
<tr class="memitem:a4654f8a83dcd16f99ce83a6a991fa348" id="r_a4654f8a83dcd16f99ce83a6a991fa348"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4654f8a83dcd16f99ce83a6a991fa348">getValueOrCreateConstantIntOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr)</td></tr>
<tr class="memdesc:a4654f8a83dcd16f99ce83a6a991fa348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> to a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <br /></td></tr>
<tr class="memitem:aa058eb9c12d3b97deb073543c1372195" id="r_aa058eb9c12d3b97deb073543c1372195"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa058eb9c12d3b97deb073543c1372195">getValueOrCreateConstantIndexOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr)</td></tr>
<tr class="memdesc:aa058eb9c12d3b97deb073543c1372195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> to a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <br /></td></tr>
<tr class="memitem:ab09c62516a7b31fc96892014feeae832" id="r_ab09c62516a7b31fc96892014feeae832"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab09c62516a7b31fc96892014feeae832">getValueOrCreateConstantIndexOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; valueOrAttrVec)</td></tr>
<tr class="memdesc:ab09c62516a7b31fc96892014feeae832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the other overload, but converts multiple OpFoldResults into Values.  <br /></td></tr>
<tr class="memitem:a7d8bbfc3d0c15e92f5cba28e5ef447b5" id="r_a7d8bbfc3d0c15e92f5cba28e5ef447b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d8bbfc3d0c15e92f5cba28e5ef447b5">getValueOrCreateCastToIndexLike</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Type.html">Type</a> targetType, <a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:a7d8bbfc3d0c15e92f5cba28e5ef447b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a cast from an index-like value (index or integer) to another index-like value.  <br /></td></tr>
<tr class="memitem:a10d383da63b1370b9cf5c13c252b391d" id="r_a10d383da63b1370b9cf5c13c252b391d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10d383da63b1370b9cf5c13c252b391d">convertScalarToDtype</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> operand, <a class="el" href="classmlir_1_1Type.html">Type</a> toType, <a class="el" href="classbool.html">bool</a> isUnsignedCast)</td></tr>
<tr class="memdesc:a10d383da63b1370b9cf5c13c252b391d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a scalar value <span class="tt">operand</span> to type <span class="tt">toType</span>.  <br /></td></tr>
<tr class="memitem:a147eacb98e107c587492012f9981cd62" id="r_a147eacb98e107c587492012f9981cd62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a147eacb98e107c587492012f9981cd62">createScalarOrSplatConstant</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Type.html">Type</a> type, const APInt &amp;value)</td></tr>
<tr class="memdesc:a147eacb98e107c587492012f9981cd62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a constant of type <span class="tt">type</span> at location <span class="tt">loc</span> whose value is <span class="tt">value</span> (an APInt or APFloat whose type must match the element type of <span class="tt">type</span>).  <br /></td></tr>
<tr class="memitem:a083c2c253d760b0fb021e6ce396105ed" id="r_a083c2c253d760b0fb021e6ce396105ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a083c2c253d760b0fb021e6ce396105ed">createScalarOrSplatConstant</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Type.html">Type</a> type, <a class="el" href="classint64__t.html">int64_t</a> value)</td></tr>
<tr class="memitem:acd7b8f0656a50e3147f888f41325b8bb" id="r_acd7b8f0656a50e3147f888f41325b8bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd7b8f0656a50e3147f888f41325b8bb">createScalarOrSplatConstant</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Type.html">Type</a> type, const APFloat &amp;value)</td></tr>
<tr class="memitem:a348ed9fcbefe1f5094cc571c346c7080" id="r_a348ed9fcbefe1f5094cc571c346c7080"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a348ed9fcbefe1f5094cc571c346c7080">getType</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr)</td></tr>
<tr class="memdesc:a348ed9fcbefe1f5094cc571c346c7080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the int type of the integer in ofr.  <br /></td></tr>
<tr class="memitem:ab4e0bc56426ca98e9bddc31e4ec82d35" id="r_ab4e0bc56426ca98e9bddc31e4ec82d35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4e0bc56426ca98e9bddc31e4ec82d35">populateArmSVELegalizeForLLVMExportPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:ab4e0bc56426ca98e9bddc31e4ec82d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to lower ArmSVE ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <br /></td></tr>
<tr class="memitem:aa975dde69503e4fee3f3a75dca5c9fac" id="r_aa975dde69503e4fee3f3a75dca5c9fac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa975dde69503e4fee3f3a75dca5c9fac">populateLowerContractionToSVEI8MMPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memitem:a95f30ee88fb58c23838e930cd42216c7" id="r_a95f30ee88fb58c23838e930cd42216c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95f30ee88fb58c23838e930cd42216c7">populateLowerContractionToSVEBFMMLAPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memitem:a026c18765c0bc2d44d9ab120174d36ae" id="r_a026c18765c0bc2d44d9ab120174d36ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a026c18765c0bc2d44d9ab120174d36ae">configureArmSVELegalizeForExportTarget</a> (<a class="el" href="classmlir_1_1LLVMConversionTarget.html">LLVMConversionTarget</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a5d2c023108742a1ce78ba9823c06ea35">target</a>)</td></tr>
<tr class="memdesc:a026c18765c0bc2d44d9ab120174d36ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the target to support lowering ArmSVE ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <br /></td></tr>
<tr class="memitem:a0e511207789978d6d07a7c8b6aec4c80" id="r_a0e511207789978d6d07a7c8b6aec4c80"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e511207789978d6d07a7c8b6aec4c80">createAsyncFuncToAsyncRuntimePass</a> ()</td></tr>
<tr class="memitem:ac97fb57e86e446cb9d52e54f21a194d8" id="r_ac97fb57e86e446cb9d52e54f21a194d8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac97fb57e86e446cb9d52e54f21a194d8">createAsyncParallelForPass</a> ()</td></tr>
<tr class="memitem:aa3335fc8c681130dac811a245e650554" id="r_aa3335fc8c681130dac811a245e650554"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3335fc8c681130dac811a245e650554">createAsyncParallelForPass</a> (<a class="el" href="structmlir_1_1AsyncParallelForPassOptions.html">AsyncParallelForPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:ab6945fc733c7c670fcbf10239e42bb29" id="r_ab6945fc733c7c670fcbf10239e42bb29"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6945fc733c7c670fcbf10239e42bb29">createAsyncRuntimePolicyBasedRefCountingPass</a> ()</td></tr>
<tr class="memitem:abac416dacbf73937288179c2daa2616b" id="r_abac416dacbf73937288179c2daa2616b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abac416dacbf73937288179c2daa2616b">createAsyncRuntimeRefCountingOptPass</a> ()</td></tr>
<tr class="memitem:a9cc934834f9684342d145bd21f653b08" id="r_a9cc934834f9684342d145bd21f653b08"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cc934834f9684342d145bd21f653b08">createAsyncRuntimeRefCountingPass</a> ()</td></tr>
<tr class="memitem:a82d800b64d126a8337def630902bd683" id="r_a82d800b64d126a8337def630902bd683"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82d800b64d126a8337def630902bd683">createAsyncToAsyncRuntimePass</a> ()</td></tr>
<tr class="memitem:aa9ea90e10c603e639fe6b6cbc9f24265" id="r_aa9ea90e10c603e639fe6b6cbc9f24265"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9ea90e10c603e639fe6b6cbc9f24265">populateAsyncFuncToAsyncRuntimeConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classConversionTarget.html">ConversionTarget</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a5d2c023108742a1ce78ba9823c06ea35">target</a>)</td></tr>
<tr class="memitem:a9b1d5689e67822e988ebe93a71a50477" id="r_a9b1d5689e67822e988ebe93a71a50477"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b1d5689e67822e988ebe93a71a50477">registerAsyncFuncToAsyncRuntimePass</a> ()</td></tr>
<tr class="memitem:a5b13504225fee209724382bef7f11fdd" id="r_a5b13504225fee209724382bef7f11fdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b13504225fee209724382bef7f11fdd">registerAsyncFuncToAsyncRuntimePassPass</a> ()</td></tr>
<tr class="memitem:a02ab19a0df07b7c1e51c2d1c335d9f7c" id="r_a02ab19a0df07b7c1e51c2d1c335d9f7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02ab19a0df07b7c1e51c2d1c335d9f7c">registerAsyncParallelForPass</a> ()</td></tr>
<tr class="memitem:af1d3ddf63ee3618c9a5aaab1a6936cc0" id="r_af1d3ddf63ee3618c9a5aaab1a6936cc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1d3ddf63ee3618c9a5aaab1a6936cc0">registerAsyncParallelForPassPass</a> ()</td></tr>
<tr class="memitem:a2b376130b053ae00adc79a5f52ca02d8" id="r_a2b376130b053ae00adc79a5f52ca02d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b376130b053ae00adc79a5f52ca02d8">registerAsyncRuntimePolicyBasedRefCountingPass</a> ()</td></tr>
<tr class="memitem:ac6d3a8e5ccd3f0e27b3ba387c29611fd" id="r_ac6d3a8e5ccd3f0e27b3ba387c29611fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6d3a8e5ccd3f0e27b3ba387c29611fd">registerAsyncRuntimePolicyBasedRefCountingPassPass</a> ()</td></tr>
<tr class="memitem:adb233121127b80ee0ff5161e66109534" id="r_adb233121127b80ee0ff5161e66109534"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb233121127b80ee0ff5161e66109534">registerAsyncRuntimeRefCountingOptPass</a> ()</td></tr>
<tr class="memitem:a0e07030aeb20108e9f32ccaec9412b72" id="r_a0e07030aeb20108e9f32ccaec9412b72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e07030aeb20108e9f32ccaec9412b72">registerAsyncRuntimeRefCountingOptPassPass</a> ()</td></tr>
<tr class="memitem:a7c379f5f8bfe81a3d424d21fc7df4f9a" id="r_a7c379f5f8bfe81a3d424d21fc7df4f9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c379f5f8bfe81a3d424d21fc7df4f9a">registerAsyncRuntimeRefCountingPass</a> ()</td></tr>
<tr class="memitem:a556006007575eec098059c49e034868e" id="r_a556006007575eec098059c49e034868e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a556006007575eec098059c49e034868e">registerAsyncRuntimeRefCountingPassPass</a> ()</td></tr>
<tr class="memitem:a678e44574697efc8b44cfab3e652fa9f" id="r_a678e44574697efc8b44cfab3e652fa9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a678e44574697efc8b44cfab3e652fa9f">registerAsyncToAsyncRuntimePass</a> ()</td></tr>
<tr class="memitem:aad63c49be4f113258f12361844c561a4" id="r_aad63c49be4f113258f12361844c561a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad63c49be4f113258f12361844c561a4">registerAsyncToAsyncRuntimePassPass</a> ()</td></tr>
<tr class="memitem:a0666d844412191163d8cc46d4bc03ed8" id="r_a0666d844412191163d8cc46d4bc03ed8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0666d844412191163d8cc46d4bc03ed8">registerAsyncPasses</a> ()</td></tr>
<tr class="memitem:a48b87ab675233fa833a5d5b720635ee3" id="r_a48b87ab675233fa833a5d5b720635ee3"><td class="memTemplParams" colspan="2">template&lt;class AttrElementT, class ElementValueT = typename AttrElementT::ValueType, class PoisonAttr = ub::PoisonAttr, class ResultAttrElementT = AttrElementT, class ResultElementValueT = typename ResultAttrElementT::ValueType, class CalculationT = function_ref&lt;              std::optional&lt;ResultElementValueT&gt;(ElementValueT, ElementValueT)&gt;&gt; </td></tr>
<tr class="memitem:a48b87ab675233fa833a5d5b720635ee3 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48b87ab675233fa833a5d5b720635ee3">constFoldBinaryOpConditional</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, <a class="el" href="classmlir_1_1Type.html">Type</a> resultType, CalculationT &amp;&amp;calculate)</td></tr>
<tr class="memdesc:a48b87ab675233fa833a5d5b720635ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs constant folding <span class="tt">calculate</span> with element-wise behavior on the two attributes in <span class="tt">operands</span> and returns the result if possible.  <br /></td></tr>
<tr class="memitem:a4943ae31e8f9d07e1c3fcb5c7acd431b" id="r_a4943ae31e8f9d07e1c3fcb5c7acd431b"><td class="memTemplParams" colspan="2">template&lt;class AttrElementT, class ElementValueT = typename AttrElementT::ValueType, class PoisonAttr = ub::PoisonAttr, class ResultAttrElementT = AttrElementT, class ResultElementValueT = typename ResultAttrElementT::ValueType, class CalculationT = function_ref&lt;              std::optional&lt;ResultElementValueT&gt;(ElementValueT, ElementValueT)&gt;&gt; </td></tr>
<tr class="memitem:a4943ae31e8f9d07e1c3fcb5c7acd431b template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4943ae31e8f9d07e1c3fcb5c7acd431b">constFoldBinaryOpConditional</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, CalculationT &amp;&amp;calculate)</td></tr>
<tr class="memdesc:a4943ae31e8f9d07e1c3fcb5c7acd431b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs constant folding <span class="tt">calculate</span> with element-wise behavior on the two attributes in <span class="tt">operands</span> and returns the result if possible.  <br /></td></tr>
<tr class="memitem:a3fd9ce44116535930319e01412a23b2b" id="r_a3fd9ce44116535930319e01412a23b2b"><td class="memTemplParams" colspan="2">template&lt;class AttrElementT, class ElementValueT = typename AttrElementT::ValueType, class PoisonAttr = void, class ResultAttrElementT = AttrElementT, class ResultElementValueT = typename ResultAttrElementT::ValueType, class CalculationT = function_ref&lt;ResultElementValueT(ElementValueT, ElementValueT)&gt;&gt; </td></tr>
<tr class="memitem:a3fd9ce44116535930319e01412a23b2b template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fd9ce44116535930319e01412a23b2b">constFoldBinaryOp</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, <a class="el" href="classmlir_1_1Type.html">Type</a> resultType, CalculationT &amp;&amp;calculate)</td></tr>
<tr class="memitem:ae63b6955f772ddb5f5250d3b68f2f3d0" id="r_ae63b6955f772ddb5f5250d3b68f2f3d0"><td class="memTemplParams" colspan="2">template&lt;class AttrElementT, class ElementValueT = typename AttrElementT::ValueType, class PoisonAttr = ub::PoisonAttr, class ResultAttrElementT = AttrElementT, class ResultElementValueT = typename ResultAttrElementT::ValueType, class CalculationT = function_ref&lt;ResultElementValueT(ElementValueT, ElementValueT)&gt;&gt; </td></tr>
<tr class="memitem:ae63b6955f772ddb5f5250d3b68f2f3d0 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae63b6955f772ddb5f5250d3b68f2f3d0">constFoldBinaryOp</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, CalculationT &amp;&amp;calculate)</td></tr>
<tr class="memitem:a8b937ae50f6f106b6dc607e66d8f492c" id="r_a8b937ae50f6f106b6dc607e66d8f492c"><td class="memTemplParams" colspan="2">template&lt;class AttrElementT, class ElementValueT = typename AttrElementT::ValueType, class PoisonAttr = ub::PoisonAttr, class ResultAttrElementT = AttrElementT, class ResultElementValueT = typename ResultAttrElementT::ValueType, class CalculationT = function_ref&lt;std::optional&lt;ResultElementValueT&gt;(ElementValueT)&gt;&gt; </td></tr>
<tr class="memitem:a8b937ae50f6f106b6dc607e66d8f492c template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b937ae50f6f106b6dc607e66d8f492c">constFoldUnaryOpConditional</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, <a class="el" href="classmlir_1_1Type.html">Type</a> resultType, CalculationT &amp;&amp;calculate)</td></tr>
<tr class="memdesc:a8b937ae50f6f106b6dc607e66d8f492c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs constant folding <span class="tt">calculate</span> with element-wise behavior on the one attributes in <span class="tt">operands</span> and returns the result if possible.  <br /></td></tr>
<tr class="memitem:abe49ca1aa50f0d7946abfe265867bc43" id="r_abe49ca1aa50f0d7946abfe265867bc43"><td class="memTemplParams" colspan="2">template&lt;class AttrElementT, class ElementValueT = typename AttrElementT::ValueType, class PoisonAttr = ub::PoisonAttr, class ResultAttrElementT = AttrElementT, class ResultElementValueT = typename ResultAttrElementT::ValueType, class CalculationT = function_ref&lt;std::optional&lt;ResultElementValueT&gt;(ElementValueT)&gt;&gt; </td></tr>
<tr class="memitem:abe49ca1aa50f0d7946abfe265867bc43 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe49ca1aa50f0d7946abfe265867bc43">constFoldUnaryOpConditional</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, CalculationT &amp;&amp;calculate)</td></tr>
<tr class="memdesc:abe49ca1aa50f0d7946abfe265867bc43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs constant folding <span class="tt">calculate</span> with element-wise behavior on the one attributes in <span class="tt">operands</span> and returns the result if possible.  <br /></td></tr>
<tr class="memitem:ad687d33171f30e523f14be6c69555587" id="r_ad687d33171f30e523f14be6c69555587"><td class="memTemplParams" colspan="2">template&lt;class AttrElementT, class ElementValueT = typename AttrElementT::ValueType, class PoisonAttr = ub::PoisonAttr, class ResultAttrElementT = AttrElementT, class ResultElementValueT = typename ResultAttrElementT::ValueType, class CalculationT = function_ref&lt;ResultElementValueT(ElementValueT)&gt;&gt; </td></tr>
<tr class="memitem:ad687d33171f30e523f14be6c69555587 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad687d33171f30e523f14be6c69555587">constFoldUnaryOp</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, <a class="el" href="classmlir_1_1Type.html">Type</a> resultType, CalculationT &amp;&amp;calculate)</td></tr>
<tr class="memitem:a617f90c080cbc282bfc1263ad077070e" id="r_a617f90c080cbc282bfc1263ad077070e"><td class="memTemplParams" colspan="2">template&lt;class AttrElementT, class ElementValueT = typename AttrElementT::ValueType, class PoisonAttr = ub::PoisonAttr, class ResultAttrElementT = AttrElementT, class ResultElementValueT = typename ResultAttrElementT::ValueType, class CalculationT = function_ref&lt;ResultElementValueT(ElementValueT)&gt;&gt; </td></tr>
<tr class="memitem:a617f90c080cbc282bfc1263ad077070e template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a617f90c080cbc282bfc1263ad077070e">constFoldUnaryOp</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, CalculationT &amp;&amp;calculate)</td></tr>
<tr class="memitem:a2927f15718a47f9dfaa0090c2235e954" id="r_a2927f15718a47f9dfaa0090c2235e954"><td class="memTemplParams" colspan="2">template&lt;class AttrElementT, class TargetAttrElementT, class ElementValueT = typename AttrElementT::ValueType, class TargetElementValueT = typename TargetAttrElementT::ValueType, class PoisonAttr = ub::PoisonAttr, class CalculationT = function_ref&lt;TargetElementValueT(ElementValueT, bool)&gt;&gt; </td></tr>
<tr class="memitem:a2927f15718a47f9dfaa0090c2235e954 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2927f15718a47f9dfaa0090c2235e954">constFoldCastOp</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, <a class="el" href="classmlir_1_1Type.html">Type</a> resType, CalculationT &amp;&amp;calculate)</td></tr>
<tr class="memitem:a5f173d8afb5bfa9aca23651433c1c3a1" id="r_a5f173d8afb5bfa9aca23651433c1c3a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f173d8afb5bfa9aca23651433c1c3a1">populateEmitCSizeTTypeConversions</a> (<a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;converter)</td></tr>
<tr class="memitem:a48b2f65418c4fb28b0988f59d86dd3d3" id="r_a48b2f65418c4fb28b0988f59d86dd3d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48b2f65418c4fb28b0988f59d86dd3d3">populateCallOpTypeConversionPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a48b2f65418c4fb28b0988f59d86dd3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a pattern to the given pattern list to convert the operand and result types of a CallOp with the given type converter.  <br /></td></tr>
<tr class="memitem:a67ef267fd846574457641b3fc2ec2088" id="r_a67ef267fd846574457641b3fc2ec2088"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67ef267fd846574457641b3fc2ec2088">populateBranchOpInterfaceTypeConversionPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;converter, <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(BranchOpInterface branchOp, int idx)&gt; shouldConvertBranchOperand=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a67ef267fd846574457641b3fc2ec2088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a pattern to the given pattern list to rewrite branch operations to use operands that have been legalized by the conversion framework.  <br /></td></tr>
<tr class="memitem:af57575f33d64fcef5f5027164a59d87d" id="r_af57575f33d64fcef5f5027164a59d87d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af57575f33d64fcef5f5027164a59d87d">isLegalForBranchOpInterfaceTypeConversionPattern</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;converter)</td></tr>
<tr class="memdesc:af57575f33d64fcef5f5027164a59d87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if op is a BranchOpInterface op whose operands are all legal according to converter.  <br /></td></tr>
<tr class="memitem:a220ac6ca7c2aa2d95bfef6be6e813fc4" id="r_a220ac6ca7c2aa2d95bfef6be6e813fc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a220ac6ca7c2aa2d95bfef6be6e813fc4">populateReturnOpTypeConversionPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a220ac6ca7c2aa2d95bfef6be6e813fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a pattern to the given pattern list to rewrite <span class="tt">return</span> ops to use operands that have been legalized by the conversion framework.  <br /></td></tr>
<tr class="memitem:a0a4d325aad6186114a919156b25b29bc" id="r_a0a4d325aad6186114a919156b25b29bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a4d325aad6186114a919156b25b29bc">isLegalForReturnOpTypeConversionPattern</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;converter, <a class="el" href="classbool.html">bool</a> returnOpAlwaysLegal=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a0a4d325aad6186114a919156b25b29bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">For ReturnLike ops (except <span class="tt">return</span>), return True.  <br /></td></tr>
<tr class="memitem:a625259a35e521a9f6d7b7fe115423e87" id="r_a625259a35e521a9f6d7b7fe115423e87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a625259a35e521a9f6d7b7fe115423e87">isNotBranchOpInterfaceOrReturnLikeOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a625259a35e521a9f6d7b7fe115423e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if op is neither BranchOpInterface nor ReturnLike.  <br /></td></tr>
<tr class="memitem:a7173c36d6b113dcdb0599eb672526b43" id="r_a7173c36d6b113dcdb0599eb672526b43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7173c36d6b113dcdb0599eb672526b43">promoteToWorkgroupMemory</a> (gpu::GPUFuncOp op, <a class="el" href="classunsigned.html">unsigned</a> arg)</td></tr>
<tr class="memdesc:a7173c36d6b113dcdb0599eb672526b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes a function argument to workgroup memory in the given function.  <br /></td></tr>
<tr class="memitem:a501e9247e75ceaa26398973e8ba2ac50" id="r_a501e9247e75ceaa26398973e8ba2ac50"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a501e9247e75ceaa26398973e8ba2ac50">createGpuAsyncRegionPass</a> ()</td></tr>
<tr class="memitem:a8303d57a9212db2fcb7a96de8138b627" id="r_a8303d57a9212db2fcb7a96de8138b627"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8303d57a9212db2fcb7a96de8138b627">createGpuDecomposeMemrefsPass</a> ()</td></tr>
<tr class="memitem:a82921858a4c71b9795162bd2fe5fce82" id="r_a82921858a4c71b9795162bd2fe5fce82"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82921858a4c71b9795162bd2fe5fce82">createGpuEliminateBarriers</a> ()</td></tr>
<tr class="memitem:af89bf1dcbff14236cbbb02bf9ca6acd3" id="r_af89bf1dcbff14236cbbb02bf9ca6acd3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af89bf1dcbff14236cbbb02bf9ca6acd3">createGpuKernelOutliningPass</a> ()</td></tr>
<tr class="memitem:a283c0d12766f8664ad7c01a2f61a6c32" id="r_a283c0d12766f8664ad7c01a2f61a6c32"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a283c0d12766f8664ad7c01a2f61a6c32">createGpuKernelOutliningPass</a> (<a class="el" href="structmlir_1_1GpuKernelOutliningPassOptions.html">GpuKernelOutliningPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:af1068af4f216444681166b6fcf01c40f" id="r_af1068af4f216444681166b6fcf01c40f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1068af4f216444681166b6fcf01c40f">createGpuLaunchSinkIndexComputationsPass</a> ()</td></tr>
<tr class="memitem:a2a1ca46fd37bc796f482ab4620d95642" id="r_a2a1ca46fd37bc796f482ab4620d95642"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a1ca46fd37bc796f482ab4620d95642">createGpuMapParallelLoopsPass</a> ()</td></tr>
<tr class="memitem:ab4d005bd13585ac6ce5ec48e6d729c61" id="r_ab4d005bd13585ac6ce5ec48e6d729c61"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4d005bd13585ac6ce5ec48e6d729c61">createGpuMapParallelLoopsPass</a> (<a class="el" href="structmlir_1_1GpuMapParallelLoopsPassOptions.html">GpuMapParallelLoopsPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:abd46abfc961058869f991e26e19a622d" id="r_abd46abfc961058869f991e26e19a622d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd46abfc961058869f991e26e19a622d">createGpuModuleToBinaryPass</a> ()</td></tr>
<tr class="memitem:ac36d1b32d002fc1c91b34c4474596b21" id="r_ac36d1b32d002fc1c91b34c4474596b21"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac36d1b32d002fc1c91b34c4474596b21">createGpuModuleToBinaryPass</a> (<a class="el" href="structmlir_1_1GpuModuleToBinaryPassOptions.html">GpuModuleToBinaryPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a659763d266f0cb16406ad2faba74c158" id="r_a659763d266f0cb16406ad2faba74c158"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a659763d266f0cb16406ad2faba74c158">createGpuNVVMAttachTarget</a> ()</td></tr>
<tr class="memitem:a08c2b400d025a2d8f1757f4b23c05fcc" id="r_a08c2b400d025a2d8f1757f4b23c05fcc"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08c2b400d025a2d8f1757f4b23c05fcc">createGpuNVVMAttachTarget</a> (<a class="el" href="structmlir_1_1GpuNVVMAttachTargetOptions.html">GpuNVVMAttachTargetOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a846a0d18cb1e8e4ee88a39a73c411ef3" id="r_a846a0d18cb1e8e4ee88a39a73c411ef3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a846a0d18cb1e8e4ee88a39a73c411ef3">createGpuROCDLAttachTarget</a> ()</td></tr>
<tr class="memitem:a043a0b34b5ba663cc71af65273744891" id="r_a043a0b34b5ba663cc71af65273744891"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a043a0b34b5ba663cc71af65273744891">createGpuROCDLAttachTarget</a> (<a class="el" href="structmlir_1_1GpuROCDLAttachTargetOptions.html">GpuROCDLAttachTargetOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a0904453d137ead66dfc9532afc1c5643" id="r_a0904453d137ead66dfc9532afc1c5643"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0904453d137ead66dfc9532afc1c5643">createGpuSPIRVAttachTarget</a> ()</td></tr>
<tr class="memitem:abac4fa2e5d211942a4b1e2c841dff92a" id="r_abac4fa2e5d211942a4b1e2c841dff92a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abac4fa2e5d211942a4b1e2c841dff92a">createGpuSPIRVAttachTarget</a> (<a class="el" href="structmlir_1_1GpuSPIRVAttachTargetOptions.html">GpuSPIRVAttachTargetOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a7f8af4ad927ba4ff2e1263c27b4042f7" id="r_a7f8af4ad927ba4ff2e1263c27b4042f7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f8af4ad927ba4ff2e1263c27b4042f7">createGpuXeVMAttachTarget</a> ()</td></tr>
<tr class="memitem:af7f37c09444f9e376c704cf103b665ea" id="r_af7f37c09444f9e376c704cf103b665ea"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7f37c09444f9e376c704cf103b665ea">createGpuXeVMAttachTarget</a> (<a class="el" href="structmlir_1_1GpuXeVMAttachTargetOptions.html">GpuXeVMAttachTargetOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a352a5fec8fc09705220c6ed268d15709" id="r_a352a5fec8fc09705220c6ed268d15709"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a352a5fec8fc09705220c6ed268d15709">populateGpuGlobalIdPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a352a5fec8fc09705220c6ed268d15709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to rewrite GlobalIdOp op within the GPU dialect.  <br /></td></tr>
<tr class="memitem:adb3fb4d0bde3373634983b148f0b0c03" id="r_adb3fb4d0bde3373634983b148f0b0c03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb3fb4d0bde3373634983b148f0b0c03">populateGpuSubgroupIdPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:adb3fb4d0bde3373634983b148f0b0c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to rewrite SubgroupIdOp op within the GPU dialect.  <br /></td></tr>
<tr class="memitem:a1cdef2da7628821e92464510d6556332" id="r_a1cdef2da7628821e92464510d6556332"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1cdef2da7628821e92464510d6556332">populateGpuShufflePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a1cdef2da7628821e92464510d6556332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to rewrite shuffle ops within the GPU dialect.  <br /></td></tr>
<tr class="memitem:a9701a7692a76e65edd69bd6f22156776" id="r_a9701a7692a76e65edd69bd6f22156776"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9701a7692a76e65edd69bd6f22156776">populateGpuAllReducePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a9701a7692a76e65edd69bd6f22156776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to rewrite all-reduce ops within the GPU dialect.  <br /></td></tr>
<tr class="memitem:ab57dcf9ca48416677b4f10118916da61" id="r_ab57dcf9ca48416677b4f10118916da61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab57dcf9ca48416677b4f10118916da61">populateGpuBreakDownSubgroupReducePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classunsigned.html">unsigned</a> maxShuffleBitwidth=32, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:ab57dcf9ca48416677b4f10118916da61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to break down subgroup_reduce ops into smaller ones supported by the target of <span class="tt">size &lt;= maxShuffleBitwidth</span>, where <span class="tt">size</span> is the subgroup_reduce value bitwidth.  <br /></td></tr>
<tr class="memitem:a6c34168191ab5b4336dd5a832eab08e0" id="r_a6c34168191ab5b4336dd5a832eab08e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c34168191ab5b4336dd5a832eab08e0">populateGpuLowerSubgroupReduceToShufflePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classunsigned.html">unsigned</a> subgroupSize, <a class="el" href="classunsigned.html">unsigned</a> shuffleBitwidth=32, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a6c34168191ab5b4336dd5a832eab08e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to lower <span class="tt">gpu.subgroup_reduce</span> into <span class="tt">gpu.shuffle</span> ops over <span class="tt">shuffleBitwidth</span> scalar types.  <br /></td></tr>
<tr class="memitem:a7feacef2681f1cb159920f8a6ed188ad" id="r_a7feacef2681f1cb159920f8a6ed188ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7feacef2681f1cb159920f8a6ed188ad">populateGpuLowerClusteredSubgroupReduceToShufflePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classunsigned.html">unsigned</a> subgroupSize, <a class="el" href="classunsigned.html">unsigned</a> shuffleBitwidth=32, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a7feacef2681f1cb159920f8a6ed188ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disjoint counterpart of <span class="tt">populateGpuLowerSubgroupReduceToShufflePatterns</span> that only matches <span class="tt">gpu.subgroup_reduce</span> ops with a <span class="tt">cluster_size</span>.  <br /></td></tr>
<tr class="memitem:acfaf756739b50fa93f64e888ebd9af60" id="r_acfaf756739b50fa93f64e888ebd9af60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfaf756739b50fa93f64e888ebd9af60">populateGpuLowerSubgroupReduceToDPPPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classunsigned.html">unsigned</a> subgroupSize, <a class="el" href="structmlir_1_1amdgpu_1_1Chipset.html">amdgpu::Chipset</a> chipset, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:acfaf756739b50fa93f64e888ebd9af60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to lower <span class="tt">gpu.subgroup_reduce</span> into <span class="tt">amdgpu.dpp</span> ops over scalar types.  <br /></td></tr>
<tr class="memitem:afe98d13c529561423b0a00d4cbe7cdb1" id="r_afe98d13c529561423b0a00d4cbe7cdb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe98d13c529561423b0a00d4cbe7cdb1">populateGpuLowerClusteredSubgroupReduceToDPPPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classunsigned.html">unsigned</a> subgroupSize, <a class="el" href="structmlir_1_1amdgpu_1_1Chipset.html">amdgpu::Chipset</a> chipset, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:afe98d13c529561423b0a00d4cbe7cdb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disjoint counterpart of <span class="tt">populateGpuLowerSubgroupReduceToDPPPatterns</span> that only matches <span class="tt">gpu.subgroup_reduce</span> ops with a <span class="tt">cluster_size</span>.  <br /></td></tr>
<tr class="memitem:a4ae1d309360c9e54edaa39ddb48d3ea1" id="r_a4ae1d309360c9e54edaa39ddb48d3ea1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ae1d309360c9e54edaa39ddb48d3ea1">populateGpuRewritePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a4ae1d309360c9e54edaa39ddb48d3ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect all patterns to rewrite ops within the GPU dialect.  <br /></td></tr>
<tr class="memitem:ac0ea23f9a62b16d2214c2e70f282c5c1" id="r_ac0ea23f9a62b16d2214c2e70f282c5c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0ea23f9a62b16d2214c2e70f282c5c1">populateGpuDecomposeMemrefsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:ac0ea23f9a62b16d2214c2e70f282c5c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to decompose memrefs ops.  <br /></td></tr>
<tr class="memitem:af5eff4e5da432d2edf4f655585785460" id="r_af5eff4e5da432d2edf4f655585785460"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5eff4e5da432d2edf4f655585785460">populateGpuEliminateBarriersPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:af5eff4e5da432d2edf4f655585785460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase barriers that do not enforce conflicting memory side effects.  <br /></td></tr>
<tr class="memitem:ab7e92953bee29d6688ad7e9dd8747285" id="r_ab7e92953bee29d6688ad7e9dd8747285"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7e92953bee29d6688ad7e9dd8747285">populateGpuPromoteShuffleToAMDGPUPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, std::optional&lt; <a class="el" href="structmlir_1_1amdgpu_1_1Chipset.html">amdgpu::Chipset</a> &gt; maybeChipset)</td></tr>
<tr class="memdesc:ab7e92953bee29d6688ad7e9dd8747285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to promote <span class="tt">gpu.shuffle</span>s to specialized AMDGPU intrinsics.  <br /></td></tr>
<tr class="memitem:a482927531fc314e46ea82a0995e591d9" id="r_a482927531fc314e46ea82a0995e591d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a482927531fc314e46ea82a0995e591d9">registerGpuAsyncRegionPass</a> ()</td></tr>
<tr class="memitem:ac99755f363de6354507292d522f05df2" id="r_ac99755f363de6354507292d522f05df2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac99755f363de6354507292d522f05df2">registerGpuAsyncRegionPassPass</a> ()</td></tr>
<tr class="memitem:a16f33fdfc11d308ce88089af2bd93e9c" id="r_a16f33fdfc11d308ce88089af2bd93e9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16f33fdfc11d308ce88089af2bd93e9c">registerGpuDecomposeMemrefsPass</a> ()</td></tr>
<tr class="memitem:ad03c9fed42a4f5fcba64f13341f1ae89" id="r_ad03c9fed42a4f5fcba64f13341f1ae89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad03c9fed42a4f5fcba64f13341f1ae89">registerGpuDecomposeMemrefsPassPass</a> ()</td></tr>
<tr class="memitem:a2c285e555d33e8843aae7400a0747b9b" id="r_a2c285e555d33e8843aae7400a0747b9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c285e555d33e8843aae7400a0747b9b">registerGpuEliminateBarriers</a> ()</td></tr>
<tr class="memitem:a8915467bc4639915023534a752c34cb7" id="r_a8915467bc4639915023534a752c34cb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8915467bc4639915023534a752c34cb7">registerGpuEliminateBarriersPass</a> ()</td></tr>
<tr class="memitem:a304d86139344d8dedf0c16cfdf5dcc18" id="r_a304d86139344d8dedf0c16cfdf5dcc18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a304d86139344d8dedf0c16cfdf5dcc18">registerGpuKernelOutliningPass</a> ()</td></tr>
<tr class="memitem:a7729d63449e862160d350a8d3ab12716" id="r_a7729d63449e862160d350a8d3ab12716"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7729d63449e862160d350a8d3ab12716">registerGpuKernelOutliningPassPass</a> ()</td></tr>
<tr class="memitem:aed772ebc7afaa2193f2336067fee0415" id="r_aed772ebc7afaa2193f2336067fee0415"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed772ebc7afaa2193f2336067fee0415">registerGpuLaunchSinkIndexComputationsPass</a> ()</td></tr>
<tr class="memitem:aa4e95e8bb42d67237fae5acc09d388ac" id="r_aa4e95e8bb42d67237fae5acc09d388ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4e95e8bb42d67237fae5acc09d388ac">registerGpuLaunchSinkIndexComputationsPassPass</a> ()</td></tr>
<tr class="memitem:a8a5ec1968667f1574cd8a2fa7d86b79b" id="r_a8a5ec1968667f1574cd8a2fa7d86b79b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a5ec1968667f1574cd8a2fa7d86b79b">registerGpuMapParallelLoopsPass</a> ()</td></tr>
<tr class="memitem:a04f863369b96423c61ec7f41586f668a" id="r_a04f863369b96423c61ec7f41586f668a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04f863369b96423c61ec7f41586f668a">registerGpuMapParallelLoopsPassPass</a> ()</td></tr>
<tr class="memitem:a0b19ceddc988456a302369257ba57c3d" id="r_a0b19ceddc988456a302369257ba57c3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b19ceddc988456a302369257ba57c3d">registerGpuModuleToBinaryPass</a> ()</td></tr>
<tr class="memitem:a4544cabd9b2f8547127605809ebb9823" id="r_a4544cabd9b2f8547127605809ebb9823"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4544cabd9b2f8547127605809ebb9823">registerGpuModuleToBinaryPassPass</a> ()</td></tr>
<tr class="memitem:a5987c6bcba9d38f84fce0f19e887a8c5" id="r_a5987c6bcba9d38f84fce0f19e887a8c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5987c6bcba9d38f84fce0f19e887a8c5">registerGpuNVVMAttachTarget</a> ()</td></tr>
<tr class="memitem:a823a18a1f0d69fb1ad5cdaf5864112a6" id="r_a823a18a1f0d69fb1ad5cdaf5864112a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a823a18a1f0d69fb1ad5cdaf5864112a6">registerGpuNVVMAttachTargetPass</a> ()</td></tr>
<tr class="memitem:aad75af260d41e616f135340c2d031ed3" id="r_aad75af260d41e616f135340c2d031ed3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad75af260d41e616f135340c2d031ed3">registerGpuROCDLAttachTarget</a> ()</td></tr>
<tr class="memitem:a82b8b81fdf610ab5205b6e6bb3daf985" id="r_a82b8b81fdf610ab5205b6e6bb3daf985"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82b8b81fdf610ab5205b6e6bb3daf985">registerGpuROCDLAttachTargetPass</a> ()</td></tr>
<tr class="memitem:ac88b5bda540cbc2446a1fa4d66f8b6ba" id="r_ac88b5bda540cbc2446a1fa4d66f8b6ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac88b5bda540cbc2446a1fa4d66f8b6ba">registerGpuSPIRVAttachTarget</a> ()</td></tr>
<tr class="memitem:af61ecc4bec0daa2c13fea2995f0c8b23" id="r_af61ecc4bec0daa2c13fea2995f0c8b23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af61ecc4bec0daa2c13fea2995f0c8b23">registerGpuSPIRVAttachTargetPass</a> ()</td></tr>
<tr class="memitem:a193c8e12180e01ad4e347345eb68b6e4" id="r_a193c8e12180e01ad4e347345eb68b6e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a193c8e12180e01ad4e347345eb68b6e4">registerGpuXeVMAttachTarget</a> ()</td></tr>
<tr class="memitem:abc28af19978d5cd9c2940fa3708086c2" id="r_abc28af19978d5cd9c2940fa3708086c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc28af19978d5cd9c2940fa3708086c2">registerGpuXeVMAttachTargetPass</a> ()</td></tr>
<tr class="memitem:abdd28096ad54d3c4c633162adf520ad8" id="r_abdd28096ad54d3c4c633162adf520ad8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abdd28096ad54d3c4c633162adf520ad8">registerGPUPasses</a> ()</td></tr>
<tr class="memitem:ae9152a09d079148a1a2f40d4946f7c17" id="r_ae9152a09d079148a1a2f40d4946f7c17"><td class="memItemLeft" align="right" valign="top">gpu::GPUFuncOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9152a09d079148a1a2f40d4946f7c17">outlineKernelFunc</a> (gpu::LaunchOp launchOp, StringRef kernelFnName, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;operands)</td></tr>
<tr class="memdesc:ae9152a09d079148a1a2f40d4946f7c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a gpu.func created from outlining the region of a gpu.launch op with the given <span class="tt">kernelFnName</span>.  <br /></td></tr>
<tr class="memitem:aa6e007ae66428f560626d4ba3c58dfe2" id="r_aa6e007ae66428f560626d4ba3c58dfe2"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6e007ae66428f560626d4ba3c58dfe2">sinkOperationsIntoLaunchOp</a> (gpu::LaunchOp launchOp, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; isSinkingBeneficiary)</td></tr>
<tr class="memdesc:aa6e007ae66428f560626d4ba3c58dfe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sink operations into the <span class="tt">launchOp</span> to reduce the number of values that are used within the region of the operation, but defined outside of the region.  <br /></td></tr>
<tr class="memitem:a87bf9d304f6607cd11c69e7b49340c44" id="r_a87bf9d304f6607cd11c69e7b49340c44"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87bf9d304f6607cd11c69e7b49340c44">createConvertElementwiseToLinalgPass</a> ()</td></tr>
<tr class="memitem:aa3fa0f0614b756066964736719ed3209" id="r_aa3fa0f0614b756066964736719ed3209"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3fa0f0614b756066964736719ed3209">createConvertLinalgToAffineLoopsPass</a> ()</td></tr>
<tr class="memitem:aea3a07f65a47ca64033c943bd31687e5" id="r_aea3a07f65a47ca64033c943bd31687e5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea3a07f65a47ca64033c943bd31687e5">createConvertLinalgToLoopsPass</a> ()</td></tr>
<tr class="memitem:ae26b9d40f9bde7098b22814ca7bf9fc9" id="r_ae26b9d40f9bde7098b22814ca7bf9fc9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae26b9d40f9bde7098b22814ca7bf9fc9">createConvertLinalgToParallelLoopsPass</a> ()</td></tr>
<tr class="memitem:ad2b5e1e5d3d9050938167540a8e15b86" id="r_ad2b5e1e5d3d9050938167540a8e15b86"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2b5e1e5d3d9050938167540a8e15b86">createLinalgBlockPackMatmul</a> ()</td></tr>
<tr class="memitem:a9aefb54fcfdb352c964103b342389226" id="r_a9aefb54fcfdb352c964103b342389226"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9aefb54fcfdb352c964103b342389226">createLinalgBlockPackMatmul</a> (<a class="el" href="structmlir_1_1LinalgBlockPackMatmulOptions.html">LinalgBlockPackMatmulOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:ad39c9d48e1d88cd29793051b0e77f332" id="r_ad39c9d48e1d88cd29793051b0e77f332"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad39c9d48e1d88cd29793051b0e77f332">createLinalgDetensorizePass</a> ()</td></tr>
<tr class="memitem:a7914ade3a6157a066379b2c5e5a40fa8" id="r_a7914ade3a6157a066379b2c5e5a40fa8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7914ade3a6157a066379b2c5e5a40fa8">createLinalgDetensorizePass</a> (<a class="el" href="structmlir_1_1LinalgDetensorizePassOptions.html">LinalgDetensorizePassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a736979a5a4ca50383d3cde235bd30d6b" id="r_a736979a5a4ca50383d3cde235bd30d6b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a736979a5a4ca50383d3cde235bd30d6b">createLinalgElementwiseOpFusionPass</a> ()</td></tr>
<tr class="memitem:a6a817e4caaf87f1eba1ac390cba4194c" id="r_a6a817e4caaf87f1eba1ac390cba4194c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a817e4caaf87f1eba1ac390cba4194c">createLinalgFoldIntoElementwisePass</a> ()</td></tr>
<tr class="memitem:a8cf37093e30cc4df97e31c368130dcb9" id="r_a8cf37093e30cc4df97e31c368130dcb9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cf37093e30cc4df97e31c368130dcb9">createLinalgFoldUnitExtentDimsPass</a> ()</td></tr>
<tr class="memitem:a8823373c20a1362001318f3ae888db4c" id="r_a8823373c20a1362001318f3ae888db4c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8823373c20a1362001318f3ae888db4c">createLinalgFoldUnitExtentDimsPass</a> (<a class="el" href="structmlir_1_1LinalgFoldUnitExtentDimsPassOptions.html">LinalgFoldUnitExtentDimsPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a9ba4519efdc52e99dd87577a5e69cc30" id="r_a9ba4519efdc52e99dd87577a5e69cc30"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ba4519efdc52e99dd87577a5e69cc30">createLinalgGeneralizeNamedOpsPass</a> ()</td></tr>
<tr class="memitem:a959c568ee9ce0287a2b1f9faf7e838e8" id="r_a959c568ee9ce0287a2b1f9faf7e838e8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a959c568ee9ce0287a2b1f9faf7e838e8">createLinalgInlineScalarOperandsPass</a> ()</td></tr>
<tr class="memitem:a2554cb9a09cbf183334c4189d83762d1" id="r_a2554cb9a09cbf183334c4189d83762d1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2554cb9a09cbf183334c4189d83762d1">createLinalgMorphOpsPass</a> ()</td></tr>
<tr class="memitem:a23775595aa7aed4b62df6d1bc09c968f" id="r_a23775595aa7aed4b62df6d1bc09c968f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23775595aa7aed4b62df6d1bc09c968f">createLinalgMorphOpsPass</a> (<a class="el" href="structmlir_1_1LinalgMorphOpsPassOptions.html">LinalgMorphOpsPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a16a9896bf6e005f7b001530d3e32877c" id="r_a16a9896bf6e005f7b001530d3e32877c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16a9896bf6e005f7b001530d3e32877c">createLinalgSpecializeGenericOpsPass</a> ()</td></tr>
<tr class="memitem:ae999b87c3439f4e65c006ba97b7c5be4" id="r_ae999b87c3439f4e65c006ba97b7c5be4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae999b87c3439f4e65c006ba97b7c5be4">createSimplifyDepthwiseConvPass</a> ()</td></tr>
<tr class="memitem:a97ecdf9aebf503bb814a4c402d257ea6" id="r_a97ecdf9aebf503bb814a4c402d257ea6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97ecdf9aebf503bb814a4c402d257ea6">registerConvertElementwiseToLinalgPass</a> ()</td></tr>
<tr class="memitem:a23d118708262be53a1bec2e9ccda12b0" id="r_a23d118708262be53a1bec2e9ccda12b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23d118708262be53a1bec2e9ccda12b0">registerConvertElementwiseToLinalgPassPass</a> ()</td></tr>
<tr class="memitem:a0ec8c63c654693a9daafe4a341ce548b" id="r_a0ec8c63c654693a9daafe4a341ce548b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ec8c63c654693a9daafe4a341ce548b">registerConvertLinalgToAffineLoopsPass</a> ()</td></tr>
<tr class="memitem:a9f03c52c2be59f6f5fcf26c539069b81" id="r_a9f03c52c2be59f6f5fcf26c539069b81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f03c52c2be59f6f5fcf26c539069b81">registerConvertLinalgToAffineLoopsPassPass</a> ()</td></tr>
<tr class="memitem:a91d33006e35cfa953c7e7123793b72be" id="r_a91d33006e35cfa953c7e7123793b72be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91d33006e35cfa953c7e7123793b72be">registerConvertLinalgToLoopsPass</a> ()</td></tr>
<tr class="memitem:a73cb428ff8c212129980c83896330a76" id="r_a73cb428ff8c212129980c83896330a76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73cb428ff8c212129980c83896330a76">registerConvertLinalgToLoopsPassPass</a> ()</td></tr>
<tr class="memitem:a51a508b14163f40cf7650f0a54343c27" id="r_a51a508b14163f40cf7650f0a54343c27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51a508b14163f40cf7650f0a54343c27">registerConvertLinalgToParallelLoopsPass</a> ()</td></tr>
<tr class="memitem:a1b97ac8485f9fedb81cb3ce69021bc6d" id="r_a1b97ac8485f9fedb81cb3ce69021bc6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b97ac8485f9fedb81cb3ce69021bc6d">registerConvertLinalgToParallelLoopsPassPass</a> ()</td></tr>
<tr class="memitem:ab2a6d985c6e6121d569de20c3f7f89fc" id="r_ab2a6d985c6e6121d569de20c3f7f89fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2a6d985c6e6121d569de20c3f7f89fc">registerLinalgBlockPackMatmul</a> ()</td></tr>
<tr class="memitem:a80caeaacf364ddb81175f9b41c734a52" id="r_a80caeaacf364ddb81175f9b41c734a52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80caeaacf364ddb81175f9b41c734a52">registerLinalgBlockPackMatmulPass</a> ()</td></tr>
<tr class="memitem:ace41cb97a366d7f4de2c0c6dceb008d9" id="r_ace41cb97a366d7f4de2c0c6dceb008d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace41cb97a366d7f4de2c0c6dceb008d9">registerLinalgDetensorizePass</a> ()</td></tr>
<tr class="memitem:a3227af85b7538bdc32b1f189516329aa" id="r_a3227af85b7538bdc32b1f189516329aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3227af85b7538bdc32b1f189516329aa">registerLinalgDetensorizePassPass</a> ()</td></tr>
<tr class="memitem:a22d5f4384436d0ed58c2616c8644f80c" id="r_a22d5f4384436d0ed58c2616c8644f80c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22d5f4384436d0ed58c2616c8644f80c">registerLinalgElementwiseOpFusionPass</a> ()</td></tr>
<tr class="memitem:a2ac81842f2d678dd5f2d8dc1cb0f2335" id="r_a2ac81842f2d678dd5f2d8dc1cb0f2335"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ac81842f2d678dd5f2d8dc1cb0f2335">registerLinalgElementwiseOpFusionPassPass</a> ()</td></tr>
<tr class="memitem:aec7445c96c74f7cd2a9b0fe0eb2ea613" id="r_aec7445c96c74f7cd2a9b0fe0eb2ea613"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec7445c96c74f7cd2a9b0fe0eb2ea613">registerLinalgFoldIntoElementwisePass</a> ()</td></tr>
<tr class="memitem:afd70d5d6fd3823339e25c998c946db19" id="r_afd70d5d6fd3823339e25c998c946db19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd70d5d6fd3823339e25c998c946db19">registerLinalgFoldIntoElementwisePassPass</a> ()</td></tr>
<tr class="memitem:afb6ca7f9b45dac2ffe55c3e633ac6f23" id="r_afb6ca7f9b45dac2ffe55c3e633ac6f23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb6ca7f9b45dac2ffe55c3e633ac6f23">registerLinalgFoldUnitExtentDimsPass</a> ()</td></tr>
<tr class="memitem:aaaf4d991808c11a4b36a35d22c6864e9" id="r_aaaf4d991808c11a4b36a35d22c6864e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaaf4d991808c11a4b36a35d22c6864e9">registerLinalgFoldUnitExtentDimsPassPass</a> ()</td></tr>
<tr class="memitem:a6d684b2bc847459cc887fd45418e9670" id="r_a6d684b2bc847459cc887fd45418e9670"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d684b2bc847459cc887fd45418e9670">registerLinalgGeneralizeNamedOpsPass</a> ()</td></tr>
<tr class="memitem:a8526ed0dd37d3b6bec1a1d1f554204c8" id="r_a8526ed0dd37d3b6bec1a1d1f554204c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8526ed0dd37d3b6bec1a1d1f554204c8">registerLinalgGeneralizeNamedOpsPassPass</a> ()</td></tr>
<tr class="memitem:ae6b9637d5622bd12afabebe269c6bd6c" id="r_ae6b9637d5622bd12afabebe269c6bd6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6b9637d5622bd12afabebe269c6bd6c">registerLinalgInlineScalarOperandsPass</a> ()</td></tr>
<tr class="memitem:a044e0005438657e2a0a4bba23095e562" id="r_a044e0005438657e2a0a4bba23095e562"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a044e0005438657e2a0a4bba23095e562">registerLinalgInlineScalarOperandsPassPass</a> ()</td></tr>
<tr class="memitem:af5543a4a7fd631d5b0c34b0e48590dd3" id="r_af5543a4a7fd631d5b0c34b0e48590dd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5543a4a7fd631d5b0c34b0e48590dd3">registerLinalgMorphOpsPass</a> ()</td></tr>
<tr class="memitem:a97ce6ecdd3b66ce9cee9b535a05a3eaa" id="r_a97ce6ecdd3b66ce9cee9b535a05a3eaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97ce6ecdd3b66ce9cee9b535a05a3eaa">registerLinalgMorphOpsPassPass</a> ()</td></tr>
<tr class="memitem:a7dcdce489d744f45d02d14a11d6dab99" id="r_a7dcdce489d744f45d02d14a11d6dab99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7dcdce489d744f45d02d14a11d6dab99">registerLinalgSpecializeGenericOpsPass</a> ()</td></tr>
<tr class="memitem:a2a6f7835f99ed42c76b61b3302c0aad9" id="r_a2a6f7835f99ed42c76b61b3302c0aad9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a6f7835f99ed42c76b61b3302c0aad9">registerLinalgSpecializeGenericOpsPassPass</a> ()</td></tr>
<tr class="memitem:a2fe7d936e0bd6b4954e0222c7dcc5f38" id="r_a2fe7d936e0bd6b4954e0222c7dcc5f38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fe7d936e0bd6b4954e0222c7dcc5f38">registerSimplifyDepthwiseConvPass</a> ()</td></tr>
<tr class="memitem:a0e98d77e4a33c454d1c4c75857efa3a5" id="r_a0e98d77e4a33c454d1c4c75857efa3a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e98d77e4a33c454d1c4c75857efa3a5">registerSimplifyDepthwiseConvPassPass</a> ()</td></tr>
<tr class="memitem:a5be854529eae74333823d129362ee47c" id="r_a5be854529eae74333823d129362ee47c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5be854529eae74333823d129362ee47c">registerLinalgPasses</a> ()</td></tr>
<tr class="memitem:a774412201bb8ce6277dff9e9a73c8f68" id="r_a774412201bb8ce6277dff9e9a73c8f68"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a774412201bb8ce6277dff9e9a73c8f68">parseSemiFunctionType</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="classmlir_1_1Type.html">Type</a> &amp;argumentType, <a class="el" href="classmlir_1_1Type.html">Type</a> &amp;resultType, <a class="el" href="classbool.html">bool</a> resultOptional=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:a774412201bb8ce6277dff9e9a73c8f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a single non-function type or a function type with at least one argument.  <br /></td></tr>
<tr class="memitem:a3ee9c22e4e76e3de2f4c6da9783145a4" id="r_a3ee9c22e4e76e3de2f4c6da9783145a4"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ee9c22e4e76e3de2f4c6da9783145a4">parseSemiFunctionType</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="classmlir_1_1Type.html">Type</a> &amp;argumentType, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;resultTypes)</td></tr>
<tr class="memitem:a979423818fdead0e008345256a1e2d10" id="r_a979423818fdead0e008345256a1e2d10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a979423818fdead0e008345256a1e2d10">printSemiFunctionType</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;printer, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Type.html">Type</a> argumentType, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> resultType)</td></tr>
<tr class="memdesc:a979423818fdead0e008345256a1e2d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints argument and result types in a syntax similar to that of FunctionType but allowing and requiring one to omit the parens around the argument type in absence of result types, and without the trailing <span class="tt">-&gt; ()</span>.  <br /></td></tr>
<tr class="memitem:a89e64306db27cef578b1ba608d3d8565" id="r_a89e64306db27cef578b1ba608d3d8565"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89e64306db27cef578b1ba608d3d8565">printSemiFunctionType</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;printer, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Type.html">Type</a> argumentType, <a class="el" href="classmlir_1_1Type.html">Type</a> resultType, <a class="el" href="classbool.html">bool</a> resultOptional=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memitem:a747b91bacc09bde115c3e891deb5ebe5" id="r_a747b91bacc09bde115c3e891deb5ebe5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a747b91bacc09bde115c3e891deb5ebe5">populateMathAlgebraicSimplificationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memitem:a350315b238bcca2eb1b91364e55deaf4" id="r_a350315b238bcca2eb1b91364e55deaf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a350315b238bcca2eb1b91364e55deaf4">populatePolynomialApproximateTanhPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memitem:a3114521ec355e66601d128ab0cb9426f" id="r_a3114521ec355e66601d128ab0cb9426f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3114521ec355e66601d128ab0cb9426f">populatePolynomialApproximateErfPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memitem:a0f51bdb2fcf79501ba4d3d7840fcd756" id="r_a0f51bdb2fcf79501ba4d3d7840fcd756"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f51bdb2fcf79501ba4d3d7840fcd756">populatePolynomialApproximateErfcPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memitem:a2d9cd55affd07926cd68087af95206ba" id="r_a2d9cd55affd07926cd68087af95206ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d9cd55affd07926cd68087af95206ba">populateMathF32ExpansionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(StringRef)&gt; predicate, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>=1)</td></tr>
<tr class="memitem:afda27c3980d49d43e0256cc87d3d3b69" id="r_afda27c3980d49d43e0256cc87d3d3b69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afda27c3980d49d43e0256cc87d3d3b69">populateMathPolynomialApproximationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(StringRef)&gt; predicate, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>=1)</td></tr>
<tr class="memitem:ada84ecb306c38b4e2a547962acc98dfd" id="r_ada84ecb306c38b4e2a547962acc98dfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada84ecb306c38b4e2a547962acc98dfd">populateMathPolynomialApproximationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="structmlir_1_1MathPolynomialApproximationOptions.html">MathPolynomialApproximationOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>={})</td></tr>
<tr class="memitem:a54519be832df231094e4e22a067bde19" id="r_a54519be832df231094e4e22a067bde19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54519be832df231094e4e22a067bde19">populateUpliftToFMAPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memitem:ac7e879c874e4fdc6aaf9d4742abdb876" id="r_ac7e879c874e4fdc6aaf9d4742abdb876"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7e879c874e4fdc6aaf9d4742abdb876">operator&lt;&lt;</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, const <a class="el" href="structmlir_1_1Range.html">Range</a> &amp;range)</td></tr>
<tr class="memitem:a45e134959101de052e7dbfd12610b5d6" id="r_a45e134959101de052e7dbfd12610b5d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a>, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45e134959101de052e7dbfd12610b5d6">getOrCreateRanges</a> (OffsetSizeAndStrideOpInterface op, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a45e134959101de052e7dbfd12610b5d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of <a class="el" href="structmlir_1_1Range.html" title="Represents a range (offset, size, and stride) where each element of the triple may be dynamic or stat...">Range</a> (i.e.  <br /></td></tr>
<tr class="memitem:abd6614781b90ba9975948b3f328c4e69" id="r_abd6614781b90ba9975948b3f328c4e69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd6614781b90ba9975948b3f328c4e69">registerOptimizeSharedMemory</a> ()</td></tr>
<tr class="memitem:abc4ef7056aeaff3add219604c60fbaff" id="r_abc4ef7056aeaff3add219604c60fbaff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc4ef7056aeaff3add219604c60fbaff">registerOptimizeSharedMemoryPass</a> ()</td></tr>
<tr class="memitem:af1579c7894e37d07a13ecee146c11684" id="r_af1579c7894e37d07a13ecee146c11684"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1579c7894e37d07a13ecee146c11684">registerNVGPUPasses</a> ()</td></tr>
<tr class="memitem:a1d49e4ae28aeaaa552466850cc5e04ec" id="r_a1d49e4ae28aeaaa552466850cc5e04ec"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d49e4ae28aeaaa552466850cc5e04ec">createForLoopSpecializationPass</a> ()</td></tr>
<tr class="memdesc:a1d49e4ae28aeaaa552466850cc5e04ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that specializes for loop for unrolling and vectorization.  <br /></td></tr>
<tr class="memitem:a7acfeadb8fff74a53be77ccf540be99b" id="r_a7acfeadb8fff74a53be77ccf540be99b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7acfeadb8fff74a53be77ccf540be99b">createForLoopPeelingPass</a> ()</td></tr>
<tr class="memdesc:a7acfeadb8fff74a53be77ccf540be99b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that peels for loops at their upper bounds for better vectorization.  <br /></td></tr>
<tr class="memitem:ac7f8ebf7a2133d1c68cea6e20fba0ea8" id="r_ac7f8ebf7a2133d1c68cea6e20fba0ea8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7f8ebf7a2133d1c68cea6e20fba0ea8">createSCFForLoopCanonicalizationPass</a> ()</td></tr>
<tr class="memdesc:ac7f8ebf7a2133d1c68cea6e20fba0ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that canonicalizes affine.min and affine.max operations inside of scf.for loops with known lower and upper bounds.  <br /></td></tr>
<tr class="memitem:ab03de4687b73fcc63bfde7e0dda6b741" id="r_ab03de4687b73fcc63bfde7e0dda6b741"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab03de4687b73fcc63bfde7e0dda6b741">createTestSCFParallelLoopCollapsingPass</a> ()</td></tr>
<tr class="memdesc:ab03de4687b73fcc63bfde7e0dda6b741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that transforms a single ParallelLoop over N induction variables into another ParallelLoop over less than N induction variables.  <br /></td></tr>
<tr class="memitem:ad00701d01638289dd08ec9e255076f50" id="r_ad00701d01638289dd08ec9e255076f50"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad00701d01638289dd08ec9e255076f50">createParallelLoopFusionPass</a> ()</td></tr>
<tr class="memdesc:ad00701d01638289dd08ec9e255076f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a loop fusion pass which fuses parallel loops.  <br /></td></tr>
<tr class="memitem:a16b9f8678ec66eed9c66536834540184" id="r_a16b9f8678ec66eed9c66536834540184"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16b9f8678ec66eed9c66536834540184">createParallelLoopSpecializationPass</a> ()</td></tr>
<tr class="memdesc:a16b9f8678ec66eed9c66536834540184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that specializes parallel loop for unrolling and vectorization.  <br /></td></tr>
<tr class="memitem:a213571bc56b32e75bc35cf02098982a1" id="r_a213571bc56b32e75bc35cf02098982a1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a213571bc56b32e75bc35cf02098982a1">createParallelLoopTilingPass</a> (<a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; tileSize={}, <a class="el" href="classbool.html">bool</a> noMinMaxBounds=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a213571bc56b32e75bc35cf02098982a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which tiles innermost parallel loops.  <br /></td></tr>
<tr class="memitem:a2a6597022fdb6de5a99b895b2bfc9e0a" id="r_a2a6597022fdb6de5a99b895b2bfc9e0a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a6597022fdb6de5a99b895b2bfc9e0a">createForLoopRangeFoldingPass</a> ()</td></tr>
<tr class="memdesc:a2a6597022fdb6de5a99b895b2bfc9e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which folds arith ops on induction variable into loop range.  <br /></td></tr>
<tr class="memitem:a20e00e282baf336b34a2bb6252d163b3" id="r_a20e00e282baf336b34a2bb6252d163b3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20e00e282baf336b34a2bb6252d163b3">createForallToForLoopPass</a> ()</td></tr>
<tr class="memdesc:a20e00e282baf336b34a2bb6252d163b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that converts SCF forall loops to SCF for loops.  <br /></td></tr>
<tr class="memitem:a0fe217f8821de800b3899f931875c1c4" id="r_a0fe217f8821de800b3899f931875c1c4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fe217f8821de800b3899f931875c1c4">createForallToParallelLoopPass</a> ()</td></tr>
<tr class="memdesc:a0fe217f8821de800b3899f931875c1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that converts SCF forall loops to SCF parallel loops.  <br /></td></tr>
<tr class="memitem:a65a7635ac9704a17a904bb138eb09b5e" id="r_a65a7635ac9704a17a904bb138eb09b5e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65a7635ac9704a17a904bb138eb09b5e">createParallelForToNestedForsPass</a> ()</td></tr>
<tr class="memdesc:a65a7635ac9704a17a904bb138eb09b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that converts SCF forall loops to SCF parallel loops.  <br /></td></tr>
<tr class="memitem:a76018eef454fd668d103ea3cc6afc52a" id="r_a76018eef454fd668d103ea3cc6afc52a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76018eef454fd668d103ea3cc6afc52a">createForToWhileLoopPass</a> ()</td></tr>
<tr class="memitem:a0d9d102b1cf61a0c8373bac876739e10" id="r_a0d9d102b1cf61a0c8373bac876739e10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d9d102b1cf61a0c8373bac876739e10">registerSCFForLoopCanonicalization</a> ()</td></tr>
<tr class="memitem:a8fa20d05891b8adc460c6f3160578785" id="r_a8fa20d05891b8adc460c6f3160578785"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fa20d05891b8adc460c6f3160578785">registerSCFForLoopCanonicalizationPass</a> ()</td></tr>
<tr class="memitem:ae60d323af2bfd4d8dc4ceace5350e9d4" id="r_ae60d323af2bfd4d8dc4ceace5350e9d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae60d323af2bfd4d8dc4ceace5350e9d4">registerSCFForLoopPeeling</a> ()</td></tr>
<tr class="memitem:ae05f737ea5c496f87b892e56101819b4" id="r_ae05f737ea5c496f87b892e56101819b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae05f737ea5c496f87b892e56101819b4">registerSCFForLoopPeelingPass</a> ()</td></tr>
<tr class="memitem:ae48b20fbd65e6c82e51eab983deabfd4" id="r_ae48b20fbd65e6c82e51eab983deabfd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae48b20fbd65e6c82e51eab983deabfd4">registerSCFForLoopRangeFolding</a> ()</td></tr>
<tr class="memitem:a781dea335ee3dddc1b0a0d1010b2954b" id="r_a781dea335ee3dddc1b0a0d1010b2954b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a781dea335ee3dddc1b0a0d1010b2954b">registerSCFForLoopRangeFoldingPass</a> ()</td></tr>
<tr class="memitem:a175bdd2cba15cbe9b5ae4f1511f95005" id="r_a175bdd2cba15cbe9b5ae4f1511f95005"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a175bdd2cba15cbe9b5ae4f1511f95005">registerSCFForLoopSpecialization</a> ()</td></tr>
<tr class="memitem:af01f309dc55105cc7cb89c04a99ec517" id="r_af01f309dc55105cc7cb89c04a99ec517"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af01f309dc55105cc7cb89c04a99ec517">registerSCFForLoopSpecializationPass</a> ()</td></tr>
<tr class="memitem:a7632bd6ba19210acd438a29abc3a8b80" id="r_a7632bd6ba19210acd438a29abc3a8b80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7632bd6ba19210acd438a29abc3a8b80">registerSCFForToWhileLoop</a> ()</td></tr>
<tr class="memitem:a210bc59e2fb78571dc549020d25f8c58" id="r_a210bc59e2fb78571dc549020d25f8c58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a210bc59e2fb78571dc549020d25f8c58">registerSCFForToWhileLoopPass</a> ()</td></tr>
<tr class="memitem:ae8a31b1d85694dcc98a2370343ff5fa9" id="r_ae8a31b1d85694dcc98a2370343ff5fa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8a31b1d85694dcc98a2370343ff5fa9">registerSCFForallToForLoop</a> ()</td></tr>
<tr class="memitem:aa5e7e0cb99e9a2740dd6b1c7c56809ca" id="r_aa5e7e0cb99e9a2740dd6b1c7c56809ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5e7e0cb99e9a2740dd6b1c7c56809ca">registerSCFForallToForLoopPass</a> ()</td></tr>
<tr class="memitem:a073f93d96bed67d0e4890a0077cf5793" id="r_a073f93d96bed67d0e4890a0077cf5793"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a073f93d96bed67d0e4890a0077cf5793">registerSCFForallToParallelLoop</a> ()</td></tr>
<tr class="memitem:ae4d8310fbd00eff214b17b9eb7e72939" id="r_ae4d8310fbd00eff214b17b9eb7e72939"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4d8310fbd00eff214b17b9eb7e72939">registerSCFForallToParallelLoopPass</a> ()</td></tr>
<tr class="memitem:ae5bdcd72d469ee14ae52a624c1e9a4ae" id="r_ae5bdcd72d469ee14ae52a624c1e9a4ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5bdcd72d469ee14ae52a624c1e9a4ae">registerSCFParallelForToNestedFors</a> ()</td></tr>
<tr class="memitem:a8dd8a6c3de4888fe2aebf82713092ffc" id="r_a8dd8a6c3de4888fe2aebf82713092ffc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8dd8a6c3de4888fe2aebf82713092ffc">registerSCFParallelForToNestedForsPass</a> ()</td></tr>
<tr class="memitem:a3f8089e9e69cbb2bcccf582c01fbb043" id="r_a3f8089e9e69cbb2bcccf582c01fbb043"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f8089e9e69cbb2bcccf582c01fbb043">registerSCFParallelLoopFusion</a> ()</td></tr>
<tr class="memitem:a0afa0da149b2bfffc5247ecdc12173b6" id="r_a0afa0da149b2bfffc5247ecdc12173b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0afa0da149b2bfffc5247ecdc12173b6">registerSCFParallelLoopFusionPass</a> ()</td></tr>
<tr class="memitem:af3323eec9f185bca0f00410dd380ad8c" id="r_af3323eec9f185bca0f00410dd380ad8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3323eec9f185bca0f00410dd380ad8c">registerSCFParallelLoopSpecialization</a> ()</td></tr>
<tr class="memitem:a38e7bcbd42c865c8c9df909e02d943b8" id="r_a38e7bcbd42c865c8c9df909e02d943b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38e7bcbd42c865c8c9df909e02d943b8">registerSCFParallelLoopSpecializationPass</a> ()</td></tr>
<tr class="memitem:ad8c9e163a0ff724a6edf0bf8a4fd5d5c" id="r_ad8c9e163a0ff724a6edf0bf8a4fd5d5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8c9e163a0ff724a6edf0bf8a4fd5d5c">registerSCFParallelLoopTiling</a> ()</td></tr>
<tr class="memitem:ad01077d65b3faa30d54b09c8f8ddea87" id="r_ad01077d65b3faa30d54b09c8f8ddea87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad01077d65b3faa30d54b09c8f8ddea87">registerSCFParallelLoopTilingPass</a> ()</td></tr>
<tr class="memitem:a637857dee65c32d3b3a6244bd7613856" id="r_a637857dee65c32d3b3a6244bd7613856"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a637857dee65c32d3b3a6244bd7613856">registerTestSCFParallelLoopCollapsing</a> ()</td></tr>
<tr class="memitem:a786bcf3d1d600e1578e33313dcb6058c" id="r_a786bcf3d1d600e1578e33313dcb6058c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a786bcf3d1d600e1578e33313dcb6058c">registerTestSCFParallelLoopCollapsingPass</a> ()</td></tr>
<tr class="memitem:a3ae34ac202bc7c305171a425b1be26de" id="r_a3ae34ac202bc7c305171a425b1be26de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ae34ac202bc7c305171a425b1be26de">registerSCFPasses</a> ()</td></tr>
<tr class="memitem:a210a664ca21b677121c83e0589945a86" id="r_a210a664ca21b677121c83e0589945a86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; scf::ForOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a210a664ca21b677121c83e0589945a86">replaceLoopNestWithNewYields</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; scf::ForOp &gt; loopNest, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newIterOperands, const <a class="el" href="#a22fb6c3afa264f1726b430274179e011">NewYieldValuesFn</a> &amp;newYieldValuesFn, <a class="el" href="classbool.html">bool</a> replaceIterOperandsUsesInLoop=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:a210a664ca21b677121c83e0589945a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a perfectly nested loop nest to yield new values from the innermost loop and propagating it up through the loop nest.  <br /></td></tr>
<tr class="memitem:abdec8fa23b93085ee2e142defd7c5599" id="r_abdec8fa23b93085ee2e142defd7c5599"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; func::FuncOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abdec8fa23b93085ee2e142defd7c5599">outlineSingleBlockRegion</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, StringRef funcName, func::CallOp *callOp=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:abdec8fa23b93085ee2e142defd7c5599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outline a region with a single block into a new FuncOp.  <br /></td></tr>
<tr class="memitem:a10aad3624e000c0585087c96357ea857" id="r_a10aad3624e000c0585087c96357ea857"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10aad3624e000c0585087c96357ea857">outlineIfOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, scf::IfOp ifOp, func::FuncOp *thenFn, StringRef thenFnName, func::FuncOp *elseFn, StringRef elseFnName)</td></tr>
<tr class="memdesc:a10aad3624e000c0585087c96357ea857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outline the then and/or else regions of <span class="tt">ifOp</span> as follows:  <br /></td></tr>
<tr class="memitem:a820f3296c3cd59eaed418f42f874a217" id="r_a820f3296c3cd59eaed418f42f874a217"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a820f3296c3cd59eaed418f42f874a217">getInnermostParallelLoops</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *rootOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; scf::ParallelOp &gt; &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a>)</td></tr>
<tr class="memdesc:a820f3296c3cd59eaed418f42f874a217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of innermost parallel loops contained in <span class="tt">rootOp</span>.  <br /></td></tr>
<tr class="memitem:acb4551ba2eb907b65cc0fb1800d98d28" id="r_acb4551ba2eb907b65cc0fb1800d98d28"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::pair&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb4551ba2eb907b65cc0fb1800d98d28">getSCFMinMaxExpr</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;dims, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;symbols, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; loopFilter=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:acb4551ba2eb907b65cc0fb1800d98d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the min/max expressions for <span class="tt">value</span> if it is an induction variable from scf.for or scf.parallel loop.  <br /></td></tr>
<tr class="memitem:ad6d3795f1b83fc9e56398102edb81bd4" id="r_ad6d3795f1b83fc9e56398102edb81bd4"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6d3795f1b83fc9e56398102edb81bd4">coalesceLoops</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; scf::ForOp &gt; loops)</td></tr>
<tr class="memdesc:ad6d3795f1b83fc9e56398102edb81bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a perfect nest of "for" loops with a single linearized loop.  <br /></td></tr>
<tr class="memitem:abfbbec94f6bbf0a536fa87c73dd4c61b" id="r_abfbbec94f6bbf0a536fa87c73dd4c61b"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfbbec94f6bbf0a536fa87c73dd4c61b">coalesceLoops</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; scf::ForOp &gt;)</td></tr>
<tr class="memitem:a39a046fcc3a4da7eb0d54f9f6a65c3c5" id="r_a39a046fcc3a4da7eb0d54f9f6a65c3c5"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39a046fcc3a4da7eb0d54f9f6a65c3c5">coalescePerfectlyNestedSCFForLoops</a> (scf::ForOp op)</td></tr>
<tr class="memdesc:a39a046fcc3a4da7eb0d54f9f6a65c3c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk an affine.for to find a band to coalesce.  <br /></td></tr>
<tr class="memitem:a698165b61870c49ff1d068b7aba57fd6" id="r_a698165b61870c49ff1d068b7aba57fd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a698165b61870c49ff1d068b7aba57fd6">collapseParallelLoops</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, scf::ParallelOp loops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::vector&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &gt; combinedDimensions)</td></tr>
<tr class="memdesc:a698165b61870c49ff1d068b7aba57fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the ParallelLoop and for each set of dimension indices, combine them into a single dimension.  <br /></td></tr>
<tr class="memitem:a7d85acf663c85ff9286024bd8ca84f1b" id="r_a7d85acf663c85ff9286024bd8ca84f1b"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1UnrolledLoopInfo.html">UnrolledLoopInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d85acf663c85ff9286024bd8ca84f1b">loopUnrollByFactor</a> (scf::ForOp forOp, uint64_t unrollFactor, <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>)&gt; annotateFn=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a7d85acf663c85ff9286024bd8ca84f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls this for operation by the specified unroll factor.  <br /></td></tr>
<tr class="memitem:a4fc247600aa65daf2fd099cb63a5bcee" id="r_a4fc247600aa65daf2fd099cb63a5bcee"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fc247600aa65daf2fd099cb63a5bcee">loopUnrollFull</a> (scf::ForOp forOp)</td></tr>
<tr class="memdesc:a4fc247600aa65daf2fd099cb63a5bcee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls this loop completely.  <br /></td></tr>
<tr class="memitem:a7f0b0e4e1d0aa48d157009f2f9530492" id="r_a7f0b0e4e1d0aa48d157009f2f9530492"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f0b0e4e1d0aa48d157009f2f9530492">loopUnrollJamByFactor</a> (scf::ForOp forOp, uint64_t unrollFactor)</td></tr>
<tr class="memdesc:a7f0b0e4e1d0aa48d157009f2f9530492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls and jams this <span class="tt">scf.for</span> operation by the specified unroll factor.  <br /></td></tr>
<tr class="memitem:aecf5a29768872240e0bbd49d969f084b" id="r_aecf5a29768872240e0bbd49d969f084b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1Range.html">Range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecf5a29768872240e0bbd49d969f084b">emitNormalizedLoopBounds</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> lb, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ub, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> step)</td></tr>
<tr class="memdesc:aecf5a29768872240e0bbd49d969f084b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Materialize bounds and step of a zero-based and unit-step loop derived by normalizing the specified bounds and step.  <br /></td></tr>
<tr class="memitem:acad9612c1d4f11375369c3d1b2029b5c" id="r_acad9612c1d4f11375369c3d1b2029b5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acad9612c1d4f11375369c3d1b2029b5c">denormalizeInductionVariable</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> normalizedIv, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> origLb, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> origStep)</td></tr>
<tr class="memdesc:acad9612c1d4f11375369c3d1b2029b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get back the original induction variable values after loop normalization.  <br /></td></tr>
<tr class="memitem:aecdaa20d0acb7aec0f05cb700b1e09df" id="r_aecdaa20d0acb7aec0f05cb700b1e09df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a5510ab947817d6f0bf6617e367113963">TileLoops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecdaa20d0acb7aec0f05cb700b1e09df">extractFixedOuterLoops</a> (scf::ForOp rootFOrOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; sizes)</td></tr>
<tr class="memitem:ab15bd4c107bb9ea52b7fcc11c283c129" id="r_ab15bd4c107bb9ea52b7fcc11c283c129"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="#aed48aeaaa3484827b729cced4fb0dfb6">Loops</a>, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab15bd4c107bb9ea52b7fcc11c283c129">tile</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt; forOps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt; targets)</td></tr>
<tr class="memdesc:ab15bd4c107bb9ea52b7fcc11c283c129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs tiling fo imperfectly nested loops (with interchange) by strip-mining the <span class="tt">forOps</span> by <span class="tt">sizes</span> and sinking them, in their order of occurrence in <span class="tt">forOps</span>, under each of the <span class="tt">targets</span>.  <br /></td></tr>
<tr class="memitem:adb3ac25a4d763e0e5234f6b347c7f17a" id="r_adb3ac25a4d763e0e5234f6b347c7f17a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aed48aeaaa3484827b729cced4fb0dfb6">Loops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb3ac25a4d763e0e5234f6b347c7f17a">tile</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt; forOps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizes, scf::ForOp <a class="el" href="LinalgTransformOps_8cpp.html#a5d2c023108742a1ce78ba9823c06ea35">target</a>)</td></tr>
<tr class="memdesc:adb3ac25a4d763e0e5234f6b347c7f17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs tiling (with interchange) by strip-mining the <span class="tt">forOps</span> by <span class="tt">sizes</span> and sinking them, in their order of occurrence in <span class="tt">forOps</span>, under <span class="tt">target</span>.  <br /></td></tr>
<tr class="memitem:a76588ffa46e04caaa584360fa5cdde4c" id="r_a76588ffa46e04caaa584360fa5cdde4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aed48aeaaa3484827b729cced4fb0dfb6">Loops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76588ffa46e04caaa584360fa5cdde4c">tilePerfectlyNested</a> (scf::ForOp rootForOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizes)</td></tr>
<tr class="memdesc:a76588ffa46e04caaa584360fa5cdde4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile a nest of scf::ForOp loops rooted at <span class="tt">rootForOp</span> with the given (parametric) sizes.  <br /></td></tr>
<tr class="memitem:a002c6258ba17b3a08e25cde241861c3f" id="r_a002c6258ba17b3a08e25cde241861c3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a002c6258ba17b3a08e25cde241861c3f">getPerfectlyNestedLoops</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; scf::ForOp &gt; &amp;nestedLoops, scf::ForOp root)</td></tr>
<tr class="memdesc:a002c6258ba17b3a08e25cde241861c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get perfectly nested sequence of loops starting at root of loop nest (the first op being another AffineFor, and the second op - a terminator).  <br /></td></tr>
<tr class="memitem:acdfbb5ad3709577536fd8002ed734921" id="r_acdfbb5ad3709577536fd8002ed734921"><td class="memItemLeft" align="right" valign="top">scf::ForallOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdfbb5ad3709577536fd8002ed734921">fuseIndependentSiblingForallLoops</a> (scf::ForallOp <a class="el" href="LinalgTransformOps_8cpp.html#a5d2c023108742a1ce78ba9823c06ea35">target</a>, scf::ForallOp source, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter)</td></tr>
<tr class="memdesc:acdfbb5ad3709577536fd8002ed734921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two scf.forall loops, <span class="tt">target</span> and <span class="tt">source</span>, fuses <span class="tt">target</span> into <span class="tt">source</span>.  <br /></td></tr>
<tr class="memitem:ad7634eaf008502f8ebca317ec4a1ad84" id="r_ad7634eaf008502f8ebca317ec4a1ad84"><td class="memItemLeft" align="right" valign="top">scf::ForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7634eaf008502f8ebca317ec4a1ad84">fuseIndependentSiblingForLoops</a> (scf::ForOp <a class="el" href="LinalgTransformOps_8cpp.html#a5d2c023108742a1ce78ba9823c06ea35">target</a>, scf::ForOp source, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter)</td></tr>
<tr class="memdesc:ad7634eaf008502f8ebca317ec4a1ad84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two scf.for loops, <span class="tt">target</span> and <span class="tt">source</span>, fuses <span class="tt">target</span> into <span class="tt">source</span>.  <br /></td></tr>
<tr class="memitem:afff65ad1a751cdba6e58ef912d9ebaa8" id="r_afff65ad1a751cdba6e58ef912d9ebaa8"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; scf::ForallOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afff65ad1a751cdba6e58ef912d9ebaa8">normalizeForallOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, scf::ForallOp forallOp)</td></tr>
<tr class="memdesc:afff65ad1a751cdba6e58ef912d9ebaa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize an <span class="tt">scf.forall</span> operation.  <br /></td></tr>
<tr class="memitem:a02cbcfb8713e367c7f1866a83625edcf" id="r_a02cbcfb8713e367c7f1866a83625edcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02cbcfb8713e367c7f1866a83625edcf">isPerfectlyNestedForLoops</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; LoopLikeOpInterface &gt; loops)</td></tr>
<tr class="memdesc:a02cbcfb8713e367c7f1866a83625edcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the provided loops are perfectly nested for-loops.  <br /></td></tr>
<tr class="memitem:a3ddb0c1a5398951747604e655e4eb371" id="r_a3ddb0c1a5398951747604e655e4eb371"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ddb0c1a5398951747604e655e4eb371">generateUnrolledLoop</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *loopBodyBlock, <a class="el" href="classmlir_1_1Value.html">Value</a> iv, uint64_t unrollFactor, <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>(<a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>)&gt; ivRemapFn, <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>)&gt; annotateFn, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> iterArgs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> yieldedValues, <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> *clonedToSrcOpsMap=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a3ddb0c1a5398951747604e655e4eb371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate unrolled copies of an scf loop's 'loopBodyBlock', with 'iterArgs' and 'yieldedValues' as the block arguments and yielded values of the loop.  <br /></td></tr>
<tr class="memitem:a926832e2ae31cbf66f87b6508bca56cd" id="r_a926832e2ae31cbf66f87b6508bca56cd"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; scf::ParallelOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a926832e2ae31cbf66f87b6508bca56cd">parallelLoopUnrollByFactors</a> (scf::ParallelOp op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt; unrollFactors, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>)&gt; annotateFn=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>, <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> *clonedToSrcOpsMap=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a926832e2ae31cbf66f87b6508bca56cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unroll this scf::Parallel loop by the specified unroll factors.  <br /></td></tr>
<tr class="memitem:a4960f3e0f3dfa808af78990b8e395d40" id="r_a4960f3e0f3dfa808af78990b8e395d40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">llvm::SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4960f3e0f3dfa808af78990b8e395d40">getConstLoopTripCounts</a> (mlir::LoopLikeOpInterface loopOp)</td></tr>
<tr class="memdesc:a4960f3e0f3dfa808af78990b8e395d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get constant trip counts for each of the induction variables of the given loop operation.  <br /></td></tr>
<tr class="memitem:add898725653f18825c4a1b441e55a5ae" id="r_add898725653f18825c4a1b441e55a5ae"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add898725653f18825c4a1b441e55a5ae">createOutlineShapeComputationPass</a> ()</td></tr>
<tr class="memitem:a4eb08a2d2939d0043d471ea4ff5745f6" id="r_a4eb08a2d2939d0043d471ea4ff5745f6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4eb08a2d2939d0043d471ea4ff5745f6">createRemoveShapeConstraintsPass</a> ()</td></tr>
<tr class="memitem:a3bc1ef32acaa89b19ce4b38dbc626801" id="r_a3bc1ef32acaa89b19ce4b38dbc626801"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bc1ef32acaa89b19ce4b38dbc626801">createShapeToShapeLoweringPass</a> ()</td></tr>
<tr class="memitem:a068b739b7424900d4d98c15c81e4609e" id="r_a068b739b7424900d4d98c15c81e4609e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a068b739b7424900d4d98c15c81e4609e">populateShapeRewritePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a068b739b7424900d4d98c15c81e4609e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects a set of patterns to rewrite ops within the Shape dialect.  <br /></td></tr>
<tr class="memitem:ac260b877914dd5ce7bf80eb50ff87a4b" id="r_ac260b877914dd5ce7bf80eb50ff87a4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac260b877914dd5ce7bf80eb50ff87a4b">populateRemoveShapeConstraintsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memitem:a922b21fc4f546577a0c2ee3281095143" id="r_a922b21fc4f546577a0c2ee3281095143"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a922b21fc4f546577a0c2ee3281095143">registerOutlineShapeComputationPass</a> ()</td></tr>
<tr class="memitem:aaf2646c4b6cf320953491cd8c72d1a15" id="r_aaf2646c4b6cf320953491cd8c72d1a15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf2646c4b6cf320953491cd8c72d1a15">registerOutlineShapeComputationPassPass</a> ()</td></tr>
<tr class="memitem:a7d2c5affc0233b165876f802918807df" id="r_a7d2c5affc0233b165876f802918807df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d2c5affc0233b165876f802918807df">registerRemoveShapeConstraintsPass</a> ()</td></tr>
<tr class="memitem:a4627ca3894a6af8f55b220c3197dd4cc" id="r_a4627ca3894a6af8f55b220c3197dd4cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4627ca3894a6af8f55b220c3197dd4cc">registerRemoveShapeConstraintsPassPass</a> ()</td></tr>
<tr class="memitem:a4b32eb2464cc8a75d1db1e43b07db4aa" id="r_a4b32eb2464cc8a75d1db1e43b07db4aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b32eb2464cc8a75d1db1e43b07db4aa">registerShapeToShapeLoweringPass</a> ()</td></tr>
<tr class="memitem:aa934e0ae0a2fc73da99e0cf3d871f1df" id="r_aa934e0ae0a2fc73da99e0cf3d871f1df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa934e0ae0a2fc73da99e0cf3d871f1df">registerShapeToShapeLoweringPassPass</a> ()</td></tr>
<tr class="memitem:ae6cb2b4fddca0abf12bdbb4c774f349b" id="r_ae6cb2b4fddca0abf12bdbb4c774f349b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6cb2b4fddca0abf12bdbb4c774f349b">registerShapePasses</a> ()</td></tr>
<tr class="memitem:aacaa4c3b727375b5ba2dc196a70a42bb" id="r_aacaa4c3b727375b5ba2dc196a70a42bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacaa4c3b727375b5ba2dc196a70a42bb">populateSparseAssembler</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classbool.html">bool</a> directOut)</td></tr>
<tr class="memitem:a07377f22cc6146bebe3a32a4a13c00bb" id="r_a07377f22cc6146bebe3a32a4a13c00bb"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07377f22cc6146bebe3a32a4a13c00bb">createSparseAssembler</a> ()</td></tr>
<tr class="memitem:ac113f2b89a3f2ad9abce500e0c48d9f4" id="r_ac113f2b89a3f2ad9abce500e0c48d9f4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac113f2b89a3f2ad9abce500e0c48d9f4">createSparseAssembler</a> (<a class="el" href="classbool.html">bool</a> directOut)</td></tr>
<tr class="memitem:ae43552eafb8cb1d923a84783b520748d" id="r_ae43552eafb8cb1d923a84783b520748d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae43552eafb8cb1d923a84783b520748d">populateSparseReinterpretMap</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="#a855a7d93430958efaaf3a6f69e3dac1c">ReinterpretMapScope</a> scope, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a831cb9fe0506a02a0ad7a9babfba8eb7">sparse_tensor::LoopOrderingStrategy</a> strategy=<a class="el" href="namespacemlir_1_1sparse__tensor.html#a831cb9fe0506a02a0ad7a9babfba8eb7a6867faeaa475fda467e48267db2bb8a8">sparse_tensor::LoopOrderingStrategy::kDefault</a>)</td></tr>
<tr class="memitem:a3968e0a16a255017c133162badae2da2" id="r_a3968e0a16a255017c133162badae2da2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3968e0a16a255017c133162badae2da2">createSparseReinterpretMapPass</a> ()</td></tr>
<tr class="memitem:ac6f3748b0d302eac21bac48a9887146b" id="r_ac6f3748b0d302eac21bac48a9887146b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6f3748b0d302eac21bac48a9887146b">createSparseReinterpretMapPass</a> (<a class="el" href="#a855a7d93430958efaaf3a6f69e3dac1c">ReinterpretMapScope</a> scope)</td></tr>
<tr class="memitem:a51d5d032337b816f2fa52e45893536e1" id="r_a51d5d032337b816f2fa52e45893536e1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51d5d032337b816f2fa52e45893536e1">createSparseReinterpretMapPass</a> (<a class="el" href="#a855a7d93430958efaaf3a6f69e3dac1c">ReinterpretMapScope</a> scope, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a831cb9fe0506a02a0ad7a9babfba8eb7">sparse_tensor::LoopOrderingStrategy</a> strategy)</td></tr>
<tr class="memitem:a667f68e2860101c8caec8f46732e316e" id="r_a667f68e2860101c8caec8f46732e316e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a667f68e2860101c8caec8f46732e316e">populatePreSparsificationRewriting</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memitem:aa6abc74515648dc477ae4f5af8cbf310" id="r_aa6abc74515648dc477ae4f5af8cbf310"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6abc74515648dc477ae4f5af8cbf310">createPreSparsificationRewritePass</a> ()</td></tr>
<tr class="memitem:a86f7f8933f0baf6ebeddfdc698327c31" id="r_a86f7f8933f0baf6ebeddfdc698327c31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86f7f8933f0baf6ebeddfdc698327c31">populateSparsificationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>=<a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a>())</td></tr>
<tr class="memdesc:a86f7f8933f0baf6ebeddfdc698327c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up sparsification rewriting rules with the given options.  <br /></td></tr>
<tr class="memitem:ae0be4f778219bfb3917a2c7d3e7e1bd0" id="r_ae0be4f778219bfb3917a2c7d3e7e1bd0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0be4f778219bfb3917a2c7d3e7e1bd0">createSparsificationPass</a> ()</td></tr>
<tr class="memitem:a11b0dcc4a707e4e560a7a2f69a95a7c9" id="r_a11b0dcc4a707e4e560a7a2f69a95a7c9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11b0dcc4a707e4e560a7a2f69a95a7c9">createSparsificationPass</a> (const <a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:ab05749dd321afd1862ad40e29349e733" id="r_ab05749dd321afd1862ad40e29349e733"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab05749dd321afd1862ad40e29349e733">populateStageSparseOperationsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:ab05749dd321afd1862ad40e29349e733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up StageSparseOperation rewriting rules.  <br /></td></tr>
<tr class="memitem:adfa7974cf8032ae0d38f7fcc16387d3a" id="r_adfa7974cf8032ae0d38f7fcc16387d3a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfa7974cf8032ae0d38f7fcc16387d3a">createStageSparseOperationsPass</a> ()</td></tr>
<tr class="memitem:a9848c16612b09d5d062b7e49564e8659" id="r_a9848c16612b09d5d062b7e49564e8659"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9848c16612b09d5d062b7e49564e8659">populateLowerSparseOpsToForeachPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classbool.html">bool</a> enableRT, <a class="el" href="classbool.html">bool</a> enableConvert)</td></tr>
<tr class="memitem:a0c927ead951ebddddb979353f1ddda9e" id="r_a0c927ead951ebddddb979353f1ddda9e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c927ead951ebddddb979353f1ddda9e">createLowerSparseOpsToForeachPass</a> ()</td></tr>
<tr class="memitem:a93efca2366cbf131cf7359f94cc5f2a5" id="r_a93efca2366cbf131cf7359f94cc5f2a5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93efca2366cbf131cf7359f94cc5f2a5">createLowerSparseOpsToForeachPass</a> (<a class="el" href="classbool.html">bool</a> enableRT, <a class="el" href="classbool.html">bool</a> enableConvert)</td></tr>
<tr class="memitem:aeac82ef141dff9c99336d99169954925" id="r_aeac82ef141dff9c99336d99169954925"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeac82ef141dff9c99336d99169954925">populateLowerForeachToSCFPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memitem:aaa0dbcff2285d9b5fc43c67189e783d6" id="r_aaa0dbcff2285d9b5fc43c67189e783d6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa0dbcff2285d9b5fc43c67189e783d6">createLowerForeachToSCFPass</a> ()</td></tr>
<tr class="memitem:a8f175c99ce23bb21e02b216876b31171" id="r_a8f175c99ce23bb21e02b216876b31171"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f175c99ce23bb21e02b216876b31171">populateLowerSparseIterationToSCFPatterns</a> (const <a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memitem:ab956888e7892e8d37b40f660d2ab3222" id="r_ab956888e7892e8d37b40f660d2ab3222"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab956888e7892e8d37b40f660d2ab3222">createLowerSparseIterationToSCFPass</a> ()</td></tr>
<tr class="memitem:a5a109a00c2dac890cb8db767e9a9982d" id="r_a5a109a00c2dac890cb8db767e9a9982d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a109a00c2dac890cb8db767e9a9982d">populateSparseTensorConversionPatterns</a> (const <a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a5a109a00c2dac890cb8db767e9a9982d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up sparse tensor conversion rules.  <br /></td></tr>
<tr class="memitem:a50fe6af993ee7df395f88312234f0dc0" id="r_a50fe6af993ee7df395f88312234f0dc0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50fe6af993ee7df395f88312234f0dc0">createSparseTensorConversionPass</a> ()</td></tr>
<tr class="memitem:a271ea308903cf0d605df0c3ba5f13b6c" id="r_a271ea308903cf0d605df0c3ba5f13b6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a271ea308903cf0d605df0c3ba5f13b6c">populateSparseTensorCodegenPatterns</a> (const <a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classbool.html">bool</a> createSparseDeallocs, <a class="el" href="classbool.html">bool</a> enableBufferInitialization)</td></tr>
<tr class="memdesc:a271ea308903cf0d605df0c3ba5f13b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up sparse tensor codegen rules.  <br /></td></tr>
<tr class="memitem:a1444af92cb6556316a97dbd17dc10ea4" id="r_a1444af92cb6556316a97dbd17dc10ea4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1444af92cb6556316a97dbd17dc10ea4">createSparseTensorCodegenPass</a> ()</td></tr>
<tr class="memitem:ad11d8839f833db69a07242adf6894472" id="r_ad11d8839f833db69a07242adf6894472"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad11d8839f833db69a07242adf6894472">createSparseTensorCodegenPass</a> (<a class="el" href="classbool.html">bool</a> createSparseDeallocs, <a class="el" href="classbool.html">bool</a> enableBufferInitialization)</td></tr>
<tr class="memitem:a6168f425252f728e066433be9ee022b2" id="r_a6168f425252f728e066433be9ee022b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6168f425252f728e066433be9ee022b2">populateSparseBufferRewriting</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classbool.html">bool</a> enableBufferInitialization)</td></tr>
<tr class="memitem:a52922b4f9a9b71d07318a65565e1d95d" id="r_a52922b4f9a9b71d07318a65565e1d95d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52922b4f9a9b71d07318a65565e1d95d">createSparseBufferRewritePass</a> ()</td></tr>
<tr class="memitem:aa9c5d254155d499befa419181f2539ea" id="r_aa9c5d254155d499befa419181f2539ea"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9c5d254155d499befa419181f2539ea">createSparseBufferRewritePass</a> (<a class="el" href="classbool.html">bool</a> enableBufferInitialization)</td></tr>
<tr class="memitem:a76dc06de29760922469c1e4bd10a62c9" id="r_a76dc06de29760922469c1e4bd10a62c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76dc06de29760922469c1e4bd10a62c9">populateSparseVectorizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classunsigned.html">unsigned</a> vectorLength, <a class="el" href="classbool.html">bool</a> enableVLAVectorization, <a class="el" href="classbool.html">bool</a> enableSIMDIndex32)</td></tr>
<tr class="memdesc:a76dc06de29760922469c1e4bd10a62c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the given patterns list with vectorization rules.  <br /></td></tr>
<tr class="memitem:a06a9ca41ccfad286cda8688e8d66f588" id="r_a06a9ca41ccfad286cda8688e8d66f588"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06a9ca41ccfad286cda8688e8d66f588">createSparseVectorizationPass</a> ()</td></tr>
<tr class="memitem:a3399bec16625e6af75488bb739d48d4c" id="r_a3399bec16625e6af75488bb739d48d4c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3399bec16625e6af75488bb739d48d4c">createSparseVectorizationPass</a> (<a class="el" href="classunsigned.html">unsigned</a> vectorLength, <a class="el" href="classbool.html">bool</a> enableVLAVectorization, <a class="el" href="classbool.html">bool</a> enableSIMDIndex32)</td></tr>
<tr class="memitem:ad48873e0e6f944a5579b28be3cc1c944" id="r_ad48873e0e6f944a5579b28be3cc1c944"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad48873e0e6f944a5579b28be3cc1c944">populateSparseGPUCodegenPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classunsigned.html">unsigned</a> numThreads)</td></tr>
<tr class="memitem:a41ac451ba0b1c3393df013233d3c93c2" id="r_a41ac451ba0b1c3393df013233d3c93c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41ac451ba0b1c3393df013233d3c93c2">populateSparseGPULibgenPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classbool.html">bool</a> enableRT)</td></tr>
<tr class="memitem:a2fa7d8a0754783f37e6e38a77c7e8116" id="r_a2fa7d8a0754783f37e6e38a77c7e8116"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fa7d8a0754783f37e6e38a77c7e8116">createSparseGPUCodegenPass</a> ()</td></tr>
<tr class="memitem:ab19ebeb6aa5cf97ebbb73f3b7cd8c6c1" id="r_ab19ebeb6aa5cf97ebbb73f3b7cd8c6c1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab19ebeb6aa5cf97ebbb73f3b7cd8c6c1">createSparseGPUCodegenPass</a> (<a class="el" href="classunsigned.html">unsigned</a> numThreads, <a class="el" href="classbool.html">bool</a> enableRT)</td></tr>
<tr class="memitem:a07d707e1aa02507e261dec9e171b37d1" id="r_a07d707e1aa02507e261dec9e171b37d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07d707e1aa02507e261dec9e171b37d1">populateStorageSpecifierToLLVMPatterns</a> (const <a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memitem:aa52fe837d33ee51beba517a1d44dbea3" id="r_aa52fe837d33ee51beba517a1d44dbea3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa52fe837d33ee51beba517a1d44dbea3">createStorageSpecifierToLLVMPass</a> ()</td></tr>
<tr class="memitem:a3775f03f9a65464fefb370229adcac95" id="r_a3775f03f9a65464fefb370229adcac95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">bufferization::OneShotBufferizationOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3775f03f9a65464fefb370229adcac95">getBufferizationOptionsForSparsification</a> (<a class="el" href="classbool.html">bool</a> analysisOnly)</td></tr>
<tr class="memitem:a5328b60bddf5d222bef6d92658019b9d" id="r_a5328b60bddf5d222bef6d92658019b9d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5328b60bddf5d222bef6d92658019b9d">createSparsificationAndBufferizationPass</a> ()</td></tr>
<tr class="memitem:af312c1b22096f10a3123c5136824b691" id="r_af312c1b22096f10a3123c5136824b691"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af312c1b22096f10a3123c5136824b691">createSparsificationAndBufferizationPass</a> (const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">bufferization::OneShotBufferizationOptions</a> &amp;bufferizationOptions, const <a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a> &amp;sparsificationOptions, <a class="el" href="classbool.html">bool</a> createSparseDeallocs, <a class="el" href="classbool.html">bool</a> enableRuntimeLibrary, <a class="el" href="classbool.html">bool</a> enableBufferInitialization, <a class="el" href="classunsigned.html">unsigned</a> vectorLength, <a class="el" href="classbool.html">bool</a> enableVLAVectorization, <a class="el" href="classbool.html">bool</a> enableSIMDIndex32, <a class="el" href="classbool.html">bool</a> enableGPULibgen, <a class="el" href="#a90f3feaa61d2ade78f26489cc92061c9">SparseEmitStrategy</a> emitStrategy, <a class="el" href="#a781474aef998ccce168b69ae973cd832">SparseParallelizationStrategy</a> parallelizationStrategy)</td></tr>
<tr class="memitem:a3110b4f58e57c2f284923d882d45cff4" id="r_a3110b4f58e57c2f284923d882d45cff4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3110b4f58e57c2f284923d882d45cff4">createSparseSpaceCollapsePass</a> ()</td></tr>
<tr class="memitem:a49b63d76c793afa7b98fdb476dbcdd4f" id="r_a49b63d76c793afa7b98fdb476dbcdd4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49b63d76c793afa7b98fdb476dbcdd4f">registerLowerForeachToSCF</a> ()</td></tr>
<tr class="memitem:a210ead914f04a46c7e6a86074f1ca5d8" id="r_a210ead914f04a46c7e6a86074f1ca5d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a210ead914f04a46c7e6a86074f1ca5d8">registerLowerForeachToSCFPass</a> ()</td></tr>
<tr class="memitem:acb4ebdfa6c244c84da2d8f75bb7e2be2" id="r_acb4ebdfa6c244c84da2d8f75bb7e2be2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb4ebdfa6c244c84da2d8f75bb7e2be2">registerLowerSparseIterationToSCF</a> ()</td></tr>
<tr class="memitem:a209751dcd4d78134d054f383f861d323" id="r_a209751dcd4d78134d054f383f861d323"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a209751dcd4d78134d054f383f861d323">registerLowerSparseIterationToSCFPass</a> ()</td></tr>
<tr class="memitem:ae4b51f56ea70dae66a8cc1ece74f90a6" id="r_ae4b51f56ea70dae66a8cc1ece74f90a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4b51f56ea70dae66a8cc1ece74f90a6">registerLowerSparseOpsToForeach</a> ()</td></tr>
<tr class="memitem:adf27a0b1b44bbe0369b3a37db64efb67" id="r_adf27a0b1b44bbe0369b3a37db64efb67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf27a0b1b44bbe0369b3a37db64efb67">registerLowerSparseOpsToForeachPass</a> ()</td></tr>
<tr class="memitem:a934661b51fd450e3ad6bb883dd709789" id="r_a934661b51fd450e3ad6bb883dd709789"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a934661b51fd450e3ad6bb883dd709789">registerPreSparsificationRewrite</a> ()</td></tr>
<tr class="memitem:a7548e3512a8da14739ee2c8d113e992a" id="r_a7548e3512a8da14739ee2c8d113e992a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7548e3512a8da14739ee2c8d113e992a">registerPreSparsificationRewritePass</a> ()</td></tr>
<tr class="memitem:a6183051415ba8e8aba515e37d885d8ba" id="r_a6183051415ba8e8aba515e37d885d8ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6183051415ba8e8aba515e37d885d8ba">registerSparseAssembler</a> ()</td></tr>
<tr class="memitem:ad1ec42768e9620fbc3faf3d78971fc6b" id="r_ad1ec42768e9620fbc3faf3d78971fc6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1ec42768e9620fbc3faf3d78971fc6b">registerSparseAssemblerPass</a> ()</td></tr>
<tr class="memitem:a6f15b8670b123dce36fb07f80e0f05a7" id="r_a6f15b8670b123dce36fb07f80e0f05a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f15b8670b123dce36fb07f80e0f05a7">registerSparseBufferRewrite</a> ()</td></tr>
<tr class="memitem:a9b3ca94a2b794e37ccec8c493163345c" id="r_a9b3ca94a2b794e37ccec8c493163345c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b3ca94a2b794e37ccec8c493163345c">registerSparseBufferRewritePass</a> ()</td></tr>
<tr class="memitem:a69d15be700aa8382b29b58dd0c5c86ca" id="r_a69d15be700aa8382b29b58dd0c5c86ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69d15be700aa8382b29b58dd0c5c86ca">registerSparseGPUCodegen</a> ()</td></tr>
<tr class="memitem:a1158082f4a56bba72317752a1869bba4" id="r_a1158082f4a56bba72317752a1869bba4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1158082f4a56bba72317752a1869bba4">registerSparseGPUCodegenPass</a> ()</td></tr>
<tr class="memitem:a5c014df7aff145788ec7255c3a014fd5" id="r_a5c014df7aff145788ec7255c3a014fd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c014df7aff145788ec7255c3a014fd5">registerSparseReinterpretMap</a> ()</td></tr>
<tr class="memitem:a40b83f3b7db1bc8c563133ea40e1e271" id="r_a40b83f3b7db1bc8c563133ea40e1e271"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40b83f3b7db1bc8c563133ea40e1e271">registerSparseReinterpretMapPass</a> ()</td></tr>
<tr class="memitem:a5d41535cdc30434df761304d60543028" id="r_a5d41535cdc30434df761304d60543028"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d41535cdc30434df761304d60543028">registerSparseSpaceCollapse</a> ()</td></tr>
<tr class="memitem:a45ee41d6e54aea82f314c435144cc13d" id="r_a45ee41d6e54aea82f314c435144cc13d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45ee41d6e54aea82f314c435144cc13d">registerSparseSpaceCollapsePass</a> ()</td></tr>
<tr class="memitem:a7ef8aea2f01115612037875d2f283647" id="r_a7ef8aea2f01115612037875d2f283647"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ef8aea2f01115612037875d2f283647">registerSparseTensorCodegen</a> ()</td></tr>
<tr class="memitem:a973d0cb845cabe7b1db4ff8166041196" id="r_a973d0cb845cabe7b1db4ff8166041196"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a973d0cb845cabe7b1db4ff8166041196">registerSparseTensorCodegenPass</a> ()</td></tr>
<tr class="memitem:afbb860e1972525881da72170adf4398a" id="r_afbb860e1972525881da72170adf4398a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbb860e1972525881da72170adf4398a">registerSparseTensorConversionPass</a> ()</td></tr>
<tr class="memitem:a57f3586e55dbbdb9608b84f92d2efb27" id="r_a57f3586e55dbbdb9608b84f92d2efb27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57f3586e55dbbdb9608b84f92d2efb27">registerSparseTensorConversionPassPass</a> ()</td></tr>
<tr class="memitem:a224c635adefbfd082b51339b59dae7c0" id="r_a224c635adefbfd082b51339b59dae7c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a224c635adefbfd082b51339b59dae7c0">registerSparseVectorization</a> ()</td></tr>
<tr class="memitem:aa373f3a1f0c8313868741af7ea32a5c5" id="r_aa373f3a1f0c8313868741af7ea32a5c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa373f3a1f0c8313868741af7ea32a5c5">registerSparseVectorizationPass</a> ()</td></tr>
<tr class="memitem:a506d52d361e0a1275a7761eb403bbd85" id="r_a506d52d361e0a1275a7761eb403bbd85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a506d52d361e0a1275a7761eb403bbd85">registerSparsificationAndBufferization</a> ()</td></tr>
<tr class="memitem:a4a812d6e57454d1d0caef811d3c46c6e" id="r_a4a812d6e57454d1d0caef811d3c46c6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a812d6e57454d1d0caef811d3c46c6e">registerSparsificationAndBufferizationPass</a> ()</td></tr>
<tr class="memitem:ae3b3b3c1aba6d4dfa4da45a1bb7bf398" id="r_ae3b3b3c1aba6d4dfa4da45a1bb7bf398"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3b3b3c1aba6d4dfa4da45a1bb7bf398">registerSparsificationPass</a> ()</td></tr>
<tr class="memitem:ac1ff078a407f63aaf674e1909afb5741" id="r_ac1ff078a407f63aaf674e1909afb5741"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1ff078a407f63aaf674e1909afb5741">registerSparsificationPassPass</a> ()</td></tr>
<tr class="memitem:ad460042feb741008a5a4578a56bd5702" id="r_ad460042feb741008a5a4578a56bd5702"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad460042feb741008a5a4578a56bd5702">registerStageSparseOperations</a> ()</td></tr>
<tr class="memitem:a67b15607425b4cead1760537e5d40402" id="r_a67b15607425b4cead1760537e5d40402"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67b15607425b4cead1760537e5d40402">registerStageSparseOperationsPass</a> ()</td></tr>
<tr class="memitem:a7ce9edd7c2427054d9e28ec7ddd480a6" id="r_a7ce9edd7c2427054d9e28ec7ddd480a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ce9edd7c2427054d9e28ec7ddd480a6">registerStorageSpecifierToLLVM</a> ()</td></tr>
<tr class="memitem:a3bd20fe234baec1d1ed83c3f4eda4829" id="r_a3bd20fe234baec1d1ed83c3f4eda4829"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bd20fe234baec1d1ed83c3f4eda4829">registerStorageSpecifierToLLVMPass</a> ()</td></tr>
<tr class="memitem:a0019f87f0182bf0d7455f7b47ce5f1bc" id="r_a0019f87f0182bf0d7455f7b47ce5f1bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0019f87f0182bf0d7455f7b47ce5f1bc">registerSparseTensorPasses</a> ()</td></tr>
<tr class="memitem:a5c9ab382a920a458ce63cd4534dcb273" id="r_a5c9ab382a920a458ce63cd4534dcb273"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c9ab382a920a458ce63cd4534dcb273">populateBuiltinFuncToSPIRVPatterns</a> (const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a5c9ab382a920a458ce63cd4534dcb273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating the builtin <span class="tt">func</span> op to the SPIR-V dialect.  <br /></td></tr>
<tr class="memitem:a00c79fe894fb6efe41ad37b5219a7b8a" id="r_a00c79fe894fb6efe41ad37b5219a7b8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00c79fe894fb6efe41ad37b5219a7b8a">populateFuncOpVectorRewritePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memitem:a2162d2bc9640db32d4ae88c12ef3bd23" id="r_a2162d2bc9640db32d4ae88c12ef3bd23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2162d2bc9640db32d4ae88c12ef3bd23">populateReturnOpVectorRewritePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memitem:a7739fe988f31077f0005b73f457eb373" id="r_a7739fe988f31077f0005b73f457eb373"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DiagnosedDefiniteFailure.html">DiagnosedDefiniteFailure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7739fe988f31077f0005b73f457eb373">emitDefiniteFailure</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, const Twine &amp;message)</td></tr>
<tr class="memdesc:a7739fe988f31077f0005b73f457eb373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits a definite failure with the given message.  <br /></td></tr>
<tr class="memitem:a1f82005038ea404596c74643db0d564f" id="r_a1f82005038ea404596c74643db0d564f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DiagnosedDefiniteFailure.html">DiagnosedDefiniteFailure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f82005038ea404596c74643db0d564f">emitDefiniteFailure</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const Twine &amp;message={})</td></tr>
<tr class="memitem:a428b91d18eabd5b259a3ed6e0f27f60c" id="r_a428b91d18eabd5b259a3ed6e0f27f60c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DiagnosedSilenceableFailure.html">DiagnosedSilenceableFailure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a428b91d18eabd5b259a3ed6e0f27f60c">emitSilenceableFailure</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, const Twine &amp;message={})</td></tr>
<tr class="memdesc:a428b91d18eabd5b259a3ed6e0f27f60c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits a silenceable failure with the given message.  <br /></td></tr>
<tr class="memitem:a078c07e9f16a6122a56bae420ce94308" id="r_a078c07e9f16a6122a56bae420ce94308"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DiagnosedSilenceableFailure.html">DiagnosedSilenceableFailure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a078c07e9f16a6122a56bae420ce94308">emitSilenceableFailure</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const Twine &amp;message={})</td></tr>
<tr class="memitem:a93db6f545964ed23f06b57618f09b33a" id="r_a93db6f545964ed23f06b57618f09b33a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93db6f545964ed23f06b57618f09b33a">computeSuffixProduct</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; sizes)</td></tr>
<tr class="memdesc:a93db6f545964ed23f06b57618f09b33a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of sizes, return the suffix product.  <br /></td></tr>
<tr class="memitem:a2d431e82eeecb3e976189fdcd8283004" id="r_a2d431e82eeecb3e976189fdcd8283004"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d431e82eeecb3e976189fdcd8283004">computeStrides</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; sizes)</td></tr>
<tr class="memitem:a1c7ccdb269314ad17ee4550b4bcb608a" id="r_a1c7ccdb269314ad17ee4550b4bcb608a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c7ccdb269314ad17ee4550b4bcb608a">computeElementwiseMul</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; v1, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; v2)</td></tr>
<tr class="memdesc:a1c7ccdb269314ad17ee4550b4bcb608a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing llvm::zip_equal(v1, v2) multiplied elementwise.  <br /></td></tr>
<tr class="memitem:aea26c0821fa35a09260cd1aeb694d0df" id="r_aea26c0821fa35a09260cd1aeb694d0df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint64__t.html">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea26c0821fa35a09260cd1aeb694d0df">computeSum</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; basis)</td></tr>
<tr class="memdesc:aea26c0821fa35a09260cd1aeb694d0df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Self-explicit.  <br /></td></tr>
<tr class="memitem:a68e66c407bcfb1b4bbba4693496dbdc6" id="r_a68e66c407bcfb1b4bbba4693496dbdc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint64__t.html">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68e66c407bcfb1b4bbba4693496dbdc6">computeProduct</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; basis)</td></tr>
<tr class="memdesc:a68e66c407bcfb1b4bbba4693496dbdc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Self-explicit.  <br /></td></tr>
<tr class="memitem:a9c157bd2c9cf4949b45235593f6ef994" id="r_a9c157bd2c9cf4949b45235593f6ef994"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint64__t.html">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c157bd2c9cf4949b45235593f6ef994">computeMaxLinearIndex</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; basis)</td></tr>
<tr class="memdesc:a9c157bd2c9cf4949b45235593f6ef994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements of basis (i.e.  <br /></td></tr>
<tr class="memitem:ac84b6a6dfd9d9eb78ca02c17cabbebed" id="r_ac84b6a6dfd9d9eb78ca02c17cabbebed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint64__t.html">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac84b6a6dfd9d9eb78ca02c17cabbebed">linearize</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; offsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; basis)</td></tr>
<tr class="memdesc:ac84b6a6dfd9d9eb78ca02c17cabbebed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the linearized index of 'offsets' w.r.t.  <br /></td></tr>
<tr class="memitem:a448d2cc69bc47c1304f4f1608937c3c4" id="r_a448d2cc69bc47c1304f4f1608937c3c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a448d2cc69bc47c1304f4f1608937c3c4">delinearize</a> (<a class="el" href="classint64__t.html">int64_t</a> linearIndex, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; strides)</td></tr>
<tr class="memdesc:a448d2cc69bc47c1304f4f1608937c3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the strides together with a linear index in the dimension space, return the vector-space offsets in each dimension for a de-linearized index.  <br /></td></tr>
<tr class="memitem:ad1c2ae63c247a9ba4509c8d1181127b0" id="r_ad1c2ae63c247a9ba4509c8d1181127b0"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1c2ae63c247a9ba4509c8d1181127b0">computeShapeRatio</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; shape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; subShape)</td></tr>
<tr class="memdesc:ad1c2ae63c247a9ba4509c8d1181127b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the multi-dimensional integral ratio of <span class="tt">subShape</span> to the trailing dimensions of <span class="tt">shape</span>.  <br /></td></tr>
<tr class="memitem:a530d6a928389d2f4c0234b059442a03a" id="r_a530d6a928389d2f4c0234b059442a03a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a530d6a928389d2f4c0234b059442a03a">computeSuffixProduct</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; sizes)</td></tr>
<tr class="memdesc:a530d6a928389d2f4c0234b059442a03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of sizes, return the suffix product.  <br /></td></tr>
<tr class="memitem:a511690ae218cc4d32852eae4eb1dd0bc" id="r_a511690ae218cc4d32852eae4eb1dd0bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a511690ae218cc4d32852eae4eb1dd0bc">computeStrides</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; sizes)</td></tr>
<tr class="memitem:ad0f77472da918076c9d2a222a501823f" id="r_ad0f77472da918076c9d2a222a501823f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0f77472da918076c9d2a222a501823f">computeElementwiseMul</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; v1, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; v2)</td></tr>
<tr class="memdesc:ad0f77472da918076c9d2a222a501823f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing llvm::zip_equal(v1, v2) multiplied elementwise.  <br /></td></tr>
<tr class="memitem:a4cb1a444a06409db3eedd783e7f9ab0b" id="r_a4cb1a444a06409db3eedd783e7f9ab0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cb1a444a06409db3eedd783e7f9ab0b">computeSum</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; basis)</td></tr>
<tr class="memdesc:a4cb1a444a06409db3eedd783e7f9ab0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Self-explicit.  <br /></td></tr>
<tr class="memitem:ada8d7a2a03264db5a6ac02a351f1e059" id="r_ada8d7a2a03264db5a6ac02a351f1e059"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada8d7a2a03264db5a6ac02a351f1e059">computeProduct</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; basis)</td></tr>
<tr class="memdesc:ada8d7a2a03264db5a6ac02a351f1e059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Self-explicit.  <br /></td></tr>
<tr class="memitem:ac2248838afeb293df08c1731f2d12fc2" id="r_ac2248838afeb293df08c1731f2d12fc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2248838afeb293df08c1731f2d12fc2">computeMaxLinearIndex</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; basis)</td></tr>
<tr class="memdesc:ac2248838afeb293df08c1731f2d12fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements of basis (i.e.  <br /></td></tr>
<tr class="memitem:a3e83fe20fc8231df5769e1eebe268bdd" id="r_a3e83fe20fc8231df5769e1eebe268bdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e83fe20fc8231df5769e1eebe268bdd">linearize</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; offsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; basis)</td></tr>
<tr class="memdesc:a3e83fe20fc8231df5769e1eebe268bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the linearized index of 'offsets' w.r.t.  <br /></td></tr>
<tr class="memitem:a1c0b8417b72fde91ffbc7d792fc97121" id="r_a1c0b8417b72fde91ffbc7d792fc97121"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c0b8417b72fde91ffbc7d792fc97121">linearize</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; offsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; basis)</td></tr>
<tr class="memitem:a1041856e784cdbf7811cd10bc5a5ffd6" id="r_a1041856e784cdbf7811cd10bc5a5ffd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1041856e784cdbf7811cd10bc5a5ffd6">delinearize</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> linearIndex, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; strides)</td></tr>
<tr class="memdesc:a1041856e784cdbf7811cd10bc5a5ffd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the strides together with a linear index in the dimension space, return the vector-space offsets in each dimension for a de-linearized index.  <br /></td></tr>
<tr class="memitem:a2830e5f60c269c339ef24c33d8f7fbf0" id="r_a2830e5f60c269c339ef24c33d8f7fbf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2830e5f60c269c339ef24c33d8f7fbf0">delinearize</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> linearIndex, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; strides)</td></tr>
<tr class="memitem:a3f2a0eb3232125bb6fa1a65302b8285d" id="r_a3f2a0eb3232125bb6fa1a65302b8285d"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a3f2a0eb3232125bb6fa1a65302b8285d template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f2a0eb3232125bb6fa1a65302b8285d">applyPermutation</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; T &gt; input, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; permutation)</td></tr>
<tr class="memitem:aa0b287d644de3e87a4f3e1d7cf31bd5a" id="r_aa0b287d644de3e87a4f3e1d7cf31bd5a"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:aa0b287d644de3e87a4f3e1d7cf31bd5a template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0b287d644de3e87a4f3e1d7cf31bd5a">applyPermutation</a> (const <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; T &gt; &amp;input, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; permutation)</td></tr>
<tr class="memitem:adbcff71555e8c1965e508f324f43a55a" id="r_adbcff71555e8c1965e508f324f43a55a"><td class="memTemplParams" colspan="2">template&lt;typename T, <a class="el" href="classunsigned.html">unsigned</a> N&gt; </td></tr>
<tr class="memitem:adbcff71555e8c1965e508f324f43a55a template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbcff71555e8c1965e508f324f43a55a">applyPermutationToVector</a> (<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; T, N &gt; &amp;inVec, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; permutation)</td></tr>
<tr class="memdesc:adbcff71555e8c1965e508f324f43a55a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the permutation defined by <span class="tt">permutation</span> to <span class="tt">inVec</span>.  <br /></td></tr>
<tr class="memitem:afc254f56cba37671e1e5b2b933c6a090" id="r_afc254f56cba37671e1e5b2b933c6a090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc254f56cba37671e1e5b2b933c6a090">invertPermutationVector</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; permutation)</td></tr>
<tr class="memdesc:afc254f56cba37671e1e5b2b933c6a090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to apply to inverse a permutation.  <br /></td></tr>
<tr class="memitem:a6cf90202d2d87692ea1b8d22068bffa7" id="r_a6cf90202d2d87692ea1b8d22068bffa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cf90202d2d87692ea1b8d22068bffa7">isIdentityPermutation</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; permutation)</td></tr>
<tr class="memdesc:a6cf90202d2d87692ea1b8d22068bffa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <span class="tt">permutation</span> is an identity permutation.  <br /></td></tr>
<tr class="memitem:aeb49fb26d8c1e3dc571db7ff9e34cb7f" id="r_aeb49fb26d8c1e3dc571db7ff9e34cb7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb49fb26d8c1e3dc571db7ff9e34cb7f">isPermutationVector</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; interchange)</td></tr>
<tr class="memdesc:aeb49fb26d8c1e3dc571db7ff9e34cb7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to check if an interchange vector is a permutation.  <br /></td></tr>
<tr class="memitem:a6eab61c26bfef3d7aaf3db051d58230b" id="r_a6eab61c26bfef3d7aaf3db051d58230b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6eab61c26bfef3d7aaf3db051d58230b">computePermutationVector</a> (<a class="el" href="classint64__t.html">int64_t</a> permSize, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; positions, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; desiredPositions)</td></tr>
<tr class="memdesc:a6eab61c26bfef3d7aaf3db051d58230b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a permutation vector of size permSize that would result in moving positions into desiredPositions.  <br /></td></tr>
<tr class="memitem:aeaf688b845e36e8284034d28fe9899bc" id="r_aeaf688b845e36e8284034d28fe9899bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeaf688b845e36e8284034d28fe9899bc">dropDims</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; inputPerm, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; dropPositions)</td></tr>
<tr class="memdesc:aeaf688b845e36e8284034d28fe9899bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a permutation vector that drop the input dims in dropPositions from inputPerm.  <br /></td></tr>
<tr class="memitem:a84637d8636fade36ebdd466b38527c23" id="r_a84637d8636fade36ebdd466b38527c23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84637d8636fade36ebdd466b38527c23">getI64SubArray</a> (<a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a> arrayAttr, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="CRunnerUtils_8h.html#aa3eaa688e40e1afbf39c1a4736aae30b">dropFront</a>=0, <a class="el" href="classunsigned.html">unsigned</a> dropBack=0)</td></tr>
<tr class="memdesc:a84637d8636fade36ebdd466b38527c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to return a subset of <span class="tt">arrayAttr</span> as a vector of <a class="el" href="classint64__t.html">int64_t</a>.  <br /></td></tr>
<tr class="memitem:a3eafff30d6e835bda8247cf34463df2c" id="r_a3eafff30d6e835bda8247cf34463df2c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3eafff30d6e835bda8247cf34463df2c">computeLinearIndex</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> sourceOffset, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; strides, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; <a class="el" href="AffineAnalysis_8cpp.html#a7b261d2d5f193015afc3427b0c0951ed">indices</a>)</td></tr>
<tr class="memdesc:a3eafff30d6e835bda8247cf34463df2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute linear index from provided strides and indices, assuming strided layout.  <br /></td></tr>
<tr class="memitem:a19e07ab53e78b29f77777f2ade29c9e8" id="r_a19e07ab53e78b29f77777f2ade29c9e8"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19e07ab53e78b29f77777f2ade29c9e8">computeLinearIndex</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> sourceOffset, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; strides, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; <a class="el" href="AffineAnalysis_8cpp.html#a7b261d2d5f193015afc3427b0c0951ed">indices</a>)</td></tr>
<tr class="memitem:a12acf2020ef95ce0a5d7c3f2bbb6af14" id="r_a12acf2020ef95ce0a5d7c3f2bbb6af14"><td class="memItemLeft" align="right" valign="top">constexpr StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12acf2020ef95ce0a5d7c3f2bbb6af14">getReassociationAttrName</a> ()</td></tr>
<tr class="memdesc:a12acf2020ef95ce0a5d7c3f2bbb6af14"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> name for the ArrayAttr which encodes reassociation indices.  <br /></td></tr>
<tr class="memitem:aab965622bbf0ccdfcb51384517fd3117" id="r_aab965622bbf0ccdfcb51384517fd3117"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab965622bbf0ccdfcb51384517fd3117">composeReassociationIndices</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt; producerReassociations, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt; consumerReassociations, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:aab965622bbf0ccdfcb51384517fd3117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose reassociation maps that are used in pair of reshape ops where one is a producer and other is the consumer.  <br /></td></tr>
<tr class="memitem:a9b2799e8f52860dadc460b88a8f2df32" id="r_a9b2799e8f52860dadc460b88a8f2df32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 2 &gt;, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b2799e8f52860dadc460b88a8f2df32">convertReassociationIndicesToExprs</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt; reassociationIndices)</td></tr>
<tr class="memdesc:a9b2799e8f52860dadc460b88a8f2df32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert reassociation indices to affine expressions.  <br /></td></tr>
<tr class="memitem:a561d5231fcefc471a4c9069fce2eaf87" id="r_a561d5231fcefc471a4c9069fce2eaf87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a561d5231fcefc471a4c9069fce2eaf87">getSymbolLessAffineMaps</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#a9d60419b09330b78865818c679695080">ReassociationExprs</a> &gt; reassociation)</td></tr>
<tr class="memdesc:a561d5231fcefc471a4c9069fce2eaf87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs affine maps out of Array&lt;Array&lt;AffineExpr&gt;&gt;.  <br /></td></tr>
<tr class="memitem:ae7220b1ee91536560d8599b5aceaea71" id="r_ae7220b1ee91536560d8599b5aceaea71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7220b1ee91536560d8599b5aceaea71">getReassociationIndicesAttribute</a> (<a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt; reassociation)</td></tr>
<tr class="memdesc:ae7220b1ee91536560d8599b5aceaea71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a list of reassociations in an ArrayAttr.  <br /></td></tr>
<tr class="memitem:a59a9251459ba0d0ff0b94d3084e429c4" id="r_a59a9251459ba0d0ff0b94d3084e429c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a>, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59a9251459ba0d0ff0b94d3084e429c4">convertReassociationMapsToIndices</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#a9d60419b09330b78865818c679695080">ReassociationExprs</a> &gt; reassociationExprs)</td></tr>
<tr class="memdesc:a59a9251459ba0d0ff0b94d3084e429c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Array&lt;Array&lt;AffineExpr&gt;&gt; to Array&lt;Array&lt;int64_t&gt;&gt;.  <br /></td></tr>
<tr class="memitem:a6783c78835273b8062a5b5e2a710d863" id="r_a6783c78835273b8062a5b5e2a710d863"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6783c78835273b8062a5b5e2a710d863">getReassociationIndicesForReshape</a> (ShapedType sourceType, ShapedType targetType)</td></tr>
<tr class="memdesc:a6783c78835273b8062a5b5e2a710d863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reassociations maps to use to reshape given the source type and the target type when possible.  <br /></td></tr>
<tr class="memitem:a76b303e750705222900d23e44f2a22ce" id="r_a76b303e750705222900d23e44f2a22ce"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76b303e750705222900d23e44f2a22ce">getReassociationIndicesForCollapse</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; sourceShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; targetShape)</td></tr>
<tr class="memdesc:a76b303e750705222900d23e44f2a22ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the reassociation maps to collapse <span class="tt">sourceShape</span> to <span class="tt">targetShape</span> if possible.  <br /></td></tr>
<tr class="memitem:a9e3d6f94b6a941066c3e7e5535817a9b" id="r_a9e3d6f94b6a941066c3e7e5535817a9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e3d6f94b6a941066c3e7e5535817a9b">isReassociationValid</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; reassociation, int *invalidIndex=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a9e3d6f94b6a941066c3e7e5535817a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the reassociation specification is valid, false otherwise.  <br /></td></tr>
<tr class="memitem:a2b0271e4a2b1e694242618a6e91a9c37" id="r_a2b0271e4a2b1e694242618a6e91a9c37"><td class="memTemplParams" colspan="2">template&lt;typename ReshapeOpTy, typename InverseReshapeOpTy&gt; </td></tr>
<tr class="memitem:a2b0271e4a2b1e694242618a6e91a9c37 template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b0271e4a2b1e694242618a6e91a9c37">foldReshapeOp</a> (ReshapeOpTy reshapeOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands)</td></tr>
<tr class="memitem:a10337918edd90e6a270db09d71d66dc5" id="r_a10337918edd90e6a270db09d71d66dc5"><td class="memItemLeft" align="right" valign="top">llvm::SmallBitVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10337918edd90e6a270db09d71d66dc5">getSlicedDimensions</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sliceInputShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; sliceParams)</td></tr>
<tr class="memdesc:a10337918edd90e6a270db09d71d66dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The input parameters <span class="tt">offsets</span>, <span class="tt">sizes</span>, <span class="tt">strides</span> specify a rectangular non rank-reducing slice of the collapse_shape output.  <br /></td></tr>
<tr class="memitem:ace39a548030ae8416f5ae52af1eb24e1" id="r_ace39a548030ae8416f5ae52af1eb24e1"><td class="memItemLeft" align="right" valign="top">llvm::SmallBitVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace39a548030ae8416f5ae52af1eb24e1">getLinearizedDimensions</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt; reassociationIndices)</td></tr>
<tr class="memdesc:ace39a548030ae8416f5ae52af1eb24e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine which dimensions are linearized by a <span class="tt">tensor.collapse_shape</span> op by inspecting its reassociation indices.  <br /></td></tr>
<tr class="memitem:a87f260b5183e13d54bcf371961d8051b" id="r_a87f260b5183e13d54bcf371961d8051b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87f260b5183e13d54bcf371961d8051b">isZeroInteger</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> v)</td></tr>
<tr class="memdesc:a87f260b5183e13d54bcf371961d8051b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <span class="tt">v</span> is an IntegerAttr with value <span class="tt">0</span>.  <br /></td></tr>
<tr class="memitem:af0f2798d2b9db90ac8a8f2b7a0958327" id="r_af0f2798d2b9db90ac8a8f2b7a0958327"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0f2798d2b9db90ac8a8f2b7a0958327">isOneInteger</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> v)</td></tr>
<tr class="memdesc:af0f2798d2b9db90ac8a8f2b7a0958327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <span class="tt">v</span> is an IntegerAttr with value <span class="tt">1</span>.  <br /></td></tr>
<tr class="memitem:a0d96a98d184d13853b53c410d814775c" id="r_a0d96a98d184d13853b53c410d814775c"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d96a98d184d13853b53c410d814775c">getOffsetsSizesAndStrides</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; ranges)</td></tr>
<tr class="memdesc:a0d96a98d184d13853b53c410d814775c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an array of <a class="el" href="structmlir_1_1Range.html" title="Represents a range (offset, size, and stride) where each element of the triple may be dynamic or stat...">Range</a> values, return a tuple of (offset vector, sizes vector, and strides vector) formed by separating out the individual elements of each range.  <br /></td></tr>
<tr class="memitem:abf9a8d86f0213b02a553c01aea31e6e4" id="r_abf9a8d86f0213b02a553c01aea31e6e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf9a8d86f0213b02a553c01aea31e6e4">dispatchIndexOpFoldResult</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;dynamicVec, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &amp;staticVec)</td></tr>
<tr class="memdesc:abf9a8d86f0213b02a553c01aea31e6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to dispatch an <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> into <span class="tt">staticVec</span> if: a) it is an IntegerAttr In other cases, the <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> is dispached to the <span class="tt">dynamicVec</span>.  <br /></td></tr>
<tr class="memitem:a923d05c8f39df57cf19f1ec709bbe5a5" id="r_a923d05c8f39df57cf19f1ec709bbe5a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a923d05c8f39df57cf19f1ec709bbe5a5">dispatchIndexOpFoldResults</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ofrs, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;dynamicVec, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &amp;staticVec)</td></tr>
<tr class="memdesc:a923d05c8f39df57cf19f1ec709bbe5a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to dispatch multiple OpFoldResults according to the behavior of <span class="tt">dispatchIndexOpFoldResult(<a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> ofr</span> for a single <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a>.  <br /></td></tr>
<tr class="memitem:ad533bd7ca28e9b550e615d21e6ac2c8b" id="r_ad533bd7ca28e9b550e615d21e6ac2c8b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classint64__t.html">int64_t</a>, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad533bd7ca28e9b550e615d21e6ac2c8b">getSimplifiedOfrAndStaticSizePair</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr, <a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>)</td></tr>
<tr class="memdesc:ad533bd7ca28e9b550e615d21e6ac2c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> representing dim size value (*), generates a pair of sizes:  <br /></td></tr>
<tr class="memitem:ad6a57f568be3df657740d74ad2fa382f" id="r_ad6a57f568be3df657740d74ad2fa382f"><td class="memTemplParams" colspan="2">template&lt;typename IntTy&gt; </td></tr>
<tr class="memitem:ad6a57f568be3df657740d74ad2fa382f template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; IntTy &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6a57f568be3df657740d74ad2fa382f">extractFromIntegerArrayAttr</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="memdesc:ad6a57f568be3df657740d74ad2fa382f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract integer values from the assumed ArrayAttr of IntegerAttr.  <br /></td></tr>
<tr class="memitem:ac19b7af1333485b34ebfe4bf6300c362" id="r_ac19b7af1333485b34ebfe4bf6300c362"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac19b7af1333485b34ebfe4bf6300c362">getAsOpFoldResult</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:ac19b7af1333485b34ebfe4bf6300c362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a value, try to extract a constant <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>.  <br /></td></tr>
<tr class="memitem:a0f4688956ac5cd539b0b3e134af30248" id="r_a0f4688956ac5cd539b0b3e134af30248"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f4688956ac5cd539b0b3e134af30248">getAsOpFoldResult</a> (<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values)</td></tr>
<tr class="memdesc:a0f4688956ac5cd539b0b3e134af30248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an array of values, try to extract a constant <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> from each value.  <br /></td></tr>
<tr class="memitem:a622f03f8cb8e4cfde7e34c30e9aa02b6" id="r_a622f03f8cb8e4cfde7e34c30e9aa02b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a622f03f8cb8e4cfde7e34c30e9aa02b6">getAsOpFoldResult</a> (<a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a> arrayAttr)</td></tr>
<tr class="memdesc:a622f03f8cb8e4cfde7e34c30e9aa02b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <span class="tt">arrayAttr</span> to a vector of <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a>.  <br /></td></tr>
<tr class="memitem:a0c18958fe34840cfafad41a1226f7a68" id="r_a0c18958fe34840cfafad41a1226f7a68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c18958fe34840cfafad41a1226f7a68">getAsIndexOpFoldResult</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classint64__t.html">int64_t</a> val)</td></tr>
<tr class="memdesc:a0c18958fe34840cfafad41a1226f7a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <a class="el" href="classint64__t.html">int64_t</a> to integer attributes of index type and return them as <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a>.  <br /></td></tr>
<tr class="memitem:aa18214f3aabbab8c3e5197b719ba72dc" id="r_aa18214f3aabbab8c3e5197b719ba72dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa18214f3aabbab8c3e5197b719ba72dc">getAsIndexOpFoldResult</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; values)</td></tr>
<tr class="memitem:a7335030e42a74c6badff43ebf110d896" id="r_a7335030e42a74c6badff43ebf110d896"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::pair&lt; APInt, <a class="el" href="classbool.html">bool</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7335030e42a74c6badff43ebf110d896">getConstantAPIntValue</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr)</td></tr>
<tr class="memdesc:a7335030e42a74c6badff43ebf110d896"><td class="mdescLeft">&#160;</td><td class="mdescRight">If ofr is a constant integer or an IntegerAttr, return the integer.  <br /></td></tr>
<tr class="memitem:a22bfcc5fa9deffb32e7c39183f732c90" id="r_a22bfcc5fa9deffb32e7c39183f732c90"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22bfcc5fa9deffb32e7c39183f732c90">getConstantIntValue</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr)</td></tr>
<tr class="memdesc:a22bfcc5fa9deffb32e7c39183f732c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">If ofr is a constant integer or an IntegerAttr, return the integer.  <br /></td></tr>
<tr class="memitem:addda9c80b032fe1ec781a4317d45725f" id="r_addda9c80b032fe1ec781a4317d45725f"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addda9c80b032fe1ec781a4317d45725f">getConstantIntValues</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ofrs)</td></tr>
<tr class="memdesc:addda9c80b032fe1ec781a4317d45725f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If all ofrs are constant integers or IntegerAttrs, return the integers.  <br /></td></tr>
<tr class="memitem:a043789541ff1881513700b717bf5491d" id="r_a043789541ff1881513700b717bf5491d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a043789541ff1881513700b717bf5491d">isConstantIntValue</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr, <a class="el" href="classint64__t.html">int64_t</a> value)</td></tr>
<tr class="memdesc:a043789541ff1881513700b717bf5491d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <span class="tt">ofr</span> is constant integer equal to <span class="tt">value</span>.  <br /></td></tr>
<tr class="memitem:a2d5371859b520e2bba7334d675f9cad8" id="r_a2d5371859b520e2bba7334d675f9cad8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d5371859b520e2bba7334d675f9cad8">areAllConstantIntValue</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ofrs, <a class="el" href="classint64__t.html">int64_t</a> value)</td></tr>
<tr class="memdesc:a2d5371859b520e2bba7334d675f9cad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all of <span class="tt">ofrs</span> are constant integers equal to <span class="tt">value</span>.  <br /></td></tr>
<tr class="memitem:a0bd3fa6148f71be3287a672b843f55f1" id="r_a0bd3fa6148f71be3287a672b843f55f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0bd3fa6148f71be3287a672b843f55f1">areConstantIntValues</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ofrs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; values)</td></tr>
<tr class="memdesc:a0bd3fa6148f71be3287a672b843f55f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all of <span class="tt">ofrs</span> are constant integers equal to the corresponding value in <span class="tt">values</span>.  <br /></td></tr>
<tr class="memitem:a2ee77c6f0feb82212b1b817785f95f48" id="r_a2ee77c6f0feb82212b1b817785f95f48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ee77c6f0feb82212b1b817785f95f48">isEqualConstantIntOrValue</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr1, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr2)</td></tr>
<tr class="memdesc:a2ee77c6f0feb82212b1b817785f95f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if ofr1 and ofr2 are the same integer constant attribute values or the same SSA value.  <br /></td></tr>
<tr class="memitem:ab03d63917414f04e985c804f24086b76" id="r_ab03d63917414f04e985c804f24086b76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab03d63917414f04e985c804f24086b76">isEqualConstantIntOrValueArray</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ofrs1, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ofrs2)</td></tr>
<tr class="memitem:a05b6893963209031e53537629a129df5" id="r_a05b6893963209031e53537629a129df5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05b6893963209031e53537629a129df5">getMixedValues</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; staticValues, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> dynamicValues, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a05b6893963209031e53537629a129df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of OpFoldResults with the same size a staticValues, but all elements for which ShapedType::isDynamic is true, will be replaced by dynamicValues.  <br /></td></tr>
<tr class="memitem:abe07ed04a2b4a8d370ba318bb94316a2" id="r_abe07ed04a2b4a8d370ba318bb94316a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe07ed04a2b4a8d370ba318bb94316a2">getMixedValues</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; staticValues, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> dynamicValues, <a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>)</td></tr>
<tr class="memitem:af97b84cc5405247356b5af71ef661d9b" id="r_af97b84cc5405247356b5af71ef661d9b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af97b84cc5405247356b5af71ef661d9b">decomposeMixedValues</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mixedValues)</td></tr>
<tr class="memdesc:af97b84cc5405247356b5af71ef661d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose a vector of mixed static or dynamic values into the corresponding pair of arrays.  <br /></td></tr>
<tr class="memitem:ae8b5c05e14ade6108624f49c4c8bf104" id="r_ae8b5c05e14ade6108624f49c4c8bf104"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8b5c05e14ade6108624f49c4c8bf104">getValuesSortedByKey</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; keys, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; values, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt; compare)</td></tr>
<tr class="memdesc:ae8b5c05e14ade6108624f49c4c8bf104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to sort <span class="tt">values</span> according to matching <span class="tt">keys</span>.  <br /></td></tr>
<tr class="memitem:af3ec25d896f63f835649e57fa1156deb" id="r_af3ec25d896f63f835649e57fa1156deb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3ec25d896f63f835649e57fa1156deb">getValuesSortedByKey</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; keys, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; values, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt; compare)</td></tr>
<tr class="memitem:ad2bf7271ea0c5e95377e621f7923baa7" id="r_ad2bf7271ea0c5e95377e621f7923baa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2bf7271ea0c5e95377e621f7923baa7">getValuesSortedByKey</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; keys, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; values, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt; compare)</td></tr>
<tr class="memitem:a653bf589569eab36eb696bc4db3371c6" id="r_a653bf589569eab36eb696bc4db3371c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a653bf589569eab36eb696bc4db3371c6">hasValidSizesOffsets</a> (<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; sizesOrOffsets)</td></tr>
<tr class="memdesc:a653bf589569eab36eb696bc4db3371c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to check whether the passed in <span class="tt">sizes</span> or <span class="tt">offsets</span> are valid.  <br /></td></tr>
<tr class="memitem:a88795bccdeef2b7388f2bbd6d1c15ae7" id="r_a88795bccdeef2b7388f2bbd6d1c15ae7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88795bccdeef2b7388f2bbd6d1c15ae7">hasValidStrides</a> (<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; strides)</td></tr>
<tr class="memdesc:a88795bccdeef2b7388f2bbd6d1c15ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to check whether the passed in <span class="tt">strides</span> are valid.  <br /></td></tr>
<tr class="memitem:afccef918a87cccab273bba3cb00beed7" id="r_afccef918a87cccab273bba3cb00beed7"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afccef918a87cccab273bba3cb00beed7">foldDynamicIndexList</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;ofrs, <a class="el" href="classbool.html">bool</a> onlyNonNegative=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>, <a class="el" href="classbool.html">bool</a> onlyNonZero=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:afccef918a87cccab273bba3cb00beed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns "success" when any of the elements in <span class="tt">ofrs</span> is a constant value.  <br /></td></tr>
<tr class="memitem:af04a9037c5785dac1e037c025297c4da" id="r_af04a9037c5785dac1e037c025297c4da"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af04a9037c5785dac1e037c025297c4da">foldDynamicOffsetSizeList</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;offsetsOrSizes)</td></tr>
<tr class="memdesc:af04a9037c5785dac1e037c025297c4da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns "success" when any of the elements in <span class="tt">offsetsOrSizes</span> is a constant value.  <br /></td></tr>
<tr class="memitem:a26f1eae6696c52c728b7109da9e8ceb8" id="r_a26f1eae6696c52c728b7109da9e8ceb8"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26f1eae6696c52c728b7109da9e8ceb8">foldDynamicStrideList</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;strides)</td></tr>
<tr class="memdesc:a26f1eae6696c52c728b7109da9e8ceb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns "success" when any of the elements in <span class="tt">strides</span> is a constant value.  <br /></td></tr>
<tr class="memitem:af2c57691c632b0f92b39c265af63a96d" id="r_af2c57691c632b0f92b39c265af63a96d"><td class="memItemLeft" align="right" valign="top">std::optional&lt; APInt &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2c57691c632b0f92b39c265af63a96d">constantTripCount</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> lb, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ub, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> step, <a class="el" href="classbool.html">bool</a> isSigned, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; std::optional&lt; llvm::APSInt &gt;(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classbool.html">bool</a>)&gt; computeUbMinusLb)</td></tr>
<tr class="memdesc:af2c57691c632b0f92b39c265af63a96d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of iterations for a loop with a lower bound <span class="tt">lb</span>, upper bound <span class="tt">ub</span> and step <span class="tt">step</span>.  <br /></td></tr>
<tr class="memitem:ae53f9bcf99efe125a11237ad6b64642c" id="r_ae53f9bcf99efe125a11237ad6b64642c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae53f9bcf99efe125a11237ad6b64642c">isRowMajorMatmul</a> (<a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a> indexingMaps)</td></tr>
<tr class="memdesc:ae53f9bcf99efe125a11237ad6b64642c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the given maps describe a row major matmul.  <br /></td></tr>
<tr class="memitem:a0dfea8ee2dd0eba944b0cd299591ccf9" id="r_a0dfea8ee2dd0eba944b0cd299591ccf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0dfea8ee2dd0eba944b0cd299591ccf9">isColumnMajorMatmul</a> (<a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a> indexingMaps)</td></tr>
<tr class="memdesc:a0dfea8ee2dd0eba944b0cd299591ccf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the given maps describe a column major matmul.  <br /></td></tr>
<tr class="memitem:aa28d7afae3a8e6d54489b5857b938d07" id="r_aa28d7afae3a8e6d54489b5857b938d07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa28d7afae3a8e6d54489b5857b938d07">isRowMajorBatchMatmul</a> (<a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a> indexingMaps)</td></tr>
<tr class="memdesc:aa28d7afae3a8e6d54489b5857b938d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the given maps describe a row major batch matmul.  <br /></td></tr>
<tr class="memitem:ac5fb321c11f8758094dbc4ece855d206" id="r_ac5fb321c11f8758094dbc4ece855d206"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5fb321c11f8758094dbc4ece855d206">isVecmat</a> (<a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a> indexingMaps)</td></tr>
<tr class="memdesc:ac5fb321c11f8758094dbc4ece855d206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the given maps describe a vector matrix multiplication.  <br /></td></tr>
<tr class="memitem:a9c3a18535f4146298157c782e5254e94" id="r_a9c3a18535f4146298157c782e5254e94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c3a18535f4146298157c782e5254e94">isBatchVecmat</a> (<a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a> indexingMaps)</td></tr>
<tr class="memdesc:a9c3a18535f4146298157c782e5254e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the given maps describe a batch vector matrix multiplication.  <br /></td></tr>
<tr class="memitem:a50aeecdfac818acb74f464b9f19a030e" id="r_a50aeecdfac818acb74f464b9f19a030e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50aeecdfac818acb74f464b9f19a030e">isMatvec</a> (<a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a> indexingMaps)</td></tr>
<tr class="memdesc:a50aeecdfac818acb74f464b9f19a030e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the given maps describe a matrix vector multiplication.  <br /></td></tr>
<tr class="memitem:a2823559fb2fadd8959a578eecc499342" id="r_a2823559fb2fadd8959a578eecc499342"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2823559fb2fadd8959a578eecc499342">isBatchMatvec</a> (<a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a> indexingMaps)</td></tr>
<tr class="memdesc:a2823559fb2fadd8959a578eecc499342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the given maps describe a batch matrix vector multiplication.  <br /></td></tr>
<tr class="memitem:adb672e2258ecd8657ec36b0fd391208a" id="r_adb672e2258ecd8657ec36b0fd391208a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb672e2258ecd8657ec36b0fd391208a">findPositionsOfType</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; utils::IteratorType &gt; iteratorTypes, utils::IteratorType iteratorTypeName, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;res)</td></tr>
<tr class="memdesc:adb672e2258ecd8657ec36b0fd391208a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return positions in <span class="tt">iteratorTypes</span> that match <span class="tt">iteratorTypeName</span>.  <br /></td></tr>
<tr class="memitem:ab07dda6e0df087e91b18fdb2b8bfe5aa" id="r_ab07dda6e0df087e91b18fdb2b8bfe5aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab07dda6e0df087e91b18fdb2b8bfe5aa">clone</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> newResultTypes, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newOperands)</td></tr>
<tr class="memitem:aa75b562b2c25a3d66295d10efde0b996" id="r_aa75b562b2c25a3d66295d10efde0b996"><td class="memTemplParams" colspan="2">template&lt;typename OpT&gt; </td></tr>
<tr class="memitem:aa75b562b2c25a3d66295d10efde0b996 template"><td class="memItemLeft" align="right" valign="top">OpT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa75b562b2c25a3d66295d10efde0b996">clone</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, OpT op, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> newResultTypes, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newOperands)</td></tr>
<tr class="memitem:a49429f945b2bca0efdd4c315bb68505b" id="r_a49429f945b2bca0efdd4c315bb68505b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49429f945b2bca0efdd4c315bb68505b">cloneWithoutRegions</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> newResultTypes, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newOperands)</td></tr>
<tr class="memitem:aeba376b9b63ed400e64bb041e459a62e" id="r_aeba376b9b63ed400e64bb041e459a62e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeba376b9b63ed400e64bb041e459a62e">getPrunedAttributeList</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt; elidedAttrs)</td></tr>
<tr class="memitem:a05930f6194dee5366651710de8da45c9" id="r_a05930f6194dee5366651710de8da45c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05930f6194dee5366651710de8da45c9">populateX86VectorLegalizeForLLVMExportPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a05930f6194dee5366651710de8da45c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to lower X86Vector ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <br /></td></tr>
<tr class="memitem:afa8013cee2241cd53aa923b23e4e3575" id="r_afa8013cee2241cd53aa923b23e4e3575"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa8013cee2241cd53aa923b23e4e3575">configureX86VectorLegalizeForExportTarget</a> (<a class="el" href="classmlir_1_1LLVMConversionTarget.html">LLVMConversionTarget</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a5d2c023108742a1ce78ba9823c06ea35">target</a>)</td></tr>
<tr class="memdesc:afa8013cee2241cd53aa923b23e4e3575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the target to support lowering X86Vector ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <br /></td></tr>
<tr class="memitem:a4bfe9337070eb0f67cb7a3098ee136ee" id="r_a4bfe9337070eb0f67cb7a3098ee136ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bfe9337070eb0f67cb7a3098ee136ee">JitRunnerMain</a> (int argc, char **argv, const <a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry, <a class="el" href="structmlir_1_1JitRunnerConfig.html">JitRunnerConfig</a> <a class="el" href="#a3ecea12db18ed347ea11d1d999237b24">config</a>={})</td></tr>
<tr class="memdesc:a4bfe9337070eb0f67cb7a3098ee136ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for all CPU runners.  <br /></td></tr>
<tr class="memitem:a159f88d87b78c353731e1661c65a0b98" id="r_a159f88d87b78c353731e1661c65a0b98"><td class="memItemLeft" align="right" valign="top">std::function&lt; llvm::Error(llvm::Module *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a159f88d87b78c353731e1661c65a0b98">makeOptimizingTransformer</a> (<a class="el" href="classunsigned.html">unsigned</a> optLevel, <a class="el" href="classunsigned.html">unsigned</a> sizeLevel, llvm::TargetMachine *targetMachine)</td></tr>
<tr class="memdesc:a159f88d87b78c353731e1661c65a0b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a module transformer function for MLIR <a class="el" href="classmlir_1_1ExecutionEngine.html" title="JIT-backed execution engine for MLIR.">ExecutionEngine</a> that runs <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR passes corresponding to the given speed and size optimization levels (e.g.  <br /></td></tr>
<tr class="memitem:afe55df95d48191f0fa2c5ab8f4e81e34" id="r_afe55df95d48191f0fa2c5ab8f4e81e34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe55df95d48191f0fa2c5ab8f4e81e34">registerAllDialects</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:afe55df95d48191f0fa2c5ab8f4e81e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all the MLIR dialects to the provided registry.  <br /></td></tr>
<tr class="memitem:a5fcd07e2ad26a58627d961ce8e544f1b" id="r_a5fcd07e2ad26a58627d961ce8e544f1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fcd07e2ad26a58627d961ce8e544f1b">registerAllDialects</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a5fcd07e2ad26a58627d961ce8e544f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append all the MLIR dialects to the registry contained in the given context.  <br /></td></tr>
<tr class="memitem:af478d18d439a803300e8e086d32bbb6e" id="r_af478d18d439a803300e8e086d32bbb6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af478d18d439a803300e8e086d32bbb6e">registerAllExtensions</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:af478d18d439a803300e8e086d32bbb6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function may be called to register all MLIR dialect extensions with the provided registry.  <br /></td></tr>
<tr class="memitem:afb552a159c6c887b98b3583dfd5cbe5d" id="r_afb552a159c6c887b98b3583dfd5cbe5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb552a159c6c887b98b3583dfd5cbe5d">registerAllPasses</a> ()</td></tr>
<tr class="memitem:a7a267e7e7ec38e0a09285a20831414d3" id="r_a7a267e7e7ec38e0a09285a20831414d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a267e7e7ec38e0a09285a20831414d3">registerFromLLVMIRTranslation</a> ()</td></tr>
<tr class="memitem:a51ef91a9901d4d87a042990ccb79f2be" id="r_a51ef91a9901d4d87a042990ccb79f2be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51ef91a9901d4d87a042990ccb79f2be">registerFromSPIRVTranslation</a> ()</td></tr>
<tr class="memitem:a3985663c2b0a51493efab15e2f9f06bc" id="r_a3985663c2b0a51493efab15e2f9f06bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3985663c2b0a51493efab15e2f9f06bc">registerFromWasmTranslation</a> ()</td></tr>
<tr class="memitem:a520bc0aa5f34c15a39f2202fdf521382" id="r_a520bc0aa5f34c15a39f2202fdf521382"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a520bc0aa5f34c15a39f2202fdf521382">registerToCppTranslation</a> ()</td></tr>
<tr class="memitem:a003d72c96a8bffacc207ba165212e2db" id="r_a003d72c96a8bffacc207ba165212e2db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a003d72c96a8bffacc207ba165212e2db">registerToLLVMIRTranslation</a> ()</td></tr>
<tr class="memitem:af7f5d34c37689ae9b05537a040d9e0a0" id="r_af7f5d34c37689ae9b05537a040d9e0a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7f5d34c37689ae9b05537a040d9e0a0">registerToSPIRVTranslation</a> ()</td></tr>
<tr class="memitem:a8d16808b31b66905b067720d428adf61" id="r_a8d16808b31b66905b067720d428adf61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d16808b31b66905b067720d428adf61">registerAllTranslations</a> ()</td></tr>
<tr class="memitem:a62534636110d65226b611986e9a316a1" id="r_a62534636110d65226b611986e9a316a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62534636110d65226b611986e9a316a1">operator!=</a> (<a class="el" href="classmlir_1_1RegionBranchPoint.html">RegionBranchPoint</a> <a class="el" href="IR_2AffineExpr_8cpp.html#a204f446339af7929852f44df41484be5">lhs</a>, <a class="el" href="classmlir_1_1RegionBranchPoint.html">RegionBranchPoint</a> <a class="el" href="VectorTransforms_8cpp.html#a611c177776150f2e11f15c1cec5764c1">rhs</a>)</td></tr>
<tr class="memitem:aa96fcd93e4a339c2cff5c75bf37447e8" id="r_aa96fcd93e4a339c2cff5c75bf37447e8"><td class="memItemLeft" align="right" valign="top">llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa96fcd93e4a339c2cff5c75bf37447e8">operator&lt;&lt;</a> (llvm::raw_ostream &amp;os, <a class="el" href="classmlir_1_1RegionBranchPoint.html">RegionBranchPoint</a> point)</td></tr>
<tr class="memitem:ae4193648916732525e8b9ffff25b7140" id="r_ae4193648916732525e8b9ffff25b7140"><td class="memItemLeft" align="right" valign="top">llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4193648916732525e8b9ffff25b7140">operator&lt;&lt;</a> (llvm::raw_ostream &amp;os, <a class="el" href="classmlir_1_1RegionSuccessor.html">RegionSuccessor</a> successor)</td></tr>
<tr class="memitem:a426b7e62d7400b01d368a3db835df9d3" id="r_a426b7e62d7400b01d368a3db835df9d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a426b7e62d7400b01d368a3db835df9d3">insideMutuallyExclusiveRegions</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *a, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>)</td></tr>
<tr class="memdesc:a426b7e62d7400b01d368a3db835df9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <span class="tt">true</span> if <span class="tt">a</span> and <span class="tt">b</span> are in mutually exclusive regions as per RegionBranchOpInterface.  <br /></td></tr>
<tr class="memitem:a59222c6d1f54e57a5f71291f205911da" id="r_a59222c6d1f54e57a5f71291f205911da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59222c6d1f54e57a5f71291f205911da">getEnclosingRepetitiveRegion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a59222c6d1f54e57a5f71291f205911da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first enclosing region of the given op that may be executed repetitively as per RegionBranchOpInterface or <span class="tt">nullptr</span> if no such region exists.  <br /></td></tr>
<tr class="memitem:abea4281da1b0006e0c9622cff14858a7" id="r_abea4281da1b0006e0c9622cff14858a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abea4281da1b0006e0c9622cff14858a7">getEnclosingRepetitiveRegion</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:abea4281da1b0006e0c9622cff14858a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first enclosing region of the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> that may be executed repetitively as per RegionBranchOpInterface or <span class="tt">nullptr</span> if no such region exists.  <br /></td></tr>
<tr class="memitem:a9d68b8241f5fecc2c47b23acbb6910c8" id="r_a9d68b8241f5fecc2c47b23acbb6910c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d68b8241f5fecc2c47b23acbb6910c8">operator&lt;&lt;</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, const <a class="el" href="classmlir_1_1ConstantIntRanges.html">ConstantIntRanges</a> &amp;range)</td></tr>
<tr class="memitem:ab96f3b26c90ea659c4be029b0e410cd3" id="r_ab96f3b26c90ea659c4be029b0e410cd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab96f3b26c90ea659c4be029b0e410cd3">operator&lt;&lt;</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;, const <a class="el" href="classmlir_1_1IntegerValueRange.html">IntegerValueRange</a> &amp;)</td></tr>
<tr class="memitem:a781931f0aa43382f928cd17998c615c3" id="r_a781931f0aa43382f928cd17998c615c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1IntegerValueRange.html">IntegerValueRange</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a781931f0aa43382f928cd17998c615c3">getIntValueRanges</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; values, <a class="el" href="#afbe7bd7ebed80ba2be13ab5e9387f3fe">GetIntRangeFn</a> getIntRange, int32_t indexBitwidth)</td></tr>
<tr class="memdesc:a781931f0aa43382f928cd17998c615c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to collect the integer range values of an array of op fold results.  <br /></td></tr>
<tr class="memitem:acad8f15b79c90ee0690435ef9f1377bf" id="r_acad8f15b79c90ee0690435ef9f1377bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acad8f15b79c90ee0690435ef9f1377bf">operator&lt;&lt;</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, const <a class="el" href="classmlir_1_1StridedMetadataRange.html">StridedMetadataRange</a> &amp;range)</td></tr>
<tr class="memdesc:acad8f15b79c90ee0690435ef9f1377bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the strided metadata to <span class="tt">os</span>.  <br /></td></tr>
<tr class="memitem:a24aeba82a83b5f51bfe338ed5156887a" id="r_a24aeba82a83b5f51bfe338ed5156887a"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24aeba82a83b5f51bfe338ed5156887a">reifyResultShapes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="#a676bc3fbf14bd5dba33f962b259d2034">ReifiedRankedShapedTypeDims</a> &amp;reifiedReturnShapes)</td></tr>
<tr class="memdesc:a24aeba82a83b5f51bfe338ed5156887a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reify the shape of the result of an operation (typically in terms of the shape of its operands).  <br /></td></tr>
<tr class="memitem:afa982da5f726a3b3bfd9b416ae933ea3" id="r_afa982da5f726a3b3bfd9b416ae933ea3"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa982da5f726a3b3bfd9b416ae933ea3">reifyShapeOfResult</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, int resultIndex)</td></tr>
<tr class="memitem:a59ab8abadf1cca831e879d1f8058aecf" id="r_a59ab8abadf1cca831e879d1f8058aecf"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59ab8abadf1cca831e879d1f8058aecf">reifyDimOfResult</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, int resultIndex, int dim)</td></tr>
<tr class="memitem:ad9b46b5604ddc7a8a370d1064ad5108c" id="r_ad9b46b5604ddc7a8a370d1064ad5108c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9b46b5604ddc7a8a370d1064ad5108c">hasUnknownEffects</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ad9b46b5604ddc7a8a370d1064ad5108c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return "true" if <span class="tt">op</span> has unknown effects.  <br /></td></tr>
<tr class="memitem:a54bdf3d5eaaef529cc7cf1ea0fa1808b" id="r_a54bdf3d5eaaef529cc7cf1ea0fa1808b"><td class="memTemplParams" colspan="2">template&lt;typename EffectTy&gt; </td></tr>
<tr class="memitem:a54bdf3d5eaaef529cc7cf1ea0fa1808b template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54bdf3d5eaaef529cc7cf1ea0fa1808b">hasSingleEffect</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a54bdf3d5eaaef529cc7cf1ea0fa1808b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns "true" if <span class="tt">op</span> has only an effect of type <span class="tt">EffectTy</span>.  <br /></td></tr>
<tr class="memitem:a4e5c028078f8fdc86950f374b834cb07" id="r_a4e5c028078f8fdc86950f374b834cb07"><td class="memTemplParams" colspan="2">template&lt;typename EffectTy&gt; </td></tr>
<tr class="memitem:a4e5c028078f8fdc86950f374b834cb07 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e5c028078f8fdc86950f374b834cb07">hasSingleEffect</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:a4e5c028078f8fdc86950f374b834cb07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns "true" if <span class="tt">op</span> has only an effect of type <span class="tt">EffectTy</span> on <span class="tt">value</span>.  <br /></td></tr>
<tr class="memitem:a1879b99cadf0d3c0c5de98b33412b650" id="r_a1879b99cadf0d3c0c5de98b33412b650"><td class="memTemplParams" colspan="2">template&lt;typename ValueTy, typename EffectTy&gt; </td></tr>
<tr class="memitem:a1879b99cadf0d3c0c5de98b33412b650 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1879b99cadf0d3c0c5de98b33412b650">hasSingleEffect</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, ValueTy value)</td></tr>
<tr class="memdesc:a1879b99cadf0d3c0c5de98b33412b650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns "true" if <span class="tt">op</span> has only an effect of type <span class="tt">EffectTy</span> on <span class="tt">value</span> of type <span class="tt">ValueTy</span>.  <br /></td></tr>
<tr class="memitem:ac155ca106ea75d1bf8f9b995d7e2d99d" id="r_ac155ca106ea75d1bf8f9b995d7e2d99d"><td class="memTemplParams" colspan="2">template&lt;typename... EffectTys&gt; </td></tr>
<tr class="memitem:ac155ca106ea75d1bf8f9b995d7e2d99d template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac155ca106ea75d1bf8f9b995d7e2d99d">hasEffect</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ac155ca106ea75d1bf8f9b995d7e2d99d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns "true" if <span class="tt">op</span> has an effect of type <span class="tt">EffectTy</span>.  <br /></td></tr>
<tr class="memitem:ae27d7e4ff6226389cfa4a4a5129caea0" id="r_ae27d7e4ff6226389cfa4a4a5129caea0"><td class="memTemplParams" colspan="2">template&lt;typename... EffectTys&gt; </td></tr>
<tr class="memitem:ae27d7e4ff6226389cfa4a4a5129caea0 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae27d7e4ff6226389cfa4a4a5129caea0">hasEffect</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:ae27d7e4ff6226389cfa4a4a5129caea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns "true" if <span class="tt">op</span> has an effect of type <span class="tt">EffectTy</span> on <span class="tt">value</span>.  <br /></td></tr>
<tr class="memitem:a4bc8a79e07b7e048723a9fbfe9bc914e" id="r_a4bc8a79e07b7e048723a9fbfe9bc914e"><td class="memTemplParams" colspan="2">template&lt;typename ValueTy, typename... EffectTys&gt; </td></tr>
<tr class="memitem:a4bc8a79e07b7e048723a9fbfe9bc914e template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bc8a79e07b7e048723a9fbfe9bc914e">hasEffect</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, ValueTy value)</td></tr>
<tr class="memdesc:a4bc8a79e07b7e048723a9fbfe9bc914e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns "true" if <span class="tt">op</span> has an effect of type <span class="tt">EffectTy</span> on <span class="tt">value</span> of type <span class="tt">ValueTy</span>.  <br /></td></tr>
<tr class="memitem:ae5dd2f85ac8fc28edb96c1bc73f3ad0e" id="r_ae5dd2f85ac8fc28edb96c1bc73f3ad0e"><td class="memTemplParams" colspan="2">template&lt;typename... EffectTys&gt; </td></tr>
<tr class="memitem:ae5dd2f85ac8fc28edb96c1bc73f3ad0e template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5dd2f85ac8fc28edb96c1bc73f3ad0e">mightHaveEffect</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ae5dd2f85ac8fc28edb96c1bc73f3ad0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns "true" if <span class="tt">op</span> might have an effect of type <span class="tt">EffectTy</span>.  <br /></td></tr>
<tr class="memitem:a82cc254e5dca6419b6cba5e19b3f8acc" id="r_a82cc254e5dca6419b6cba5e19b3f8acc"><td class="memTemplParams" colspan="2">template&lt;typename... EffectTys&gt; </td></tr>
<tr class="memitem:a82cc254e5dca6419b6cba5e19b3f8acc template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82cc254e5dca6419b6cba5e19b3f8acc">mightHaveEffect</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:a82cc254e5dca6419b6cba5e19b3f8acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns "true" if <span class="tt">op</span> might have an effect of type <span class="tt">EffectTy</span> on <span class="tt">value</span>.  <br /></td></tr>
<tr class="memitem:ac3671b9478b3b43240ca578ec2ce89c3" id="r_ac3671b9478b3b43240ca578ec2ce89c3"><td class="memTemplParams" colspan="2">template&lt;typename ValueTy, typename... EffectTys&gt; </td></tr>
<tr class="memitem:ac3671b9478b3b43240ca578ec2ce89c3 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3671b9478b3b43240ca578ec2ce89c3">mightHaveEffect</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, ValueTy value)</td></tr>
<tr class="memdesc:ac3671b9478b3b43240ca578ec2ce89c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns "true" if <span class="tt">op</span> might have an effect of type <span class="tt">EffectTy</span> on <span class="tt">value</span> of type <span class="tt">ValueTy</span>.  <br /></td></tr>
<tr class="memitem:a8583719d6a8f0699c36ac4c4b53057f2" id="r_a8583719d6a8f0699c36ac4c4b53057f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8583719d6a8f0699c36ac4c4b53057f2">isOpTriviallyDead</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a8583719d6a8f0699c36ac4c4b53057f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given operation is unused, and has no side effects on memory that prevent erasing.  <br /></td></tr>
<tr class="memitem:a655db45ed8c23d04d5ed5ee0abe041ad" id="r_a655db45ed8c23d04d5ed5ee0abe041ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a655db45ed8c23d04d5ed5ee0abe041ad">wouldOpBeTriviallyDead</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a655db45ed8c23d04d5ed5ee0abe041ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given operation would be dead if unused, and has no side effects on memory that would prevent erasing.  <br /></td></tr>
<tr class="memitem:a5799849a369b839d27241c96a9572de7" id="r_a5799849a369b839d27241c96a9572de7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5799849a369b839d27241c96a9572de7">isMemoryEffectFree</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a5799849a369b839d27241c96a9572de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given operation is free of memory effects.  <br /></td></tr>
<tr class="memitem:abd4e8ec066bf4a2025b81d2a8c0c9ebe" id="r_abd4e8ec066bf4a2025b81d2a8c0c9ebe"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">llvm::SmallVector</a>&lt; <a class="el" href="namespacemlir_1_1MemoryEffects.html#aba14da80da7a4a192a129fecdb0ac624">MemoryEffects::EffectInstance</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd4e8ec066bf4a2025b81d2a8c0c9ebe">getEffectsRecursively</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *rootOp)</td></tr>
<tr class="memdesc:abd4e8ec066bf4a2025b81d2a8c0c9ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the side effects of an operation.  <br /></td></tr>
<tr class="memitem:a7a2c465ce654633415e61167b64b8a91" id="r_a7a2c465ce654633415e61167b64b8a91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a2c465ce654633415e61167b64b8a91">isSpeculatable</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a7a2c465ce654633415e61167b64b8a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given operation is speculatable, i.e.  <br /></td></tr>
<tr class="memitem:a550cdaef652bf5d59dfe33a15dc81af5" id="r_a550cdaef652bf5d59dfe33a15dc81af5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a550cdaef652bf5d59dfe33a15dc81af5">isPure</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a550cdaef652bf5d59dfe33a15dc81af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given operation is pure, i.e., is speculatable that does not touch memory.  <br /></td></tr>
<tr class="memitem:a31371cb9cd00eaf06ad3b6ee1bf08ca7" id="r_a31371cb9cd00eaf06ad3b6ee1bf08ca7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1SliceBoundsVerificationResult.html">SliceBoundsVerificationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31371cb9cd00eaf06ad3b6ee1bf08ca7">verifyInBoundsSlice</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; shape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; staticOffsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; staticSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; staticStrides, <a class="el" href="classbool.html">bool</a> generateErrorMessage=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a31371cb9cd00eaf06ad3b6ee1bf08ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that the offsets/sizes/strides-style access into the given shape is in-bounds.  <br /></td></tr>
<tr class="memitem:a79ad2e2e2af3d995b2f49c0196b29c12" id="r_a79ad2e2e2af3d995b2f49c0196b29c12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1SliceBoundsVerificationResult.html">SliceBoundsVerificationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79ad2e2e2af3d995b2f49c0196b29c12">verifyInBoundsSlice</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; shape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mixedOffsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mixedSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mixedStrides, <a class="el" href="classbool.html">bool</a> generateErrorMessage=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memitem:af0ddf52b0e7e83bc5b1add0aef99f487" id="r_af0ddf52b0e7e83bc5b1add0aef99f487"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0ddf52b0e7e83bc5b1add0aef99f487">printDynamicIndexList</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;printer, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OperandRange.html">OperandRange</a> values, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; integers, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classbool.html">bool</a> &gt; scalableFlags, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> valueTypes=<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>(), <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">AsmParser::Delimiter</a> delimiter=<a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">AsmParser::Delimiter::Square</a>)</td></tr>
<tr class="memdesc:af0ddf52b0e7e83bc5b1add0aef99f487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Printer hooks for custom directive in assemblyFormat.  <br /></td></tr>
<tr class="memitem:aac3d9353398664321147f5b579f1d767" id="r_aac3d9353398664321147f5b579f1d767"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac3d9353398664321147f5b579f1d767">printDynamicIndexList</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;printer, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OperandRange.html">OperandRange</a> values, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; integers, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> valueTypes=<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>(), <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">AsmParser::Delimiter</a> delimiter=<a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">AsmParser::Delimiter::Square</a>)</td></tr>
<tr class="memitem:a29a5b016cd9b34a332636231a29f78d1" id="r_a29a5b016cd9b34a332636231a29f78d1"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29a5b016cd9b34a332636231a29f78d1">parseDynamicIndexList</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">OpAsmParser::UnresolvedOperand</a> &gt; &amp;values, <a class="el" href="#a12cd3f8e7b8c9f2cac6f17ff1dd80cd8">DenseI64ArrayAttr</a> &amp;integers, <a class="el" href="#abac17268f4f35fc764ae9f810faad3df">DenseBoolArrayAttr</a> &amp;scalableFlags, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; *valueTypes=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">AsmParser::Delimiter</a> delimiter=<a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">AsmParser::Delimiter::Square</a>)</td></tr>
<tr class="memdesc:a29a5b016cd9b34a332636231a29f78d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parser hooks for custom directive in assemblyFormat.  <br /></td></tr>
<tr class="memitem:a113026edf72f8e99369fc9128e2e0da2" id="r_a113026edf72f8e99369fc9128e2e0da2"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a113026edf72f8e99369fc9128e2e0da2">parseDynamicIndexList</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">OpAsmParser::UnresolvedOperand</a> &gt; &amp;values, <a class="el" href="#a12cd3f8e7b8c9f2cac6f17ff1dd80cd8">DenseI64ArrayAttr</a> &amp;integers, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; *valueTypes=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">AsmParser::Delimiter</a> delimiter=<a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">AsmParser::Delimiter::Square</a>)</td></tr>
<tr class="memitem:ad1a1c57fc94caa37e2b98499a48eea86" id="r_ad1a1c57fc94caa37e2b98499a48eea86"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1a1c57fc94caa37e2b98499a48eea86">verifyListOfOperandsOrIntegers</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, StringRef name, <a class="el" href="classunsigned.html">unsigned</a> expectedNumElements, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; attr, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values)</td></tr>
<tr class="memdesc:ad1a1c57fc94caa37e2b98499a48eea86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that a the <span class="tt">values</span> has as many elements as the number of entries in <span class="tt">attr</span> for which <span class="tt">isDynamic</span> evaluates to true.  <br /></td></tr>
<tr class="memitem:ad9141d8b586a68549d2ecaccbce99a69" id="r_ad9141d8b586a68549d2ecaccbce99a69"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9141d8b586a68549d2ecaccbce99a69">hash_value</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> arg)</td></tr>
<tr class="memdesc:ad9141d8b586a68549d2ecaccbce99a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> hashable.  <br /></td></tr>
<tr class="memitem:a8f6f52bcd2d859c9d9a6f393ad5481c1" id="r_a8f6f52bcd2d859c9d9a6f393ad5481c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f6f52bcd2d859c9d9a6f393ad5481c1">operator+</a> (<a class="el" href="classint64__t.html">int64_t</a> val, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr)</td></tr>
<tr class="memitem:a9137193b56dc5134c3092273b13e3f47" id="r_a9137193b56dc5134c3092273b13e3f47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9137193b56dc5134c3092273b13e3f47">operator*</a> (<a class="el" href="classint64__t.html">int64_t</a> val, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr)</td></tr>
<tr class="memitem:a72aa3fc8e169b33e5d4a63f593172d4e" id="r_a72aa3fc8e169b33e5d4a63f593172d4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72aa3fc8e169b33e5d4a63f593172d4e">operator-</a> (<a class="el" href="classint64__t.html">int64_t</a> val, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr)</td></tr>
<tr class="memitem:addfd4323ef72147332661606b030d04d" id="r_addfd4323ef72147332661606b030d04d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addfd4323ef72147332661606b030d04d">getAffineDimExpr</a> (<a class="el" href="classunsigned.html">unsigned</a> position, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:addfd4323ef72147332661606b030d04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">These free functions allow clients of the API to not use classes in detail.  <br /></td></tr>
<tr class="memitem:aefb7ba5a55b4f16631528884d3617a47" id="r_aefb7ba5a55b4f16631528884d3617a47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefb7ba5a55b4f16631528884d3617a47">getAffineSymbolExpr</a> (<a class="el" href="classunsigned.html">unsigned</a> position, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memitem:ab26cdced424aa629fde4150cc8674d50" id="r_ab26cdced424aa629fde4150cc8674d50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab26cdced424aa629fde4150cc8674d50">getAffineConstantExpr</a> (<a class="el" href="classint64__t.html">int64_t</a> constant, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memitem:ace395202c24e4dc75013296cf46ed692" id="r_ace395202c24e4dc75013296cf46ed692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace395202c24e4dc75013296cf46ed692">getAffineConstantExprs</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; constants, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memitem:a6e8a0f44c623301035b6151ca51cca4d" id="r_a6e8a0f44c623301035b6151ca51cca4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e8a0f44c623301035b6151ca51cca4d">getAffineBinaryOpExpr</a> (<a class="el" href="#a6d3b7fd763c24274db6c115579084133">AffineExprKind</a> kind, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> <a class="el" href="IR_2AffineExpr_8cpp.html#a204f446339af7929852f44df41484be5">lhs</a>, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> <a class="el" href="VectorTransforms_8cpp.html#a611c177776150f2e11f15c1cec5764c1">rhs</a>)</td></tr>
<tr class="memitem:a8ad71c14bebce843758768ff160e2283" id="r_a8ad71c14bebce843758768ff160e2283"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ad71c14bebce843758768ff160e2283">getAffineExprFromFlatForm</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; flatExprs, <a class="el" href="classunsigned.html">unsigned</a> numDims, <a class="el" href="classunsigned.html">unsigned</a> numSymbols, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; localExprs, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a8ad71c14bebce843758768ff160e2283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an affine expression from a flat <a class="el" href="classmlir_1_1ArrayRef.html">ArrayRef</a>.  <br /></td></tr>
<tr class="memitem:ae69078b1d3f3263a1769df2e0f1730df" id="r_ae69078b1d3f3263a1769df2e0f1730df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae69078b1d3f3263a1769df2e0f1730df">operator&lt;&lt;</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr)</td></tr>
<tr class="memitem:acbf369c69cfb613cd018ef4ce188809c" id="r_acbf369c69cfb613cd018ef4ce188809c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbf369c69cfb613cd018ef4ce188809c">simplifyAffineExpr</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr, <a class="el" href="classunsigned.html">unsigned</a> numDims, <a class="el" href="classunsigned.html">unsigned</a> numSymbols)</td></tr>
<tr class="memdesc:acbf369c69cfb613cd018ef4ce188809c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify an affine expression by flattening and some amount of simple analysis.  <br /></td></tr>
<tr class="memitem:a3d147ba82716614172eb7e9b5209d3eb" id="r_a3d147ba82716614172eb7e9b5209d3eb"><td class="memTemplParams" colspan="2">template&lt;typename... AffineExprTy&gt; </td></tr>
<tr class="memitem:a3d147ba82716614172eb7e9b5209d3eb template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d147ba82716614172eb7e9b5209d3eb">bindDims</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, AffineExprTy &amp;...exprs)</td></tr>
<tr class="memdesc:a3d147ba82716614172eb7e9b5209d3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a list of <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> references to DimExpr at positions: [0 .  <br /></td></tr>
<tr class="memitem:a2c870d90073423151a32e2c0f2afa506" id="r_a2c870d90073423151a32e2c0f2afa506"><td class="memTemplParams" colspan="2">template&lt;typename AffineExprTy&gt; </td></tr>
<tr class="memitem:a2c870d90073423151a32e2c0f2afa506 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c870d90073423151a32e2c0f2afa506">bindDimsList</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineExprTy &gt; exprs)</td></tr>
<tr class="memitem:a8df39b3ef750e258dbe3dfe5b251cea5" id="r_a8df39b3ef750e258dbe3dfe5b251cea5"><td class="memTemplParams" colspan="2">template&lt;typename... AffineExprTy&gt; </td></tr>
<tr class="memitem:a8df39b3ef750e258dbe3dfe5b251cea5 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8df39b3ef750e258dbe3dfe5b251cea5">bindSymbols</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, AffineExprTy &amp;...exprs)</td></tr>
<tr class="memdesc:a8df39b3ef750e258dbe3dfe5b251cea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a list of <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> references to SymbolExpr at positions: [0 .  <br /></td></tr>
<tr class="memitem:af523defc0429b26ab3f85b7023748822" id="r_af523defc0429b26ab3f85b7023748822"><td class="memTemplParams" colspan="2">template&lt;typename AffineExprTy&gt; </td></tr>
<tr class="memitem:af523defc0429b26ab3f85b7023748822 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af523defc0429b26ab3f85b7023748822">bindSymbolsList</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineExprTy &gt; exprs)</td></tr>
<tr class="memitem:a40cdc27e9612cb7a782faea9ead39aec" id="r_a40cdc27e9612cb7a782faea9ead39aec"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40cdc27e9612cb7a782faea9ead39aec">getBoundForAffineExpr</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr, <a class="el" href="classunsigned.html">unsigned</a> numDims, <a class="el" href="classunsigned.html">unsigned</a> numSymbols, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &gt; constLowerBounds, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &gt; constUpperBounds, <a class="el" href="classbool.html">bool</a> isUpper)</td></tr>
<tr class="memdesc:a40cdc27e9612cb7a782faea9ead39aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a lower or upper (depending on <span class="tt">isUpper</span>) bound for <span class="tt">expr</span> while using the constant lower and upper bounds for its inputs provided in <span class="tt">constLowerBounds</span> and <span class="tt">constUpperBounds</span>.  <br /></td></tr>
<tr class="memitem:a032c893ca9a2fff3b16e5a7cb6d413cd" id="r_a032c893ca9a2fff3b16e5a7cb6d413cd"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a032c893ca9a2fff3b16e5a7cb6d413cd">hash_value</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> arg)</td></tr>
<tr class="memitem:a014d8e82c51794d145267690b2b5bd58" id="r_a014d8e82c51794d145267690b2b5bd58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a014d8e82c51794d145267690b2b5bd58">simplifyAffineMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:a014d8e82c51794d145267690b2b5bd58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies an affine map by simplifying its underlying <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> results.  <br /></td></tr>
<tr class="memitem:ab05caafff59182b2191e4645cdceb5d5" id="r_ab05caafff59182b2191e4645cdceb5d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab05caafff59182b2191e4645cdceb5d5">compressDims</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, const llvm::SmallBitVector &amp;unusedDims)</td></tr>
<tr class="memdesc:ab05caafff59182b2191e4645cdceb5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the dims that are listed in <span class="tt">unusedDims</span>.  <br /></td></tr>
<tr class="memitem:a99f84d2ce14eec6c85a20251582e5cc1" id="r_a99f84d2ce14eec6c85a20251582e5cc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99f84d2ce14eec6c85a20251582e5cc1">compressUnusedDims</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:a99f84d2ce14eec6c85a20251582e5cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the dims that are not used.  <br /></td></tr>
<tr class="memitem:ae2a3cbce4381f83b710fe6cfc9a867c9" id="r_ae2a3cbce4381f83b710fe6cfc9a867c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2a3cbce4381f83b710fe6cfc9a867c9">compressUnusedDims</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; maps)</td></tr>
<tr class="memdesc:ae2a3cbce4381f83b710fe6cfc9a867c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the dims that are not used by any of the individual maps in <span class="tt">maps</span>.  <br /></td></tr>
<tr class="memitem:a6de5b9ec7c351db7ed870d0df7248342" id="r_a6de5b9ec7c351db7ed870d0df7248342"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6de5b9ec7c351db7ed870d0df7248342">compressSymbols</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, const llvm::SmallBitVector &amp;unusedSymbols)</td></tr>
<tr class="memdesc:a6de5b9ec7c351db7ed870d0df7248342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the symbols that are listed in <span class="tt">unusedSymbols</span>.  <br /></td></tr>
<tr class="memitem:ae4c401a074fdcc1cb0efb7e5369b2ef3" id="r_ae4c401a074fdcc1cb0efb7e5369b2ef3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4c401a074fdcc1cb0efb7e5369b2ef3">compressUnusedSymbols</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:ae4c401a074fdcc1cb0efb7e5369b2ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the symbols that are not used.  <br /></td></tr>
<tr class="memitem:a4a26d1a643586acb4362f535168be129" id="r_a4a26d1a643586acb4362f535168be129"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a26d1a643586acb4362f535168be129">compressUnusedSymbols</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; maps)</td></tr>
<tr class="memdesc:a4a26d1a643586acb4362f535168be129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the symbols that are not used by any of the individual maps in <span class="tt">maps</span>.  <br /></td></tr>
<tr class="memitem:ae92bdb36e3e6eeecc32f23923e58d973" id="r_ae92bdb36e3e6eeecc32f23923e58d973"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae92bdb36e3e6eeecc32f23923e58d973">foldAttributesIntoMap</a> (<a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; operands, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;remainingValues)</td></tr>
<tr class="memdesc:ae92bdb36e3e6eeecc32f23923e58d973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold all attributes among the given operands into the affine map.  <br /></td></tr>
<tr class="memitem:a1fa0a7e84eb2af3d70c98d59fc9ccbd3" id="r_a1fa0a7e84eb2af3d70c98d59fc9ccbd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fa0a7e84eb2af3d70c98d59fc9ccbd3">removeDuplicateExprs</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:a1fa0a7e84eb2af3d70c98d59fc9ccbd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map with the same dimension and symbol count as <span class="tt">map</span>, but whose results are the unique affine expressions of <span class="tt">map</span>.  <br /></td></tr>
<tr class="memitem:a52b322818d83a2256d4e4391acbf78a2" id="r_a52b322818d83a2256d4e4391acbf78a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52b322818d83a2256d4e4391acbf78a2">inversePermutation</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:a52b322818d83a2256d4e4391acbf78a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map of codomain to domain dimensions such that the first codomain dimension for a particular domain dimension is selected.  <br /></td></tr>
<tr class="memitem:a39612be2ef116102866d3bb9c6a8ca88" id="r_a39612be2ef116102866d3bb9c6a8ca88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39612be2ef116102866d3bb9c6a8ca88">inverseAndBroadcastProjectedPermutation</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:a39612be2ef116102866d3bb9c6a8ca88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reverse map of a projected permutation where the projected dimensions are transformed into 0s.  <br /></td></tr>
<tr class="memitem:a0b5c68aa8f528b64d3f4f8990b0b5dde" id="r_a0b5c68aa8f528b64d3f4f8990b0b5dde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b5c68aa8f528b64d3f4f8990b0b5dde">concatAffineMaps</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; maps, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a0b5c68aa8f528b64d3f4f8990b0b5dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates a list of <span class="tt">maps</span> into a single <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a>, stepping over potentially empty maps.  <br /></td></tr>
<tr class="memitem:ae1261e0343cefe25ab1724c67005b7d2" id="r_ae1261e0343cefe25ab1724c67005b7d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1261e0343cefe25ab1724c67005b7d2">projectDims</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, const llvm::SmallBitVector &amp;projectedDimensions, <a class="el" href="classbool.html">bool</a> compressDimsFlag=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:ae1261e0343cefe25ab1724c67005b7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the map that results from projecting out the dimensions specified in <span class="tt">projectedDimensions</span>.  <br /></td></tr>
<tr class="memitem:ae5ec6082bc5758f83f4b0938b00b160d" id="r_ae5ec6082bc5758f83f4b0938b00b160d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5ec6082bc5758f83f4b0938b00b160d">projectSymbols</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, const llvm::SmallBitVector &amp;projectedSymbols, <a class="el" href="classbool.html">bool</a> compressSymbolsFlag=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:ae5ec6082bc5758f83f4b0938b00b160d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol counterpart of <span class="tt">projectDims</span>.  <br /></td></tr>
<tr class="memitem:ab45e3ce76869b05848f96a5f8b97fc90" id="r_ab45e3ce76869b05848f96a5f8b97fc90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab45e3ce76869b05848f96a5f8b97fc90">getProjectedMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, const llvm::SmallBitVector &amp;projectedDimensions, <a class="el" href="classbool.html">bool</a> compressDimsFlag=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>, <a class="el" href="classbool.html">bool</a> compressSymbolsFlag=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:ab45e3ce76869b05848f96a5f8b97fc90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <span class="tt">projectDims(map, projectedDimensions, compressDimsFlag)</span>.  <br /></td></tr>
<tr class="memitem:ac61c6bb6068af953a0711cf404a99645" id="r_ac61c6bb6068af953a0711cf404a99645"><td class="memItemLeft" align="right" valign="top">llvm::SmallBitVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac61c6bb6068af953a0711cf404a99645">getUnusedDimsBitVector</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; maps)</td></tr>
<tr class="memitem:a2798707e1d2321021e16802305d3c152" id="r_a2798707e1d2321021e16802305d3c152"><td class="memItemLeft" align="right" valign="top">llvm::SmallBitVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2798707e1d2321021e16802305d3c152">getUnusedSymbolsBitVector</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; maps)</td></tr>
<tr class="memitem:a0bbb3252a45b5feab49c0bac2a68779c" id="r_a0bbb3252a45b5feab49c0bac2a68779c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0bbb3252a45b5feab49c0bac2a68779c">expandDimsToRank</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classint64__t.html">int64_t</a> rank, const llvm::SmallBitVector &amp;projectedDimensions)</td></tr>
<tr class="memdesc:a0bbb3252a45b5feab49c0bac2a68779c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand <span class="tt">map</span> to operate on <span class="tt">rank</span> dims while projecting out the dims in <span class="tt">projectedDimensions</span>.  <br /></td></tr>
<tr class="memitem:a425d39b5f3079c19e427e5ae82cb7838" id="r_a425d39b5f3079c19e427e5ae82cb7838"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a425d39b5f3079c19e427e5ae82cb7838">operator&lt;&lt;</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memitem:abf34b5ae79f6561558887f2dd8254f94" id="r_abf34b5ae79f6561558887f2dd8254f94"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:abf34b5ae79f6561558887f2dd8254f94 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf34b5ae79f6561558887f2dd8254f94">applyPermutationMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; T &gt; source)</td></tr>
<tr class="memdesc:abf34b5ae79f6561558887f2dd8254f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a permutation from <span class="tt">map</span> to <span class="tt">source</span> and return the result.  <br /></td></tr>
<tr class="memitem:a74485bec820f2186ce852a09f45ebd47" id="r_a74485bec820f2186ce852a09f45ebd47"><td class="memTemplParams" colspan="2">template&lt;typename AffineExprContainer&gt; </td></tr>
<tr class="memitem:a74485bec820f2186ce852a09f45ebd47 template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74485bec820f2186ce852a09f45ebd47">getMaxDimAndSymbol</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineExprContainer &gt; exprsList, <a class="el" href="classint64__t.html">int64_t</a> &amp;maxDim, <a class="el" href="classint64__t.html">int64_t</a> &amp;maxSym)</td></tr>
<tr class="memdesc:a74485bec820f2186ce852a09f45ebd47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates maximum dimension and symbol positions from the expressions in <span class="tt">exprsLists</span> and stores them in <span class="tt">maxDim</span> and <span class="tt">maxSym</span> respectively.  <br /></td></tr>
<tr class="memitem:a23e5dd60111e86e0df4b52a7d3befd33" id="r_a23e5dd60111e86e0df4b52a7d3befd33"><td class="memItemLeft" align="right" valign="top">StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23e5dd60111e86e0df4b52a7d3befd33">toString</a> (<a class="el" href="#ac84871bcca0aaa0176d43dbdbffe9a6c">AsmResourceEntryKind</a> kind)</td></tr>
<tr class="memitem:a894a08aa6ed051f55e57bc35859a379f" id="r_a894a08aa6ed051f55e57bc35859a379f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a894a08aa6ed051f55e57bc35859a379f">registerAsmPrinterCLOptions</a> ()</td></tr>
<tr class="memdesc:a894a08aa6ed051f55e57bc35859a379f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a set of useful command-line options that can be used to configure various flags within the <a class="el" href="classmlir_1_1AsmPrinter.html" title="This base class exposes generic asm printer hooks, usable across the various derived printers.">AsmPrinter</a>.  <br /></td></tr>
<tr class="memitem:a2b6866ece3e4c58dfc2a59a233c4ce7b" id="r_a2b6866ece3e4c58dfc2a59a233c4ce7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b6866ece3e4c58dfc2a59a233c4ce7b">operator&lt;&lt;</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="memitem:a68bae84b1d7cdba11b048d9af3478a07" id="r_a68bae84b1d7cdba11b048d9af3478a07"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68bae84b1d7cdba11b048d9af3478a07">hash_value</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> arg)</td></tr>
<tr class="memitem:aa4b795f2f972c070efff53082563f976" id="r_aa4b795f2f972c070efff53082563f976"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4b795f2f972c070efff53082563f976">hash_value</a> (const <a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a> &amp;arg)</td></tr>
<tr class="memitem:a13e488dd4f0933d688cd10581b313afb" id="r_a13e488dd4f0933d688cd10581b313afb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13e488dd4f0933d688cd10581b313afb">operator&lt;&lt;</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;, <a class="el" href="classmlir_1_1Block.html">Block</a> &amp;)</td></tr>
<tr class="memitem:a543c4328a4fa5ed530aa88a9d7d158a9" id="r_a543c4328a4fa5ed530aa88a9d7d158a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a543c4328a4fa5ed530aa88a9d7d158a9">operator==</a> (StringAttr <a class="el" href="IR_2AffineExpr_8cpp.html#a204f446339af7929852f44df41484be5">lhs</a>, std::nullptr_t)</td></tr>
<tr class="memdesc:a543c4328a4fa5ed530aa88a9d7d158a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define comparisons for StringAttr against nullptr and itself to avoid the StringRef overloads from being chosen when not desirable.  <br /></td></tr>
<tr class="memitem:a8db56ba5c170b04848e194937be59a56" id="r_a8db56ba5c170b04848e194937be59a56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8db56ba5c170b04848e194937be59a56">operator!=</a> (StringAttr <a class="el" href="IR_2AffineExpr_8cpp.html#a204f446339af7929852f44df41484be5">lhs</a>, std::nullptr_t)</td></tr>
<tr class="memitem:a40ce38cb70a016263f28574d4982475b" id="r_a40ce38cb70a016263f28574d4982475b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40ce38cb70a016263f28574d4982475b">operator==</a> (StringAttr <a class="el" href="IR_2AffineExpr_8cpp.html#a204f446339af7929852f44df41484be5">lhs</a>, StringAttr <a class="el" href="VectorTransforms_8cpp.html#a611c177776150f2e11f15c1cec5764c1">rhs</a>)</td></tr>
<tr class="memitem:a6bb385e3105982b905c5ef4db9f9f21b" id="r_a6bb385e3105982b905c5ef4db9f9f21b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bb385e3105982b905c5ef4db9f9f21b">operator!=</a> (StringAttr <a class="el" href="IR_2AffineExpr_8cpp.html#a204f446339af7929852f44df41484be5">lhs</a>, StringAttr <a class="el" href="VectorTransforms_8cpp.html#a611c177776150f2e11f15c1cec5764c1">rhs</a>)</td></tr>
<tr class="memitem:a075d7bf5dfe5d33c409763bc28330180" id="r_a075d7bf5dfe5d33c409763bc28330180"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a075d7bf5dfe5d33c409763bc28330180">operator==</a> (StringAttr <a class="el" href="IR_2AffineExpr_8cpp.html#a204f446339af7929852f44df41484be5">lhs</a>, StringRef <a class="el" href="VectorTransforms_8cpp.html#a611c177776150f2e11f15c1cec5764c1">rhs</a>)</td></tr>
<tr class="memdesc:a075d7bf5dfe5d33c409763bc28330180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow direct comparison with StringRef.  <br /></td></tr>
<tr class="memitem:a48146d74baebce1c83140c378053f3c2" id="r_a48146d74baebce1c83140c378053f3c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48146d74baebce1c83140c378053f3c2">operator!=</a> (StringAttr <a class="el" href="IR_2AffineExpr_8cpp.html#a204f446339af7929852f44df41484be5">lhs</a>, StringRef <a class="el" href="VectorTransforms_8cpp.html#a611c177776150f2e11f15c1cec5764c1">rhs</a>)</td></tr>
<tr class="memitem:a50c46bfb0a0fbbe700ef6c07a611dbf8" id="r_a50c46bfb0a0fbbe700ef6c07a611dbf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50c46bfb0a0fbbe700ef6c07a611dbf8">operator==</a> (StringRef <a class="el" href="IR_2AffineExpr_8cpp.html#a204f446339af7929852f44df41484be5">lhs</a>, StringAttr <a class="el" href="VectorTransforms_8cpp.html#a611c177776150f2e11f15c1cec5764c1">rhs</a>)</td></tr>
<tr class="memitem:a4bfbb1c5941d2cc005eb3f483e881202" id="r_a4bfbb1c5941d2cc005eb3f483e881202"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bfbb1c5941d2cc005eb3f483e881202">operator!=</a> (StringRef <a class="el" href="IR_2AffineExpr_8cpp.html#a204f446339af7929852f44df41484be5">lhs</a>, StringAttr <a class="el" href="VectorTransforms_8cpp.html#a611c177776150f2e11f15c1cec5764c1">rhs</a>)</td></tr>
<tr class="memitem:a923fafcbdcfdcb3b735fab2ab293a1ad" id="r_a923fafcbdcfdcb3b735fab2ab293a1ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a923fafcbdcfdcb3b735fab2ab293a1ad">makeStridedLinearLayoutMap</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; strides, <a class="el" href="classint64__t.html">int64_t</a> offset, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a923fafcbdcfdcb3b735fab2ab293a1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of strides (in which ShapedType::kDynamic represents a dynamic value), return the single result <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> which represents the linearized strided layout map.  <br /></td></tr>
<tr class="memitem:a1077d0bb73f4b48dfdff162ee992e116" id="r_a1077d0bb73f4b48dfdff162ee992e116"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1077d0bb73f4b48dfdff162ee992e116">isValidVectorTypeElementType</a> (<a class="el" href="classmlir_1_1Type.html">::mlir::Type</a> type)</td></tr>
<tr class="memitem:ac7e47350637dfbf8ad64f9e3bba17bdd" id="r_ac7e47350637dfbf8ad64f9e3bba17bdd"><td class="memItemLeft" align="right" valign="top">std::optional&lt; llvm::SmallDenseSet&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7e47350637dfbf8ad64f9e3bba17bdd">computeRankReductionMask</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; originalShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; reducedShape, <a class="el" href="classbool.html">bool</a> matchDynamic=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:ac7e47350637dfbf8ad64f9e3bba17bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an <span class="tt">originalShape</span> and a <span class="tt">reducedShape</span> assumed to be a subset of <span class="tt">originalShape</span> with some <span class="tt">1</span> entries erased, return the set of indices that specifies which of the entries of <span class="tt">originalShape</span> are dropped to obtain <span class="tt">reducedShape</span>.  <br /></td></tr>
<tr class="memitem:ae209f096d9240a818927afbab10f43b8" id="r_ae209f096d9240a818927afbab10f43b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a11353e6611651b85531ad95629c57d75">SliceVerificationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae209f096d9240a818927afbab10f43b8">isRankReducedType</a> (ShapedType originalType, ShapedType candidateReducedType)</td></tr>
<tr class="memdesc:ae209f096d9240a818927afbab10f43b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <span class="tt">originalType</span> can be rank reduced to <span class="tt">candidateReducedType</span> type by dropping some dimensions with static size <span class="tt">1</span>.  <br /></td></tr>
<tr class="memitem:ac603376cc0dac0b2bd27c2dcde3c2e14" id="r_ac603376cc0dac0b2bd27c2dcde3c2e14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac603376cc0dac0b2bd27c2dcde3c2e14">makeCanonicalStridedLayoutExpr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; sizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; exprs, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ac603376cc0dac0b2bd27c2dcde3c2e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given MemRef <span class="tt">sizes</span> that are either static or dynamic, returns the canonical "contiguous" strides <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a>.  <br /></td></tr>
<tr class="memitem:ad25cd8672ecb721d7a4f0ecd22bac6e8" id="r_ad25cd8672ecb721d7a4f0ecd22bac6e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad25cd8672ecb721d7a4f0ecd22bac6e8">makeCanonicalStridedLayoutExpr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; sizes, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ad25cd8672ecb721d7a4f0ecd22bac6e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of makeCanonicalStrudedLayoutExpr for the common case where <span class="tt">exprs</span> is {d0, d1, .., d_(sizes.size()-1)}.  <br /></td></tr>
<tr class="memitem:a4c2a679d84bee635872c71c673d32927" id="r_a4c2a679d84bee635872c71c673d32927"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c2a679d84bee635872c71c673d32927">operator&lt;&lt;</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, const <a class="el" href="classmlir_1_1DiagnosticArgument.html">DiagnosticArgument</a> &amp;arg)</td></tr>
<tr class="memitem:a0bc71fe62040378c9ab46fff9d5d7fff" id="r_a0bc71fe62040378c9ab46fff9d5d7fff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0bc71fe62040378c9ab46fff9d5d7fff">operator&lt;&lt;</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, const <a class="el" href="classmlir_1_1Diagnostic.html">Diagnostic</a> &amp;<a class="el" href="ModuleImport_8cpp.html#a0ba25d7b0573f8dd5fd669095441a61e">diag</a>)</td></tr>
<tr class="memitem:a4e96b0c437652eb5a4890734bb6bcee7" id="r_a4e96b0c437652eb5a4890734bb6bcee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a4e96b0c437652eb5a4890734bb6bcee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to emit an error message using this location.  <br /></td></tr>
<tr class="memitem:a2dc4e9418ff63ebea20c7f709ebcb0f8" id="r_a2dc4e9418ff63ebea20c7f709ebcb0f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2dc4e9418ff63ebea20c7f709ebcb0f8">emitError</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, const Twine &amp;message)</td></tr>
<tr class="memitem:a0768c8a572dc71b0b00d57414b56b60d" id="r_a0768c8a572dc71b0b00d57414b56b60d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0768c8a572dc71b0b00d57414b56b60d">emitWarning</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a0768c8a572dc71b0b00d57414b56b60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to emit a warning message using this location.  <br /></td></tr>
<tr class="memitem:a5e96e5ea091fb5bea539cef6ea7c5624" id="r_a5e96e5ea091fb5bea539cef6ea7c5624"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e96e5ea091fb5bea539cef6ea7c5624">emitWarning</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, const Twine &amp;message)</td></tr>
<tr class="memitem:a8a9ca6fe9d5aab498bf090db3e878c87" id="r_a8a9ca6fe9d5aab498bf090db3e878c87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a9ca6fe9d5aab498bf090db3e878c87">emitRemark</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a8a9ca6fe9d5aab498bf090db3e878c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to emit a remark message using this location.  <br /></td></tr>
<tr class="memitem:a391c4b4ea9dc95fbcfbfdab8a49547a3" id="r_a391c4b4ea9dc95fbcfbfdab8a49547a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a391c4b4ea9dc95fbcfbfdab8a49547a3">emitRemark</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, const Twine &amp;message)</td></tr>
<tr class="memitem:a45deee4eed2b998fbde1d3573325bc6e" id="r_a45deee4eed2b998fbde1d3573325bc6e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a45deee4eed2b998fbde1d3573325bc6e template"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45deee4eed2b998fbde1d3573325bc6e">emitOptionalError</a> (std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; loc, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a45deee4eed2b998fbde1d3573325bc6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads of the above emission functions that take an optionally null location.  <br /></td></tr>
<tr class="memitem:ac03c4337fa32d3045568e4dc6eef60ca" id="r_ac03c4337fa32d3045568e4dc6eef60ca"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ac03c4337fa32d3045568e4dc6eef60ca template"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac03c4337fa32d3045568e4dc6eef60ca">emitOptionalWarning</a> (std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; loc, Args &amp;&amp;...args)</td></tr>
<tr class="memitem:a3f5cd384eee5c5c8a7125233ade78eea" id="r_a3f5cd384eee5c5c8a7125233ade78eea"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a3f5cd384eee5c5c8a7125233ade78eea template"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f5cd384eee5c5c8a7125233ade78eea">emitOptionalRemark</a> (std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; loc, Args &amp;&amp;...args)</td></tr>
<tr class="memitem:a655bb0e17a21ea2c35194f7c822c9ca5" id="r_a655bb0e17a21ea2c35194f7c822c9ca5"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a655bb0e17a21ea2c35194f7c822c9ca5">hash_value</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> arg)</td></tr>
<tr class="memitem:ae846cd7dd23c30e524844ff15e90ee93" id="r_ae846cd7dd23c30e524844ff15e90ee93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae846cd7dd23c30e524844ff15e90ee93">operator&lt;&lt;</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, const <a class="el" href="classmlir_1_1Location.html">Location</a> &amp;loc)</td></tr>
<tr class="memitem:aa6261878bc5197cfcc003e5b3fa735ea" id="r_aa6261878bc5197cfcc003e5b3fa735ea"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6261878bc5197cfcc003e5b3fa735ea">hash_value</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> arg)</td></tr>
<tr class="memitem:afe7f79e5d443d52d8bd488719b15dc63" id="r_afe7f79e5d443d52d8bd488719b15dc63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe7f79e5d443d52d8bd488719b15dc63">isStrictFileLineColLoc</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:afe7f79e5d443d52d8bd488719b15dc63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the given location is a <a class="el" href="classFileLineColRange.html">FileLineColRange</a> with exactly one line and column.  <br /></td></tr>
<tr class="memitem:ad402a86ee4c9000c6fa1fceaddab560b" id="r_ad402a86ee4c9000c6fa1fceaddab560b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__op__matcher.html">detail::constant_op_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad402a86ee4c9000c6fa1fceaddab560b">m_Constant</a> ()</td></tr>
<tr class="memdesc:ad402a86ee4c9000c6fa1fceaddab560b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant foldable operation.  <br /></td></tr>
<tr class="memitem:a18d87ea3290be975b746704e58465017" id="r_a18d87ea3290be975b746704e58465017"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1AttrOpMatcher.html">detail::AttrOpMatcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18d87ea3290be975b746704e58465017">m_Attr</a> (StringRef attrName)</td></tr>
<tr class="memdesc:a18d87ea3290be975b746704e58465017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a named attribute operation.  <br /></td></tr>
<tr class="memitem:a69b52f968271c9a4da1bc766ee083a9c" id="r_a69b52f968271c9a4da1bc766ee083a9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1NameOpMatcher.html">detail::NameOpMatcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69b52f968271c9a4da1bc766ee083a9c">m_Op</a> (StringRef opName)</td></tr>
<tr class="memdesc:a69b52f968271c9a4da1bc766ee083a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a named operation.  <br /></td></tr>
<tr class="memitem:a1eb2469cde2027cb17828303ca629518" id="r_a1eb2469cde2027cb17828303ca629518"><td class="memTemplParams" colspan="2">template&lt;typename AttrT&gt; </td></tr>
<tr class="memitem:a1eb2469cde2027cb17828303ca629518 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__op__binder.html">detail::constant_op_binder</a>&lt; AttrT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1eb2469cde2027cb17828303ca629518">m_Constant</a> (AttrT *bind_value)</td></tr>
<tr class="memdesc:a1eb2469cde2027cb17828303ca629518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a value from a constant foldable operation and writes the value to bind_value.  <br /></td></tr>
<tr class="memitem:a51586639ab172c46df53c0c718cb6fbc" id="r_a51586639ab172c46df53c0c718cb6fbc"><td class="memTemplParams" colspan="2">template&lt;typename AttrT&gt; </td></tr>
<tr class="memitem:a51586639ab172c46df53c0c718cb6fbc template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1AttrOpBinder.html">detail::AttrOpBinder</a>&lt; AttrT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51586639ab172c46df53c0c718cb6fbc">m_Attr</a> (StringRef attrName, AttrT *bindValue)</td></tr>
<tr class="memdesc:a51586639ab172c46df53c0c718cb6fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a named attribute operation and writes the value to bind_value.  <br /></td></tr>
<tr class="memitem:a8ea33aa665368d4f2108eb2d41c85111" id="r_a8ea33aa665368d4f2108eb2d41c85111"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ea33aa665368d4f2108eb2d41c85111">m_AnyZeroFloat</a> ()</td></tr>
<tr class="memdesc:a8ea33aa665368d4f2108eb2d41c85111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat float (both positive and negative) zero.  <br /></td></tr>
<tr class="memitem:a774a1ae971f4ef00eb57389293dfe617" id="r_a774a1ae971f4ef00eb57389293dfe617"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a774a1ae971f4ef00eb57389293dfe617">m_PosZeroFloat</a> ()</td></tr>
<tr class="memdesc:a774a1ae971f4ef00eb57389293dfe617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat float positive zero.  <br /></td></tr>
<tr class="memitem:aa9eba8d1292854c0da6c062988ecac9b" id="r_aa9eba8d1292854c0da6c062988ecac9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9eba8d1292854c0da6c062988ecac9b">m_NegZeroFloat</a> ()</td></tr>
<tr class="memdesc:aa9eba8d1292854c0da6c062988ecac9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat float negative zero.  <br /></td></tr>
<tr class="memitem:af0495d84f34cf3238a7741fa6974a485" id="r_af0495d84f34cf3238a7741fa6974a485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0495d84f34cf3238a7741fa6974a485">m_OneFloat</a> ()</td></tr>
<tr class="memdesc:af0495d84f34cf3238a7741fa6974a485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat float ones.  <br /></td></tr>
<tr class="memitem:a17093f5e4f75a743e4cf9ac9af43a506" id="r_a17093f5e4f75a743e4cf9ac9af43a506"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17093f5e4f75a743e4cf9ac9af43a506">m_NaNFloat</a> ()</td></tr>
<tr class="memdesc:a17093f5e4f75a743e4cf9ac9af43a506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat float ones.  <br /></td></tr>
<tr class="memitem:adc93dfeaa35bda23b16591c462c335f6" id="r_adc93dfeaa35bda23b16591c462c335f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc93dfeaa35bda23b16591c462c335f6">m_PosInfFloat</a> ()</td></tr>
<tr class="memdesc:adc93dfeaa35bda23b16591c462c335f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat float positive infinity.  <br /></td></tr>
<tr class="memitem:a9e89b015211525b010832d2d2c37650b" id="r_a9e89b015211525b010832d2d2c37650b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e89b015211525b010832d2d2c37650b">m_NegInfFloat</a> ()</td></tr>
<tr class="memdesc:a9e89b015211525b010832d2d2c37650b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat float negative infinity.  <br /></td></tr>
<tr class="memitem:a7f5d8af15bd8994b1a7abeaaacfe1b06" id="r_a7f5d8af15bd8994b1a7abeaaacfe1b06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html">detail::constant_int_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f5d8af15bd8994b1a7abeaaacfe1b06">m_Zero</a> ()</td></tr>
<tr class="memdesc:a7f5d8af15bd8994b1a7abeaaacfe1b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat integer zero.  <br /></td></tr>
<tr class="memitem:a94bb42600b9be680591776fdc14a53cd" id="r_a94bb42600b9be680591776fdc14a53cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html">detail::constant_int_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94bb42600b9be680591776fdc14a53cd">m_NonZero</a> ()</td></tr>
<tr class="memdesc:a94bb42600b9be680591776fdc14a53cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat integer that is any non-zero value.  <br /></td></tr>
<tr class="memitem:afbe6d87f8ecb162173628bc66674ba72" id="r_afbe6d87f8ecb162173628bc66674ba72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__int__range__predicate__matcher.html">detail::constant_int_range_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbe6d87f8ecb162173628bc66674ba72">m_IntRangeWithoutZeroU</a> ()</td></tr>
<tr class="memdesc:afbe6d87f8ecb162173628bc66674ba72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat integer or a unsigned integer range that does not contain zero.  <br /></td></tr>
<tr class="memitem:ab744f07f6776a02e49c0851786db161a" id="r_ab744f07f6776a02e49c0851786db161a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__int__range__predicate__matcher.html">detail::constant_int_range_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab744f07f6776a02e49c0851786db161a">m_IntRangeWithoutZeroS</a> ()</td></tr>
<tr class="memdesc:ab744f07f6776a02e49c0851786db161a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat integer or a signed integer range that does not contain zero.  <br /></td></tr>
<tr class="memitem:a4136ce33972b8eb3801f4c304f53acae" id="r_a4136ce33972b8eb3801f4c304f53acae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__int__range__predicate__matcher.html">detail::constant_int_range_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4136ce33972b8eb3801f4c304f53acae">m_IntRangeWithoutNegOneS</a> ()</td></tr>
<tr class="memdesc:a4136ce33972b8eb3801f4c304f53acae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat integer or a signed integer range that does not contain minus one.  <br /></td></tr>
<tr class="memitem:a907f415a4c803b15ef57db37cc732f39" id="r_a907f415a4c803b15ef57db37cc732f39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html">detail::constant_int_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a907f415a4c803b15ef57db37cc732f39">m_One</a> ()</td></tr>
<tr class="memdesc:a907f415a4c803b15ef57db37cc732f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat integer one.  <br /></td></tr>
<tr class="memitem:acc77c58bbea63e3a122e37a2a608ae92" id="r_acc77c58bbea63e3a122e37a2a608ae92"><td class="memTemplParams" colspan="2">template&lt;typename OpClass&gt; </td></tr>
<tr class="memitem:acc77c58bbea63e3a122e37a2a608ae92 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1op__matcher.html">detail::op_matcher</a>&lt; OpClass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc77c58bbea63e3a122e37a2a608ae92">m_Op</a> ()</td></tr>
<tr class="memdesc:acc77c58bbea63e3a122e37a2a608ae92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the given OpClass.  <br /></td></tr>
<tr class="memitem:a0190228b09e7b51a4bc1e013c01d404c" id="r_a0190228b09e7b51a4bc1e013c01d404c"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classmlir_1_1Pattern.html">Pattern</a>&gt; </td></tr>
<tr class="memitem:a0190228b09e7b51a4bc1e013c01d404c template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0190228b09e7b51a4bc1e013c01d404c">matchPattern</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, const <a class="el" href="classmlir_1_1Pattern.html">Pattern</a> &amp;pattern)</td></tr>
<tr class="memdesc:a0190228b09e7b51a4bc1e013c01d404c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for matching a pattern over a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <br /></td></tr>
<tr class="memitem:a1b97d57dcd6c08b495fbd3ef22aeda6f" id="r_a1b97d57dcd6c08b495fbd3ef22aeda6f"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classmlir_1_1Pattern.html">Pattern</a>&gt; </td></tr>
<tr class="memitem:a1b97d57dcd6c08b495fbd3ef22aeda6f template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b97d57dcd6c08b495fbd3ef22aeda6f">matchPattern</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classmlir_1_1Pattern.html">Pattern</a> &amp;pattern)</td></tr>
<tr class="memdesc:a1b97d57dcd6c08b495fbd3ef22aeda6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for matching a pattern over an <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>.  <br /></td></tr>
<tr class="memitem:a77883d2221f5bdf428d745d778f90d49" id="r_a77883d2221f5bdf428d745d778f90d49"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classmlir_1_1Pattern.html">Pattern</a>&gt; </td></tr>
<tr class="memitem:a77883d2221f5bdf428d745d778f90d49 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77883d2221f5bdf428d745d778f90d49">matchPattern</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr, const <a class="el" href="classmlir_1_1Pattern.html">Pattern</a> &amp;pattern)</td></tr>
<tr class="memdesc:a77883d2221f5bdf428d745d778f90d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for matching a pattern over an <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>.  <br /></td></tr>
<tr class="memitem:aefeea9b182f6e6e1a267b0bd157e7970" id="r_aefeea9b182f6e6e1a267b0bd157e7970"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__float__value__binder.html">detail::constant_float_value_binder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefeea9b182f6e6e1a267b0bd157e7970">m_ConstantFloat</a> (FloatAttr::ValueType *bind_value)</td></tr>
<tr class="memdesc:aefeea9b182f6e6e1a267b0bd157e7970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant holding a scalar/vector/tensor float (splat) and writes the float value to bind_value.  <br /></td></tr>
<tr class="memitem:a091c0686ba6d6f3ad4af9db1aea8063f" id="r_a091c0686ba6d6f3ad4af9db1aea8063f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__int__value__binder.html">detail::constant_int_value_binder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a091c0686ba6d6f3ad4af9db1aea8063f">m_ConstantInt</a> (IntegerAttr::ValueType *bind_value)</td></tr>
<tr class="memdesc:a091c0686ba6d6f3ad4af9db1aea8063f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant holding a scalar/vector/tensor integer (splat) and writes the integer value to bind_value.  <br /></td></tr>
<tr class="memitem:a7ecde76b07cd295bae0d6ef10d1c45d8" id="r_a7ecde76b07cd295bae0d6ef10d1c45d8"><td class="memTemplParams" colspan="2">template&lt;typename OpType, typename... Matchers&gt; </td></tr>
<tr class="memitem:a7ecde76b07cd295bae0d6ef10d1c45d8 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ecde76b07cd295bae0d6ef10d1c45d8">m_Op</a> (Matchers... matchers)</td></tr>
<tr class="memitem:a5254079fbbd31a78a3430bff18df2d7c" id="r_a5254079fbbd31a78a3430bff18df2d7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5254079fbbd31a78a3430bff18df2d7c">registerMLIRContextCLOptions</a> ()</td></tr>
<tr class="memdesc:a5254079fbbd31a78a3430bff18df2d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a set of useful command-line options that can be used to configure various flags within the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a>.  <br /></td></tr>
<tr class="memitem:abb62375c248ed1a8f282211f5d0cedd8" id="r_abb62375c248ed1a8f282211f5d0cedd8"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb62375c248ed1a8f282211f5d0cedd8">convertFromAttribute</a> (<a class="el" href="classint64__t.html">int64_t</a> &amp;storage, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr, <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>)</td></tr>
<tr class="memdesc:abb62375c248ed1a8f282211f5d0cedd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an IntegerAttr attribute to an <a class="el" href="classint64__t.html">int64_t</a>, or return an error if the attribute isn't an IntegerAttr.  <br /></td></tr>
<tr class="memitem:ab81e61402439e0b78cd25dc4ad7eb591" id="r_ab81e61402439e0b78cd25dc4ad7eb591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab81e61402439e0b78cd25dc4ad7eb591">convertToAttribute</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classint64__t.html">int64_t</a> storage)</td></tr>
<tr class="memdesc:ab81e61402439e0b78cd25dc4ad7eb591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the provided <a class="el" href="classint64__t.html">int64_t</a> to an IntegerAttr attribute.  <br /></td></tr>
<tr class="memitem:abaaf50aca64f58a65c55414d3f3309d5" id="r_abaaf50aca64f58a65c55414d3f3309d5"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abaaf50aca64f58a65c55414d3f3309d5">convertFromAttribute</a> (int32_t &amp;storage, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr, <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>)</td></tr>
<tr class="memdesc:abaaf50aca64f58a65c55414d3f3309d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an IntegerAttr attribute to an int32_t, or return an error if the attribute isn't an IntegerAttr.  <br /></td></tr>
<tr class="memitem:adc7fea0a3f8193ef3ab5dd53c78968f6" id="r_adc7fea0a3f8193ef3ab5dd53c78968f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc7fea0a3f8193ef3ab5dd53c78968f6">convertToAttribute</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, int32_t storage)</td></tr>
<tr class="memdesc:adc7fea0a3f8193ef3ab5dd53c78968f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the provided int32_t to an IntegerAttr attribute.  <br /></td></tr>
<tr class="memitem:a981b42df6743d410432f0e45a378448f" id="r_a981b42df6743d410432f0e45a378448f"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a981b42df6743d410432f0e45a378448f">convertFromAttribute</a> (int8_t &amp;storage, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr, <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>)</td></tr>
<tr class="memdesc:a981b42df6743d410432f0e45a378448f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an IntegerAttr attribute to an int8_t, or return an error if the attribute isn't an IntegerAttr.  <br /></td></tr>
<tr class="memitem:abf99f6ed6149460531799878f061456b" id="r_abf99f6ed6149460531799878f061456b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf99f6ed6149460531799878f061456b">convertToAttribute</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, int8_t storage)</td></tr>
<tr class="memdesc:abf99f6ed6149460531799878f061456b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the provided int8_t to an IntegerAttr attribute.  <br /></td></tr>
<tr class="memitem:af70830e5507912cdb5082955f8517fb9" id="r_af70830e5507912cdb5082955f8517fb9"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af70830e5507912cdb5082955f8517fb9">convertFromAttribute</a> (uint8_t &amp;storage, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr, <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>)</td></tr>
<tr class="memdesc:af70830e5507912cdb5082955f8517fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an IntegerAttr attribute to an uint8_t, or return an error if the attribute isn't an IntegerAttr.  <br /></td></tr>
<tr class="memitem:a985e89e4699d13cf9ff448d0eefdcb43" id="r_a985e89e4699d13cf9ff448d0eefdcb43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a985e89e4699d13cf9ff448d0eefdcb43">convertToAttribute</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, uint8_t storage)</td></tr>
<tr class="memdesc:a985e89e4699d13cf9ff448d0eefdcb43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the provided uint8_t to an IntegerAttr attribute.  <br /></td></tr>
<tr class="memitem:a9846d2959aaf3565b6e538b320b19c4a" id="r_a9846d2959aaf3565b6e538b320b19c4a"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9846d2959aaf3565b6e538b320b19c4a">convertFromAttribute</a> (std::string &amp;storage, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr, <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>)</td></tr>
<tr class="memdesc:a9846d2959aaf3565b6e538b320b19c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the string from <span class="tt">attr</span> into <span class="tt">storage</span>.  <br /></td></tr>
<tr class="memitem:a68dfe2bb2693d4a826a40b0c0a7cc362" id="r_a68dfe2bb2693d4a826a40b0c0a7cc362"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68dfe2bb2693d4a826a40b0c0a7cc362">convertToAttribute</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, const std::string &amp;storage)</td></tr>
<tr class="memdesc:a68dfe2bb2693d4a826a40b0c0a7cc362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given string into a StringAttr.  <br /></td></tr>
<tr class="memitem:a8def5e235dec49017ed2ab6ca765e96f" id="r_a8def5e235dec49017ed2ab6ca765e96f"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8def5e235dec49017ed2ab6ca765e96f">convertFromAttribute</a> (<a class="el" href="classbool.html">bool</a> &amp;storage, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr, <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>)</td></tr>
<tr class="memdesc:a8def5e235dec49017ed2ab6ca765e96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the boolean from <span class="tt">attr</span> into <span class="tt">storage</span>.  <br /></td></tr>
<tr class="memitem:a2aad04a9375046387a3f9a4bea0293ec" id="r_a2aad04a9375046387a3f9a4bea0293ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2aad04a9375046387a3f9a4bea0293ec">convertToAttribute</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classbool.html">bool</a> storage)</td></tr>
<tr class="memdesc:a2aad04a9375046387a3f9a4bea0293ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given string into a BooleanAttr.  <br /></td></tr>
<tr class="memitem:a7950ff8da3b75555e08167ea5ea94eed" id="r_a7950ff8da3b75555e08167ea5ea94eed"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7950ff8da3b75555e08167ea5ea94eed">convertFromAttribute</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; storage, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr, <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>)</td></tr>
<tr class="memdesc:a7950ff8da3b75555e08167ea5ea94eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="#a12cd3f8e7b8c9f2cac6f17ff1dd80cd8">DenseI64ArrayAttr</a> to the provided storage.  <br /></td></tr>
<tr class="memitem:a44ed2f9952d1cb1a2eb02252768af95b" id="r_a44ed2f9952d1cb1a2eb02252768af95b"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44ed2f9952d1cb1a2eb02252768af95b">convertFromAttribute</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; int32_t &gt; storage, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr, <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>)</td></tr>
<tr class="memdesc:a44ed2f9952d1cb1a2eb02252768af95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="#a8810f74ec6699911bda66ad210693ab9">DenseI32ArrayAttr</a> to the provided storage.  <br /></td></tr>
<tr class="memitem:ae3dd8a9b554ad036fb40ec639db2b065" id="r_ae3dd8a9b554ad036fb40ec639db2b065"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3dd8a9b554ad036fb40ec639db2b065">convertFromAttribute</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &amp;storage, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr, <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>)</td></tr>
<tr class="memdesc:ae3dd8a9b554ad036fb40ec639db2b065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="#a12cd3f8e7b8c9f2cac6f17ff1dd80cd8">DenseI64ArrayAttr</a> to the provided storage, which will be cleared before writing.  <br /></td></tr>
<tr class="memitem:a588ba679548595723d4e190dd6dc80b9" id="r_a588ba679548595723d4e190dd6dc80b9"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a588ba679548595723d4e190dd6dc80b9">convertFromAttribute</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int32_t &gt; &amp;storage, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr, <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>)</td></tr>
<tr class="memdesc:a588ba679548595723d4e190dd6dc80b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="#a8810f74ec6699911bda66ad210693ab9">DenseI32ArrayAttr</a> to the provided storage, which will be cleared before writing.  <br /></td></tr>
<tr class="memitem:abd5c480f463f3ed7b6369caae8c8d366" id="r_abd5c480f463f3ed7b6369caae8c8d366"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd5c480f463f3ed7b6369caae8c8d366">convertToAttribute</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; storage)</td></tr>
<tr class="memdesc:abd5c480f463f3ed7b6369caae8c8d366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the provided <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;int64_t&gt;</a> to a <a class="el" href="#a12cd3f8e7b8c9f2cac6f17ff1dd80cd8">DenseI64ArrayAttr</a> attribute.  <br /></td></tr>
<tr class="memitem:a081568ff8bd9ba6a6dc9a023fe5103d3" id="r_a081568ff8bd9ba6a6dc9a023fe5103d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a081568ff8bd9ba6a6dc9a023fe5103d3">convertToAttribute</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int32_t &gt; storage)</td></tr>
<tr class="memdesc:a081568ff8bd9ba6a6dc9a023fe5103d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the provided <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;int32_t&gt;</a> to a <a class="el" href="#a8810f74ec6699911bda66ad210693ab9">DenseI32ArrayAttr</a> attribute.  <br /></td></tr>
<tr class="memitem:abc4f129dda2c412845b5ec66a77325a3" id="r_abc4f129dda2c412845b5ec66a77325a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc4f129dda2c412845b5ec66a77325a3">operator==</a> (<a class="el" href="classmlir_1_1OpState.html">OpState</a> <a class="el" href="IR_2AffineExpr_8cpp.html#a204f446339af7929852f44df41484be5">lhs</a>, <a class="el" href="classmlir_1_1OpState.html">OpState</a> <a class="el" href="VectorTransforms_8cpp.html#a611c177776150f2e11f15c1cec5764c1">rhs</a>)</td></tr>
<tr class="memitem:aee326f96469cd288efb48265e173295e" id="r_aee326f96469cd288efb48265e173295e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee326f96469cd288efb48265e173295e">operator!=</a> (<a class="el" href="classmlir_1_1OpState.html">OpState</a> <a class="el" href="IR_2AffineExpr_8cpp.html#a204f446339af7929852f44df41484be5">lhs</a>, <a class="el" href="classmlir_1_1OpState.html">OpState</a> <a class="el" href="VectorTransforms_8cpp.html#a611c177776150f2e11f15c1cec5764c1">rhs</a>)</td></tr>
<tr class="memitem:a8c357b30f2e56803678fe5f7b75e80a1" id="r_a8c357b30f2e56803678fe5f7b75e80a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c357b30f2e56803678fe5f7b75e80a1">operator&lt;&lt;</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr)</td></tr>
<tr class="memdesc:a8c357b30f2e56803678fe5f7b75e80a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow printing to a stream.  <br /></td></tr>
<tr class="memitem:a4b8f6ec965d2fe8aa8366a1a2a3a5625" id="r_a4b8f6ec965d2fe8aa8366a1a2a3a5625"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b8f6ec965d2fe8aa8366a1a2a3a5625">operator&lt;&lt;</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, <a class="el" href="classmlir_1_1OpState.html">OpState</a> op)</td></tr>
<tr class="memdesc:a4b8f6ec965d2fe8aa8366a1a2a3a5625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow printing to a stream.  <br /></td></tr>
<tr class="memitem:a562b0755b16f72f37cd4a237a1a4726e" id="r_a562b0755b16f72f37cd4a237a1a4726e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a562b0755b16f72f37cd4a237a1a4726e">operator&lt;&lt;</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, const <a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;op)</td></tr>
<tr class="memitem:abc6d43cb09978b626a10009d6717ac19" id="r_abc6d43cb09978b626a10009d6717ac19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc6d43cb09978b626a10009d6717ac19">operator&lt;&lt;</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, <a class="el" href="classmlir_1_1OpWithFlags.html">OpWithFlags</a> opWithFlags)</td></tr>
<tr class="memitem:adff0953d991123738b20a3a06880bf4f" id="r_adff0953d991123738b20a3a06880bf4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adff0953d991123738b20a3a06880bf4f">operator&lt;&lt;</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, const <a class="el" href="classmlir_1_1OpWithState.html">OpWithState</a> &amp;opWithState)</td></tr>
<tr class="memitem:a8e27c9f52d26754f19dd7389f3fcba13" id="r_a8e27c9f52d26754f19dd7389f3fcba13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e27c9f52d26754f19dd7389f3fcba13">operator&lt;&lt;</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, <a class="el" href="classmlir_1_1OperationName.html">OperationName</a> info)</td></tr>
<tr class="memitem:ad93109842c1b05424c5052d9bd9a4394" id="r_ad93109842c1b05424c5052d9bd9a4394"><td class="memItemLeft" align="right" valign="top">llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad93109842c1b05424c5052d9bd9a4394">hash_value</a> (<a class="el" href="classmlir_1_1OperationName.html">OperationName</a> arg)</td></tr>
<tr class="memitem:af912da94236cff04e9076f6e052676b1" id="r_af912da94236cff04e9076f6e052676b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af912da94236cff04e9076f6e052676b1">LLVM_ENABLE_BITMASK_ENUMS_IN_NAMESPACE</a> ()</td></tr>
<tr class="memdesc:af912da94236cff04e9076f6e052676b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable Bitmask enums for <a class="el" href="structmlir_1_1OperationEquivalence.html#a292ebf6a0885a07fd4c94f9750587dfe">OperationEquivalence::Flags</a>.  <br /></td></tr>
<tr class="memitem:aac18c17aca8d8a8549fef55a52af5393" id="r_aac18c17aca8d8a8549fef55a52af5393"><td class="memItemLeft" align="right" valign="top">llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac18c17aca8d8a8549fef55a52af5393">hash_value</a> (const <a class="el" href="classmlir_1_1AsmDialectResourceHandle.html">AsmDialectResourceHandle</a> &amp;param)</td></tr>
<tr class="memitem:abd77c78ac9e1328408b0b68a432bfeb7" id="r_abd77c78ac9e1328408b0b68a432bfeb7"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT&gt; </td></tr>
<tr class="memitem:abd77c78ac9e1328408b0b68a432bfeb7 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd77c78ac9e1328408b0b68a432bfeb7">operator&lt;&lt;</a> (AsmPrinterT &amp;p, <a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="memitem:aa8ebd23da6c03a288b5c18332b631820" id="r_aa8ebd23da6c03a288b5c18332b631820"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT&gt; </td></tr>
<tr class="memitem:aa8ebd23da6c03a288b5c18332b631820 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8ebd23da6c03a288b5c18332b631820">operator&lt;&lt;</a> (AsmPrinterT &amp;p, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="memitem:aad6015509602df66ca1bd652646cb2f4" id="r_aad6015509602df66ca1bd652646cb2f4"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT&gt; </td></tr>
<tr class="memitem:aad6015509602df66ca1bd652646cb2f4 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad6015509602df66ca1bd652646cb2f4">operator&lt;&lt;</a> (AsmPrinterT &amp;p, const APFloat &amp;value)</td></tr>
<tr class="memitem:af822a020908515c46b867efc178eca9a" id="r_af822a020908515c46b867efc178eca9a"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT&gt; </td></tr>
<tr class="memitem:af822a020908515c46b867efc178eca9a template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af822a020908515c46b867efc178eca9a">operator&lt;&lt;</a> (AsmPrinterT &amp;p, float value)</td></tr>
<tr class="memitem:a5005efd19da059f389f19aba557cf694" id="r_a5005efd19da059f389f19aba557cf694"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT&gt; </td></tr>
<tr class="memitem:a5005efd19da059f389f19aba557cf694 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5005efd19da059f389f19aba557cf694">operator&lt;&lt;</a> (AsmPrinterT &amp;p, double value)</td></tr>
<tr class="memitem:aa8dacf7f3e3ed3310320966a4b83d744" id="r_aa8dacf7f3e3ed3310320966a4b83d744"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT, typename T, std::enable_if_t&lt;!std::is_convertible&lt; T &amp;, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp; &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, <a class="el" href="classmlir_1_1Type.html">Type</a> &amp; &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &amp; &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, APFloat &amp; &gt;::value &amp;&amp;!llvm::is_one_of&lt; T, <a class="el" href="classbool.html">bool</a>, float, double &gt;::value, T &gt; * = nullptr&gt; </td></tr>
<tr class="memitem:aa8dacf7f3e3ed3310320966a4b83d744 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8dacf7f3e3ed3310320966a4b83d744">operator&lt;&lt;</a> (AsmPrinterT &amp;p, const T &amp;other)</td></tr>
<tr class="memitem:a48a311b94dbcdd8d8a8f496782255017" id="r_a48a311b94dbcdd8d8a8f496782255017"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT&gt; </td></tr>
<tr class="memitem:a48a311b94dbcdd8d8a8f496782255017 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48a311b94dbcdd8d8a8f496782255017">operator&lt;&lt;</a> (AsmPrinterT &amp;p, <a class="el" href="classbool.html">bool</a> value)</td></tr>
<tr class="memitem:af58488c343a38262634f085412b61111" id="r_af58488c343a38262634f085412b61111"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT, typename ValueRangeT&gt; </td></tr>
<tr class="memitem:af58488c343a38262634f085412b61111 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af58488c343a38262634f085412b61111">operator&lt;&lt;</a> (AsmPrinterT &amp;p, const <a class="el" href="classmlir_1_1ValueTypeRange.html">ValueTypeRange</a>&lt; ValueRangeT &gt; &amp;types)</td></tr>
<tr class="memitem:a2dcbaa0d8dada489c3adb5b030487e55" id="r_a2dcbaa0d8dada489c3adb5b030487e55"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT&gt; </td></tr>
<tr class="memitem:a2dcbaa0d8dada489c3adb5b030487e55 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2dcbaa0d8dada489c3adb5b030487e55">operator&lt;&lt;</a> (AsmPrinterT &amp;p, const <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> &amp;types)</td></tr>
<tr class="memitem:a36d6ce3e12cd2c5c887b82abd275b25b" id="r_a36d6ce3e12cd2c5c887b82abd275b25b"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT, typename T&gt; </td></tr>
<tr class="memitem:a36d6ce3e12cd2c5c887b82abd275b25b template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value &amp;&amp;std::is_convertible&lt; T &amp;, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36d6ce3e12cd2c5c887b82abd275b25b">operator&lt;&lt;</a> (AsmPrinterT &amp;p, const T &amp;other)=delete</td></tr>
<tr class="memitem:ab8eec2af29b78e6f1f81872e63d4824a" id="r_ab8eec2af29b78e6f1f81872e63d4824a"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT, typename ElementT&gt; </td></tr>
<tr class="memitem:ab8eec2af29b78e6f1f81872e63d4824a template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8eec2af29b78e6f1f81872e63d4824a">operator&lt;&lt;</a> (AsmPrinterT &amp;p, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; ElementT &gt; types)</td></tr>
<tr class="memitem:ae7e3ca24d197f44633191038fa9730d0" id="r_ae7e3ca24d197f44633191038fa9730d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7e3ca24d197f44633191038fa9730d0">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, <a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memitem:a0454cf763cf2a4bab30345a05f174fe6" id="r_a0454cf763cf2a4bab30345a05f174fe6"><td class="memTemplParams" colspan="2">template&lt;typename T, std::enable_if_t&lt; std::is_convertible&lt; T &amp;, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp; &gt;::value, T &gt; * = nullptr&gt; </td></tr>
<tr class="memitem:a0454cf763cf2a4bab30345a05f174fe6 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0454cf763cf2a4bab30345a05f174fe6">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, const T &amp;values)</td></tr>
<tr class="memitem:af58e1ab7641f5c0781af1f167b66d4ca" id="r_af58e1ab7641f5c0781af1f167b66d4ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af58e1ab7641f5c0781af1f167b66d4ca">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, <a class="el" href="classmlir_1_1Block.html">Block</a> *value)</td></tr>
<tr class="memitem:a34ab168056505b09c113dda01ee42d5e" id="r_a34ab168056505b09c113dda01ee42d5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34ab168056505b09c113dda01ee42d5e">printDimensionList</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;printer, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; dimensions)</td></tr>
<tr class="memitem:a12d828f0860b1c0863b1badf0fe06e30" id="r_a12d828f0860b1c0863b1badf0fe06e30"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12d828f0860b1c0863b1badf0fe06e30">parseDimensionList</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="#a12cd3f8e7b8c9f2cac6f17ff1dd80cd8">DenseI64ArrayAttr</a> &amp;dimensions)</td></tr>
<tr class="memitem:a3bf207a294e93baf22d2bc33d903b721" id="r_a3bf207a294e93baf22d2bc33d903b721"><td class="memItemLeft" align="right" valign="top">llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bf207a294e93baf22d2bc33d903b721">operator&lt;&lt;</a> (llvm::raw_ostream &amp;os, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region)</td></tr>
<tr class="memitem:a5ed40bd15766a7dff96f3d30577d8f87" id="r_a5ed40bd15766a7dff96f3d30577d8f87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ed40bd15766a7dff96f3d30577d8f87">mayHaveSSADominance</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region)</td></tr>
<tr class="memdesc:a5ed40bd15766a7dff96f3d30577d8f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return "true" if the given region may have SSA dominance.  <br /></td></tr>
<tr class="memitem:a5c318aa15564b0d662d9a699f74f8eea" id="r_a5c318aa15564b0d662d9a699f74f8eea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c318aa15564b0d662d9a699f74f8eea">mayBeGraphRegion</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region)</td></tr>
<tr class="memdesc:a5c318aa15564b0d662d9a699f74f8eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return "true" if the given region may be a graph region without SSA dominance.  <br /></td></tr>
<tr class="memitem:a78425f2c879f5b708f5c58af03931e9f" id="r_a78425f2c879f5b708f5c58af03931e9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78425f2c879f5b708f5c58af03931e9f">operator&lt;&lt;</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, <a class="el" href="classmlir_1_1SymbolTable.html#a4f1a6f39b93a08abe4e80a5c15fe32b8">SymbolTable::Visibility</a> visibility)</td></tr>
<tr class="memitem:a3083728e72d361c987c5e5a0e8d2f39a" id="r_a3083728e72d361c987c5e5a0e8d2f39a"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT, typename FuncT&gt; </td></tr>
<tr class="memitem:a3083728e72d361c987c5e5a0e8d2f39a template"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3083728e72d361c987c5e5a0e8d2f39a">failableParallelForEach</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, IteratorT begin, IteratorT end, FuncT &amp;&amp;func)</td></tr>
<tr class="memdesc:a3083728e72d361c987c5e5a0e8d2f39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the given function on the elements between [begin, end) asynchronously.  <br /></td></tr>
<tr class="memitem:a98aa0f01173a481075d9d5a2ca50d8ab" id="r_a98aa0f01173a481075d9d5a2ca50d8ab"><td class="memTemplParams" colspan="2">template&lt;typename RangeT, typename FuncT&gt; </td></tr>
<tr class="memitem:a98aa0f01173a481075d9d5a2ca50d8ab template"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98aa0f01173a481075d9d5a2ca50d8ab">failableParallelForEach</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, RangeT &amp;&amp;range, FuncT &amp;&amp;func)</td></tr>
<tr class="memdesc:a98aa0f01173a481075d9d5a2ca50d8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the given function on the elements in the provided range asynchronously.  <br /></td></tr>
<tr class="memitem:af5aa5179ec6f13db4eaa8fa255bde665" id="r_af5aa5179ec6f13db4eaa8fa255bde665"><td class="memTemplParams" colspan="2">template&lt;typename FuncT&gt; </td></tr>
<tr class="memitem:af5aa5179ec6f13db4eaa8fa255bde665 template"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5aa5179ec6f13db4eaa8fa255bde665">failableParallelForEachN</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, size_t begin, size_t end, FuncT &amp;&amp;func)</td></tr>
<tr class="memdesc:af5aa5179ec6f13db4eaa8fa255bde665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the given function on the elements between [begin, end) asynchronously.  <br /></td></tr>
<tr class="memitem:a7acf0c58d63da562112dd8f6a81b49e3" id="r_a7acf0c58d63da562112dd8f6a81b49e3"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT, typename FuncT&gt; </td></tr>
<tr class="memitem:a7acf0c58d63da562112dd8f6a81b49e3 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7acf0c58d63da562112dd8f6a81b49e3">parallelForEach</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, IteratorT begin, IteratorT end, FuncT &amp;&amp;func)</td></tr>
<tr class="memdesc:a7acf0c58d63da562112dd8f6a81b49e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the given function on the elements between [begin, end) asynchronously.  <br /></td></tr>
<tr class="memitem:af1232c5821e793866aa3cf2234e1ba93" id="r_af1232c5821e793866aa3cf2234e1ba93"><td class="memTemplParams" colspan="2">template&lt;typename RangeT, typename FuncT&gt; </td></tr>
<tr class="memitem:af1232c5821e793866aa3cf2234e1ba93 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1232c5821e793866aa3cf2234e1ba93">parallelForEach</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, RangeT &amp;&amp;range, FuncT &amp;&amp;func)</td></tr>
<tr class="memdesc:af1232c5821e793866aa3cf2234e1ba93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the given function on the elements in the provided range asynchronously.  <br /></td></tr>
<tr class="memitem:ad02ff92115796118c612bc82db603b7e" id="r_ad02ff92115796118c612bc82db603b7e"><td class="memTemplParams" colspan="2">template&lt;typename FuncT&gt; </td></tr>
<tr class="memitem:ad02ff92115796118c612bc82db603b7e template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad02ff92115796118c612bc82db603b7e">parallelFor</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, size_t begin, size_t end, FuncT &amp;&amp;func)</td></tr>
<tr class="memdesc:ad02ff92115796118c612bc82db603b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the given function on the elements between [begin, end) asynchronously.  <br /></td></tr>
<tr class="memitem:abb322b17530b4289c3e3ec1f4ad2ecce" id="r_abb322b17530b4289c3e3ec1f4ad2ecce"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb322b17530b4289c3e3ec1f4ad2ecce">hash_value</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> arg)</td></tr>
<tr class="memdesc:abb322b17530b4289c3e3ec1f4ad2ecce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make <a class="el" href="classmlir_1_1TypeRange.html" title="This class provides an abstraction over the various different ranges of value types.">TypeRange</a> hashable.  <br /></td></tr>
<tr class="memitem:a92c9dfdfaa5c9ea5bc0f92d5c5958ade" id="r_a92c9dfdfaa5c9ea5bc0f92d5c5958ade"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92c9dfdfaa5c9ea5bc0f92d5c5958ade">operator&lt;&lt;</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, const <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> &amp;types)</td></tr>
<tr class="memdesc:a92c9dfdfaa5c9ea5bc0f92d5c5958ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a type range to the given output stream.  <br /></td></tr>
<tr class="memitem:a8fc3d1f66f267d9111234fac1effdfce" id="r_a8fc3d1f66f267d9111234fac1effdfce"><td class="memTemplParams" colspan="2">template&lt;typename RangeT&gt; </td></tr>
<tr class="memitem:a8fc3d1f66f267d9111234fac1effdfce template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fc3d1f66f267d9111234fac1effdfce">operator==</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; <a class="el" href="IR_2AffineExpr_8cpp.html#a204f446339af7929852f44df41484be5">lhs</a>, const <a class="el" href="classmlir_1_1ValueTypeRange.html">ValueTypeRange</a>&lt; RangeT &gt; &amp;<a class="el" href="VectorTransforms_8cpp.html#a611c177776150f2e11f15c1cec5764c1">rhs</a>)</td></tr>
<tr class="memitem:a6786609f81b82b6052450de22a9b1b26" id="r_a6786609f81b82b6052450de22a9b1b26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6786609f81b82b6052450de22a9b1b26">operator&lt;&lt;</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, <a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="memitem:a31eede9183d3fdae566e18d94a5ef51b" id="r_a31eede9183d3fdae566e18d94a5ef51b"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31eede9183d3fdae566e18d94a5ef51b">hash_value</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> arg)</td></tr>
<tr class="memitem:a82686ceb29eb0f78b59e29021f1b2cdd" id="r_a82686ceb29eb0f78b59e29021f1b2cdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82686ceb29eb0f78b59e29021f1b2cdd">getElementTypeOrSelf</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="memdesc:a82686ceb29eb0f78b59e29021f1b2cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element type or return the type itself.  <br /></td></tr>
<tr class="memitem:a252aee27751e05d584d0b1a8e793ecf0" id="r_a252aee27751e05d584d0b1a8e793ecf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a252aee27751e05d584d0b1a8e793ecf0">getElementTypeOrSelf</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="memdesc:a252aee27751e05d584d0b1a8e793ecf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element type or return the type itself.  <br /></td></tr>
<tr class="memitem:ae81d443c449b61825fb2c2ec6aa90d35" id="r_ae81d443c449b61825fb2c2ec6aa90d35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae81d443c449b61825fb2c2ec6aa90d35">getElementTypeOrSelf</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memitem:a46bbb7497276c5ea7e8ed4ad1315bf40" id="r_a46bbb7497276c5ea7e8ed4ad1315bf40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a>, 10 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46bbb7497276c5ea7e8ed4ad1315bf40">getFlattenedTypes</a> (TupleType t)</td></tr>
<tr class="memdesc:a46bbb7497276c5ea7e8ed4ad1315bf40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the types within a nested Tuple.  <br /></td></tr>
<tr class="memitem:a4bd6b581b08699ce79d3e9f820c1ade9" id="r_a4bd6b581b08699ce79d3e9f820c1ade9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bd6b581b08699ce79d3e9f820c1ade9">isOpaqueTypeWithName</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, StringRef dialect, StringRef typeData)</td></tr>
<tr class="memdesc:a4bd6b581b08699ce79d3e9f820c1ade9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified type is an opaque type with the specified dialect and typeData.  <br /></td></tr>
<tr class="memitem:acb414ad1d507c2ab841305c273f4deb8" id="r_acb414ad1d507c2ab841305c273f4deb8"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb414ad1d507c2ab841305c273f4deb8">verifyCompatibleShape</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; shape1, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; shape2)</td></tr>
<tr class="memdesc:acb414ad1d507c2ab841305c273f4deb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns success if the given two shapes are compatible.  <br /></td></tr>
<tr class="memitem:ac54e5e6c31f51ef648f7c03652a29ce6" id="r_ac54e5e6c31f51ef648f7c03652a29ce6"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac54e5e6c31f51ef648f7c03652a29ce6">verifyCompatibleShape</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type1, <a class="el" href="classmlir_1_1Type.html">Type</a> type2)</td></tr>
<tr class="memdesc:ac54e5e6c31f51ef648f7c03652a29ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns success if the given two types have compatible shape.  <br /></td></tr>
<tr class="memitem:a2801a1733326688cf0c9bee8d633f234" id="r_a2801a1733326688cf0c9bee8d633f234"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2801a1733326688cf0c9bee8d633f234">verifyCompatibleShapes</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types1, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types2)</td></tr>
<tr class="memdesc:a2801a1733326688cf0c9bee8d633f234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns success if the given two arrays have the same number of elements and each pair wise entries have compatible shape.  <br /></td></tr>
<tr class="memitem:a132fff065736d8e977fe8179f2e7086c" id="r_a132fff065736d8e977fe8179f2e7086c"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a132fff065736d8e977fe8179f2e7086c">verifyCompatibleShapes</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types)</td></tr>
<tr class="memdesc:a132fff065736d8e977fe8179f2e7086c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns success if all given types have compatible shapes.  <br /></td></tr>
<tr class="memitem:a961cf9926486f7d6e7160efa8f846d64" id="r_a961cf9926486f7d6e7160efa8f846d64"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a961cf9926486f7d6e7160efa8f846d64">verifyCompatibleDims</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; dims)</td></tr>
<tr class="memdesc:a961cf9926486f7d6e7160efa8f846d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimensions are compatible if all non-dynamic dims are equal.  <br /></td></tr>
<tr class="memitem:ae873ed9c30ada4ee5e87cf53a550c610" id="r_ae873ed9c30ada4ee5e87cf53a550c610"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae873ed9c30ada4ee5e87cf53a550c610">insertTypesInto</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> oldTypes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; <a class="el" href="AffineAnalysis_8cpp.html#a7b261d2d5f193015afc3427b0c0951ed">indices</a>, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> newTypes, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;storage)</td></tr>
<tr class="memdesc:ae873ed9c30ada4ee5e87cf53a550c610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a set of <span class="tt">newTypes</span> into <span class="tt">oldTypes</span> at the given <span class="tt">indices</span>.  <br /></td></tr>
<tr class="memitem:a6ceb7a2611f873431057e03992432701" id="r_a6ceb7a2611f873431057e03992432701"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ceb7a2611f873431057e03992432701">filterTypesOut</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types, const BitVector &amp;<a class="el" href="AffineAnalysis_8cpp.html#a7b261d2d5f193015afc3427b0c0951ed">indices</a>, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;storage)</td></tr>
<tr class="memdesc:a6ceb7a2611f873431057e03992432701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters out any elements referenced by <span class="tt">indices</span>.  <br /></td></tr>
<tr class="memitem:a8f9664a2bf70922634eb43fbb1a21d6f" id="r_a8f9664a2bf70922634eb43fbb1a21d6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f9664a2bf70922634eb43fbb1a21d6f">operator&lt;&lt;</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, const <a class="el" href="classmlir_1_1IRUnit.html">IRUnit</a> &amp;unit)</td></tr>
<tr class="memitem:a95e1190b2da04d950c05089d47cd09ff" id="r_a95e1190b2da04d950c05089d47cd09ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95e1190b2da04d950c05089d47cd09ff">operator&lt;&lt;</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, <a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memitem:ab710b1f6f21f3f35197575b609aae4b4" id="r_ab710b1f6f21f3f35197575b609aae4b4"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab710b1f6f21f3f35197575b609aae4b4">hash_value</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> arg)</td></tr>
<tr class="memdesc:ab710b1f6f21f3f35197575b609aae4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> hashable.  <br /></td></tr>
<tr class="memitem:ae4b1ba650fd43b50351e92bbb75bd4c0" id="r_ae4b1ba650fd43b50351e92bbb75bd4c0"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4b1ba650fd43b50351e92bbb75bd4c0">verify</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classbool.html">bool</a> verifyRecursively=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:ae4b1ba650fd43b50351e92bbb75bd4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform (potentially expensive) checks of invariants, used to detect compiler bugs, on this operation and any nested operations.  <br /></td></tr>
<tr class="memitem:ab0f975095772c8ece0dbda8bf7f455eb" id="r_ab0f975095772c8ece0dbda8bf7f455eb"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0f975095772c8ece0dbda8bf7f455eb">parseSourceFile</a> (const llvm::SourceMgr &amp;sourceMgr, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;<a class="el" href="#a3ecea12db18ed347ea11d1d999237b24">config</a>, <a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *sourceFileLoc=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:ab0f975095772c8ece0dbda8bf7f455eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated SourceMgr and appends parsed operations to the given block.  <br /></td></tr>
<tr class="memitem:a537a80c31d8487a710f53cd9a38e390a" id="r_a537a80c31d8487a710f53cd9a38e390a"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a537a80c31d8487a710f53cd9a38e390a">parseSourceFile</a> (const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;sourceMgr, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;<a class="el" href="#a3ecea12db18ed347ea11d1d999237b24">config</a>, <a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *sourceFileLoc=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a537a80c31d8487a710f53cd9a38e390a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overload with a source manager that may have references taken during the parsing process, and whose lifetime can be freely extended (such that the source manager is not destroyed before the parsed IR).  <br /></td></tr>
<tr class="memitem:a006a32917056b7f14d65e9ea5cc08392" id="r_a006a32917056b7f14d65e9ea5cc08392"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a006a32917056b7f14d65e9ea5cc08392">parseSourceFile</a> (llvm::StringRef filename, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;<a class="el" href="#a3ecea12db18ed347ea11d1d999237b24">config</a>, <a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *sourceFileLoc=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a006a32917056b7f14d65e9ea5cc08392"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated filename and appends parsed operations to the given block.  <br /></td></tr>
<tr class="memitem:a13ad011b0b3c1635c410fe60bfd557c2" id="r_a13ad011b0b3c1635c410fe60bfd557c2"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13ad011b0b3c1635c410fe60bfd557c2">parseSourceFile</a> (llvm::StringRef filename, llvm::SourceMgr &amp;sourceMgr, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;<a class="el" href="#a3ecea12db18ed347ea11d1d999237b24">config</a>, <a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *sourceFileLoc=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a13ad011b0b3c1635c410fe60bfd557c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated filename using the provided SourceMgr and appends parsed operations to the given block.  <br /></td></tr>
<tr class="memitem:a54875232f3a58ed939964dc275d1e36f" id="r_a54875232f3a58ed939964dc275d1e36f"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54875232f3a58ed939964dc275d1e36f">parseSourceFile</a> (llvm::StringRef filename, const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;sourceMgr, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;<a class="el" href="#a3ecea12db18ed347ea11d1d999237b24">config</a>, <a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *sourceFileLoc=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a54875232f3a58ed939964dc275d1e36f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overload with a source manager that may have references taken during the parsing process, and whose lifetime can be freely extended (such that the source manager is not destroyed before the parsed IR).  <br /></td></tr>
<tr class="memitem:a80178c9e23c4fd7db357124cbe19651a" id="r_a80178c9e23c4fd7db357124cbe19651a"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80178c9e23c4fd7db357124cbe19651a">parseSourceString</a> (llvm::StringRef sourceStr, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;<a class="el" href="#a3ecea12db18ed347ea11d1d999237b24">config</a>, StringRef sourceName=&quot;&quot;, <a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *sourceFileLoc=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a80178c9e23c4fd7db357124cbe19651a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the IR string and appends parsed operations to the given block.  <br /></td></tr>
<tr class="memitem:abd9f27d3cd1ed0e2476079e5b21bd280" id="r_abd9f27d3cd1ed0e2476079e5b21bd280"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT = Operation *&gt; </td></tr>
<tr class="memitem:abd9f27d3cd1ed0e2476079e5b21bd280 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd9f27d3cd1ed0e2476079e5b21bd280">parseSourceFile</a> (const llvm::SourceMgr &amp;sourceMgr, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;<a class="el" href="#a3ecea12db18ed347ea11d1d999237b24">config</a>)</td></tr>
<tr class="memdesc:abd9f27d3cd1ed0e2476079e5b21bd280"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated SourceMgr.  <br /></td></tr>
<tr class="memitem:a1cb2000f972c9b5bdd065f9df337daf6" id="r_a1cb2000f972c9b5bdd065f9df337daf6"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT = Operation *&gt; </td></tr>
<tr class="memitem:a1cb2000f972c9b5bdd065f9df337daf6 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1cb2000f972c9b5bdd065f9df337daf6">parseSourceFile</a> (const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;sourceMgr, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;<a class="el" href="#a3ecea12db18ed347ea11d1d999237b24">config</a>)</td></tr>
<tr class="memdesc:a1cb2000f972c9b5bdd065f9df337daf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overload with a source manager that may have references taken during the parsing process, and whose lifetime can be freely extended (such that the source manager is not destroyed before the parsed IR).  <br /></td></tr>
<tr class="memitem:ad8ee13d8990b60e1f9a11f3b4f86b1fa" id="r_ad8ee13d8990b60e1f9a11f3b4f86b1fa"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT = Operation *&gt; </td></tr>
<tr class="memitem:ad8ee13d8990b60e1f9a11f3b4f86b1fa template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8ee13d8990b60e1f9a11f3b4f86b1fa">parseSourceFile</a> (StringRef filename, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;<a class="el" href="#a3ecea12db18ed347ea11d1d999237b24">config</a>)</td></tr>
<tr class="memdesc:ad8ee13d8990b60e1f9a11f3b4f86b1fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated filename.  <br /></td></tr>
<tr class="memitem:a268594711173cad736a1f63c3cc87dd2" id="r_a268594711173cad736a1f63c3cc87dd2"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT = Operation *&gt; </td></tr>
<tr class="memitem:a268594711173cad736a1f63c3cc87dd2 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a268594711173cad736a1f63c3cc87dd2">parseSourceFile</a> (llvm::StringRef filename, llvm::SourceMgr &amp;sourceMgr, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;<a class="el" href="#a3ecea12db18ed347ea11d1d999237b24">config</a>)</td></tr>
<tr class="memdesc:a268594711173cad736a1f63c3cc87dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated filename using the provided SourceMgr.  <br /></td></tr>
<tr class="memitem:a03c54eff1ecb9aed89506db0c67637ef" id="r_a03c54eff1ecb9aed89506db0c67637ef"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT = Operation *&gt; </td></tr>
<tr class="memitem:a03c54eff1ecb9aed89506db0c67637ef template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03c54eff1ecb9aed89506db0c67637ef">parseSourceFile</a> (llvm::StringRef filename, const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;sourceMgr, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;<a class="el" href="#a3ecea12db18ed347ea11d1d999237b24">config</a>)</td></tr>
<tr class="memdesc:a03c54eff1ecb9aed89506db0c67637ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overload with a source manager that may have references taken during the parsing process, and whose lifetime can be freely extended (such that the source manager is not destroyed before the parsed IR).  <br /></td></tr>
<tr class="memitem:af093c42a93dadc189eb4502ffcc4395c" id="r_af093c42a93dadc189eb4502ffcc4395c"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT = Operation *&gt; </td></tr>
<tr class="memitem:af093c42a93dadc189eb4502ffcc4395c template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af093c42a93dadc189eb4502ffcc4395c">parseSourceString</a> (llvm::StringRef sourceStr, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;<a class="el" href="#a3ecea12db18ed347ea11d1d999237b24">config</a>, StringRef sourceName=&quot;&quot;)</td></tr>
<tr class="memdesc:af093c42a93dadc189eb4502ffcc4395c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the provided string containing MLIR.  <br /></td></tr>
<tr class="memitem:a4df3b51e6123c8ab9fb3809ba255e00b" id="r_a4df3b51e6123c8ab9fb3809ba255e00b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4df3b51e6123c8ab9fb3809ba255e00b">makeReproducer</a> (StringRef anchorName, const <a class="el" href="classllvm_1_1iterator__range.html">llvm::iterator_range</a>&lt; <a class="el" href="classmlir_1_1OpPassManager.html#a837570fd9379798502631e59734ae30e">OpPassManager::pass_iterator</a> &gt; &amp;passes, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, StringRef outputFile, <a class="el" href="classbool.html">bool</a> disableThreads=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>, <a class="el" href="classbool.html">bool</a> verifyPasses=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memitem:aa5c4edce10b597637635af55bb162477" id="r_aa5c4edce10b597637635af55bb162477"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5c4edce10b597637635af55bb162477">registerPassManagerCLOptions</a> ()</td></tr>
<tr class="memdesc:aa5c4edce10b597637635af55bb162477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a set of useful command-line options that can be used to configure a pass manager.  <br /></td></tr>
<tr class="memitem:a133398d008de5837d6df9b322b62f5f6" id="r_a133398d008de5837d6df9b322b62f5f6"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a133398d008de5837d6df9b322b62f5f6">applyPassManagerCLOptions</a> (<a class="el" href="classmlir_1_1PassManager.html">PassManager</a> &amp;pm)</td></tr>
<tr class="memdesc:a133398d008de5837d6df9b322b62f5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply any values provided to the pass manager options that were registered with 'registerPassManagerOptions'.  <br /></td></tr>
<tr class="memitem:acd78ebb9f95cfe7ea3856d9f9c46d030" id="r_acd78ebb9f95cfe7ea3856d9f9c46d030"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd78ebb9f95cfe7ea3856d9f9c46d030">applyDefaultTimingPassManagerCLOptions</a> (<a class="el" href="classmlir_1_1PassManager.html">PassManager</a> &amp;pm)</td></tr>
<tr class="memdesc:acd78ebb9f95cfe7ea3856d9f9c46d030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply any values provided to the timing manager options that were registered with <span class="tt">registerDefaultTimingManagerOptions</span>.  <br /></td></tr>
<tr class="memitem:a41d5e525ca50e6257e78416957f7778c" id="r_a41d5e525ca50e6257e78416957f7778c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41d5e525ca50e6257e78416957f7778c">printRegisteredPasses</a> ()</td></tr>
<tr class="memdesc:a41d5e525ca50e6257e78416957f7778c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the passes that were previously registered and stored in passRegistry.  <br /></td></tr>
<tr class="memitem:a83965c855ad737422194336251348893" id="r_a83965c855ad737422194336251348893"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83965c855ad737422194336251348893">registerPassPipeline</a> (StringRef arg, StringRef description, const <a class="el" href="#a1eb8eb86939076c1bf86f544e23aef0e">PassRegistryFunction</a> &amp;function, std::function&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(const <a class="el" href="classmlir_1_1detail_1_1PassOptions.html">detail::PassOptions</a> &amp;)&gt;)&gt; optHandler)</td></tr>
<tr class="memdesc:a83965c855ad737422194336251348893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a specific dialect pipeline registry function with the system, typically used through the <a class="el" href="structmlir_1_1PassPipelineRegistration.html" title="PassPipelineRegistration provides a global initializer that registers a Pass pipeline builder routine...">PassPipelineRegistration</a> template.  <br /></td></tr>
<tr class="memitem:a5a4626059212aef6f3aa5fa7088ce667" id="r_a5a4626059212aef6f3aa5fa7088ce667"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a4626059212aef6f3aa5fa7088ce667">registerPass</a> (const <a class="el" href="#a13509926eab92d24bb5729fef49bdf37">PassAllocatorFunction</a> &amp;function)</td></tr>
<tr class="memdesc:a5a4626059212aef6f3aa5fa7088ce667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a specific dialect pass allocator function with the system, typically used through the <a class="el" href="structmlir_1_1PassRegistration.html" title="PassRegistration provides a global initializer that registers a Pass allocation routine for a concret...">PassRegistration</a> template.  <br /></td></tr>
<tr class="memitem:ad8d10077c7edf58c1152a1170257d739" id="r_ad8d10077c7edf58c1152a1170257d739"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8d10077c7edf58c1152a1170257d739">parsePassPipeline</a> (StringRef pipeline, <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;pm, <a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;errorStream=llvm::errs())</td></tr>
<tr class="memdesc:ad8d10077c7edf58c1152a1170257d739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the textual representation of a pass pipeline, adding the result to 'pm' on success.  <br /></td></tr>
<tr class="memitem:aef5abaea7950d9dc385a018dbbb40d0b" id="r_aef5abaea7950d9dc385a018dbbb40d0b"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef5abaea7950d9dc385a018dbbb40d0b">parsePassPipeline</a> (StringRef pipeline, <a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;errorStream=llvm::errs())</td></tr>
<tr class="memdesc:aef5abaea7950d9dc385a018dbbb40d0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the given textual representation of a pass pipeline, and return the parsed pipeline on success.  <br /></td></tr>
<tr class="memitem:ab6588ae12002d371fd6b5c1afa41dc9e" id="r_ab6588ae12002d371fd6b5c1afa41dc9e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6588ae12002d371fd6b5c1afa41dc9e">createOptReductionPass</a> ()</td></tr>
<tr class="memitem:a755d1f9cb439d725bf5fb1ac1fdb5365" id="r_a755d1f9cb439d725bf5fb1ac1fdb5365"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a755d1f9cb439d725bf5fb1ac1fdb5365">createOptReductionPass</a> (<a class="el" href="structmlir_1_1OptReductionPassOptions.html">OptReductionPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a4b89c742e753afbb6502b61b2c79732b" id="r_a4b89c742e753afbb6502b61b2c79732b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b89c742e753afbb6502b61b2c79732b">createReductionTreePass</a> ()</td></tr>
<tr class="memitem:af2effc06aa98d551670ed273542853d6" id="r_af2effc06aa98d551670ed273542853d6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2effc06aa98d551670ed273542853d6">createReductionTreePass</a> (<a class="el" href="structmlir_1_1ReductionTreePassOptions.html">ReductionTreePassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:ae18ecc9eaa414b5de74e7c8eb2eecea8" id="r_ae18ecc9eaa414b5de74e7c8eb2eecea8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae18ecc9eaa414b5de74e7c8eb2eecea8">registerOptReductionPass</a> ()</td></tr>
<tr class="memitem:acb4b3950c4cb51f6f4089625f2e5c76e" id="r_acb4b3950c4cb51f6f4089625f2e5c76e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb4b3950c4cb51f6f4089625f2e5c76e">registerOptReductionPassPass</a> ()</td></tr>
<tr class="memitem:ad6f16e0db4eded0cefae0e63db471b32" id="r_ad6f16e0db4eded0cefae0e63db471b32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6f16e0db4eded0cefae0e63db471b32">registerReductionTreePass</a> ()</td></tr>
<tr class="memitem:a892a8e3becb55d2f56f877d4df851435" id="r_a892a8e3becb55d2f56f877d4df851435"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a892a8e3becb55d2f56f877d4df851435">registerReductionTreePassPass</a> ()</td></tr>
<tr class="memitem:af871dbe2d47c7f6da2d9e40ad12065e2" id="r_af871dbe2d47c7f6da2d9e40ad12065e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af871dbe2d47c7f6da2d9e40ad12065e2">registerReducerPasses</a> ()</td></tr>
<tr class="memitem:a54881321f630a119cdee5af076de868d" id="r_a54881321f630a119cdee5af076de868d"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a54881321f630a119cdee5af076de868d template"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54881321f630a119cdee5af076de868d">debugString</a> (T &amp;&amp;op)</td></tr>
<tr class="memitem:a5ca85238ce4c87b3f6c9c5dd1c0969f7" id="r_a5ca85238ce4c87b3f6c9c5dd1c0969f7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::MemoryBuffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ca85238ce4c87b3f6c9c5dd1c0969f7">openInputFile</a> (llvm::StringRef inputFilename, std::string *errorMessage=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a5ca85238ce4c87b3f6c9c5dd1c0969f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the file specified by its name for reading.  <br /></td></tr>
<tr class="memitem:a4ec63c3f9b9b50f77b7cc8b92f506204" id="r_a4ec63c3f9b9b50f77b7cc8b92f506204"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::MemoryBuffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ec63c3f9b9b50f77b7cc8b92f506204">openInputFile</a> (llvm::StringRef inputFilename, llvm::Align alignment, std::string *errorMessage=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a4ec63c3f9b9b50f77b7cc8b92f506204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the file specified by its name for reading, with the given buffer alignment constraint.  <br /></td></tr>
<tr class="memitem:a2385cabecee3f62afafa0e997df79f5f" id="r_a2385cabecee3f62afafa0e997df79f5f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::ToolOutputFile &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2385cabecee3f62afafa0e997df79f5f">openOutputFile</a> (llvm::StringRef outputFilename, std::string *errorMessage=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a2385cabecee3f62afafa0e997df79f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the file specified by its name for writing.  <br /></td></tr>
<tr class="memitem:aa109c04ae9443b1c88bd605dec0fa9b6" id="r_aa109c04ae9443b1c88bd605dec0fa9b6"><td class="memItemLeft" align="right" valign="top">llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa109c04ae9443b1c88bd605dec0fa9b6">thread_safe_nulls</a> ()</td></tr>
<tr class="memdesc:aa109c04ae9443b1c88bd605dec0fa9b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a raw output stream that simply discards the output, but in a thread-safe manner.  <br /></td></tr>
<tr class="memitem:a1da5a75b8bc3193908b0e222a6da1d85" id="r_a1da5a75b8bc3193908b0e222a6da1d85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1da5a75b8bc3193908b0e222a6da1d85">registerDefaultTimingManagerCLOptions</a> ()</td></tr>
<tr class="memdesc:a1da5a75b8bc3193908b0e222a6da1d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a set of useful command-line options that can be used to configure a <span class="tt"><a class="el" href="classmlir_1_1DefaultTimingManager.html" title="Facilities for time measurement and report printing to an output stream.">DefaultTimingManager</a></span>.  <br /></td></tr>
<tr class="memitem:ab41920e66a206248f862766a705125d1" id="r_ab41920e66a206248f862766a705125d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab41920e66a206248f862766a705125d1">applyDefaultTimingManagerCLOptions</a> (<a class="el" href="classmlir_1_1DefaultTimingManager.html">DefaultTimingManager</a> &amp;tm)</td></tr>
<tr class="memdesc:ab41920e66a206248f862766a705125d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply any values that were registered with 'registerDefaultTimingManagerOptions' to a <span class="tt"><a class="el" href="classmlir_1_1DefaultTimingManager.html" title="Facilities for time measurement and report printing to an output stream.">DefaultTimingManager</a></span>.  <br /></td></tr>
<tr class="memitem:aba4430e6a611255c7e2c879fd42b49ec" id="r_aba4430e6a611255c7e2c879fd42b49ec"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OutputStrategy.html">OutputStrategy</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba4430e6a611255c7e2c879fd42b49ec">createOutputStrategy</a> (<a class="el" href="classmlir_1_1DefaultTimingManager.html#adf35dcb59c4c28f4d5e9ae5ca4c57f83">DefaultTimingManager::OutputFormat</a> fmt, <a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os)</td></tr>
<tr class="memdesc:aba4430e6a611255c7e2c879fd42b49ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an output strategy for the specified format, to be passed to <a class="el" href="classmlir_1_1DefaultTimingManager.html#a2570c6d75a6fd314ec646db5cbf69293" title="Change the stream where the output will be printed to.">DefaultTimingManager::setOutput()</a>.  <br /></td></tr>
<tr class="memitem:a715b8c35aa2d5155832ef2f0c09db693" id="r_a715b8c35aa2d5155832ef2f0c09db693"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a715b8c35aa2d5155832ef2f0c09db693">splitAndProcessBuffer</a> (std::unique_ptr&lt; llvm::MemoryBuffer &gt; originalBuffer, <a class="el" href="#a9676bd96b41f931d8a8919d5bbb52e78">ChunkBufferHandler</a> processChunkBuffer, <a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, llvm::StringRef inputSplitMarker=<a class="el" href="#a1349a176f4860c35697f441e414bf358">kDefaultSplitMarker</a>, llvm::StringRef outputSplitMarker=&quot;&quot;)</td></tr>
<tr class="memdesc:a715b8c35aa2d5155832ef2f0c09db693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the specified buffer on a marker (<span class="tt">// -----</span> by default), processes each chunk independently according to the normal <span class="tt">processChunkBuffer</span> logic, and writes all results to <span class="tt">os</span>.  <br /></td></tr>
<tr class="memitem:a3f29fc9a815a5778fcb23ff4b3c224d6" id="r_a3f29fc9a815a5778fcb23ff4b3c224d6"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f29fc9a815a5778fcb23ff4b3c224d6">splitAndProcessBuffer</a> (std::unique_ptr&lt; llvm::MemoryBuffer &gt; originalBuffer, <a class="el" href="#a8abaf89ab4e6fae5aca7471295fba915">NoSourceChunkBufferHandler</a> processChunkBuffer, <a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, llvm::StringRef inputSplitMarker=<a class="el" href="#a1349a176f4860c35697f441e414bf358">kDefaultSplitMarker</a>, llvm::StringRef outputSplitMarker=&quot;&quot;)</td></tr>
<tr class="memdesc:a3f29fc9a815a5778fcb23ff4b3c224d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above, but for case where the original buffer is not used while processing the chunk.  <br /></td></tr>
<tr class="memitem:aafb3bcc9d23b2cfd1367b84f5b00b7c1" id="r_aafb3bcc9d23b2cfd1367b84f5b00b7c1"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafb3bcc9d23b2cfd1367b84f5b00b7c1">hash_value</a> (<a class="el" href="classmlir_1_1TypeID.html">TypeID</a> id)</td></tr>
<tr class="memdesc:aafb3bcc9d23b2cfd1367b84f5b00b7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable hashing <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type.">TypeID</a>.  <br /></td></tr>
<tr class="memitem:a4b6247969f741fbafa5b04b6d65da860" id="r_a4b6247969f741fbafa5b04b6d65da860"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b6247969f741fbafa5b04b6d65da860">registerIRDLToCppTranslation</a> ()</td></tr>
<tr class="memitem:ad1e68be8ebf61b3be9572769e19bc467" id="r_ad1e68be8ebf61b3be9572769e19bc467"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1e68be8ebf61b3be9572769e19bc467">registerAllToLLVMIRTranslations</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:ad1e68be8ebf61b3be9572769e19bc467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers all dialects that can be translated to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR and the corresponding translation interfaces.  <br /></td></tr>
<tr class="memitem:a6f90059c48bfaae011de1a44d1d80683" id="r_a6f90059c48bfaae011de1a44d1d80683"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f90059c48bfaae011de1a44d1d80683">registerAllGPUToLLVMIRTranslations</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a6f90059c48bfaae011de1a44d1d80683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers all the translations to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR required by GPU passes.  <br /></td></tr>
<tr class="memitem:a5b51fcb4b20988958223a34812c119a3" id="r_a5b51fcb4b20988958223a34812c119a3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b51fcb4b20988958223a34812c119a3">registerAllFromLLVMIRTranslations</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a5b51fcb4b20988958223a34812c119a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers all dialects that can be translated from <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR and the corresponding translation interfaces.  <br /></td></tr>
<tr class="memitem:ac8cfe4c9ed6ee3105af1b2d4d4b7c2ad" id="r_ac8cfe4c9ed6ee3105af1b2d4d4b7c2ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8cfe4c9ed6ee3105af1b2d4d4b7c2ad">registerArmNeonDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:ac8cfe4c9ed6ee3105af1b2d4d4b7c2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the ArmNeon dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <br /></td></tr>
<tr class="memitem:a559f20bb41c97729f2d089e6f7a72e4e" id="r_a559f20bb41c97729f2d089e6f7a72e4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a559f20bb41c97729f2d089e6f7a72e4e">registerArmNeonDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a559f20bb41c97729f2d089e6f7a72e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the ArmNeon dialect and the translation from it in the registry associated with the given context.  <br /></td></tr>
<tr class="memitem:a44e3d0ed9dee8abc1c1da567b31f3520" id="r_a44e3d0ed9dee8abc1c1da567b31f3520"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44e3d0ed9dee8abc1c1da567b31f3520">registerArmSMEDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a44e3d0ed9dee8abc1c1da567b31f3520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the ArmSME dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <br /></td></tr>
<tr class="memitem:a7e8ba95f7e3fc0b3d4885f3ae1b2926e" id="r_a7e8ba95f7e3fc0b3d4885f3ae1b2926e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e8ba95f7e3fc0b3d4885f3ae1b2926e">registerArmSMEDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a7e8ba95f7e3fc0b3d4885f3ae1b2926e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the ArmSME dialect and the translation from it in the registry associated with the given context.  <br /></td></tr>
<tr class="memitem:a53be2d34e1d4e96ea100bbf93af35a2c" id="r_a53be2d34e1d4e96ea100bbf93af35a2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53be2d34e1d4e96ea100bbf93af35a2c">registerArmSVEDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a53be2d34e1d4e96ea100bbf93af35a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the ArmSVE dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <br /></td></tr>
<tr class="memitem:afc9c160fac7074517c6f013864acee68" id="r_afc9c160fac7074517c6f013864acee68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc9c160fac7074517c6f013864acee68">registerArmSVEDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:afc9c160fac7074517c6f013864acee68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the ArmSVE dialect and the translation from it in the registry associated with the given context.  <br /></td></tr>
<tr class="memitem:a857314125d33fcc46a38cd3aca4d1d12" id="r_a857314125d33fcc46a38cd3aca4d1d12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a857314125d33fcc46a38cd3aca4d1d12">registerBuiltinDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a857314125d33fcc46a38cd3aca4d1d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the translation from the builtin dialect to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry.  <br /></td></tr>
<tr class="memitem:a1af1c7f18bef740745581f7130c8c46e" id="r_a1af1c7f18bef740745581f7130c8c46e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1af1c7f18bef740745581f7130c8c46e">registerBuiltinDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a1af1c7f18bef740745581f7130c8c46e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the translation from the builtin dialect in the registry associated with the given context.  <br /></td></tr>
<tr class="memitem:aa9427230420827cff7cd15f78924cdb4" id="r_aa9427230420827cff7cd15f78924cdb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9427230420827cff7cd15f78924cdb4">registerGPUDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:aa9427230420827cff7cd15f78924cdb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the GPU dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <br /></td></tr>
<tr class="memitem:afe90c6efbbc0e7e7469f14619fd7445b" id="r_afe90c6efbbc0e7e7469f14619fd7445b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe90c6efbbc0e7e7469f14619fd7445b">registerGPUDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:afe90c6efbbc0e7e7469f14619fd7445b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the GPU dialect and the translation from it in the registry associated with the given context.  <br /></td></tr>
<tr class="memitem:ab01617995d72a114db65ee711b2422d5" id="r_ab01617995d72a114db65ee711b2422d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab01617995d72a114db65ee711b2422d5">registerLLVMDialectImport</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:ab01617995d72a114db65ee711b2422d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and its import from <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry.  <br /></td></tr>
<tr class="memitem:a4a0110d23914c27f0140d63a8bb934d4" id="r_a4a0110d23914c27f0140d63a8bb934d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a0110d23914c27f0140d63a8bb934d4">registerLLVMDialectImport</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a4a0110d23914c27f0140d63a8bb934d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and its import from <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR with the given context.  <br /></td></tr>
<tr class="memitem:a8b9759ca57d83ec47b341d58d966b9e8" id="r_a8b9759ca57d83ec47b341d58d966b9e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b9759ca57d83ec47b341d58d966b9e8">registerLLVMDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a8b9759ca57d83ec47b341d58d966b9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <br /></td></tr>
<tr class="memitem:a74024a3b8ec9af8d50db598772774a96" id="r_a74024a3b8ec9af8d50db598772774a96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74024a3b8ec9af8d50db598772774a96">registerLLVMDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a74024a3b8ec9af8d50db598772774a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and the translation from it in the registry associated with the given context.  <br /></td></tr>
<tr class="memitem:a59faf81890b27fbd773f3ae78f47a07b" id="r_a59faf81890b27fbd773f3ae78f47a07b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59faf81890b27fbd773f3ae78f47a07b">registerNVVMDialectImport</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a59faf81890b27fbd773f3ae78f47a07b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> dialect and its import from <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry.  <br /></td></tr>
<tr class="memitem:add91ee93d64f27e24f1d6e1856893c5b" id="r_add91ee93d64f27e24f1d6e1856893c5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add91ee93d64f27e24f1d6e1856893c5b">registerNVVMDialectImport</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:add91ee93d64f27e24f1d6e1856893c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> dialect and its import from <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR with the given context.  <br /></td></tr>
<tr class="memitem:a2989267e0da323d644b3316b85b3942f" id="r_a2989267e0da323d644b3316b85b3942f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2989267e0da323d644b3316b85b3942f">registerNVVMDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a2989267e0da323d644b3316b85b3942f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <br /></td></tr>
<tr class="memitem:a00d03cc4e706acdb35969f4d4e78142a" id="r_a00d03cc4e706acdb35969f4d4e78142a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00d03cc4e706acdb35969f4d4e78142a">registerNVVMDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a00d03cc4e706acdb35969f4d4e78142a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> dialect and the translation from it in the registry associated with the given context.  <br /></td></tr>
<tr class="memitem:ae9bc345c5d25bda3847f7ddf6cebe9bc" id="r_ae9bc345c5d25bda3847f7ddf6cebe9bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9bc345c5d25bda3847f7ddf6cebe9bc">registerOpenACCDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:ae9bc345c5d25bda3847f7ddf6cebe9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the OpenACC dialect and the translation to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <br /></td></tr>
<tr class="memitem:a889d8518a5c67b981e76d27c9a256d86" id="r_a889d8518a5c67b981e76d27c9a256d86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a889d8518a5c67b981e76d27c9a256d86">registerOpenACCDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a889d8518a5c67b981e76d27c9a256d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the OpenACC dialect and the translation in the registry associated with the given context.  <br /></td></tr>
<tr class="memitem:a6ea20d97a32efd36c02468e54db4b2e7" id="r_a6ea20d97a32efd36c02468e54db4b2e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ea20d97a32efd36c02468e54db4b2e7">registerOpenMPDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a6ea20d97a32efd36c02468e54db4b2e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the OpenMP dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <br /></td></tr>
<tr class="memitem:aaa35b353841b70d090e1ead360536308" id="r_aaa35b353841b70d090e1ead360536308"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa35b353841b70d090e1ead360536308">registerOpenMPDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:aaa35b353841b70d090e1ead360536308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the OpenMP dialect and the translation from it in the registry associated with the given context.  <br /></td></tr>
<tr class="memitem:a254a9153445a5c111b6eeb35feed7050" id="r_a254a9153445a5c111b6eeb35feed7050"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a254a9153445a5c111b6eeb35feed7050">registerPtrDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a254a9153445a5c111b6eeb35feed7050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the <span class="tt">ptr</span> dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <br /></td></tr>
<tr class="memitem:a453be5718dbda2042925e4e7076c9d91" id="r_a453be5718dbda2042925e4e7076c9d91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a453be5718dbda2042925e4e7076c9d91">registerPtrDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a453be5718dbda2042925e4e7076c9d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the <span class="tt">ptr</span> dialect and the translation from it in the registry associated with the given context.  <br /></td></tr>
<tr class="memitem:ab895c88d57833ccee805eb3233c04ca6" id="r_ab895c88d57833ccee805eb3233c04ca6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab895c88d57833ccee805eb3233c04ca6">registerROCDLDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:ab895c88d57833ccee805eb3233c04ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <br /></td></tr>
<tr class="memitem:a4e522221c6652cb1450a6a3803125534" id="r_a4e522221c6652cb1450a6a3803125534"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e522221c6652cb1450a6a3803125534">registerROCDLDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a4e522221c6652cb1450a6a3803125534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> dialect and the translation from it in the registry associated with the given context.  <br /></td></tr>
<tr class="memitem:ad6971e37634f3b392e868dc60aefab9a" id="r_ad6971e37634f3b392e868dc60aefab9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6971e37634f3b392e868dc60aefab9a">registerSPIRVDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:ad6971e37634f3b392e868dc60aefab9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the SPIR-V dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <br /></td></tr>
<tr class="memitem:a74395e0d79520f9e47d1467c7d4dcb25" id="r_a74395e0d79520f9e47d1467c7d4dcb25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74395e0d79520f9e47d1467c7d4dcb25">registerSPIRVDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a74395e0d79520f9e47d1467c7d4dcb25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the SPIR-V dialect and the translation from it in the registry associated with the given context.  <br /></td></tr>
<tr class="memitem:a8ea099d5836b931b596ca22c70878760" id="r_a8ea099d5836b931b596ca22c70878760"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ea099d5836b931b596ca22c70878760">registerVCIXDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a8ea099d5836b931b596ca22c70878760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the VCIX dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry.  <br /></td></tr>
<tr class="memitem:a134adbd787b504667bef30d219adfed8" id="r_a134adbd787b504667bef30d219adfed8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a134adbd787b504667bef30d219adfed8">registerVCIXDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a134adbd787b504667bef30d219adfed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the VCIX dialect and the translation from it in the registry associated with the given context.  <br /></td></tr>
<tr class="memitem:aaa1eb668cf1f44410ce301800e747661" id="r_aaa1eb668cf1f44410ce301800e747661"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa1eb668cf1f44410ce301800e747661">registerXeVMDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">mlir::DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:aaa1eb668cf1f44410ce301800e747661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the XeVM dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <br /></td></tr>
<tr class="memitem:a8fba154bf3c2388d815a405b00b85974" id="r_a8fba154bf3c2388d815a405b00b85974"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fba154bf3c2388d815a405b00b85974">registerXeVMDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">mlir::MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a8fba154bf3c2388d815a405b00b85974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the XeVM dialect and the translation from it in the registry associated with the given context.  <br /></td></tr>
<tr class="memitem:a4eef291fcf02aee4a7125d0c6420fdad" id="r_a4eef291fcf02aee4a7125d0c6420fdad"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::Module &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4eef291fcf02aee4a7125d0c6420fdad">translateModuleToLLVMIR</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *module, llvm::LLVMContext &amp;llvmContext, llvm::StringRef name=&quot;LLVMDialectModule&quot;, <a class="el" href="classbool.html">bool</a> disableVerification=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a4eef291fcf02aee4a7125d0c6420fdad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a given <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect <span class="tt">module</span> into an <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR module living in the given context.  <br /></td></tr>
<tr class="memitem:ade5a695801255c4560465f9e494de6ed" id="r_ade5a695801255c4560465f9e494de6ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ModuleOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade5a695801255c4560465f9e494de6ed">translateLLVMIRToModule</a> (std::unique_ptr&lt; llvm::Module &gt; llvmModule, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classbool.html">bool</a> emitExpensiveWarnings=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>, <a class="el" href="classbool.html">bool</a> dropDICompositeTypeElements=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>, <a class="el" href="classbool.html">bool</a> loadAllDialects=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>, <a class="el" href="classbool.html">bool</a> preferUnregisteredIntrinsics=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>, <a class="el" href="classbool.html">bool</a> importStructsAsLiterals=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:ade5a695801255c4560465f9e494de6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> module into an MLIR module living in the given context.  <br /></td></tr>
<tr class="memitem:a2f93379e5dbb5551bbe57170230a1d92" id="r_a2f93379e5dbb5551bbe57170230a1d92"><td class="memItemLeft" align="right" valign="top">DataLayoutSpecInterface&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f93379e5dbb5551bbe57170230a1d92">translateDataLayout</a> (const llvm::DataLayout &amp;dataLayout, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a2f93379e5dbb5551bbe57170230a1d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate the given <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> data layout into an MLIR equivalent using the DLTI dialect.  <br /></td></tr>
<tr class="memitem:a5b6bd2ae129738dfe4f7ec2c98d0c603" id="r_a5b6bd2ae129738dfe4f7ec2c98d0c603"><td class="memItemLeft" align="right" valign="top">llvm::LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b6bd2ae129738dfe4f7ec2c98d0c603">MlirLspServerMain</a> (int argc, char **argv, <a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a5b6bd2ae129738dfe4f7ec2c98d0c603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for tools like <span class="tt">mlir-lsp-server</span>.  <br /></td></tr>
<tr class="memitem:a6074601f706b63b9fc40ae76198411fe" id="r_a6074601f706b63b9fc40ae76198411fe"><td class="memItemLeft" align="right" valign="top">llvm::LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6074601f706b63b9fc40ae76198411fe">MlirLspServerMain</a> (int argc, char **argv, <a class="el" href="namespacemlir_1_1lsp.html#a60b07b16e81f544ded595be16ffc501c">lsp::DialectRegistryFn</a> registry_fn)</td></tr>
<tr class="memdesc:a6074601f706b63b9fc40ae76198411fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for tools like <span class="tt">mlir-lsp-server</span>.  <br /></td></tr>
<tr class="memitem:a3dbb88af0759fb039752b61c0822afc5" id="r_a3dbb88af0759fb039752b61c0822afc5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3dbb88af0759fb039752b61c0822afc5">registerCLIOptions</a> (llvm::StringRef toolName, <a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a3dbb88af0759fb039752b61c0822afc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register basic command line options.  <br /></td></tr>
<tr class="memitem:a0671bbb5d03153a40cb4574afd081c92" id="r_a0671bbb5d03153a40cb4574afd081c92"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0671bbb5d03153a40cb4574afd081c92">parseCLIOptions</a> (int argc, char **argv, llvm::StringRef helpHeader)</td></tr>
<tr class="memdesc:a0671bbb5d03153a40cb4574afd081c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse command line options.  <br /></td></tr>
<tr class="memitem:ad495fac45c73eb07003f55e4c3c82ca2" id="r_ad495fac45c73eb07003f55e4c3c82ca2"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad495fac45c73eb07003f55e4c3c82ca2">registerAndParseCLIOptions</a> (int argc, char **argv, llvm::StringRef toolName, <a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:ad495fac45c73eb07003f55e4c3c82ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register and parse command line options.  <br /></td></tr>
<tr class="memitem:a440508357b9fe36f36010043c99e2f22" id="r_a440508357b9fe36f36010043c99e2f22"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a440508357b9fe36f36010043c99e2f22">MlirOptMain</a> (llvm::raw_ostream &amp;outputStream, std::unique_ptr&lt; llvm::MemoryBuffer &gt; buffer, <a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry, const <a class="el" href="classmlir_1_1MlirOptMainConfig.html">MlirOptMainConfig</a> &amp;<a class="el" href="#a3ecea12db18ed347ea11d1d999237b24">config</a>)</td></tr>
<tr class="memdesc:a440508357b9fe36f36010043c99e2f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the core processing behind <span class="tt">mlir-opt</span>.  <br /></td></tr>
<tr class="memitem:a1f6b96254b4e476bf34403287c27825a" id="r_a1f6b96254b4e476bf34403287c27825a"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f6b96254b4e476bf34403287c27825a">MlirOptMain</a> (int argc, char **argv, llvm::StringRef toolName, <a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a1f6b96254b4e476bf34403287c27825a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for tools like <span class="tt">mlir-opt</span>.  <br /></td></tr>
<tr class="memitem:af142b3ef60201e867dd545860bf1f71d" id="r_af142b3ef60201e867dd545860bf1f71d"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af142b3ef60201e867dd545860bf1f71d">MlirOptMain</a> (int argc, char **argv, llvm::StringRef inputFilename, llvm::StringRef outputFilename, <a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:af142b3ef60201e867dd545860bf1f71d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for tools like <span class="tt">mlir-opt</span>.  <br /></td></tr>
<tr class="memitem:a3d1168f4877a1008569deabfdab07fbb" id="r_a3d1168f4877a1008569deabfdab07fbb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d1168f4877a1008569deabfdab07fbb">asMainReturnCode</a> (LogicalResult r)</td></tr>
<tr class="memdesc:a3d1168f4877a1008569deabfdab07fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper wrapper to return the result of MlirOptMain directly from main.  <br /></td></tr>
<tr class="memitem:afcf1fa346908020b9dbc2009bb3630ce" id="r_afcf1fa346908020b9dbc2009bb3630ce"><td class="memItemLeft" align="right" valign="top">llvm::LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcf1fa346908020b9dbc2009bb3630ce">MlirPdllLspServerMain</a> (int argc, char **argv)</td></tr>
<tr class="memdesc:afcf1fa346908020b9dbc2009bb3630ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for tools like <span class="tt">mlir-pdll-lsp-server</span>.  <br /></td></tr>
<tr class="memitem:a7810268d0608849708e435fcb9791bb1" id="r_a7810268d0608849708e435fcb9791bb1"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7810268d0608849708e435fcb9791bb1">mlirQueryMain</a> (int argc, char **argv, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context, const <a class="el" href="classmlir_1_1query_1_1matcher_1_1Registry.html">mlir::query::matcher::Registry</a> &amp;matcherRegistry)</td></tr>
<tr class="memitem:ab515fd3b6aebea7df681f094b42d9e71" id="r_ab515fd3b6aebea7df681f094b42d9e71"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab515fd3b6aebea7df681f094b42d9e71">mlirReduceMain</a> (int argc, char **argv, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memitem:ad4175a8043cece857c2779663ef3ba91" id="r_ad4175a8043cece857c2779663ef3ba91"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4175a8043cece857c2779663ef3ba91">MlirTblgenMain</a> (int argc, char **argv)</td></tr>
<tr class="memdesc:ad4175a8043cece857c2779663ef3ba91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main Program for tools like 'mlir-tblgen' with custom backends.  <br /></td></tr>
<tr class="memitem:ab673e648679ec83d87417b04baf281dd" id="r_ab673e648679ec83d87417b04baf281dd"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab673e648679ec83d87417b04baf281dd">mlirTranslateMain</a> (int argc, char **argv, StringRef toolName)</td></tr>
<tr class="memdesc:ab673e648679ec83d87417b04baf281dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate to/from an MLIR module from/to an external representation (e.g.  <br /></td></tr>
<tr class="memitem:a3a41d372a37300e7b09f82fbd8b2d425" id="r_a3a41d372a37300e7b09f82fbd8b2d425"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a41d372a37300e7b09f82fbd8b2d425">registerTranslationCLOptions</a> ()</td></tr>
<tr class="memdesc:a3a41d372a37300e7b09f82fbd8b2d425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register command-line options used by the translation registry.  <br /></td></tr>
<tr class="memitem:ac869d2ba53c15c3d06e6b879a8f95d3d" id="r_ac869d2ba53c15c3d06e6b879a8f95d3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac869d2ba53c15c3d06e6b879a8f95d3d">parseSourceFileForTool</a> (const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;sourceMgr, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;<a class="el" href="#a3ecea12db18ed347ea11d1d999237b24">config</a>, <a class="el" href="classbool.html">bool</a> insertImplicitModule)</td></tr>
<tr class="memdesc:ac869d2ba53c15c3d06e6b879a8f95d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated SourceMgr.  <br /></td></tr>
<tr class="memitem:ae71592b6a57d95558cc2094b140ec445" id="r_ae71592b6a57d95558cc2094b140ec445"><td class="memItemLeft" align="right" valign="top">llvm::LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae71592b6a57d95558cc2094b140ec445">TableGenLspServerMain</a> (int argc, char **argv)</td></tr>
<tr class="memdesc:ae71592b6a57d95558cc2094b140ec445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for tools like <span class="tt">tblgen-lsp-server</span>.  <br /></td></tr>
<tr class="memitem:a87d229499a39cbc1a4e2bfd3acbe1a7e" id="r_a87d229499a39cbc1a4e2bfd3acbe1a7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87d229499a39cbc1a4e2bfd3acbe1a7e">populateBubbleDownMemorySpaceCastPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit)</td></tr>
<tr class="memdesc:a87d229499a39cbc1a4e2bfd3acbe1a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to bubble-down memory-space cast operations.  <br /></td></tr>
<tr class="memitem:a7c9887613b4e793d34591b00a9732c03" id="r_a7c9887613b4e793d34591b00a9732c03"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c9887613b4e793d34591b00a9732c03">transformCFGToSCF</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1CFGToSCFInterface.html">CFGToSCFInterface</a> &amp;interface, <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;dominanceInfo)</td></tr>
<tr class="memdesc:a7c9887613b4e793d34591b00a9732c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation lifting any dialect implementing control flow graph operations to a dialect implementing structured control flow operations.  <br /></td></tr>
<tr class="memitem:a6657dab425bc62dafe146c813979dc2b" id="r_a6657dab425bc62dafe146c813979dc2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6657dab425bc62dafe146c813979dc2b">populateCommutativityUtilsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a6657dab425bc62dafe146c813979dc2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the commutativity utility patterns.  <br /></td></tr>
<tr class="memitem:ac6e826b7dff0a2629197a20d859cd4c7" id="r_ac6e826b7dff0a2629197a20d859cd4c7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6e826b7dff0a2629197a20d859cd4c7">controlFlowSink</a> (<a class="el" href="classmlir_1_1RegionRange.html">RegionRange</a> regions, <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;domInfo, <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; shouldMoveIntoRegion, <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; moveIntoRegion)</td></tr>
<tr class="memdesc:ac6e826b7dff0a2629197a20d859cd4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of regions, perform control flow sinking on them.  <br /></td></tr>
<tr class="memitem:a03521cb5a2e00b91574ef1df705310bd" id="r_a03521cb5a2e00b91574ef1df705310bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03521cb5a2e00b91574ef1df705310bd">getSinglyExecutedRegionsToSink</a> (RegionBranchOpInterface branch, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> * &gt; &amp;regions)</td></tr>
<tr class="memdesc:a03521cb5a2e00b91574ef1df705310bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <span class="tt">regions</span> with regions of the provided region branch op that are executed at most once at that are reachable given the current operands of the op.  <br /></td></tr>
<tr class="memitem:ab05e50dddc61ab840dee2a99add961d8" id="r_ab05e50dddc61ab840dee2a99add961d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab05e50dddc61ab840dee2a99add961d8">eliminateCommonSubExpressions</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;domInfo, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classbool.html">bool</a> *<a class="el" href="#a1c6ebcdda896c9a0316c2367d2843775">changed</a>=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:ab05e50dddc61ab840dee2a99add961d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminate common subexpressions within the given operation.  <br /></td></tr>
<tr class="memitem:a40136aee562026e1f4503e32fb71fa2d" id="r_a40136aee562026e1f4503e32fb71fa2d"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40136aee562026e1f4503e32fb71fa2d">applyPatternsGreedily</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a> <a class="el" href="#a3ecea12db18ed347ea11d1d999237b24">config</a>=<a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>(), <a class="el" href="classbool.html">bool</a> *<a class="el" href="#a1c6ebcdda896c9a0316c2367d2843775">changed</a>=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a40136aee562026e1f4503e32fb71fa2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite ops in the given region, which must be isolated from above, by repeatedly applying the highest benefit patterns in a greedy worklist driven manner until a fixpoint is reached.  <br /></td></tr>
<tr class="memitem:a98d1a56c5c6dd1c979fb0b0b9abf705f" id="r_a98d1a56c5c6dd1c979fb0b0b9abf705f"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98d1a56c5c6dd1c979fb0b0b9abf705f">applyPatternsAndFoldGreedily</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a> <a class="el" href="#a3ecea12db18ed347ea11d1d999237b24">config</a>=<a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>(), <a class="el" href="classbool.html">bool</a> *<a class="el" href="#a1c6ebcdda896c9a0316c2367d2843775">changed</a>=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a98d1a56c5c6dd1c979fb0b0b9abf705f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <span class="tt">applyPatternsAndGreedily</span> above with folding.  <br /></td></tr>
<tr class="memitem:ae3b3798b1636be2aed89590adbb9a4e3" id="r_ae3b3798b1636be2aed89590adbb9a4e3"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3b3798b1636be2aed89590adbb9a4e3">applyPatternsGreedily</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a> <a class="el" href="#a3ecea12db18ed347ea11d1d999237b24">config</a>=<a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>(), <a class="el" href="classbool.html">bool</a> *<a class="el" href="#a1c6ebcdda896c9a0316c2367d2843775">changed</a>=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:ae3b3798b1636be2aed89590adbb9a4e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite ops nested under the given operation, which must be isolated from above, by repeatedly applying the highest benefit patterns in a greedy worklist driven manner until a fixpoint is reached.  <br /></td></tr>
<tr class="memitem:a7b83dd66e74f4184340fe7684edaf070" id="r_a7b83dd66e74f4184340fe7684edaf070"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b83dd66e74f4184340fe7684edaf070">applyPatternsAndFoldGreedily</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a> <a class="el" href="#a3ecea12db18ed347ea11d1d999237b24">config</a>=<a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>(), <a class="el" href="classbool.html">bool</a> *<a class="el" href="#a1c6ebcdda896c9a0316c2367d2843775">changed</a>=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a7b83dd66e74f4184340fe7684edaf070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <span class="tt">applyPatternsGreedily</span> above with folding.  <br /></td></tr>
<tr class="memitem:a66e5c50eb8b1daecc9b2ac2f97681685" id="r_a66e5c50eb8b1daecc9b2ac2f97681685"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66e5c50eb8b1daecc9b2ac2f97681685">applyOpPatternsGreedily</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; ops, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a> <a class="el" href="#a3ecea12db18ed347ea11d1d999237b24">config</a>=<a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>(), <a class="el" href="classbool.html">bool</a> *<a class="el" href="#a1c6ebcdda896c9a0316c2367d2843775">changed</a>=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>, <a class="el" href="classbool.html">bool</a> *allErased=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a66e5c50eb8b1daecc9b2ac2f97681685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the specified ops by repeatedly applying the highest benefit patterns in a greedy worklist driven manner until a fixpoint is reached.  <br /></td></tr>
<tr class="memitem:a69fd85a25b107960e7f482b7ae177dfd" id="r_a69fd85a25b107960e7f482b7ae177dfd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69fd85a25b107960e7f482b7ae177dfd">LLVM_DEPRECATED</a> (&quot;Use <a class="el" href="#a66e5c50eb8b1daecc9b2ac2f97681685">applyOpPatternsGreedily</a>() instead&quot;, &quot;applyOpPatternsGreedily&quot;) inline LogicalResult applyOpPatternsAndFold(<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; ops</td></tr>
<tr class="memdesc:a69fd85a25b107960e7f482b7ae177dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <span class="tt">applyOpPatternsGreedily</span> with folding.  <br /></td></tr>
<tr class="memitem:aea91e88bdb26082865bd45419644d99f" id="r_aea91e88bdb26082865bd45419644d99f"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea91e88bdb26082865bd45419644d99f">inlineRegion</a> (<a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;interface, <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InlinerInterface.html#a8fc732997e895e237723efbd0a1e0e5f">InlinerInterface::CloneCallbackSigTy</a> &gt; cloneCallback, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *inlinePoint, <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;mapper, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> resultsToReplace, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> regionResultTypes, std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; inlineLoc=std::nullopt, <a class="el" href="classbool.html">bool</a> shouldCloneInlinedRegion=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:aea91e88bdb26082865bd45419644d99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function inlines a region, 'src', into another.  <br /></td></tr>
<tr class="memitem:a2472c1d6da7b6e4441ca98ffb3b31520" id="r_a2472c1d6da7b6e4441ca98ffb3b31520"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2472c1d6da7b6e4441ca98ffb3b31520">inlineRegion</a> (<a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;interface, <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InlinerInterface.html#a8fc732997e895e237723efbd0a1e0e5f">InlinerInterface::CloneCallbackSigTy</a> &gt; cloneCallback, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Block.html">Block</a> *inlineBlock, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> inlinePoint, <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;mapper, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> resultsToReplace, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> regionResultTypes, std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; inlineLoc=std::nullopt, <a class="el" href="classbool.html">bool</a> shouldCloneInlinedRegion=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memitem:a1c7096b9aadeeeca00d054ab6d9eede0" id="r_a1c7096b9aadeeeca00d054ab6d9eede0"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c7096b9aadeeeca00d054ab6d9eede0">inlineRegion</a> (<a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;interface, <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InlinerInterface.html#a8fc732997e895e237723efbd0a1e0e5f">InlinerInterface::CloneCallbackSigTy</a> &gt; cloneCallback, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *inlinePoint, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> inlinedOperands, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> resultsToReplace, std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; inlineLoc=std::nullopt, <a class="el" href="classbool.html">bool</a> shouldCloneInlinedRegion=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:a1c7096b9aadeeeca00d054ab6d9eede0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is an overload of the above 'inlineRegion' that allows for providing the set of operands ('inlinedOperands') that should be used in-favor of the region arguments when inlining.  <br /></td></tr>
<tr class="memitem:a87891d50879cd33cefdec62a06ea07e8" id="r_a87891d50879cd33cefdec62a06ea07e8"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87891d50879cd33cefdec62a06ea07e8">inlineRegion</a> (<a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;interface, <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InlinerInterface.html#a8fc732997e895e237723efbd0a1e0e5f">InlinerInterface::CloneCallbackSigTy</a> &gt; cloneCallback, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Block.html">Block</a> *inlineBlock, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> inlinePoint, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> inlinedOperands, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> resultsToReplace, std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; inlineLoc=std::nullopt, <a class="el" href="classbool.html">bool</a> shouldCloneInlinedRegion=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memitem:a6bfae453ee10ef0c61c70b258633a407" id="r_a6bfae453ee10ef0c61c70b258633a407"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bfae453ee10ef0c61c70b258633a407">inlineCall</a> (<a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;interface, <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InlinerInterface.html#a8fc732997e895e237723efbd0a1e0e5f">InlinerInterface::CloneCallbackSigTy</a> &gt; cloneCallback, CallOpInterface call, CallableOpInterface callable, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classbool.html">bool</a> shouldCloneInlinedRegion=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:a6bfae453ee10ef0c61c70b258633a407"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function inlines a given region, 'src', of a callable operation, 'callable', into the location defined by the given call operation.  <br /></td></tr>
<tr class="memitem:a0198faa21d50db185dfacef5304045a7" id="r_a0198faa21d50db185dfacef5304045a7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0198faa21d50db185dfacef5304045a7">createLocationSnapshot</a> ()</td></tr>
<tr class="memitem:a4b927d064f79b5cfafba62a5da8ea2b0" id="r_a4b927d064f79b5cfafba62a5da8ea2b0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b927d064f79b5cfafba62a5da8ea2b0">createLocationSnapshot</a> (<a class="el" href="structmlir_1_1LocationSnapshotOptions.html">LocationSnapshotOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a2d3bd1afbf84ef9cca6c336a104d7280" id="r_a2d3bd1afbf84ef9cca6c336a104d7280"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d3bd1afbf84ef9cca6c336a104d7280">generateLocationsFromIR</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, StringRef fileName, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags)</td></tr>
<tr class="memdesc:a2d3bd1afbf84ef9cca6c336a104d7280"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates new locations from the given IR by snapshotting the IR to the given stream, and using the printed locations within that stream.  <br /></td></tr>
<tr class="memitem:af16c6823f94d6ce99fa7da7547658345" id="r_af16c6823f94d6ce99fa7da7547658345"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af16c6823f94d6ce99fa7da7547658345">generateLocationsFromIR</a> (StringRef fileName, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags)</td></tr>
<tr class="memdesc:af16c6823f94d6ce99fa7da7547658345"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates new locations from the given IR by snapshotting the IR to the given file, and using the printed locations within that file.  <br /></td></tr>
<tr class="memitem:a94e9bde94caabba0feba96a044a09afc" id="r_a94e9bde94caabba0feba96a044a09afc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94e9bde94caabba0feba96a044a09afc">generateLocationsFromIR</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, StringRef fileName, StringRef tag, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags)</td></tr>
<tr class="memdesc:a94e9bde94caabba0feba96a044a09afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates new locations from the given IR by snapshotting the IR to the given stream, and using the printed locations within that stream.  <br /></td></tr>
<tr class="memitem:ab170389f5f17475f89037e332018b4f8" id="r_ab170389f5f17475f89037e332018b4f8"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab170389f5f17475f89037e332018b4f8">generateLocationsFromIR</a> (StringRef fileName, StringRef tag, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags)</td></tr>
<tr class="memdesc:ab170389f5f17475f89037e332018b4f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates new locations from the given IR by snapshotting the IR to the given file, and using the printed locations within that file.  <br /></td></tr>
<tr class="memitem:af79a420cd75e576fa80212258d3de025" id="r_af79a420cd75e576fa80212258d3de025"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af79a420cd75e576fa80212258d3de025">moveLoopInvariantCode</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> * &gt; regions, <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; isDefinedOutsideRegion, <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; shouldMoveOutOfRegion, <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; moveOutOfRegion)</td></tr>
<tr class="memdesc:af79a420cd75e576fa80212258d3de025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of regions, perform loop-invariant code motion.  <br /></td></tr>
<tr class="memitem:a56b9f2d2e0330c53880b673633907ac6" id="r_a56b9f2d2e0330c53880b673633907ac6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56b9f2d2e0330c53880b673633907ac6">moveLoopInvariantCode</a> (LoopLikeOpInterface loopLike)</td></tr>
<tr class="memdesc:a56b9f2d2e0330c53880b673633907ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move side-effect free loop invariant code out of a loop-like op using methods provided by the interface.  <br /></td></tr>
<tr class="memitem:a249488f6fe37fa1e0175eed93494136d" id="r_a249488f6fe37fa1e0175eed93494136d"><td class="memItemLeft" align="right" valign="top">LoopLikeOpInterface&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a249488f6fe37fa1e0175eed93494136d">hoistLoopInvariantSubsets</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LoopLikeOpInterface loopLike)</td></tr>
<tr class="memdesc:a249488f6fe37fa1e0175eed93494136d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hoist loop-invariant tensor subsets (subset extraction and subset insertion ops) from loop-like ops.  <br /></td></tr>
<tr class="memitem:ae2434626306ac343fdef7bf1e3c10459" id="r_ae2434626306ac343fdef7bf1e3c10459"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2434626306ac343fdef7bf1e3c10459">tryToPromoteMemorySlots</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; PromotableAllocationOpInterface &gt; allocators, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;dataLayout, <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;dominance, <a class="el" href="structmlir_1_1Mem2RegStatistics.html">Mem2RegStatistics</a> statistics={})</td></tr>
<tr class="memdesc:ae2434626306ac343fdef7bf1e3c10459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to promote the memory slots of the provided allocators.  <br /></td></tr>
<tr class="memitem:a65742d21a48260fffacf848470b9a16a" id="r_a65742d21a48260fffacf848470b9a16a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65742d21a48260fffacf848470b9a16a">createBubbleDownMemorySpaceCasts</a> ()</td></tr>
<tr class="memitem:ab8e0778cc3708a3881957164fa36c9cb" id="r_ab8e0778cc3708a3881957164fa36c9cb"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8e0778cc3708a3881957164fa36c9cb">createCompositeFixedPointPass</a> ()</td></tr>
<tr class="memitem:a4acd4fb869596eb21c566f05b73c97a6" id="r_a4acd4fb869596eb21c566f05b73c97a6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4acd4fb869596eb21c566f05b73c97a6">createCompositeFixedPointPass</a> (<a class="el" href="structmlir_1_1CompositeFixedPointPassOptions.html">CompositeFixedPointPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:aa8c2a04f26396fa91ab5ecea346e142c" id="r_aa8c2a04f26396fa91ab5ecea346e142c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8c2a04f26396fa91ab5ecea346e142c">createMem2Reg</a> ()</td></tr>
<tr class="memitem:ab10eb132c1b16749670ba793d22856da" id="r_ab10eb132c1b16749670ba793d22856da"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab10eb132c1b16749670ba793d22856da">createMem2Reg</a> (<a class="el" href="structmlir_1_1Mem2RegOptions.html">Mem2RegOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a5c2b3959a06b08009c762f8612c813c7" id="r_a5c2b3959a06b08009c762f8612c813c7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c2b3959a06b08009c762f8612c813c7">createSROA</a> ()</td></tr>
<tr class="memitem:aab0069355214b578476e81bc909f7f13" id="r_aab0069355214b578476e81bc909f7f13"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab0069355214b578476e81bc909f7f13">createCanonicalizerPass</a> ()</td></tr>
<tr class="memdesc:aab0069355214b578476e81bc909f7f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the Canonicalizer pass, configured with default settings (which can be overridden by pass options on the command line).  <br /></td></tr>
<tr class="memitem:a17657c64dc73dfd6016afa019f76ecef" id="r_a17657c64dc73dfd6016afa019f76ecef"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17657c64dc73dfd6016afa019f76ecef">createCanonicalizerPass</a> (const <a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a> &amp;<a class="el" href="#a3ecea12db18ed347ea11d1d999237b24">config</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt; disabledPatterns={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt; enabledPatterns={})</td></tr>
<tr class="memdesc:a17657c64dc73dfd6016afa019f76ecef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the Canonicalizer pass with the specified config.  <br /></td></tr>
<tr class="memitem:ac1f1d125e949d2172433639f2f31d3e6" id="r_ac1f1d125e949d2172433639f2f31d3e6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1f1d125e949d2172433639f2f31d3e6">createControlFlowSinkPass</a> ()</td></tr>
<tr class="memdesc:ac1f1d125e949d2172433639f2f31d3e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to perform control-flow sinking.  <br /></td></tr>
<tr class="memitem:a14895da9723acd9c7f910c2694ff9f65" id="r_a14895da9723acd9c7f910c2694ff9f65"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14895da9723acd9c7f910c2694ff9f65">createCSEPass</a> ()</td></tr>
<tr class="memdesc:a14895da9723acd9c7f910c2694ff9f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to perform common sub expression elimination.  <br /></td></tr>
<tr class="memitem:a0a84c3fae02e7540b0db48350b738be1" id="r_a0a84c3fae02e7540b0db48350b738be1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a84c3fae02e7540b0db48350b738be1">createPrintIRPass</a> (const <a class="el" href="structmlir_1_1PrintIRPassOptions.html">PrintIRPassOptions</a> &amp;={})</td></tr>
<tr class="memdesc:a0a84c3fae02e7540b0db48350b738be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to print IR on the debug stream.  <br /></td></tr>
<tr class="memitem:a6fdd2528f381177f9ded6de5eba9900b" id="r_a6fdd2528f381177f9ded6de5eba9900b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fdd2528f381177f9ded6de5eba9900b">createGenerateRuntimeVerificationPass</a> ()</td></tr>
<tr class="memdesc:a6fdd2528f381177f9ded6de5eba9900b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that generates IR to verify ops at runtime.  <br /></td></tr>
<tr class="memitem:a319fde65e573dbc3a947d58196cb2b3a" id="r_a319fde65e573dbc3a947d58196cb2b3a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a319fde65e573dbc3a947d58196cb2b3a">createLoopInvariantCodeMotionPass</a> ()</td></tr>
<tr class="memdesc:a319fde65e573dbc3a947d58196cb2b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a loop invariant code motion pass that hoists loop invariant instructions out of the loop.  <br /></td></tr>
<tr class="memitem:acf61282117a610660819cb15624637d6" id="r_acf61282117a610660819cb15624637d6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf61282117a610660819cb15624637d6">createLoopInvariantSubsetHoistingPass</a> ()</td></tr>
<tr class="memdesc:acf61282117a610660819cb15624637d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that hoists loop-invariant subset ops.  <br /></td></tr>
<tr class="memitem:a3b152134b4d44a148dac8bfc24070dcd" id="r_a3b152134b4d44a148dac8bfc24070dcd"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b152134b4d44a148dac8bfc24070dcd">createStripDebugInfoPass</a> ()</td></tr>
<tr class="memdesc:a3b152134b4d44a148dac8bfc24070dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to strip debug information from a function.  <br /></td></tr>
<tr class="memitem:ab56d49b89c1f203d6fa20f126bf4d900" id="r_ab56d49b89c1f203d6fa20f126bf4d900"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab56d49b89c1f203d6fa20f126bf4d900">createPrintOpStatsPass</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os=llvm::errs())</td></tr>
<tr class="memdesc:ab56d49b89c1f203d6fa20f126bf4d900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which prints the list of ops and the number of occurrences in the module.  <br /></td></tr>
<tr class="memitem:a738190b0f29ddc52ba6847cb310eb60d" id="r_a738190b0f29ddc52ba6847cb310eb60d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a738190b0f29ddc52ba6847cb310eb60d">createPrintOpStatsPass</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, <a class="el" href="classbool.html">bool</a> printAsJSON)</td></tr>
<tr class="memdesc:a738190b0f29ddc52ba6847cb310eb60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which prints the list of ops and the number of occurrences in the module with the output format option.  <br /></td></tr>
<tr class="memitem:a6c6ad0644a283c257d1fbc15be6adc18" id="r_a6c6ad0644a283c257d1fbc15be6adc18"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c6ad0644a283c257d1fbc15be6adc18">createInlinerPass</a> ()</td></tr>
<tr class="memdesc:a6c6ad0644a283c257d1fbc15be6adc18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which inlines calls and callable operations as defined by the <a class="el" href="classmlir_1_1CallGraph.html">CallGraph</a>.  <br /></td></tr>
<tr class="memitem:a1372ce1294d9b98b652930aa6baf1386" id="r_a1372ce1294d9b98b652930aa6baf1386"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1372ce1294d9b98b652930aa6baf1386">createInlinerPass</a> (llvm::StringMap&lt; <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &gt; opPipelines)</td></tr>
<tr class="memdesc:a1372ce1294d9b98b652930aa6baf1386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the inliner pass, and use the provided pass managers when optimizing callable operations with names matching the key type.  <br /></td></tr>
<tr class="memitem:a282d4666d1a10f4c41e6b114bf5e6a7f" id="r_a282d4666d1a10f4c41e6b114bf5e6a7f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a282d4666d1a10f4c41e6b114bf5e6a7f">createInlinerPass</a> (llvm::StringMap&lt; <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &gt; opPipelines, std::function&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;)&gt; defaultPipelineBuilder)</td></tr>
<tr class="memdesc:a282d4666d1a10f4c41e6b114bf5e6a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the inliner pass, and use the provided pass managers when optimizing callable operations with names matching the key type.  <br /></td></tr>
<tr class="memitem:ab17b2f115a7d8025fb9d5eacf14368b3" id="r_ab17b2f115a7d8025fb9d5eacf14368b3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab17b2f115a7d8025fb9d5eacf14368b3">createRemoveDeadValuesPass</a> ()</td></tr>
<tr class="memdesc:ab17b2f115a7d8025fb9d5eacf14368b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an optimization pass to remove dead values.  <br /></td></tr>
<tr class="memitem:a6119493f8c83de427f34658e5e39cbfe" id="r_a6119493f8c83de427f34658e5e39cbfe"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6119493f8c83de427f34658e5e39cbfe">createSCCPPass</a> ()</td></tr>
<tr class="memdesc:a6119493f8c83de427f34658e5e39cbfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which performs sparse conditional constant propagation over nested operations.  <br /></td></tr>
<tr class="memitem:a69605e45210627de9b7fde4644fa50c1" id="r_a69605e45210627de9b7fde4644fa50c1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69605e45210627de9b7fde4644fa50c1">createSymbolDCEPass</a> ()</td></tr>
<tr class="memdesc:a69605e45210627de9b7fde4644fa50c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which delete symbol operations that are unreachable.  <br /></td></tr>
<tr class="memitem:ae0b0f8a089ed821a240c7dd4e5573573" id="r_ae0b0f8a089ed821a240c7dd4e5573573"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0b0f8a089ed821a240c7dd4e5573573">createSymbolPrivatizePass</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt; excludeSymbols={})</td></tr>
<tr class="memdesc:ae0b0f8a089ed821a240c7dd4e5573573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which marks top-level symbol operations as <span class="tt">private</span> unless listed in <span class="tt">excludeSymbols</span>.  <br /></td></tr>
<tr class="memitem:a4480ae6dd145482f88ec81d28df3bca8" id="r_a4480ae6dd145482f88ec81d28df3bca8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4480ae6dd145482f88ec81d28df3bca8">createTopologicalSortPass</a> ()</td></tr>
<tr class="memdesc:a4480ae6dd145482f88ec81d28df3bca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that recursively sorts nested regions without SSA dominance topologically such that, as much as possible, users of values appear after their producers.  <br /></td></tr>
<tr class="memitem:a60273f83d83a8fb7e5a1ceebb7a8d4a6" id="r_a60273f83d83a8fb7e5a1ceebb7a8d4a6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60273f83d83a8fb7e5a1ceebb7a8d4a6">createCompositeFixedPointPass</a> (std::string name, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;)&gt; populateFunc, int maxIterations=10)</td></tr>
<tr class="memdesc:a60273f83d83a8fb7e5a1ceebb7a8d4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create composite pass, which runs provided set of passes until fixed point or maximum number of iterations reached.  <br /></td></tr>
<tr class="memitem:a85fb5899228dbfc0fc1b1967a227a80b" id="r_a85fb5899228dbfc0fc1b1967a227a80b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85fb5899228dbfc0fc1b1967a227a80b">registerBubbleDownMemorySpaceCasts</a> ()</td></tr>
<tr class="memitem:adcf4a04f7d13ef88360053ccae573766" id="r_adcf4a04f7d13ef88360053ccae573766"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcf4a04f7d13ef88360053ccae573766">registerBubbleDownMemorySpaceCastsPass</a> ()</td></tr>
<tr class="memitem:ae4abc5643d0337f579425d2f48f14249" id="r_ae4abc5643d0337f579425d2f48f14249"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4abc5643d0337f579425d2f48f14249">registerCSE</a> ()</td></tr>
<tr class="memitem:aae45938de6e167022f8deb1ca2aa6ceb" id="r_aae45938de6e167022f8deb1ca2aa6ceb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae45938de6e167022f8deb1ca2aa6ceb">registerCSEPass</a> ()</td></tr>
<tr class="memitem:a616aaf5190a9b52c9ff1de894809be21" id="r_a616aaf5190a9b52c9ff1de894809be21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a616aaf5190a9b52c9ff1de894809be21">registerCanonicalizer</a> ()</td></tr>
<tr class="memitem:a8bf366f61b59925618c1dc5a16fd7755" id="r_a8bf366f61b59925618c1dc5a16fd7755"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bf366f61b59925618c1dc5a16fd7755">registerCanonicalizerPass</a> ()</td></tr>
<tr class="memitem:a803727c613f23c396fcd3b379a778a94" id="r_a803727c613f23c396fcd3b379a778a94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a803727c613f23c396fcd3b379a778a94">registerCompositeFixedPointPass</a> ()</td></tr>
<tr class="memitem:a772d94a15b48bc8b335bcd8d70601541" id="r_a772d94a15b48bc8b335bcd8d70601541"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a772d94a15b48bc8b335bcd8d70601541">registerCompositeFixedPointPassPass</a> ()</td></tr>
<tr class="memitem:ae68c338c367f123cc04551f1753ac9b4" id="r_ae68c338c367f123cc04551f1753ac9b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae68c338c367f123cc04551f1753ac9b4">registerControlFlowSink</a> ()</td></tr>
<tr class="memitem:a264461455c004817114cd73873dd2dea" id="r_a264461455c004817114cd73873dd2dea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a264461455c004817114cd73873dd2dea">registerControlFlowSinkPass</a> ()</td></tr>
<tr class="memitem:aecda2e833016d0a1cb419e39b4f00fc8" id="r_aecda2e833016d0a1cb419e39b4f00fc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecda2e833016d0a1cb419e39b4f00fc8">registerGenerateRuntimeVerification</a> ()</td></tr>
<tr class="memitem:abb38875de50b6346efa2a01191578a96" id="r_abb38875de50b6346efa2a01191578a96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb38875de50b6346efa2a01191578a96">registerGenerateRuntimeVerificationPass</a> ()</td></tr>
<tr class="memitem:a66780d20fcbef624019d5734c4853d39" id="r_a66780d20fcbef624019d5734c4853d39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66780d20fcbef624019d5734c4853d39">registerInliner</a> ()</td></tr>
<tr class="memitem:abeb616f0d7b4bb70a8444b4f516b9e74" id="r_abeb616f0d7b4bb70a8444b4f516b9e74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abeb616f0d7b4bb70a8444b4f516b9e74">registerInlinerPass</a> ()</td></tr>
<tr class="memitem:aa5484eb02e0c7711fefd5682e3232ff8" id="r_aa5484eb02e0c7711fefd5682e3232ff8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5484eb02e0c7711fefd5682e3232ff8">registerLocationSnapshot</a> ()</td></tr>
<tr class="memitem:ad72cb69ce7683e91104cea66dc51414b" id="r_ad72cb69ce7683e91104cea66dc51414b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad72cb69ce7683e91104cea66dc51414b">registerLocationSnapshotPass</a> ()</td></tr>
<tr class="memitem:a1184a39f4795553b783a2a75e22cd793" id="r_a1184a39f4795553b783a2a75e22cd793"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1184a39f4795553b783a2a75e22cd793">registerLoopInvariantCodeMotion</a> ()</td></tr>
<tr class="memitem:a35701f9efec5e981cbaf69333ccf8621" id="r_a35701f9efec5e981cbaf69333ccf8621"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35701f9efec5e981cbaf69333ccf8621">registerLoopInvariantCodeMotionPass</a> ()</td></tr>
<tr class="memitem:ab6acd4737757d4aaad024fd4bb599de6" id="r_ab6acd4737757d4aaad024fd4bb599de6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6acd4737757d4aaad024fd4bb599de6">registerLoopInvariantSubsetHoisting</a> ()</td></tr>
<tr class="memitem:a07926685868dde44533a673f3d0aea70" id="r_a07926685868dde44533a673f3d0aea70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07926685868dde44533a673f3d0aea70">registerLoopInvariantSubsetHoistingPass</a> ()</td></tr>
<tr class="memitem:ab0e9d2be26bac7f415719ce5aa38ae65" id="r_ab0e9d2be26bac7f415719ce5aa38ae65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0e9d2be26bac7f415719ce5aa38ae65">registerMem2Reg</a> ()</td></tr>
<tr class="memitem:a736b18a1b20e48ece102cab1f77899a5" id="r_a736b18a1b20e48ece102cab1f77899a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a736b18a1b20e48ece102cab1f77899a5">registerMem2RegPass</a> ()</td></tr>
<tr class="memitem:afb2317027118b46ca06fcb6b08158b0f" id="r_afb2317027118b46ca06fcb6b08158b0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb2317027118b46ca06fcb6b08158b0f">registerPrintIRPass</a> ()</td></tr>
<tr class="memitem:aa1b19a9a0a3d9cd01589ac1dc43fde36" id="r_aa1b19a9a0a3d9cd01589ac1dc43fde36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1b19a9a0a3d9cd01589ac1dc43fde36">registerPrintIRPassPass</a> ()</td></tr>
<tr class="memitem:a6301f8a4ec9e21048723738a66702473" id="r_a6301f8a4ec9e21048723738a66702473"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6301f8a4ec9e21048723738a66702473">registerPrintOpStats</a> ()</td></tr>
<tr class="memitem:a341326afd173f52f0673fe2a6b6a0dba" id="r_a341326afd173f52f0673fe2a6b6a0dba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a341326afd173f52f0673fe2a6b6a0dba">registerPrintOpStatsPass</a> ()</td></tr>
<tr class="memitem:ab5572eb7b4b9b8c4a269d29446f492fe" id="r_ab5572eb7b4b9b8c4a269d29446f492fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5572eb7b4b9b8c4a269d29446f492fe">registerRemoveDeadValues</a> ()</td></tr>
<tr class="memitem:a2b0c904754b8ce6c0c38b7a688a306a9" id="r_a2b0c904754b8ce6c0c38b7a688a306a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b0c904754b8ce6c0c38b7a688a306a9">registerRemoveDeadValuesPass</a> ()</td></tr>
<tr class="memitem:ae1aada75389e4d473a32b3e4175465eb" id="r_ae1aada75389e4d473a32b3e4175465eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1aada75389e4d473a32b3e4175465eb">registerSCCP</a> ()</td></tr>
<tr class="memitem:a128bb4a336733aa44c305996e74b0b90" id="r_a128bb4a336733aa44c305996e74b0b90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a128bb4a336733aa44c305996e74b0b90">registerSCCPPass</a> ()</td></tr>
<tr class="memitem:a62c66c897aff4ca94aba5db2244a2f54" id="r_a62c66c897aff4ca94aba5db2244a2f54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62c66c897aff4ca94aba5db2244a2f54">registerSROA</a> ()</td></tr>
<tr class="memitem:af469192db553aad94693e1a61f57ec3c" id="r_af469192db553aad94693e1a61f57ec3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af469192db553aad94693e1a61f57ec3c">registerSROAPass</a> ()</td></tr>
<tr class="memitem:ae1141fa3cd9876e6ae1c7d67ded257af" id="r_ae1141fa3cd9876e6ae1c7d67ded257af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1141fa3cd9876e6ae1c7d67ded257af">registerStripDebugInfo</a> ()</td></tr>
<tr class="memitem:a768914db327de87f19a87905f293cf80" id="r_a768914db327de87f19a87905f293cf80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a768914db327de87f19a87905f293cf80">registerStripDebugInfoPass</a> ()</td></tr>
<tr class="memitem:a5d32ff1beeedc06a000e7cac2370aa7a" id="r_a5d32ff1beeedc06a000e7cac2370aa7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d32ff1beeedc06a000e7cac2370aa7a">registerSymbolDCE</a> ()</td></tr>
<tr class="memitem:a0e46bdac75c47d0c236e2731c40ba227" id="r_a0e46bdac75c47d0c236e2731c40ba227"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e46bdac75c47d0c236e2731c40ba227">registerSymbolDCEPass</a> ()</td></tr>
<tr class="memitem:a24d9ebd0dd67c407135fcaff3f125c86" id="r_a24d9ebd0dd67c407135fcaff3f125c86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24d9ebd0dd67c407135fcaff3f125c86">registerSymbolPrivatize</a> ()</td></tr>
<tr class="memitem:a1052b12c0656e19b1fed04b73bb17113" id="r_a1052b12c0656e19b1fed04b73bb17113"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1052b12c0656e19b1fed04b73bb17113">registerSymbolPrivatizePass</a> ()</td></tr>
<tr class="memitem:a2e42cd6b5ac50f5a0ade0755e2622a18" id="r_a2e42cd6b5ac50f5a0ade0755e2622a18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e42cd6b5ac50f5a0ade0755e2622a18">registerTopologicalSort</a> ()</td></tr>
<tr class="memitem:a56ab21a56a084aaa120dfca1e0683ced" id="r_a56ab21a56a084aaa120dfca1e0683ced"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56ab21a56a084aaa120dfca1e0683ced">registerTopologicalSortPass</a> ()</td></tr>
<tr class="memitem:a196e2505c22020acd6ded246b84ee84a" id="r_a196e2505c22020acd6ded246b84ee84a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a196e2505c22020acd6ded246b84ee84a">registerViewOpGraph</a> ()</td></tr>
<tr class="memitem:a803c90f072df3c3e2dcaa56f4b89b486" id="r_a803c90f072df3c3e2dcaa56f4b89b486"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a803c90f072df3c3e2dcaa56f4b89b486">registerViewOpGraphPass</a> ()</td></tr>
<tr class="memitem:a8aa80526a38efe3ad444112c4f8a85c8" id="r_a8aa80526a38efe3ad444112c4f8a85c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8aa80526a38efe3ad444112c4f8a85c8">registerTransformsPasses</a> ()</td></tr>
<tr class="memitem:ac680df79552c596c048cd9cb27638c5f" id="r_ac680df79552c596c048cd9cb27638c5f"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="structmlir_1_1Range.html">Range</a>&gt; </td></tr>
<tr class="memitem:ac680df79552c596c048cd9cb27638c5f template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac680df79552c596c048cd9cb27638c5f">areValuesDefinedAbove</a> (<a class="el" href="structmlir_1_1Range.html">Range</a> values, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;limit)</td></tr>
<tr class="memdesc:ac680df79552c596c048cd9cb27638c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all values in the provided range are defined above the <span class="tt">limit</span> region.  <br /></td></tr>
<tr class="memitem:a15a5d204dd78ac563241168e6b2e40eb" id="r_a15a5d204dd78ac563241168e6b2e40eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15a5d204dd78ac563241168e6b2e40eb">replaceAllUsesInRegionWith</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> orig, <a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="LoopUtils_8cpp.html#af34d730a7920f1ae277f8c166146132d">replacement</a>, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region)</td></tr>
<tr class="memdesc:a15a5d204dd78ac563241168e6b2e40eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all uses of <span class="tt">orig</span> within the given region with <span class="tt">replacement</span>.  <br /></td></tr>
<tr class="memitem:ae644ec0854505ef60f12c23b96de595b" id="r_ae644ec0854505ef60f12c23b96de595b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae644ec0854505ef60f12c23b96de595b">visitUsedValuesDefinedAbove</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;limit, <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *)&gt; callback)</td></tr>
<tr class="memdesc:ae644ec0854505ef60f12c23b96de595b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <span class="tt">callback</span> for each use of a value within <span class="tt">region</span> or its descendants that was defined at the ancestors of the <span class="tt">limit</span>.  <br /></td></tr>
<tr class="memitem:a036e7ce3c7c3bf73fc0a653cd98bb7c0" id="r_a036e7ce3c7c3bf73fc0a653cd98bb7c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a036e7ce3c7c3bf73fc0a653cd98bb7c0">visitUsedValuesDefinedAbove</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; regions, <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *)&gt; callback)</td></tr>
<tr class="memdesc:a036e7ce3c7c3bf73fc0a653cd98bb7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <span class="tt">callback</span> for each use of a value within any of the regions provided that was defined in one of the ancestors.  <br /></td></tr>
<tr class="memitem:a98f08e970a346cd42559db87f97f0b91" id="r_a98f08e970a346cd42559db87f97f0b91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98f08e970a346cd42559db87f97f0b91">getUsedValuesDefinedAbove</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;limit, <a class="el" href="#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;values)</td></tr>
<tr class="memdesc:a98f08e970a346cd42559db87f97f0b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill <span class="tt">values</span> with a list of values defined at the ancestors of the <span class="tt">limit</span> region and used within <span class="tt">region</span> or its descendants.  <br /></td></tr>
<tr class="memitem:a2c45b388f069e9396c50660f41a7eacf" id="r_a2c45b388f069e9396c50660f41a7eacf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c45b388f069e9396c50660f41a7eacf">getUsedValuesDefinedAbove</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; regions, <a class="el" href="#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;values)</td></tr>
<tr class="memdesc:a2c45b388f069e9396c50660f41a7eacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill <span class="tt">values</span> with a list of values used within any of the regions provided but defined in one of the ancestors.  <br /></td></tr>
<tr class="memitem:a7d806144c2d33e56f341109c75c3d277" id="r_a7d806144c2d33e56f341109c75c3d277"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d806144c2d33e56f341109c75c3d277">makeRegionIsolatedFromAbove</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; cloneOperationIntoRegion=[](<a class="el" href="classmlir_1_1Operation.html">Operation</a> *) { return <a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>;})</td></tr>
<tr class="memdesc:a7d806144c2d33e56f341109c75c3d277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a region isolated from above.  <br /></td></tr>
<tr class="memitem:a2fdbd0b74e2e10bef579e3e78fd9c5b1" id="r_a2fdbd0b74e2e10bef579e3e78fd9c5b1"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fdbd0b74e2e10bef579e3e78fd9c5b1">moveOperationDependencies</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *insertionPoint, <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;dominance)</td></tr>
<tr class="memdesc:a2fdbd0b74e2e10bef579e3e78fd9c5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move SSA values used within an operation before an insertion point, so that the operation itself (or its replacement) can be moved to the insertion point.  <br /></td></tr>
<tr class="memitem:a9dae870bd077007ddaae656fd4ddf14a" id="r_a9dae870bd077007ddaae656fd4ddf14a"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9dae870bd077007ddaae656fd4ddf14a">moveOperationDependencies</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *insertionPoint)</td></tr>
<tr class="memitem:adfb87364046c64c85ee85e862ee4d19e" id="r_adfb87364046c64c85ee85e862ee4d19e"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfb87364046c64c85ee85e862ee4d19e">moveValueDefinitions</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *insertionPoint, <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;dominance)</td></tr>
<tr class="memdesc:adfb87364046c64c85ee85e862ee4d19e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move definitions of <span class="tt">values</span> before an insertion point.  <br /></td></tr>
<tr class="memitem:a1506f6b75720ad7dfe864646585c4ba2" id="r_a1506f6b75720ad7dfe864646585c4ba2"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1506f6b75720ad7dfe864646585c4ba2">moveValueDefinitions</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *insertionPoint)</td></tr>
<tr class="memitem:ad38fea8480dfb78d9d3bd0736ccbfa2e" id="r_ad38fea8480dfb78d9d3bd0736ccbfa2e"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad38fea8480dfb78d9d3bd0736ccbfa2e">simplifyRegions</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; regions, <a class="el" href="classbool.html">bool</a> mergeBlocks=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:ad38fea8480dfb78d9d3bd0736ccbfa2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a set of structural simplifications over the given regions.  <br /></td></tr>
<tr class="memitem:a6ab9585c8607c12142232e0f58ebcc8b" id="r_a6ab9585c8607c12142232e0f58ebcc8b"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ab9585c8607c12142232e0f58ebcc8b">eraseUnreachableBlocks</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; regions)</td></tr>
<tr class="memdesc:a6ab9585c8607c12142232e0f58ebcc8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the unreachable blocks within the provided regions.  <br /></td></tr>
<tr class="memitem:a9eb183dcb73d44f0e0aedb09b73c7fd7" id="r_a9eb183dcb73d44f0e0aedb09b73c7fd7"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9eb183dcb73d44f0e0aedb09b73c7fd7">runRegionDCE</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; regions)</td></tr>
<tr class="memdesc:a9eb183dcb73d44f0e0aedb09b73c7fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns success if any operations or arguments were deleted, failure otherwise.  <br /></td></tr>
<tr class="memitem:ad4695076b1d2f75930c85058c6b42084" id="r_ad4695076b1d2f75930c85058c6b42084"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4695076b1d2f75930c85058c6b42084">tryToDestructureMemorySlots</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; DestructurableAllocationOpInterface &gt; allocators, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;dataLayout, <a class="el" href="structmlir_1_1SROAStatistics.html">SROAStatistics</a> statistics={})</td></tr>
<tr class="memdesc:ad4695076b1d2f75930c85058c6b42084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to destructure the slots of destructurable allocators.  <br /></td></tr>
<tr class="memitem:a045e1f32a8d90260d292aad61149c0ef" id="r_a045e1f32a8d90260d292aad61149c0ef"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a045e1f32a8d90260d292aad61149c0ef">createPrintOpGraphPass</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os=llvm::errs())</td></tr>
<tr class="memdesc:a045e1f32a8d90260d292aad61149c0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to print op graphs.  <br /></td></tr>
<tr class="memitem:ab84fd477538fb25ddc796e5cd7d85999" id="r_ab84fd477538fb25ddc796e5cd7d85999"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab84fd477538fb25ddc796e5cd7d85999">walkAndApplyPatterns</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;<a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="structmlir_1_1RewriterBase_1_1Listener.html">RewriterBase::Listener</a> *listener=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:ab84fd477538fb25ddc796e5cd7d85999"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fast walk-based pattern rewrite driver.  <br /></td></tr>
<tr class="memitem:a696b120da9a342a4bada4e5ba2da1bbe" id="r_a696b120da9a342a4bada4e5ba2da1bbe"><td class="memItemLeft" align="right" valign="top">LLVM::LLVMFuncOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a696b120da9a342a4bada4e5ba2da1bbe">getOrDefineFunction</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *moduleOp, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, StringRef name, LLVM::LLVMFunctionType type)</td></tr>
<tr class="memdesc:a696b120da9a342a4bada4e5ba2da1bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Note that these functions don't take a <span class="tt"><a class="el" href="classmlir_1_1SymbolTable.html" title="This class allows for representing and managing the symbol table used by operations with the &#39;SymbolT...">SymbolTable</a></span> because GPU module lowerings can have name collisions as an intermediate state.  <br /></td></tr>
<tr class="memitem:af5581571a04b2bd6b89abce0a4ae85dd" id="r_af5581571a04b2bd6b89abce0a4ae85dd"><td class="memItemLeft" align="right" valign="top">LLVM::GlobalOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5581571a04b2bd6b89abce0a4ae85dd">getOrCreateStringConstant</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *moduleOp, <a class="el" href="classmlir_1_1Type.html">Type</a> llvmI8, StringRef namePrefix, StringRef str, uint64_t alignment=0, <a class="el" href="classunsigned.html">unsigned</a> addrSpace=0)</td></tr>
<tr class="memdesc:af5581571a04b2bd6b89abce0a4ae85dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a global that contains the given string.  <br /></td></tr>
<tr class="memitem:a7c4ce1ebc47dbd367b9b8b19ceeafcb3" id="r_a7c4ce1ebc47dbd367b9b8b19ceeafcb3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c4ce1ebc47dbd367b9b8b19ceeafcb3">createElementwiseOp</a> (ConversionPatternRewriter &amp;builder, gpu::SubgroupMmaElementwiseOp op, <a class="el" href="classmlir_1_1Type.html">Type</a> coopType, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands)</td></tr>
<tr class="memdesc:a7c4ce1ebc47dbd367b9b8b19ceeafcb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a SPIR-V op to replace the given GPU subgroup mma elementwise op when the elementwise op directly supports with cooperative matrix type.  <br /></td></tr>
<tr class="memitem:aaf43b39cbc5116796f9b6550f99dee0d" id="r_aaf43b39cbc5116796f9b6550f99dee0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf43b39cbc5116796f9b6550f99dee0d">allOperandsHaveSameCoopMatrixType</a> (<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands)</td></tr>
<tr class="memitem:a58c1a102a79cae901d44e104d0299da3" id="r_a58c1a102a79cae901d44e104d0299da3"><td class="memTemplParams" colspan="2">template&lt;typename K, typename V&gt; </td></tr>
<tr class="memitem:a58c1a102a79cae901d44e104d0299da3 template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58c1a102a79cae901d44e104d0299da3">getValuesSortedByKeyImpl</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; K &gt; keys, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; V &gt; values, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(K, K)&gt; compare)</td></tr>
<tr class="memdesc:a58c1a102a79cae901d44e104d0299da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to sort <span class="tt">values</span> according to matching <span class="tt">keys</span>.  <br /></td></tr>
<tr class="memitem:a34ab168056505b09c113dda01ee42d5e" id="r_a34ab168056505b09c113dda01ee42d5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34ab168056505b09c113dda01ee42d5e">printDimensionList</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;printer, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; dimensions)</td></tr>
<tr class="memitem:a2b336390b16983a364b2d95bd2a64a2f" id="r_a2b336390b16983a364b2d95bd2a64a2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b336390b16983a364b2d95bd2a64a2f">registerTestRoundtripSPIRV</a> ()</td></tr>
<tr class="memitem:a9ed913befc935e3b4b3e622838655b30" id="r_a9ed913befc935e3b4b3e622838655b30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ed913befc935e3b4b3e622838655b30">registerTestRoundtripDebugSPIRV</a> ()</td></tr>
<tr class="memitem:a579b330f2795cc0443c3a508a9585772" id="r_a579b330f2795cc0443c3a508a9585772"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a579b330f2795cc0443c3a508a9585772">reconcileUnrealizedCasts</a> (const <a class="el" href="#abde461319ad5039ddbf5b4e70f47618b">DenseMap</a>&lt; UnrealizedConversionCastOp, UnresolvedMaterializationInfo &gt; &amp;castOps, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; UnrealizedConversionCastOp &gt; *remainingCastOps)</td></tr>
<tr class="memitem:a465b98f3a320b384f6141df0ae267afb" id="r_a465b98f3a320b384f6141df0ae267afb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a465b98f3a320b384f6141df0ae267afb">findReachableBlocks</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="#a4aa33aa05f4fcff8a40613b43fb06f01">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Block.html">Block</a> * &gt; &amp;reachableBlocks)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a2887883f00b094c5ca61c631d7b093a0" id="r_a2887883f00b094c5ca61c631d7b093a0"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2887883f00b094c5ca61c631d7b093a0">kDeriveIndexBitwidthFromDataLayout</a> = 0</td></tr>
<tr class="memdesc:a2887883f00b094c5ca61c631d7b093a0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> to pass as bitwidth for the index type when the converter is expected to derive the bitwidth from the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> data layout.  <br /></td></tr>
<tr class="memitem:a52f52f0c5e268decd5b4ff95c42ea054" id="r_a52f52f0c5e268decd5b4ff95c42ea054"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a52f52f0c5e268decd5b4ff95c42ea054 template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52f52f0c5e268decd5b4ff95c42ea054">has_sub_attr_or_type_v</a></td></tr>
<tr class="memitem:a1349a176f4860c35697f441e414bf358" id="r_a1349a176f4860c35697f441e414bf358"><td class="memItemLeft" align="right" valign="top">const char *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1349a176f4860c35697f441e414bf358">kDefaultSplitMarker</a> = &quot;// -----&quot;</td></tr>
<tr class="memitem:a8789c71249b4fcc3059f4ba4a9d27f26" id="r_a8789c71249b4fcc3059f4ba4a9d27f26"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a></td></tr>
<tr class="memitem:a3ecea12db18ed347ea11d1d999237b24" id="r_a3ecea12db18ed347ea11d1d999237b24"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> <a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ecea12db18ed347ea11d1d999237b24">config</a> = <a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>()</td></tr>
<tr class="memitem:a1c6ebcdda896c9a0316c2367d2843775" id="r_a1c6ebcdda896c9a0316c2367d2843775"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> <a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a> <a class="el" href="classbool.html">bool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c6ebcdda896c9a0316c2367d2843775">changed</a> = <a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Include the generated interface declarations. </p>
<p>Part of the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> Project, under the Apache License v2.0 with <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> Exceptions.</p>
<p>The pass expands memref operations that modify the metadata of a memref (sizes, offset, strides) into a sequence of easier to analyze constructs.</p>
<p><a class="el" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements.">RewritePattern</a> API.</p>
<p>This header declares functions that assist transformations in the MemRef dialect.</p>
<p>In particular, this pass transforms operations into explicit sequence of operations that model the effect of this operation on the different metadata. This pass uses affine constructs to materialize these effects.</p>
<p>See <a href="https://llvm.org/LICENSE.txt">https://llvm.org/LICENSE.txt</a> for license information. SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception </p>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="a044e19a45e06290430f27c9c818bf71a" name="a044e19a45e06290430f27c9c818bf71a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044e19a45e06290430f27c9c818bf71a">&#9670;&#160;</a></span>AllocFunType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a044e19a45e06290430f27c9c818bf71a">mlir::AllocFunType</a> = <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt;<a class="el" href="classvoid.html">void</a> *(size_t)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html#l00037">37</a> of file <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html">MemRefUtils.h</a>.</p>

</div>
</div>
<a id="a5bf01d72562fd4631776bb74fa4efe47" name="a5bf01d72562fd4631776bb74fa4efe47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf01d72562fd4631776bb74fa4efe47">&#9670;&#160;</a></span>AttributeStorageAllocator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a5bf01d72562fd4631776bb74fa4efe47">mlir::AttributeStorageAllocator</a> = <a class="el" href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html">StorageUniquer::StorageAllocator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AttributeSupport_8h_source.html#l00207">207</a> of file <a class="el" href="AttributeSupport_8h_source.html">AttributeSupport.h</a>.</p>

</div>
</div>
<a id="a5ba7e9a69eabd40dd01927f0185517f7" name="a5ba7e9a69eabd40dd01927f0185517f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba7e9a69eabd40dd01927f0185517f7">&#9670;&#160;</a></span>AttrSubElementReplacements</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a5ba7e9a69eabd40dd01927f0185517f7">mlir::AttrSubElementReplacements</a> = <a class="el" href="classmlir_1_1AttrTypeSubElementReplacements.html">AttrTypeSubElementReplacements</a>&lt;<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AttrTypeSubElements_8h_source.html#l00373">373</a> of file <a class="el" href="AttrTypeSubElements_8h_source.html">AttrTypeSubElements.h</a>.</p>

</div>
</div>
<a id="a9676bd96b41f931d8a8919d5bbb52e78" name="a9676bd96b41f931d8a8919d5bbb52e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9676bd96b41f931d8a8919d5bbb52e78">&#9670;&#160;</a></span>ChunkBufferHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a9676bd96b41f931d8a8919d5bbb52e78">mlir::ChunkBufferHandler</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <a class="code hl_typedef" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt;LogicalResult(</div>
<div class="line">    std::unique_ptr&lt;llvm::MemoryBuffer&gt; chunkBuffer,</div>
<div class="line">    <span class="keyword">const</span> llvm::MemoryBufferRef &amp;sourceBuffer, <a class="code hl_class" href="classmlir_1_1raw__ostream.html">raw_ostream</a> &amp;os)&gt;</div>
<div class="ttc" id="aclassmlir_1_1raw__ostream_html"><div class="ttname"><a href="classmlir_1_1raw__ostream.html">mlir::raw_ostream</a></div></div>
<div class="ttc" id="anamespacemlir_html_aeb139bbbd94ce3525f61d508772f5d69"><div class="ttname"><a href="#aeb139bbbd94ce3525f61d508772f5d69">mlir::function_ref</a></div><div class="ttdeci">llvm::function_ref&lt; Fn &gt; function_ref</div><div class="ttdef"><b>Definition</b> <a href="mlir_2Support_2LLVM_8h_source.html#l00152">LLVM.h:152</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="ToolUtilities_8h_source.html#l00030">30</a> of file <a class="el" href="ToolUtilities_8h_source.html">ToolUtilities.h</a>.</p>

</div>
</div>
<a id="a2b41a15774356d85c622215d017ac254" name="a2b41a15774356d85c622215d017ac254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b41a15774356d85c622215d017ac254">&#9670;&#160;</a></span>DataLayoutEntryKey</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a2b41a15774356d85c622215d017ac254">mlir::DataLayoutEntryKey</a> = <a class="el" href="classllvm_1_1PointerUnion.html">llvm::PointerUnion</a>&lt;<a class="el" href="classmlir_1_1Type.html">Type</a>, StringAttr&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8h_source.html#l00031">31</a> of file <a class="el" href="DataLayoutInterfaces_8h_source.html">DataLayoutInterfaces.h</a>.</p>

</div>
</div>
<a id="a17d2b8b3bf4e818da2900efa145bd05b" name="a17d2b8b3bf4e818da2900efa145bd05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d2b8b3bf4e818da2900efa145bd05b">&#9670;&#160;</a></span>DataLayoutEntryList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a17d2b8b3bf4e818da2900efa145bd05b">mlir::DataLayoutEntryList</a> = <a class="el" href="classllvm_1_1SmallVector.html">llvm::SmallVector</a>&lt;DataLayoutEntryInterface, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8h_source.html#l00034">34</a> of file <a class="el" href="DataLayoutInterfaces_8h_source.html">DataLayoutInterfaces.h</a>.</p>

</div>
</div>
<a id="aca03ba5e554abcffe4c1d89c53424982" name="aca03ba5e554abcffe4c1d89c53424982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca03ba5e554abcffe4c1d89c53424982">&#9670;&#160;</a></span>DataLayoutEntryListRef</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aca03ba5e554abcffe4c1d89c53424982">mlir::DataLayoutEntryListRef</a> = <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt;DataLayoutEntryInterface&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8h_source.html#l00035">35</a> of file <a class="el" href="DataLayoutInterfaces_8h_source.html">DataLayoutInterfaces.h</a>.</p>

</div>
</div>
<a id="a5dc0778d8b69de79a256dfcfe7664956" name="a5dc0778d8b69de79a256dfcfe7664956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dc0778d8b69de79a256dfcfe7664956">&#9670;&#160;</a></span>DataLayoutIdentifiedEntryMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a5dc0778d8b69de79a256dfcfe7664956">mlir::DataLayoutIdentifiedEntryMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    ::llvm::MapVector&lt;::mlir::StringAttr, ::mlir::DataLayoutEntryInterface&gt;</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8h_source.html#l00038">38</a> of file <a class="el" href="DataLayoutInterfaces_8h_source.html">DataLayoutInterfaces.h</a>.</p>

</div>
</div>
<a id="afb0f7ff64a84622f6ab30510c2225795" name="afb0f7ff64a84622f6ab30510c2225795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb0f7ff64a84622f6ab30510c2225795">&#9670;&#160;</a></span>DefaultAttributeStorage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#afb0f7ff64a84622f6ab30510c2225795">mlir::DefaultAttributeStorage</a> = <a class="el" href="classmlir_1_1AttributeStorage.html">AttributeStorage</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default storage type for attributes that require no additional initialization or storage. </p>

<p class="definition">Definition at line <a class="el" href="AttributeSupport_8h_source.html#l00199">199</a> of file <a class="el" href="AttributeSupport_8h_source.html">AttributeSupport.h</a>.</p>

</div>
</div>
<a id="a4f291a678314f33c164a2bb33d32f8f5" name="a4f291a678314f33c164a2bb33d32f8f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f291a678314f33c164a2bb33d32f8f5">&#9670;&#160;</a></span>DefaultTypeStorage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a4f291a678314f33c164a2bb33d32f8f5">mlir::DefaultTypeStorage</a> = <a class="el" href="classmlir_1_1TypeStorage.html">TypeStorage</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default storage type for types that require no additional initialization or storage. </p>

<p class="definition">Definition at line <a class="el" href="TypeSupport_8h_source.html#l00194">194</a> of file <a class="el" href="TypeSupport_8h_source.html">TypeSupport.h</a>.</p>

</div>
</div>
<a id="abac17268f4f35fc764ae9f810faad3df" name="abac17268f4f35fc764ae9f810faad3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac17268f4f35fc764ae9f810faad3df">&#9670;&#160;</a></span>DenseBoolArrayAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#abac17268f4f35fc764ae9f810faad3df">mlir::DenseBoolArrayAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt;<a class="el" href="classbool.html">bool</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00766">766</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a5df7b76c5b37ebb08dd8ee485555287a" name="a5df7b76c5b37ebb08dd8ee485555287a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df7b76c5b37ebb08dd8ee485555287a">&#9670;&#160;</a></span>DenseBoolResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a5df7b76c5b37ebb08dd8ee485555287a">mlir::DenseBoolResourceElementsAttr</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase&lt;bool&gt;</a></div>
<div class="ttc" id="aclassmlir_1_1detail_1_1DenseResourceElementsAttrBase_html"><div class="ttname"><a href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">mlir::detail::DenseResourceElementsAttrBase</a></div><div class="ttdoc">Base class for DenseResourceElementsAttr that is instantiated and specialized for each supported elem...</div><div class="ttdef"><b>Definition</b> <a href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00782">BuiltinAttributes.h:782</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00817">817</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="ad0d3ebf4f71f1220646aba6d1a805672" name="ad0d3ebf4f71f1220646aba6d1a805672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0d3ebf4f71f1220646aba6d1a805672">&#9670;&#160;</a></span>DenseF32ArrayAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ad0d3ebf4f71f1220646aba6d1a805672">mlir::DenseF32ArrayAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00771">771</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a5233c3052f050497e318bd0b91bf0ee8" name="a5233c3052f050497e318bd0b91bf0ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5233c3052f050497e318bd0b91bf0ee8">&#9670;&#160;</a></span>DenseF32ResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a5233c3052f050497e318bd0b91bf0ee8">mlir::DenseF32ResourceElementsAttr</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase&lt;float&gt;</a></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00835">835</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="ab56db522421522a641e396eafaffbc72" name="ab56db522421522a641e396eafaffbc72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab56db522421522a641e396eafaffbc72">&#9670;&#160;</a></span>DenseF64ArrayAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ab56db522421522a641e396eafaffbc72">mlir::DenseF64ArrayAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00772">772</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="aecf75b79ba339133a7c1aa0880b54a70" name="aecf75b79ba339133a7c1aa0880b54a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf75b79ba339133a7c1aa0880b54a70">&#9670;&#160;</a></span>DenseF64ResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aecf75b79ba339133a7c1aa0880b54a70">mlir::DenseF64ResourceElementsAttr</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase&lt;double&gt;</a></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00837">837</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="ae10aae53e540089fe9ad4fc6ed8aecb0" name="ae10aae53e540089fe9ad4fc6ed8aecb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae10aae53e540089fe9ad4fc6ed8aecb0">&#9670;&#160;</a></span>DenseI16ArrayAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae10aae53e540089fe9ad4fc6ed8aecb0">mlir::DenseI16ArrayAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt;int16_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00768">768</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a6c662950241aa2f480b1d68ab64164c7" name="a6c662950241aa2f480b1d68ab64164c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c662950241aa2f480b1d68ab64164c7">&#9670;&#160;</a></span>DenseI16ResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a6c662950241aa2f480b1d68ab64164c7">mlir::DenseI16ResourceElementsAttr</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase&lt;int16_t&gt;</a></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00821">821</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a8810f74ec6699911bda66ad210693ab9" name="a8810f74ec6699911bda66ad210693ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8810f74ec6699911bda66ad210693ab9">&#9670;&#160;</a></span>DenseI32ArrayAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a8810f74ec6699911bda66ad210693ab9">mlir::DenseI32ArrayAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt;int32_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00769">769</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a3064aa49ad102963ff202e9903385bdc" name="a3064aa49ad102963ff202e9903385bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3064aa49ad102963ff202e9903385bdc">&#9670;&#160;</a></span>DenseI32ResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a3064aa49ad102963ff202e9903385bdc">mlir::DenseI32ResourceElementsAttr</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase&lt;int32_t&gt;</a></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00823">823</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a12cd3f8e7b8c9f2cac6f17ff1dd80cd8" name="a12cd3f8e7b8c9f2cac6f17ff1dd80cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12cd3f8e7b8c9f2cac6f17ff1dd80cd8">&#9670;&#160;</a></span>DenseI64ArrayAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a12cd3f8e7b8c9f2cac6f17ff1dd80cd8">mlir::DenseI64ArrayAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt;<a class="el" href="classint64__t.html">int64_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00770">770</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a85932b40fda20f471041793c35ab742a" name="a85932b40fda20f471041793c35ab742a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85932b40fda20f471041793c35ab742a">&#9670;&#160;</a></span>DenseI64ResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a85932b40fda20f471041793c35ab742a">mlir::DenseI64ResourceElementsAttr</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase&lt;int64_t&gt;</a></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00825">825</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a3d68b629669b4329d85248453c29f2b4" name="a3d68b629669b4329d85248453c29f2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d68b629669b4329d85248453c29f2b4">&#9670;&#160;</a></span>DenseI8ArrayAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a3d68b629669b4329d85248453c29f2b4">mlir::DenseI8ArrayAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt;int8_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00767">767</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="abd8c55aab8498932190dd8014d1a445c" name="abd8c55aab8498932190dd8014d1a445c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8c55aab8498932190dd8014d1a445c">&#9670;&#160;</a></span>DenseI8ResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#abd8c55aab8498932190dd8014d1a445c">mlir::DenseI8ResourceElementsAttr</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase&lt;int8_t&gt;</a></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00819">819</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="abde461319ad5039ddbf5b4e70f47618b" name="abde461319ad5039ddbf5b4e70f47618b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde461319ad5039ddbf5b4e70f47618b">&#9670;&#160;</a></span>DenseMap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT, typename ValueT, typename KeyInfoT = DenseMapInfo&lt;KeyT&gt;, typename BucketT = llvm::detail::DenseMapPair&lt;KeyT, ValueT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#abde461319ad5039ddbf5b4e70f47618b">mlir::DenseMap</a> = <a class="el" href="classllvm_1_1DenseMap.html">llvm::DenseMap</a>&lt;KeyT, ValueT, KeyInfoT, BucketT&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Support_2LLVM_8h_source.html#l00126">126</a> of file <a class="el" href="mlir_2Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="a0fe2f804c3b5ffdbebdae95e127ce987" name="a0fe2f804c3b5ffdbebdae95e127ce987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe2f804c3b5ffdbebdae95e127ce987">&#9670;&#160;</a></span>DenseMapInfo</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Enable = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a0fe2f804c3b5ffdbebdae95e127ce987">mlir::DenseMapInfo</a> = <a class="el" href="structllvm_1_1DenseMapInfo.html">llvm::DenseMapInfo</a>&lt;T, Enable&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Support_2LLVM_8h_source.html#l00122">122</a> of file <a class="el" href="mlir_2Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="a47d2df4a0e350ac0c7fe9c87c76a0188" name="a47d2df4a0e350ac0c7fe9c87c76a0188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d2df4a0e350ac0c7fe9c87c76a0188">&#9670;&#160;</a></span>DenseResourceElementsHandle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a47d2df4a0e350ac0c7fe9c87c76a0188">mlir::DenseResourceElementsHandle</a> = <a class="el" href="structmlir_1_1DialectResourceBlobHandle.html">DialectResourceBlobHandle</a>&lt;BuiltinDialect&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00702">702</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a4aa33aa05f4fcff8a40613b43fb06f01" name="a4aa33aa05f4fcff8a40613b43fb06f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aa33aa05f4fcff8a40613b43fb06f01">&#9670;&#160;</a></span>DenseSet</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, typename ValueInfoT = DenseMapInfo&lt;ValueT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a4aa33aa05f4fcff8a40613b43fb06f01">mlir::DenseSet</a> = <a class="el" href="classllvm_1_1DenseSet.html">llvm::DenseSet</a>&lt;ValueT, ValueInfoT&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Support_2LLVM_8h_source.html#l00128">128</a> of file <a class="el" href="mlir_2Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="a88c45efc3c82e10f4e49696b1baaa40b" name="a88c45efc3c82e10f4e49696b1baaa40b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c45efc3c82e10f4e49696b1baaa40b">&#9670;&#160;</a></span>DenseUI16ResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a88c45efc3c82e10f4e49696b1baaa40b">mlir::DenseUI16ResourceElementsAttr</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase&lt;uint16_t&gt;</a></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00829">829</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a373f31c5e81954deaccebf02fd177040" name="a373f31c5e81954deaccebf02fd177040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a373f31c5e81954deaccebf02fd177040">&#9670;&#160;</a></span>DenseUI32ResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a373f31c5e81954deaccebf02fd177040">mlir::DenseUI32ResourceElementsAttr</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase&lt;uint32_t&gt;</a></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00831">831</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a2077156a5dc77393da6566434fb15aa6" name="a2077156a5dc77393da6566434fb15aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2077156a5dc77393da6566434fb15aa6">&#9670;&#160;</a></span>DenseUI64ResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a2077156a5dc77393da6566434fb15aa6">mlir::DenseUI64ResourceElementsAttr</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase&lt;uint64_t&gt;</a></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00833">833</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="adfbe9b27a834264f1cf1bc56f9a36c3a" name="adfbe9b27a834264f1cf1bc56f9a36c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfbe9b27a834264f1cf1bc56f9a36c3a">&#9670;&#160;</a></span>DenseUI8ResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#adfbe9b27a834264f1cf1bc56f9a36c3a">mlir::DenseUI8ResourceElementsAttr</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase&lt;uint8_t&gt;</a></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00827">827</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="aadc2250b56aebea7d22d222929a86dd9" name="aadc2250b56aebea7d22d222929a86dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc2250b56aebea7d22d222929a86dd9">&#9670;&#160;</a></span>DialectAllocatorFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aadc2250b56aebea7d22d222929a86dd9">mlir::DialectAllocatorFunction</a> = std::function&lt;<a class="el" href="classmlir_1_1Dialect.html">Dialect</a> *(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectRegistry_8h_source.html#l00027">27</a> of file <a class="el" href="DialectRegistry_8h_source.html">DialectRegistry.h</a>.</p>

</div>
</div>
<a id="ac2ab3da480d1cc6d3104dd423086fa7c" name="ac2ab3da480d1cc6d3104dd423086fa7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2ab3da480d1cc6d3104dd423086fa7c">&#9670;&#160;</a></span>DialectAllocatorFunctionRef</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ac2ab3da480d1cc6d3104dd423086fa7c">mlir::DialectAllocatorFunctionRef</a> = <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt;<a class="el" href="classmlir_1_1Dialect.html">Dialect</a> *(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectRegistry_8h_source.html#l00028">28</a> of file <a class="el" href="DialectRegistry_8h_source.html">DialectRegistry.h</a>.</p>

</div>
</div>
<a id="a466f8ff5b3af6b8eae74d1bbef9e0c0c" name="a466f8ff5b3af6b8eae74d1bbef9e0c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466f8ff5b3af6b8eae74d1bbef9e0c0c">&#9670;&#160;</a></span>DialectRegistrationFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a466f8ff5b3af6b8eae74d1bbef9e0c0c">mlir::DialectRegistrationFunction</a> = std::function&lt;<a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface of the function that adds all dialects and dialect extensions used for the translation to the given <a class="el" href="classmlir_1_1DialectRegistry.html" title="The DialectRegistry maps a dialect namespace to a constructor for the matching dialect.">DialectRegistry</a>. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8h_source.html#l00057">57</a> of file <a class="el" href="Translation_8h_source.html">Translation.h</a>.</p>

</div>
</div>
<a id="a76b4b70c990b486e0e1c005e13d6e204" name="a76b4b70c990b486e0e1c005e13d6e204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b4b70c990b486e0e1c005e13d6e204">&#9670;&#160;</a></span>DominanceInfoNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a76b4b70c990b486e0e1c005e13d6e204">mlir::DominanceInfoNode</a> = llvm::DomTreeNodeBase&lt;<a class="el" href="classmlir_1_1Block.html">Block</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dominance_8h_source.html#l00030">30</a> of file <a class="el" href="Dominance_8h_source.html">Dominance.h</a>.</p>

</div>
</div>
<a id="adb076aced6798f0c7d41487f4d4b228e" name="adb076aced6798f0c7d41487f4d4b228e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb076aced6798f0c7d41487f4d4b228e">&#9670;&#160;</a></span>DynamicDialectPopulationFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#adb076aced6798f0c7d41487f4d4b228e">mlir::DynamicDialectPopulationFunction</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::function&lt;<a class="code hl_class" href="classvoid.html">void</a>(<a class="code hl_class" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *, <a class="code hl_class" href="classmlir_1_1DynamicDialect.html">DynamicDialect</a> *)&gt;</div>
<div class="ttc" id="aclassmlir_1_1DynamicDialect_html"><div class="ttname"><a href="classmlir_1_1DynamicDialect.html">mlir::DynamicDialect</a></div><div class="ttdoc">A dialect that can be defined at runtime.</div><div class="ttdef"><b>Definition</b> <a href="ExtensibleDialect_8h_source.html#l00631">ExtensibleDialect.h:631</a></div></div>
<div class="ttc" id="aclassmlir_1_1MLIRContext_html"><div class="ttname"><a href="classmlir_1_1MLIRContext.html">mlir::MLIRContext</a></div><div class="ttdoc">MLIRContext is the top-level object for a collection of MLIR operations.</div><div class="ttdef"><b>Definition</b> <a href="MLIRContext_8h_source.html#l00063">MLIRContext.h:63</a></div></div>
<div class="ttc" id="aclassvoid_html"><div class="ttname"><a href="classvoid.html">void</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="DialectRegistry_8h_source.html#l00029">29</a> of file <a class="el" href="DialectRegistry_8h_source.html">DialectRegistry.h</a>.</p>

</div>
</div>
<a id="a5cfab90925243f984f819e6f38a7c218" name="a5cfab90925243f984f819e6f38a7c218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cfab90925243f984f819e6f38a7c218">&#9670;&#160;</a></span>ElementWiseVisitor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a5cfab90925243f984f819e6f38a7c218">mlir::ElementWiseVisitor</a> = <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt;<a class="el" href="classvoid.html">void</a>(T &amp;ptr, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classint64__t.html">int64_t</a>&gt;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenient callback to "visit" a memref element by element. </p>
<p>This takes a reference to an individual element as well as the coordinates. It can be used in conjuction with a <a class="el" href="classStridedMemrefIterator.html" title="Iterate over all elements in a strided memref.">StridedMemrefIterator</a>. </p>

<p class="definition">Definition at line <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html#l00131">131</a> of file <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html">MemRefUtils.h</a>.</p>

</div>
</div>
<a id="a73be93fbd86b265d1dafe07fe73e807e" name="a73be93fbd86b265d1dafe07fe73e807e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73be93fbd86b265d1dafe07fe73e807e">&#9670;&#160;</a></span>ForwardSliceOptions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a73be93fbd86b265d1dafe07fe73e807e">mlir::ForwardSliceOptions</a> = <a class="el" href="structmlir_1_1SliceOptions.html">SliceOptions</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8h_source.html#l00056">56</a> of file <a class="el" href="SliceAnalysis_8h_source.html">SliceAnalysis.h</a>.</p>

</div>
</div>
<a id="aeb139bbbd94ce3525f61d508772f5d69" name="aeb139bbbd94ce3525f61d508772f5d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb139bbbd94ce3525f61d508772f5d69">&#9670;&#160;</a></span>function_ref</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">mlir::function_ref</a> = <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt;Fn&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Support_2LLVM_8h_source.html#l00152">152</a> of file <a class="el" href="mlir_2Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="ae92775d7a7fdc64390df6978badf5615" name="ae92775d7a7fdc64390df6978badf5615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae92775d7a7fdc64390df6978badf5615">&#9670;&#160;</a></span>GenFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae92775d7a7fdc64390df6978badf5615">mlir::GenFunction</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::function&lt;<a class="code hl_class" href="classbool.html">bool</a>(<span class="keyword">const</span> llvm::RecordKeeper &amp;records, <a class="code hl_class" href="classmlir_1_1raw__ostream.html">raw_ostream</a> &amp;os)&gt;</div>
<div class="ttc" id="aclassbool_html"><div class="ttname"><a href="classbool.html">bool</a></div></div>
</div><!-- fragment -->
<p>Generator function to invoke. </p>

<p class="definition">Definition at line <a class="el" href="GenInfo_8h_source.html#l00024">24</a> of file <a class="el" href="GenInfo_8h_source.html">GenInfo.h</a>.</p>

</div>
</div>
<a id="afbe7bd7ebed80ba2be13ab5e9387f3fe" name="afbe7bd7ebed80ba2be13ab5e9387f3fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe7bd7ebed80ba2be13ab5e9387f3fe">&#9670;&#160;</a></span>GetIntRangeFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#afbe7bd7ebed80ba2be13ab5e9387f3fe">mlir::GetIntRangeFn</a> = <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt;<a class="el" href="classmlir_1_1IntegerValueRange.html">IntegerValueRange</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper callback type to get the integer range of a value. </p>

<p class="definition">Definition at line <a class="el" href="InferIntRangeInterface_8h_source.html#l00172">172</a> of file <a class="el" href="InferIntRangeInterface_8h_source.html">InferIntRangeInterface.h</a>.</p>

</div>
</div>
<a id="aed48aeaaa3484827b729cced4fb0dfb6" name="aed48aeaaa3484827b729cced4fb0dfb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed48aeaaa3484827b729cced4fb0dfb6">&#9670;&#160;</a></span>Loops</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aed48aeaaa3484827b729cced4fb0dfb6">mlir::Loops</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;scf::ForOp, 8&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tile a nest of standard for loops rooted at <span class="tt">rootForOp</span> by finding such parametric tile sizes that the outer loops have a fixed number of iterations as defined in <span class="tt">sizes</span>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8h_source.html#l00154">154</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a5981724f7c36485103689d762a0b168b" name="a5981724f7c36485103689d762a0b168b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5981724f7c36485103689d762a0b168b">&#9670;&#160;</a></span>LoweringCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a5981724f7c36485103689d762a0b168b">mlir::LoweringCallback</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> std::function&lt;std::unique_ptr&lt;llvm::Module&gt;(</div>
<div class="line">    <a class="code hl_class" href="classmlir_1_1Operation.html">Operation</a> *, llvm::LLVMContext &amp;, StringRef)&gt;</div>
<div class="ttc" id="aclassmlir_1_1Operation_html"><div class="ttname"><a href="classmlir_1_1Operation.html">mlir::Operation</a></div><div class="ttdoc">Operation is the basic unit of execution within MLIR.</div><div class="ttdef"><b>Definition</b> <a href="IR_2Operation_8h_source.html#l00084">Operation.h:88</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="GPUCommonPass_8h_source.html#l00047">47</a> of file <a class="el" href="GPUCommonPass_8h_source.html">GPUCommonPass.h</a>.</p>

</div>
</div>
<a id="a7a0b25e7052411f56f063eca0b73e8a2" name="a7a0b25e7052411f56f063eca0b73e8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0b25e7052411f56f063eca0b73e8a2">&#9670;&#160;</a></span>MemorySpaceMapping</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a7a0b25e7052411f56f063eca0b73e8a2">mlir::MemorySpaceMapping</a> = std::function&lt;<a class="el" href="classunsigned.html">unsigned</a>(gpu::AddressSpace)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that maps a MemorySpace enum to a target-specific integer value. </p>

<p class="definition">Definition at line <a class="el" href="GPUCommonPass_8h_source.html#l00070">70</a> of file <a class="el" href="GPUCommonPass_8h_source.html">GPUCommonPass.h</a>.</p>

</div>
</div>
<a id="a92e239e8ecf7770f9cbdc4cdb0ccd0f6" name="a92e239e8ecf7770f9cbdc4cdb0ccd0f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e239e8ecf7770f9cbdc4cdb0ccd0f6">&#9670;&#160;</a></span>MemrefValue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a92e239e8ecf7770f9cbdc4cdb0ccd0f6">mlir::MemrefValue</a> = <a class="el" href="#a864cb5eb1fea4a548c28cda535ba7213">TypedValue</a>&lt;<a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A value with a memref type. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2MemRef_2Utils_2MemRefUtils_8h_source.html#l00026">26</a> of file <a class="el" href="Dialect_2MemRef_2Utils_2MemRefUtils_8h_source.html">MemRefUtils.h</a>.</p>

</div>
</div>
<a id="a22fb6c3afa264f1726b430274179e011" name="a22fb6c3afa264f1726b430274179e011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22fb6c3afa264f1726b430274179e011">&#9670;&#160;</a></span>NewYieldValuesFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a22fb6c3afa264f1726b430274179e011">mlir::NewYieldValuesFn</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> std::function&lt;SmallVector&lt;Value&gt;(</div>
<div class="line">    <a class="code hl_class" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="code hl_variable" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="code hl_class" href="classmlir_1_1Location.html">Location</a> loc, <a class="code hl_class" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;BlockArgument&gt;</a> newBbArgs)&gt;</div>
<div class="ttc" id="aLinalgTransformOps_8cpp_html_a21ad0bd836b90d08f4cf640b4c298e7c"><div class="ttname"><a href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a></div><div class="ttdeci">b</div><div class="ttdoc">Return true if permutation is a valid permutation of the outer_dims_perm (case OuterOrInnerPerm::Oute...</div><div class="ttdef"><b>Definition</b> <a href="LinalgTransformOps_8cpp_source.html#l02097">LinalgTransformOps.cpp:2097</a></div></div>
<div class="ttc" id="aclassllvm_1_1ArrayRef_html"><div class="ttname"><a href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a></div><div class="ttdef"><b>Definition</b> <a href="mlir_2Support_2LLVM_8h_source.html#l00048">LLVM.h:48</a></div></div>
<div class="ttc" id="aclassmlir_1_1Location_html"><div class="ttname"><a href="classmlir_1_1Location.html">mlir::Location</a></div><div class="ttdoc">This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...</div><div class="ttdef"><b>Definition</b> <a href="Location_8h_source.html#l00076">Location.h:76</a></div></div>
<div class="ttc" id="aclassmlir_1_1OpBuilder_html"><div class="ttname"><a href="classmlir_1_1OpBuilder.html">mlir::OpBuilder</a></div><div class="ttdoc">This class helps build Operations.</div><div class="ttdef"><b>Definition</b> <a href="Builders_8h_source.html#l00207">Builders.h:207</a></div></div>
</div><!-- fragment -->
<p>A function that returns the additional yielded values during <span class="tt">replaceWithAdditionalYields</span>. </p>
<p><span class="tt">newBbArgs</span> are the newly added region iter_args. This function should return as many values as there are block arguments in <span class="tt">newBbArgs</span>. </p>

<p class="definition">Definition at line <a class="el" href="LoopLikeInterface_8h_source.html#l00025">25</a> of file <a class="el" href="LoopLikeInterface_8h_source.html">LoopLikeInterface.h</a>.</p>

</div>
</div>
<a id="a8abaf89ab4e6fae5aca7471295fba915" name="a8abaf89ab4e6fae5aca7471295fba915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8abaf89ab4e6fae5aca7471295fba915">&#9670;&#160;</a></span>NoSourceChunkBufferHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a8abaf89ab4e6fae5aca7471295fba915">mlir::NoSourceChunkBufferHandler</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <a class="code hl_typedef" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt;LogicalResult(</div>
<div class="line">    std::unique_ptr&lt;llvm::MemoryBuffer&gt; chunkBuffer, <a class="code hl_class" href="classmlir_1_1raw__ostream.html">raw_ostream</a> &amp;os)&gt;</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="ToolUtilities_8h_source.html#l00033">33</a> of file <a class="el" href="ToolUtilities_8h_source.html">ToolUtilities.h</a>.</p>

</div>
</div>
<a id="afe0f321b0342e2d3b005627d85baa5ad" name="afe0f321b0342e2d3b005627d85baa5ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe0f321b0342e2d3b005627d85baa5ad">&#9670;&#160;</a></span>OpAsmSetBlockNameFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#afe0f321b0342e2d3b005627d85baa5ad">mlir::OpAsmSetBlockNameFn</a> = <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt;<a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Block.html">Block</a> *, StringRef)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A functor used to set the name of blocks in regions directly nested under an operation. </p>

<p class="definition">Definition at line <a class="el" href="OpAsmSupport_8h_source.html#l00036">36</a> of file <a class="el" href="OpAsmSupport_8h_source.html">OpAsmSupport.h</a>.</p>

</div>
</div>
<a id="aab1e861818e2f0fd512d7269a9c95a1d" name="aab1e861818e2f0fd512d7269a9c95a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1e861818e2f0fd512d7269a9c95a1d">&#9670;&#160;</a></span>OpAsmSetNameFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aab1e861818e2f0fd512d7269a9c95a1d">mlir::OpAsmSetNameFn</a> = <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt;<a class="el" href="classvoid.html">void</a>(StringRef)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A functor used to set the name of the result. </p>
<p>See 'getAsmResultNames' below for more details. </p>

<p class="definition">Definition at line <a class="el" href="OpAsmSupport_8h_source.html#l00028">28</a> of file <a class="el" href="OpAsmSupport_8h_source.html">OpAsmSupport.h</a>.</p>

</div>
</div>
<a id="a1732950cbc518fd5656351ecc1f3dcea" name="a1732950cbc518fd5656351ecc1f3dcea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1732950cbc518fd5656351ecc1f3dcea">&#9670;&#160;</a></span>OpAsmSetValueNameFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a1732950cbc518fd5656351ecc1f3dcea">mlir::OpAsmSetValueNameFn</a> = <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt;<a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, StringRef)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A functor used to set the name of the start of a result group of an operation. </p>
<p>See 'getAsmResultNames' below for more details. </p>

<p class="definition">Definition at line <a class="el" href="OpAsmSupport_8h_source.html#l00032">32</a> of file <a class="el" href="OpAsmSupport_8h_source.html">OpAsmSupport.h</a>.</p>

</div>
</div>
<a id="a2fea733fc78ca9f48e6d1e5003350fe2" name="a2fea733fc78ca9f48e6d1e5003350fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fea733fc78ca9f48e6d1e5003350fe2">&#9670;&#160;</a></span>OperandElementTypeRange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a2fea733fc78ca9f48e6d1e5003350fe2">mlir::OperandElementTypeRange</a> = <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt;<a class="el" href="classmlir_1_1OperandElementTypeIterator.html">OperandElementTypeIterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8h_source.html#l00097">97</a> of file <a class="el" href="TypeUtilities_8h_source.html">TypeUtilities.h</a>.</p>

</div>
</div>
<a id="a13509926eab92d24bb5729fef49bdf37" name="a13509926eab92d24bb5729fef49bdf37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13509926eab92d24bb5729fef49bdf37">&#9670;&#160;</a></span>PassAllocatorFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a13509926eab92d24bb5729fef49bdf37">mlir::PassAllocatorFunction</a> = std::function&lt;std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">Pass</a>&gt;()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PassRegistry_8h_source.html#l00041">41</a> of file <a class="el" href="PassRegistry_8h_source.html">PassRegistry.h</a>.</p>

</div>
</div>
<a id="a6aad297ee60ea11aca22b19fba8f27ac" name="a6aad297ee60ea11aca22b19fba8f27ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aad297ee60ea11aca22b19fba8f27ac">&#9670;&#160;</a></span>PassPipelineFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a6aad297ee60ea11aca22b19fba8f27ac">mlir::PassPipelineFn</a> = <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt;LogicalResult(<a class="el" href="classmlir_1_1PassManager.html">PassManager</a> &amp;pm)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This defines the function type used to setup the pass manager. </p>
<p>This can be used to pass in a callback to setup a default pass pipeline to be applied on the loaded IR. </p>

<p class="definition">Definition at line <a class="el" href="MlirOptMain_8h_source.html#l00360">360</a> of file <a class="el" href="MlirOptMain_8h_source.html">MlirOptMain.h</a>.</p>

</div>
</div>
<a id="a1eb8eb86939076c1bf86f544e23aef0e" name="a1eb8eb86939076c1bf86f544e23aef0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb8eb86939076c1bf86f544e23aef0e">&#9670;&#160;</a></span>PassRegistryFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a1eb8eb86939076c1bf86f544e23aef0e">mlir::PassRegistryFunction</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> std::function&lt;LogicalResult(</div>
<div class="line">    <a class="code hl_class" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;, StringRef <a class="code hl_variable" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>,</div>
<div class="line">    <a class="code hl_typedef" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt;LogicalResult(<span class="keyword">const</span> Twine &amp;)&gt; errorHandler)&gt;</div>
<div class="ttc" id="aPassManagerOptions_8cpp_html_a565f4d58c99c19dde9d8fb7d12fd8a16"><div class="ttname"><a href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a></div><div class="ttdeci">static llvm::ManagedStatic&lt; PassManagerOptions &gt; options</div><div class="ttdef"><b>Definition</b> <a href="PassManagerOptions_8cpp_source.html#l00089">PassManagerOptions.cpp:89</a></div></div>
<div class="ttc" id="aclassmlir_1_1OpPassManager_html"><div class="ttname"><a href="classmlir_1_1OpPassManager.html">mlir::OpPassManager</a></div><div class="ttdoc">This class represents a pass manager that runs passes on either a specific operation type,...</div><div class="ttdef"><b>Definition</b> <a href="PassManager_8h_source.html#l00046">PassManager.h:46</a></div></div>
</div><!-- fragment -->
<p>A registry function that adds passes to the given pass manager. </p>
<p>This should also parse options and return <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a> if parsing succeeded. <span class="tt">errorHandler</span> is a functor used to emit errors during parsing. parameter corresponds to the raw location within the pipeline string. This should always return failure. </p>

<p class="definition">Definition at line <a class="el" href="PassRegistry_8h_source.html#l00038">38</a> of file <a class="el" href="PassRegistry_8h_source.html">PassRegistry.h</a>.</p>

</div>
</div>
<a id="a9d60419b09330b78865818c679695080" name="a9d60419b09330b78865818c679695080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d60419b09330b78865818c679695080">&#9670;&#160;</a></span>ReassociationExprs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a9d60419b09330b78865818c679695080">mlir::ReassociationExprs</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8h_source.html#l00029">29</a> of file <a class="el" href="ReshapeOpsUtils_8h_source.html">ReshapeOpsUtils.h</a>.</p>

</div>
</div>
<a id="ad3cda368514f1e456981bd339ef6bc92" name="ad3cda368514f1e456981bd339ef6bc92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3cda368514f1e456981bd339ef6bc92">&#9670;&#160;</a></span>ReassociationIndices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a>, 2 &gt; <a class="el" href="#ad3cda368514f1e456981bd339ef6bc92">mlir::ReassociationIndices</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classint64__t.html">int64_t</a>, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8h_source.html#l00027">27</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a11a02d1f78682e704d9aa4a6ef3cb364" name="a11a02d1f78682e704d9aa4a6ef3cb364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11a02d1f78682e704d9aa4a6ef3cb364">&#9670;&#160;</a></span>ReassociationIndicesRef</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a11a02d1f78682e704d9aa4a6ef3cb364">mlir::ReassociationIndicesRef</a> = <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classint64__t.html">int64_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8h_source.html#l00028">28</a> of file <a class="el" href="ReshapeOpsUtils_8h_source.html">ReshapeOpsUtils.h</a>.</p>

</div>
</div>
<a id="a676bc3fbf14bd5dba33f962b259d2034" name="a676bc3fbf14bd5dba33f962b259d2034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676bc3fbf14bd5dba33f962b259d2034">&#9670;&#160;</a></span>ReifiedRankedShapedTypeDims</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a676bc3fbf14bd5dba33f962b259d2034">mlir::ReifiedRankedShapedTypeDims</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InferTypeOpInterface_8h_source.html#l00029">29</a> of file <a class="el" href="InferTypeOpInterface_8h_source.html">InferTypeOpInterface.h</a>.</p>

</div>
</div>
<a id="ab2bd7f43571b8a966760c237e15e282d" name="ab2bd7f43571b8a966760c237e15e282d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2bd7f43571b8a966760c237e15e282d">&#9670;&#160;</a></span>ReproducerStreamFactory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ab2bd7f43571b8a966760c237e15e282d">mlir::ReproducerStreamFactory</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::function&lt;std::unique_ptr&lt;ReproducerStream&gt;(std::string &amp;error)&gt;</div>
</div><!-- fragment -->
<p>Method type for constructing <a class="el" href="structmlir_1_1ReproducerStream.html" title="Streams on which to output crash reproducer.">ReproducerStream</a>. </p>

<p class="definition">Definition at line <a class="el" href="PassManager_8h_source.html#l00222">222</a> of file <a class="el" href="PassManager_8h_source.html">PassManager.h</a>.</p>

</div>
</div>
<a id="a4b1e38ec88915ae4091502043a3a81f3" name="a4b1e38ec88915ae4091502043a3a81f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1e38ec88915ae4091502043a3a81f3">&#9670;&#160;</a></span>ResultElementTypeRange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a4b1e38ec88915ae4091502043a3a81f3">mlir::ResultElementTypeRange</a> = <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt;<a class="el" href="classmlir_1_1ResultElementTypeIterator.html">ResultElementTypeIterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8h_source.html#l00110">110</a> of file <a class="el" href="TypeUtilities_8h_source.html">TypeUtilities.h</a>.</p>

</div>
</div>
<a id="a2acdab8c5c09e069909b8e887f0b31ea" name="a2acdab8c5c09e069909b8e887f0b31ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2acdab8c5c09e069909b8e887f0b31ea">&#9670;&#160;</a></span>SetIntLatticeFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a2acdab8c5c09e069909b8e887f0b31ea">mlir::SetIntLatticeFn</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt;<a class="code hl_class" href="classvoid.html">void</a>(<a class="code hl_class" href="classmlir_1_1Value.html">Value</a>, <span class="keyword">const</span> <a class="code hl_class" href="classmlir_1_1IntegerValueRange.html">IntegerValueRange</a> &amp;)&gt;</div>
<div class="ttc" id="aclassllvm_1_1function__ref_html"><div class="ttname"><a href="classllvm_1_1function__ref.html">llvm::function_ref</a></div><div class="ttdef"><b>Definition</b> <a href="mlir_2Support_2LLVM_8h_source.html#l00090">LLVM.h:90</a></div></div>
<div class="ttc" id="aclassmlir_1_1IntegerValueRange_html"><div class="ttname"><a href="classmlir_1_1IntegerValueRange.html">mlir::IntegerValueRange</a></div><div class="ttdoc">This lattice value represents the integer range of an SSA value.</div><div class="ttdef"><b>Definition</b> <a href="InferIntRangeInterface_8h_source.html#l00109">InferIntRangeInterface.h:109</a></div></div>
<div class="ttc" id="aclassmlir_1_1Value_html"><div class="ttname"><a href="classmlir_1_1Value.html">mlir::Value</a></div><div class="ttdoc">This class represents an instance of an SSA value in the MLIR system, representing a computable value...</div><div class="ttdef"><b>Definition</b> <a href="Value_8h_source.html#l00096">Value.h:96</a></div></div>
</div><!-- fragment -->
<p>Similar to <a class="el" href="#a288fe47d4f5d1342fd68f6a877a23046" title="The type of the setResultRanges callback provided to ops implementing InferIntRangeInterface.">SetIntRangeFn</a>, but operating on <a class="el" href="classmlir_1_1IntegerValueRange.html" title="This lattice value represents the integer range of an SSA value.">IntegerValueRange</a> lattice values. </p>
<p>This is the <span class="tt">setResultRanges</span> callback for the <a class="el" href="classmlir_1_1IntegerValueRange.html" title="This lattice value represents the integer range of an SSA value.">IntegerValueRange</a> based interface method. </p>

<p class="definition">Definition at line <a class="el" href="InferIntRangeInterface_8h_source.html#l00168">168</a> of file <a class="el" href="InferIntRangeInterface_8h_source.html">InferIntRangeInterface.h</a>.</p>

</div>
</div>
<a id="a288fe47d4f5d1342fd68f6a877a23046" name="a288fe47d4f5d1342fd68f6a877a23046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a288fe47d4f5d1342fd68f6a877a23046">&#9670;&#160;</a></span>SetIntRangeFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a288fe47d4f5d1342fd68f6a877a23046">mlir::SetIntRangeFn</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt;<a class="code hl_class" href="classvoid.html">void</a>(<a class="code hl_class" href="classmlir_1_1Value.html">Value</a>, <span class="keyword">const</span> <a class="code hl_class" href="classmlir_1_1ConstantIntRanges.html">ConstantIntRanges</a> &amp;)&gt;</div>
<div class="ttc" id="aclassmlir_1_1ConstantIntRanges_html"><div class="ttname"><a href="classmlir_1_1ConstantIntRanges.html">mlir::ConstantIntRanges</a></div><div class="ttdoc">A set of arbitrary-precision integers representing bounds on a given integer value.</div><div class="ttdef"><b>Definition</b> <a href="InferIntRangeInterface_8h_source.html#l00027">InferIntRangeInterface.h:27</a></div></div>
</div><!-- fragment -->
<p>The type of the <span class="tt">setResultRanges</span> callback provided to ops implementing InferIntRangeInterface. </p>
<p>It should be called once for each integer result value and be passed the <a class="el" href="classmlir_1_1ConstantIntRanges.html" title="A set of arbitrary-precision integers representing bounds on a given integer value.">ConstantIntRanges</a> corresponding to that value. </p>

<p class="definition">Definition at line <a class="el" href="InferIntRangeInterface_8h_source.html#l00162">162</a> of file <a class="el" href="InferIntRangeInterface_8h_source.html">InferIntRangeInterface.h</a>.</p>

</div>
</div>
<a id="ac60ebc0849fbf18245acaee5a6bc7b5b" name="ac60ebc0849fbf18245acaee5a6bc7b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60ebc0849fbf18245acaee5a6bc7b5b">&#9670;&#160;</a></span>SetStridedMetadataRangeFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ac60ebc0849fbf18245acaee5a6bc7b5b">mlir::SetStridedMetadataRangeFn</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt;<a class="code hl_class" href="classvoid.html">void</a>(<a class="code hl_class" href="classmlir_1_1Value.html">Value</a>, <span class="keyword">const</span> <a class="code hl_class" href="classmlir_1_1StridedMetadataRange.html">StridedMetadataRange</a> &amp;)&gt;</div>
<div class="ttc" id="aclassmlir_1_1StridedMetadataRange_html"><div class="ttname"><a href="classmlir_1_1StridedMetadataRange.html">mlir::StridedMetadataRange</a></div><div class="ttdoc">A class that represents the strided metadata range information, including offsets,...</div><div class="ttdef"><b>Definition</b> <a href="InferStridedMetadataInterface_8h_source.html#l00022">InferStridedMetadataInterface.h:22</a></div></div>
</div><!-- fragment -->
<p>Callback function type for setting the strided metadata of a value. </p>

<p class="definition">Definition at line <a class="el" href="InferStridedMetadataInterface_8h_source.html#l00139">139</a> of file <a class="el" href="InferStridedMetadataInterface_8h_source.html">InferStridedMetadataInterface.h</a>.</p>

</div>
</div>
<a id="a70f70d8c0fc9767c6d18b1592cd9a7ee" name="a70f70d8c0fc9767c6d18b1592cd9a7ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f70d8c0fc9767c6d18b1592cd9a7ee">&#9670;&#160;</a></span>SetVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename <a class="el" href="structVector.html">Vector</a> = llvm::SmallVector&lt;T, 0&gt;, typename Set = DenseSet&lt;T&gt;, <a class="el" href="classunsigned.html">unsigned</a> N = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a70f70d8c0fc9767c6d18b1592cd9a7ee">mlir::SetVector</a> = <a class="el" href="classllvm_1_1SetVector.html">llvm::SetVector</a>&lt;T, <a class="el" href="structVector.html">Vector</a>, Set, N&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Support_2LLVM_8h_source.html#l00131">131</a> of file <a class="el" href="mlir_2Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="a84d105d34b85fe809ec98a1391e35811" name="a84d105d34b85fe809ec98a1391e35811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84d105d34b85fe809ec98a1391e35811">&#9670;&#160;</a></span>StringSet</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorTy = llvm::MallocAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a84d105d34b85fe809ec98a1391e35811">mlir::StringSet</a> = <a class="el" href="classllvm_1_1StringSet.html">llvm::StringSet</a>&lt;AllocatorTy&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Support_2LLVM_8h_source.html#l00133">133</a> of file <a class="el" href="mlir_2Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="ada84f277868519ebf68fe9fbfc70c4a9" name="ada84f277868519ebf68fe9fbfc70c4a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada84f277868519ebf68fe9fbfc70c4a9">&#9670;&#160;</a></span>StringSwitch</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename R = T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ada84f277868519ebf68fe9fbfc70c4a9">mlir::StringSwitch</a> = <a class="el" href="classllvm_1_1StringSwitch.html">llvm::StringSwitch</a>&lt;T, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Support_2LLVM_8h_source.html#l00141">141</a> of file <a class="el" href="mlir_2Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="a4a31a056e44563d0c877ae435b5cf51c" name="a4a31a056e44563d0c877ae435b5cf51c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a31a056e44563d0c877ae435b5cf51c">&#9670;&#160;</a></span>TargetDeviceSpecEntry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a4a31a056e44563d0c877ae435b5cf51c">mlir::TargetDeviceSpecEntry</a> = std::pair&lt;StringAttr, TargetDeviceSpecInterface&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8h_source.html#l00037">37</a> of file <a class="el" href="DataLayoutInterfaces_8h_source.html">DataLayoutInterfaces.h</a>.</p>

</div>
</div>
<a id="a4bd203358eecf2493ba5344cd392aa65" name="a4bd203358eecf2493ba5344cd392aa65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd203358eecf2493ba5344cd392aa65">&#9670;&#160;</a></span>TargetDeviceSpecListRef</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a4bd203358eecf2493ba5344cd392aa65">mlir::TargetDeviceSpecListRef</a> = <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt;TargetDeviceSpecInterface&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8h_source.html#l00036">36</a> of file <a class="el" href="DataLayoutInterfaces_8h_source.html">DataLayoutInterfaces.h</a>.</p>

</div>
</div>
<a id="a5510ab947817d6f0bf6617e367113963" name="a5510ab947817d6f0bf6617e367113963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5510ab947817d6f0bf6617e367113963">&#9670;&#160;</a></span>TileLoops</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a5510ab947817d6f0bf6617e367113963">mlir::TileLoops</a> = std::pair&lt;<a class="el" href="#aed48aeaaa3484827b729cced4fb0dfb6">Loops</a>, <a class="el" href="#aed48aeaaa3484827b729cced4fb0dfb6">Loops</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8h_source.html#l00155">155</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a9a2a446f58dd14edfbb77bb2f0ea8818" name="a9a2a446f58dd14edfbb77bb2f0ea8818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2a446f58dd14edfbb77bb2f0ea8818">&#9670;&#160;</a></span>TransitiveFilter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a9a2a446f58dd14edfbb77bb2f0ea8818">mlir::TransitiveFilter</a> = <a class="el" href="structmlir_1_1SliceOptions.html#a667b0cbe189fd8ce9af2f0475a14b602">SliceOptions::TransitiveFilter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8h_source.html#l00040">40</a> of file <a class="el" href="SliceAnalysis_8h_source.html">SliceAnalysis.h</a>.</p>

</div>
</div>
<a id="a0892a7feafdcb8ef1cfd6ff43b596325" name="a0892a7feafdcb8ef1cfd6ff43b596325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0892a7feafdcb8ef1cfd6ff43b596325">&#9670;&#160;</a></span>TranslateFromMLIRFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a0892a7feafdcb8ef1cfd6ff43b596325">mlir::TranslateFromMLIRFunction</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::function&lt;LogicalResult(<a class="code hl_class" href="classmlir_1_1Operation.html">Operation</a> *, llvm::raw_ostream &amp;output)&gt;</div>
</div><!-- fragment -->
<p>Interface of the function that translates MLIR to a different format and outputs the result to a stream. </p>
<p>It is allowed to modify the operation. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8h_source.html#l00043">43</a> of file <a class="el" href="Translation_8h_source.html">Translation.h</a>.</p>

</div>
</div>
<a id="a70ee1a2d7a5a045a5b96a81e3de5950c" name="a70ee1a2d7a5a045a5b96a81e3de5950c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70ee1a2d7a5a045a5b96a81e3de5950c">&#9670;&#160;</a></span>TranslateFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a70ee1a2d7a5a045a5b96a81e3de5950c">mlir::TranslateFunction</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> std::function&lt;LogicalResult(</div>
<div class="line">    <span class="keyword">const</span> std::shared_ptr&lt;llvm::SourceMgr&gt; &amp;sourceMgr,</div>
<div class="line">    llvm::raw_ostream &amp;output, <a class="code hl_class" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</div>
</div><!-- fragment -->
<p>Interface of the function that performs file-to-file translation involving MLIR. </p>
<p>The input file is held in the given MemoryBuffer; the output file should be written to the given <a class="el" href="classmlir_1_1raw__ostream.html">raw_ostream</a>. The implementation should create all MLIR constructs needed during the process inside the given context. This can be used for round-tripping external formats through the MLIR system. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8h_source.html#l00051">51</a> of file <a class="el" href="Translation_8h_source.html">Translation.h</a>.</p>

</div>
</div>
<a id="a1075794620a8bc0580df8e315cc9e7b3" name="a1075794620a8bc0580df8e315cc9e7b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1075794620a8bc0580df8e315cc9e7b3">&#9670;&#160;</a></span>TranslateRawSourceMgrToMLIRFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a1075794620a8bc0580df8e315cc9e7b3">mlir::TranslateRawSourceMgrToMLIRFunction</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::function&lt;OwningOpRef&lt;Operation *&gt;(llvm::SourceMgr &amp;sourceMgr,</div>
<div class="line">                                           <a class="code hl_class" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="Translation_8h_source.html#l00030">30</a> of file <a class="el" href="Translation_8h_source.html">Translation.h</a>.</p>

</div>
</div>
<a id="ade33612496c16d3570c85668b8c39d2b" name="ade33612496c16d3570c85668b8c39d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade33612496c16d3570c85668b8c39d2b">&#9670;&#160;</a></span>TranslateSourceMgrToMLIRFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ade33612496c16d3570c85668b8c39d2b">mlir::TranslateSourceMgrToMLIRFunction</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> std::function&lt;OwningOpRef&lt;Operation *&gt;(</div>
<div class="line">    <span class="keyword">const</span> std::shared_ptr&lt;llvm::SourceMgr&gt; &amp;sourceMgr, <a class="code hl_class" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</div>
</div><!-- fragment -->
<p>Interface of the function that translates the sources managed by <span class="tt">sourceMgr</span> to MLIR. </p>
<p>The source manager has at least one buffer. The implementation should create a new MLIR <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> in the given context and return a pointer to it, or a nullptr in case of any error. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8h_source.html#l00028">28</a> of file <a class="el" href="Translation_8h_source.html">Translation.h</a>.</p>

</div>
</div>
<a id="ac98f5f6364a5cc66f4186b6335feb388" name="ac98f5f6364a5cc66f4186b6335feb388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98f5f6364a5cc66f4186b6335feb388">&#9670;&#160;</a></span>TranslateStringRefToMLIRFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ac98f5f6364a5cc66f4186b6335feb388">mlir::TranslateStringRefToMLIRFunction</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::function&lt;OwningOpRef&lt;Operation *&gt;(llvm::StringRef, <a class="code hl_class" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</div>
</div><!-- fragment -->
<p>Interface of the function that translates the given string to MLIR. </p>
<p>The implementation should create a new MLIR <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> in the given context. If source-related error reporting is required from within the function, use <a class="el" href="#ade33612496c16d3570c85668b8c39d2b" title="Interface of the function that translates the sources managed by sourceMgr to MLIR.">TranslateSourceMgrToMLIRFunction</a> instead. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8h_source.html#l00038">38</a> of file <a class="el" href="Translation_8h_source.html">Translation.h</a>.</p>

</div>
</div>
<a id="a864cb5eb1fea4a548c28cda535ba7213" name="a864cb5eb1fea4a548c28cda535ba7213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a864cb5eb1fea4a548c28cda535ba7213">&#9670;&#160;</a></span>TypedValue</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ty, typename <a class="el" href="classmlir_1_1Value.html">Value</a> = mlir::Value&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a864cb5eb1fea4a548c28cda535ba7213">mlir::TypedValue</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> std::conditional_t&lt;std::is_same_v&lt;Ty, mlir::Type&gt;,</div>
<div class="line">                                      <a class="code hl_class" href="classmlir_1_1Value.html">mlir::Value</a>, <a class="code hl_struct" href="structmlir_1_1detail_1_1TypedValue.html">detail::TypedValue&lt;Ty&gt;</a>&gt;</div>
<div class="ttc" id="astructmlir_1_1detail_1_1TypedValue_html"><div class="ttname"><a href="structmlir_1_1detail_1_1TypedValue.html">mlir::detail::TypedValue</a></div><div class="ttdoc">TypedValue is a Value with a statically know type.</div><div class="ttdef"><b>Definition</b> <a href="Value_8h_source.html#l00434">Value.h:434</a></div></div>
</div><!-- fragment -->
<p>If Ty is <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">mlir::Type</a> this will select <span class="tt"><a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a></span> instead of having a wrapper around it. </p>
<p>This helps resolve ambiguous conversion issues. </p>

<p class="definition">Definition at line <a class="el" href="Value_8h_source.html#l00497">497</a> of file <a class="el" href="Value_8h_source.html">Value.h</a>.</p>

</div>
</div>
<a id="a5a72cd6bb5511a9aacec43a0e40452c9" name="a5a72cd6bb5511a9aacec43a0e40452c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a72cd6bb5511a9aacec43a0e40452c9">&#9670;&#160;</a></span>TypeRangeRangeIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a5a72cd6bb5511a9aacec43a0e40452c9">mlir::TypeRangeRangeIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    llvm::mapped_iterator&lt;llvm::iota_range&lt;unsigned&gt;::iterator,</div>
<div class="line">                          std::function&lt;<a class="code hl_variable" href="LinalgTransformOps_8cpp.html#a4746ef6801d3928c0b694133e5b2789f">TypeRange</a>(<span class="keywordtype">unsigned</span>)&gt;&gt;</div>
<div class="ttc" id="aLinalgTransformOps_8cpp_html_a4746ef6801d3928c0b694133e5b2789f"><div class="ttname"><a href="LinalgTransformOps_8cpp.html#a4746ef6801d3928c0b694133e5b2789f">TypeRange</a></div><div class="ttdeci">TypeRange</div><div class="ttdef"><b>Definition</b> <a href="LinalgTransformOps_8cpp_source.html#l02099">LinalgTransformOps.cpp:2099</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="TypeRange_8h_source.html#l00088">88</a> of file <a class="el" href="TypeRange_8h_source.html">TypeRange.h</a>.</p>

</div>
</div>
<a id="a07820b1b64d9c34cc7055479eb3951aa" name="a07820b1b64d9c34cc7055479eb3951aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07820b1b64d9c34cc7055479eb3951aa">&#9670;&#160;</a></span>TypeStorageAllocator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a07820b1b64d9c34cc7055479eb3951aa">mlir::TypeStorageAllocator</a> = <a class="el" href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html">StorageUniquer::StorageAllocator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a utility allocator used to allocate memory for instances of derived Types. </p>

<p class="definition">Definition at line <a class="el" href="TypeSupport_8h_source.html#l00202">202</a> of file <a class="el" href="TypeSupport_8h_source.html">TypeSupport.h</a>.</p>

</div>
</div>
<a id="af8f67951552f6246ef1d9cfb21bf4cc5" name="af8f67951552f6246ef1d9cfb21bf4cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f67951552f6246ef1d9cfb21bf4cc5">&#9670;&#160;</a></span>TypeSubElementReplacements</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af8f67951552f6246ef1d9cfb21bf4cc5">mlir::TypeSubElementReplacements</a> = <a class="el" href="classmlir_1_1AttrTypeSubElementReplacements.html">AttrTypeSubElementReplacements</a>&lt;<a class="el" href="classmlir_1_1Type.html">Type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AttrTypeSubElements_8h_source.html#l00374">374</a> of file <a class="el" href="AttrTypeSubElements_8h_source.html">AttrTypeSubElements.h</a>.</p>

</div>
</div>
<a id="a9eabc3974d2131e15fad199b34b2eaa0" name="a9eabc3974d2131e15fad199b34b2eaa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eabc3974d2131e15fad199b34b2eaa0">&#9670;&#160;</a></span>TypeSwitch</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename ResultT = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a9eabc3974d2131e15fad199b34b2eaa0">mlir::TypeSwitch</a> = <a class="el" href="classllvm_1_1TypeSwitch.html">llvm::TypeSwitch</a>&lt;T, ResultT&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Support_2LLVM_8h_source.html#l00144">144</a> of file <a class="el" href="mlir_2Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="ae781cb86d98ed62093c16c9e8819799b" name="ae781cb86d98ed62093c16c9e8819799b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae781cb86d98ed62093c16c9e8819799b">&#9670;&#160;</a></span>ValueDimList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae781cb86d98ed62093c16c9e8819799b">mlir::ValueDimList</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;std::pair&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>, std::optional&lt;<a class="el" href="classint64__t.html">int64_t</a>&gt;&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00051">51</a> of file <a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a>.</p>

</div>
</div>
<a id="abd3021a9a0e882a2cd1061b4312a1698" name="abd3021a9a0e882a2cd1061b4312a1698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd3021a9a0e882a2cd1061b4312a1698">&#9670;&#160;</a></span>WalkCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#abd3021a9a0e882a2cd1061b4312a1698">mlir::WalkCallback</a> = <a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">mlir::function_ref</a>&lt;<a class="el" href="classmlir_1_1WalkContinuation.html">WalkContinuation</a>(<a class="el" href="classmlir_1_1Value.html">mlir::Value</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback that is invoked for each value encountered during the walk of the slice. </p>
<p>The callback takes the current value, and returns the walk continuation, which determines if the walk should proceed and if yes, with which values. </p>

<p class="definition">Definition at line <a class="el" href="SliceWalk_8h_source.html#l00081">81</a> of file <a class="el" href="SliceWalk_8h_source.html">SliceWalk.h</a>.</p>

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="a6d3b7fd763c24274db6c115579084133" name="a6d3b7fd763c24274db6c115579084133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3b7fd763c24274db6c115579084133">&#9670;&#160;</a></span>AffineExprKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a6d3b7fd763c24274db6c115579084133">mlir::AffineExprKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133aec211f7c20af43e742bf2570c3cb84f9" name="a6d3b7fd763c24274db6c115579084133aec211f7c20af43e742bf2570c3cb84f9"></a>Add&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133a62b6d55816cf737bfc6f42e60df1a3f2" name="a6d3b7fd763c24274db6c115579084133a62b6d55816cf737bfc6f42e60df1a3f2"></a>Mul&#160;</td><td class="fielddoc"><p>RHS of mul is always a constant or a symbolic expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133a7aeb0277500c86e4aa6bd23f9a737942" name="a6d3b7fd763c24274db6c115579084133a7aeb0277500c86e4aa6bd23f9a737942"></a>Mod&#160;</td><td class="fielddoc"><p>RHS of mod is always a constant or a symbolic expression with a positive value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133abaa422535e7ce48b442cc07089e64e7a" name="a6d3b7fd763c24274db6c115579084133abaa422535e7ce48b442cc07089e64e7a"></a>FloorDiv&#160;</td><td class="fielddoc"><p>RHS of floordiv is always a constant or a symbolic expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133a30c212eb3184a5ed41f01a25c8124e8a" name="a6d3b7fd763c24274db6c115579084133a30c212eb3184a5ed41f01a25c8124e8a"></a>CeilDiv&#160;</td><td class="fielddoc"><p>RHS of ceildiv is always a constant or a symbolic expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133a4be6ccd8c4af006587a76a5fd3e7dc24" name="a6d3b7fd763c24274db6c115579084133a4be6ccd8c4af006587a76a5fd3e7dc24"></a>LAST_AFFINE_BINARY_OP&#160;</td><td class="fielddoc"><p>This is a marker for the last affine binary op. </p>
<p>The range of binary op's is expected to be this element and earlier. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255" name="a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255"></a>Constant&#160;</td><td class="fielddoc"><p>Constant integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133ab49b848e4bb608f4d5650e4b2817c641" name="a6d3b7fd763c24274db6c115579084133ab49b848e4bb608f4d5650e4b2817c641"></a>DimId&#160;</td><td class="fielddoc"><p>Dimensional identifier. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133aea00d3c6059a4ff11d351696747fc7ff" name="a6d3b7fd763c24274db6c115579084133aea00d3c6059a4ff11d351696747fc7ff"></a>SymbolId&#160;</td><td class="fielddoc"><p>Symbolic identifier. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00040">40</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

</div>
</div>
<a id="ac84871bcca0aaa0176d43dbdbffe9a6c" name="ac84871bcca0aaa0176d43dbdbffe9a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84871bcca0aaa0176d43dbdbffe9a6c">&#9670;&#160;</a></span>AsmResourceEntryKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ac84871bcca0aaa0176d43dbdbffe9a6c">mlir::AsmResourceEntryKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This enum represents the different kinds of resource values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac84871bcca0aaa0176d43dbdbffe9a6cae8016c85ada38bdc5fac616ec1318047" name="ac84871bcca0aaa0176d43dbdbffe9a6cae8016c85ada38bdc5fac616ec1318047"></a>Blob&#160;</td><td class="fielddoc"><p>A blob of data with an accompanying alignment. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac84871bcca0aaa0176d43dbdbffe9a6cac26f15e86e3de4c398a8273272aba034" name="ac84871bcca0aaa0176d43dbdbffe9a6cac26f15e86e3de4c398a8273272aba034"></a>Bool&#160;</td><td class="fielddoc"><p>A boolean value. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac84871bcca0aaa0176d43dbdbffe9a6ca27118326006d3829667a400ad23d5d98" name="ac84871bcca0aaa0176d43dbdbffe9a6ca27118326006d3829667a400ad23d5d98"></a>String&#160;</td><td class="fielddoc"><p>A string value. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="AsmState_8h_source.html#l00280">280</a> of file <a class="el" href="AsmState_8h_source.html">AsmState.h</a>.</p>

</div>
</div>
<a id="a2c02a386e5ba59c4c88f83ac471f999d" name="a2c02a386e5ba59c4c88f83ac471f999d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c02a386e5ba59c4c88f83ac471f999d">&#9670;&#160;</a></span>ChangeResult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a2c02a386e5ba59c4c88f83ac471f999d">mlir::ChangeResult</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A result type used to indicate if a change happened. </p>
<p>Boolean operations on <a class="el" href="#a2c02a386e5ba59c4c88f83ac471f999d" title="A result type used to indicate if a change happened.">ChangeResult</a> behave as though <span class="tt">Change</span> is truth. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2c02a386e5ba59c4c88f83ac471f999da4bac8cdf0a968472b519b3b295d0d48b" name="a2c02a386e5ba59c4c88f83ac471f999da4bac8cdf0a968472b519b3b295d0d48b"></a>NoChange&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2c02a386e5ba59c4c88f83ac471f999daf4ec5f57bd4d31b803312d873be40da9" name="a2c02a386e5ba59c4c88f83ac471f999daf4ec5f57bd4d31b803312d873be40da9"></a>Change&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="DataFlowFramework_8h_source.html#l00037">37</a> of file <a class="el" href="DataFlowFramework_8h_source.html">DataFlowFramework.h</a>.</p>

</div>
</div>
<a id="a98b49fcd2b613b6c30ffc13f35b8675c" name="a98b49fcd2b613b6c30ffc13f35b8675c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b49fcd2b613b6c30ffc13f35b8675c">&#9670;&#160;</a></span>DeletionKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a98b49fcd2b613b6c30ffc13f35b8675c">mlir::DeletionKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returned by operation promotion logic requesting the deletion of an operation. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a98b49fcd2b613b6c30ffc13f35b8675ca02bce93bff905887ad2233110bf9c49e" name="a98b49fcd2b613b6c30ffc13f35b8675ca02bce93bff905887ad2233110bf9c49e"></a>Keep&#160;</td><td class="fielddoc"><p>Keep the operation after promotion. </p>
</td></tr>
<tr><td class="fieldname"><a id="a98b49fcd2b613b6c30ffc13f35b8675caf2a6c498fb90ee345d997f888fce3b18" name="a98b49fcd2b613b6c30ffc13f35b8675caf2a6c498fb90ee345d997f888fce3b18"></a>Delete&#160;</td><td class="fielddoc"><p>Delete the operation after promotion. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="MemorySlotInterfaces_8h_source.html#l00035">35</a> of file <a class="el" href="MemorySlotInterfaces_8h_source.html">MemorySlotInterfaces.h</a>.</p>

</div>
</div>
<a id="a247bc9a6d1f1577f2d876cb55e2ea752" name="a247bc9a6d1f1577f2d876cb55e2ea752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247bc9a6d1f1577f2d876cb55e2ea752">&#9670;&#160;</a></span>DiagnosticSeverity</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a247bc9a6d1f1577f2d876cb55e2ea752">mlir::DiagnosticSeverity</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines the different supported severity of a diagnostic. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a247bc9a6d1f1577f2d876cb55e2ea752a3b0649c72650c313a357338dcdfb64ec" name="a247bc9a6d1f1577f2d876cb55e2ea752a3b0649c72650c313a357338dcdfb64ec"></a>Note&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a247bc9a6d1f1577f2d876cb55e2ea752a0eaadb4fcb48a0a0ed7bc9868be9fbaa" name="a247bc9a6d1f1577f2d876cb55e2ea752a0eaadb4fcb48a0a0ed7bc9868be9fbaa"></a>Warning&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a247bc9a6d1f1577f2d876cb55e2ea752a902b0d55fddef6f8d651fe1035b7d4bd" name="a247bc9a6d1f1577f2d876cb55e2ea752a902b0d55fddef6f8d651fe1035b7d4bd"></a>Error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a247bc9a6d1f1577f2d876cb55e2ea752a91921ada405fd6ba65dff028df047cb6" name="a247bc9a6d1f1577f2d876cb55e2ea752a91921ada405fd6ba65dff028df047cb6"></a>Remark&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00041">41</a> of file <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

</div>
</div>
<a id="acbb0dcd5ae75936e3c6f177223c9d5eb" name="acbb0dcd5ae75936e3c6f177223c9d5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb0dcd5ae75936e3c6f177223c9d5eb">&#9670;&#160;</a></span>GreedyRewriteStrictness</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#acbb0dcd5ae75936e3c6f177223c9d5eb">mlir::GreedyRewriteStrictness</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This enum controls which ops are put on the worklist during a greedy pattern rewrite. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acbb0dcd5ae75936e3c6f177223c9d5eba97d3def284d4e3d3bef99205c339fceb" name="acbb0dcd5ae75936e3c6f177223c9d5eba97d3def284d4e3d3bef99205c339fceb"></a>AnyOp&#160;</td><td class="fielddoc"><p>No restrictions wrt. which ops are processed. </p>
</td></tr>
<tr><td class="fieldname"><a id="acbb0dcd5ae75936e3c6f177223c9d5eba8fc95fc7cfbd316cce7d887ab38f6120" name="acbb0dcd5ae75936e3c6f177223c9d5eba8fc95fc7cfbd316cce7d887ab38f6120"></a>ExistingAndNewOps&#160;</td><td class="fielddoc"><p>Only pre-existing and newly created ops are processed. </p>
</td></tr>
<tr><td class="fieldname"><a id="acbb0dcd5ae75936e3c6f177223c9d5eba475f4ba4004dc37c3764009114b6e69b" name="acbb0dcd5ae75936e3c6f177223c9d5eba475f4ba4004dc37c3764009114b6e69b"></a>ExistingOps&#160;</td><td class="fielddoc"><p>Only pre-existing ops are processed. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00023">23</a> of file <a class="el" href="GreedyPatternRewriteDriver_8h_source.html">GreedyPatternRewriteDriver.h</a>.</p>

</div>
</div>
<a id="a2aef2e1e7dac5cf18273429ca58e3f4f" name="a2aef2e1e7dac5cf18273429ca58e3f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aef2e1e7dac5cf18273429ca58e3f4f">&#9670;&#160;</a></span>GreedySimplifyRegionLevel</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a2aef2e1e7dac5cf18273429ca58e3f4f">mlir::GreedySimplifyRegionLevel</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2aef2e1e7dac5cf18273429ca58e3f4fab9f5c797ebbf55adccdd8539a65a0241" name="a2aef2e1e7dac5cf18273429ca58e3f4fab9f5c797ebbf55adccdd8539a65a0241"></a>Disabled&#160;</td><td class="fielddoc"><p>Disable region control-flow simplification. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2aef2e1e7dac5cf18273429ca58e3f4fa960b44c579bc2f6818d2daaf9e4c16f0" name="a2aef2e1e7dac5cf18273429ca58e3f4fa960b44c579bc2f6818d2daaf9e4c16f0"></a>Normal&#160;</td><td class="fielddoc"><p>Run the normal simplification (e.g. dead args elimination). </p>
</td></tr>
<tr><td class="fieldname"><a id="a2aef2e1e7dac5cf18273429ca58e3f4fa389a96d0d9b3feb46b8c9d941566a4ae" name="a2aef2e1e7dac5cf18273429ca58e3f4fa389a96d0d9b3feb46b8c9d941566a4ae"></a>Aggressive&#160;</td><td class="fielddoc"><p>Run extra simplificiations (e.g. </p>
<p>block merging), these can be more costly or have some tradeoffs associated. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00032">32</a> of file <a class="el" href="GreedyPatternRewriteDriver_8h_source.html">GreedyPatternRewriteDriver.h</a>.</p>

</div>
</div>
<a id="a6e07796c43d9bdf22c519ff44150daaf" name="a6e07796c43d9bdf22c519ff44150daaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e07796c43d9bdf22c519ff44150daaf">&#9670;&#160;</a></span>HoistingKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a6e07796c43d9bdf22c519ff44150daaf">mlir::HoistingKind</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6e07796c43d9bdf22c519ff44150daafa6adf97f83acf6453d4a6a4b1070f3754" name="a6e07796c43d9bdf22c519ff44150daafa6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6e07796c43d9bdf22c519ff44150daafa89d7b10cb4238977d2b523dfd9ea7745" name="a6e07796c43d9bdf22c519ff44150daafa89d7b10cb4238977d2b523dfd9ea7745"></a>Loop&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6e07796c43d9bdf22c519ff44150daafae1e4c8c9ccd9fc39c391da4bcd093fb2" name="a6e07796c43d9bdf22c519ff44150daafae1e4c8c9ccd9fc39c391da4bcd093fb2"></a>Block&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="AllocationOpInterface_8h_source.html#l00021">21</a> of file <a class="el" href="AllocationOpInterface_8h_source.html">AllocationOpInterface.h</a>.</p>

</div>
</div>
<a id="a55d1372af4dad8c3d157071fd4dac5b9" name="a55d1372af4dad8c3d157071fd4dac5b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55d1372af4dad8c3d157071fd4dac5b9">&#9670;&#160;</a></span>OpAsmAliasResult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a55d1372af4dad8c3d157071fd4dac5b9">mlir::OpAsmAliasResult</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Holds the result of <span class="tt">OpAsm{<a class="el" href="classmlir_1_1Dialect.html" title="Dialects are groups of MLIR operations, types and attributes, as well as behavior associated with the...">Dialect</a>,Attr,<a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a>}Interface::getAlias</span> hook call. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a55d1372af4dad8c3d157071fd4dac5b9a92ce3d03f1b110bfae63c081b030b8f7" name="a55d1372af4dad8c3d157071fd4dac5b9a92ce3d03f1b110bfae63c081b030b8f7"></a>NoAlias&#160;</td><td class="fielddoc"><p>The object (type or attribute) is not supported by the hook and an alias was not provided. </p>
</td></tr>
<tr><td class="fieldname"><a id="a55d1372af4dad8c3d157071fd4dac5b9aa221ad4ed0fa4d0ef5a74117e307cee3" name="a55d1372af4dad8c3d157071fd4dac5b9aa221ad4ed0fa4d0ef5a74117e307cee3"></a>OverridableAlias&#160;</td><td class="fielddoc"><p>An alias was provided, but it might be overriden by other hook. </p>
</td></tr>
<tr><td class="fieldname"><a id="a55d1372af4dad8c3d157071fd4dac5b9a4c9f84774db087a01403961ca633e818" name="a55d1372af4dad8c3d157071fd4dac5b9a4c9f84774db087a01403961ca633e818"></a>FinalAlias&#160;</td><td class="fielddoc"><p>An alias was provided and it should be used (no other hooks will be checked). </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="OpAsmSupport_8h_source.html#l00039">39</a> of file <a class="el" href="OpAsmSupport_8h_source.html">OpAsmSupport.h</a>.</p>

</div>
</div>
<a id="ab64460ede39d8480e398fd2e6810d95b" name="ab64460ede39d8480e398fd2e6810d95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64460ede39d8480e398fd2e6810d95b">&#9670;&#160;</a></span>PassDisplayMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ab64460ede39d8480e398fd2e6810d95b">mlir::PassDisplayMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An enum describing the different display modes for the information within the pass manager. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab64460ede39d8480e398fd2e6810d95ba4ee29ca12c7d126654bd0e5275de6135" name="ab64460ede39d8480e398fd2e6810d95ba4ee29ca12c7d126654bd0e5275de6135"></a>List&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab64460ede39d8480e398fd2e6810d95baaeaeaec51b4e6b88122f10ad96a8de72" name="ab64460ede39d8480e398fd2e6810d95baaeaeaec51b4e6b88122f10ad96a8de72"></a>Pipeline&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="PassManager_8h_source.html#l00199">199</a> of file <a class="el" href="PassManager_8h_source.html">PassManager.h</a>.</p>

</div>
</div>
<a id="a0bb57d9710216d3da4406e58e4cbdfd9" name="a0bb57d9710216d3da4406e58e4cbdfd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb57d9710216d3da4406e58e4cbdfd9">&#9670;&#160;</a></span>ReductionTilingStrategy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a0bb57d9710216d3da4406e58e4cbdfd9">mlir::ReductionTilingStrategy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tiling can be thought of as splitting a dimension into 2 and materializing the outer dimension as a loop: </p>
<p>op[original] -&gt; op[original / x, x] -&gt; loop[original] { op[x] }</p>
<p>For parallel dimensions, the split can only happen in one way, with both dimensions being parallel. For reduction dimensions however, there is a choice in how we split the reduction dimension. This enum exposes this choice. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0bb57d9710216d3da4406e58e4cbdfd9abe3b9ba476420bd7d98de1a4560c2e3d" name="a0bb57d9710216d3da4406e58e4cbdfd9abe3b9ba476420bd7d98de1a4560c2e3d"></a>FullReduction&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0bb57d9710216d3da4406e58e4cbdfd9ad958073d66382f63955875a66feb4d79" name="a0bb57d9710216d3da4406e58e4cbdfd9ad958073d66382f63955875a66feb4d79"></a>PartialReductionOuterReduction&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0bb57d9710216d3da4406e58e4cbdfd9af8276115b49533f51a75db6c8e920131" name="a0bb57d9710216d3da4406e58e4cbdfd9af8276115b49533f51a75db6c8e920131"></a>PartialReductionOuterParallel&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="TilingInterface_8h_source.html#l00048">48</a> of file <a class="el" href="TilingInterface_8h_source.html">TilingInterface.h</a>.</p>

</div>
</div>
<a id="abeb30aa1b062bf437bf3ea2b843a2ae1" name="abeb30aa1b062bf437bf3ea2b843a2ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb30aa1b062bf437bf3ea2b843a2ae1">&#9670;&#160;</a></span>RegionKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#abeb30aa1b062bf437bf3ea2b843a2ae1">mlir::RegionKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The kinds of regions contained in an operation. </p>
<p>SSACFG regions require the SSA-Dominance property to hold. Graph regions do not require SSA-Dominance. If a registered operation does not implement RegionKindInterface, then any regions it contains are assumed to be SSACFG regions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abeb30aa1b062bf437bf3ea2b843a2ae1abfd486e5c2cad6a0ba13ec4e1951815b" name="abeb30aa1b062bf437bf3ea2b843a2ae1abfd486e5c2cad6a0ba13ec4e1951815b"></a>SSACFG&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abeb30aa1b062bf437bf3ea2b843a2ae1a4cdbd2bafa8193091ba09509cedf94fd" name="abeb30aa1b062bf437bf3ea2b843a2ae1a4cdbd2bafa8193091ba09509cedf94fd"></a>Graph&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="RegionKindInterface_8h_source.html#l00026">26</a> of file <a class="el" href="RegionKindInterface_8h_source.html">RegionKindInterface.h</a>.</p>

</div>
</div>
<a id="a855a7d93430958efaaf3a6f69e3dac1c" name="a855a7d93430958efaaf3a6f69e3dac1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a855a7d93430958efaaf3a6f69e3dac1c">&#9670;&#160;</a></span>ReinterpretMapScope</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a855a7d93430958efaaf3a6f69e3dac1c">mlir::ReinterpretMapScope</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a scope for reinterpret map pass. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a855a7d93430958efaaf3a6f69e3dac1ca34bdbffdb1c0e1b603f58fc0d49548b6" name="a855a7d93430958efaaf3a6f69e3dac1ca34bdbffdb1c0e1b603f58fc0d49548b6"></a>kAll&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a855a7d93430958efaaf3a6f69e3dac1cafb396f5b35d10c817b375435e3432d4b" name="a855a7d93430958efaaf3a6f69e3dac1cafb396f5b35d10c817b375435e3432d4b"></a>kGenericOnly&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a855a7d93430958efaaf3a6f69e3dac1ca301ae8b60ff2983a1038cc11eb53089b" name="a855a7d93430958efaaf3a6f69e3dac1ca301ae8b60ff2983a1038cc11eb53089b"></a>kExceptGeneric&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l00045">45</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ad02690ebf6873c0066aac73d59d62223" name="ad02690ebf6873c0066aac73d59d62223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02690ebf6873c0066aac73d59d62223">&#9670;&#160;</a></span>RemarkFormat</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ad02690ebf6873c0066aac73d59d62223">mlir::RemarkFormat</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad02690ebf6873c0066aac73d59d62223a8ea6f3827ed0a34fa051c86ca01e8bf9" name="ad02690ebf6873c0066aac73d59d62223a8ea6f3827ed0a34fa051c86ca01e8bf9"></a>REMARK_FORMAT_STDOUT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad02690ebf6873c0066aac73d59d62223a3df5f81f68717fe4c2b0053225ec049b" name="ad02690ebf6873c0066aac73d59d62223a3df5f81f68717fe4c2b0053225ec049b"></a>REMARK_FORMAT_YAML&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad02690ebf6873c0066aac73d59d62223afc3f17fe7a2d838c21158e7dc92e2255" name="ad02690ebf6873c0066aac73d59d62223afc3f17fe7a2d838c21158e7dc92e2255"></a>REMARK_FORMAT_BITSTREAM&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="MlirOptMain_8h_source.html#l00041">41</a> of file <a class="el" href="MlirOptMain_8h_source.html">MlirOptMain.h</a>.</p>

</div>
</div>
<a id="a9802f6b43ebc64a739e08653d0983fae" name="a9802f6b43ebc64a739e08653d0983fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9802f6b43ebc64a739e08653d0983fae">&#9670;&#160;</a></span>RemarkPolicy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a9802f6b43ebc64a739e08653d0983fae">mlir::RemarkPolicy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9802f6b43ebc64a739e08653d0983faea7a094fd32a6ba8c813c99a0f2e108cda" name="a9802f6b43ebc64a739e08653d0983faea7a094fd32a6ba8c813c99a0f2e108cda"></a>REMARK_POLICY_ALL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9802f6b43ebc64a739e08653d0983faea7fbcdd9fcd7740580ba374f06a947818" name="a9802f6b43ebc64a739e08653d0983faea7fbcdd9fcd7740580ba374f06a947818"></a>REMARK_POLICY_FINAL&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="MlirOptMain_8h_source.html#l00047">47</a> of file <a class="el" href="MlirOptMain_8h_source.html">MlirOptMain.h</a>.</p>

</div>
</div>
<a id="a11353e6611651b85531ad95629c57d75" name="a11353e6611651b85531ad95629c57d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11353e6611651b85531ad95629c57d75">&#9670;&#160;</a></span>SliceVerificationResult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a11353e6611651b85531ad95629c57d75">mlir::SliceVerificationResult</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum that captures information related to verifier error conditions on slice insert/extract type of ops. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a11353e6611651b85531ad95629c57d75a505a83f220c02df2f85c3810cd9ceb38" name="a11353e6611651b85531ad95629c57d75a505a83f220c02df2f85c3810cd9ceb38"></a>Success&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a11353e6611651b85531ad95629c57d75a780dd32ee9af184442cea3f2a2a75271" name="a11353e6611651b85531ad95629c57d75a780dd32ee9af184442cea3f2a2a75271"></a>RankTooLarge&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a11353e6611651b85531ad95629c57d75a87c69361ccd090c9c844e19d08432a26" name="a11353e6611651b85531ad95629c57d75a87c69361ccd090c9c844e19d08432a26"></a>SizeMismatch&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a11353e6611651b85531ad95629c57d75a6341e1bfc09d56fa49bb1b9400459d8e" name="a11353e6611651b85531ad95629c57d75a6341e1bfc09d56fa49bb1b9400459d8e"></a>ElemTypeMismatch&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a11353e6611651b85531ad95629c57d75a36a2220daadd84aaba239b031cf4cd23" name="a11353e6611651b85531ad95629c57d75a36a2220daadd84aaba239b031cf4cd23"></a>MemSpaceMismatch&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a11353e6611651b85531ad95629c57d75a36297823a9892f9936fba1805a1c52ca" name="a11353e6611651b85531ad95629c57d75a36297823a9892f9936fba1805a1c52ca"></a>LayoutMismatch&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00356">356</a> of file <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html">BuiltinTypes.h</a>.</p>

</div>
</div>
<a id="a90f3feaa61d2ade78f26489cc92061c9" name="a90f3feaa61d2ade78f26489cc92061c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f3feaa61d2ade78f26489cc92061c9">&#9670;&#160;</a></span>SparseEmitStrategy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a90f3feaa61d2ade78f26489cc92061c9">mlir::SparseEmitStrategy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a scope for reinterpret map pass. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a90f3feaa61d2ade78f26489cc92061c9a2396498c3d09ffee6d390b4dc4939025" name="a90f3feaa61d2ade78f26489cc92061c9a2396498c3d09ffee6d390b4dc4939025"></a>kFunctional&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a90f3feaa61d2ade78f26489cc92061c9a6a8bfeffa090dea6b9365e13b07de8f5" name="a90f3feaa61d2ade78f26489cc92061c9a6a8bfeffa090dea6b9365e13b07de8f5"></a>kSparseIterator&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a90f3feaa61d2ade78f26489cc92061c9a1f8ee8266ac6831bf04f91a30d755554" name="a90f3feaa61d2ade78f26489cc92061c9a1f8ee8266ac6831bf04f91a30d755554"></a>kDebugInterface&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l00052">52</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a781474aef998ccce168b69ae973cd832" name="a781474aef998ccce168b69ae973cd832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781474aef998ccce168b69ae973cd832">&#9670;&#160;</a></span>SparseParallelizationStrategy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a781474aef998ccce168b69ae973cd832">mlir::SparseParallelizationStrategy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a parallelization strategy. </p>
<p>Any independent loop is a candidate for parallelization. The loop is made parallel if (1) allowed by the strategy (e.g., AnyStorageOuterLoop considers either a dense or sparse outermost loop only), and (2) the generated code is an actual for-loop (and not a co-iterating while-loop). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a781474aef998ccce168b69ae973cd832a35c3ace1970663a16e5c65baa5941b13" name="a781474aef998ccce168b69ae973cd832a35c3ace1970663a16e5c65baa5941b13"></a>kNone&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a781474aef998ccce168b69ae973cd832a09e4a3d1c3e70c9426528f102480e6e7" name="a781474aef998ccce168b69ae973cd832a09e4a3d1c3e70c9426528f102480e6e7"></a>kDenseOuterLoop&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a781474aef998ccce168b69ae973cd832afe3590ad05890d8754eef93504f9b7af" name="a781474aef998ccce168b69ae973cd832afe3590ad05890d8754eef93504f9b7af"></a>kAnyStorageOuterLoop&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a781474aef998ccce168b69ae973cd832a0d7778373362fd80feddcb9b38a354b8" name="a781474aef998ccce168b69ae973cd832a0d7778373362fd80feddcb9b38a354b8"></a>kDenseAnyLoop&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a781474aef998ccce168b69ae973cd832a3b1257bf6747bc07f90c215e9aafd4a7" name="a781474aef998ccce168b69ae973cd832a3b1257bf6747bc07f90c215e9aafd4a7"></a>kAnyStorageAnyLoop&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l00036">36</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a399e164b35d18e1a77053d39719844de" name="a399e164b35d18e1a77053d39719844de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399e164b35d18e1a77053d39719844de">&#9670;&#160;</a></span>SPIRVSubByteTypeStorage</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a399e164b35d18e1a77053d39719844de">mlir::SPIRVSubByteTypeStorage</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>How sub-byte values are storaged in memory. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a399e164b35d18e1a77053d39719844deaa1977c3f68d4d3bbfe14d0e51a575482" name="a399e164b35d18e1a77053d39719844deaa1977c3f68d4d3bbfe14d0e51a575482"></a>Packed&#160;</td><td class="fielddoc"><p>Sub-byte values are tightly packed without any padding, e.g., 4xi2 -&gt; i8. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SPIRVConversion_8h_source.html#l00033">33</a> of file <a class="el" href="SPIRVConversion_8h_source.html">SPIRVConversion.h</a>.</p>

</div>
</div>
<a id="a9e4d5a3d224089fd8a2ebc3e933d08b5" name="a9e4d5a3d224089fd8a2ebc3e933d08b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4d5a3d224089fd8a2ebc3e933d08b5">&#9670;&#160;</a></span>TraversalMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a9e4d5a3d224089fd8a2ebc3e933d08b5">mlir::TraversalMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the traversal method options to be used in the reduction tree traversal. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9e4d5a3d224089fd8a2ebc3e933d08b5ab8166871d66f03feaa6948b3f5727c96" name="a9e4d5a3d224089fd8a2ebc3e933d08b5ab8166871d66f03feaa6948b3f5727c96"></a>SinglePath&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9e4d5a3d224089fd8a2ebc3e933d08b5ad4f6ed581fb2f9d06c062711e30c13e1" name="a9e4d5a3d224089fd8a2ebc3e933d08b5ad4f6ed581fb2f9d06c062711e30c13e1"></a>Backtrack&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9e4d5a3d224089fd8a2ebc3e933d08b5a9addc7d66f740728689b7f9abde66593" name="a9e4d5a3d224089fd8a2ebc3e933d08b5a9addc7d66f740728689b7f9abde66593"></a>MultiPath&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ReductionNode_8h_source.html#l00036">36</a> of file <a class="el" href="ReductionNode_8h_source.html">ReductionNode.h</a>.</p>

</div>
</div>
<a id="adb385bc41aa87d4559359aa7efec524f" name="adb385bc41aa87d4559359aa7efec524f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb385bc41aa87d4559359aa7efec524f">&#9670;&#160;</a></span>VerbosityLevel</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#adb385bc41aa87d4559359aa7efec524f">mlir::VerbosityLevel</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>enum class to indicate the verbosity level of the diagnostic filter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adb385bc41aa87d4559359aa7efec524fae0a1284706116eec7a83a489235a9ef8" name="adb385bc41aa87d4559359aa7efec524fae0a1284706116eec7a83a489235a9ef8"></a>ErrorsOnly&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="adb385bc41aa87d4559359aa7efec524fac166edba58858c1730219873adabaf12" name="adb385bc41aa87d4559359aa7efec524fac166edba58858c1730219873adabaf12"></a>ErrorsAndWarnings&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="adb385bc41aa87d4559359aa7efec524faaae8c58527eab9879bef2accec35ce55" name="adb385bc41aa87d4559359aa7efec524faaae8c58527eab9879bef2accec35ce55"></a>ErrorsWarningsAndRemarks&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="MlirOptMain_8h_source.html#l00035">35</a> of file <a class="el" href="MlirOptMain_8h_source.html">MlirOptMain.h</a>.</p>

</div>
</div>
<a id="a59fa9dd53c74f1ca73aa7ef263c94adc" name="a59fa9dd53c74f1ca73aa7ef263c94adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59fa9dd53c74f1ca73aa7ef263c94adc">&#9670;&#160;</a></span>WalkOrder</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a59fa9dd53c74f1ca73aa7ef263c94adc">mlir::WalkOrder</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traversal order for region, block and operation walk utilities. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a59fa9dd53c74f1ca73aa7ef263c94adca622a0c108b4c33e1cc5ed8a22db11cbc" name="a59fa9dd53c74f1ca73aa7ef263c94adca622a0c108b4c33e1cc5ed8a22db11cbc"></a>PreOrder&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a59fa9dd53c74f1ca73aa7ef263c94adca22e80e4e88a340d28d3f27ee3d9d7163" name="a59fa9dd53c74f1ca73aa7ef263c94adca22e80e4e88a340d28d3f27ee3d9d7163"></a>PostOrder&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00028">28</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a51a6eaafe741bc1b5aaef4e3e188e868" name="a51a6eaafe741bc1b5aaef4e3e188e868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a6eaafe741bc1b5aaef4e3e188e868">&#9670;&#160;</a></span>addressSpaceToStorageClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spirv::StorageClass mlir::addressSpaceToStorageClass </td>
          <td>(</td>
          <td class="paramtype">gpu::AddressSpace</td>          <td class="paramname"><span class="paramname"><em>addressSpace</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AttrToSPIRVConverter_8cpp_source.html#l00012">12</a> of file <a class="el" href="AttrToSPIRVConverter_8cpp_source.html">AttrToSPIRVConverter.cpp</a>.</p>

</div>
</div>
<a id="a5bcc9dc786aa8f64a60f1d51cdad3361" name="a5bcc9dc786aa8f64a60f1d51cdad3361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bcc9dc786aa8f64a60f1d51cdad3361">&#9670;&#160;</a></span>alignAffineMapWithValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::alignAffineMapWithValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>operands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>dims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>syms</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>newSyms</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-indexes the dimensions and symbols of an affine map with given <span class="tt">operands</span> values to align with <span class="tt">dims</span> and <span class="tt">syms</span> values. </p>
<p>Each dimension/symbol of the map, bound to an operand <span class="tt">o</span>, is replaced with dimension <span class="tt">i</span>, where <span class="tt">i</span> is the position of <span class="tt">o</span> within <span class="tt">dims</span>. If <span class="tt">o</span> is not in <span class="tt">dims</span>, replace it with symbol <span class="tt">i</span>, where <span class="tt">i</span> is the position of <span class="tt">o</span> within <span class="tt">syms</span>. If <span class="tt">o</span> is not in <span class="tt">syms</span> either, replace it with a new symbol.</p>
<p>Note: If a value appears multiple times as a dimension/symbol (or both), all corresponding dim/sym expressions are replaced with the first dimension bound to that value (or first symbol if no such dimension exists).</p>
<p>The resulting affine map has <span class="tt">dims.size()</span> many dimensions and at least <span class="tt">syms.size()</span> many symbols.</p>
<p>The SSA values of the symbols of the resulting map are optionally returned via <span class="tt">newSyms</span>. This is a concatenation of <span class="tt">syms</span> with the SSA values of the newly added symbols.</p>
<p>Note: As part of this re-indexing, dimensions may turn into symbols, or vice versa. </p>

<p class="definition">Definition at line <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01517">1517</a> of file <a class="el" href="FlatLinearValueConstraints_8cpp_source.html">FlatLinearValueConstraints.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00364">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="Builders_8cpp_source.html#l00368">mlir::Builder::getAffineSymbolExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00496">mlir::AffineMap::replaceDimsAndSymbols()</a>, and <a class="el" href="LoopUtils_8cpp.html#af34d730a7920f1ae277f8c166146132d">replacement()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02226">alignAndAddBound()</a>, and <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01397">mlir::FlatLinearValueConstraints::computeAlignedMap()</a>.</p>

</div>
</div>
<a id="aaf43b39cbc5116796f9b6550f99dee0d" name="aaf43b39cbc5116796f9b6550f99dee0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf43b39cbc5116796f9b6550f99dee0d">&#9670;&#160;</a></span>allOperandsHaveSameCoopMatrixType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::allOperandsHaveSameCoopMatrixType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>operands</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="WmmaOpsToSPIRV_8cpp_source.html#l00085">85</a> of file <a class="el" href="WmmaOpsToSPIRV_8cpp_source.html">WmmaOpsToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, and <a class="el" href="classmlir_1_1ValueRange.html#aafdd7203c9b5d449b1b1a3b647845cf2">mlir::ValueRange::getType()</a>.</p>

</div>
</div>
<a id="ab41920e66a206248f862766a705125d1" name="ab41920e66a206248f862766a705125d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41920e66a206248f862766a705125d1">&#9670;&#160;</a></span>applyDefaultTimingManagerCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::applyDefaultTimingManagerCLOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DefaultTimingManager.html">DefaultTimingManager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tm</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply any values that were registered with 'registerDefaultTimingManagerOptions' to a <span class="tt"><a class="el" href="classmlir_1_1DefaultTimingManager.html" title="Facilities for time measurement and report printing to an output stream.">DefaultTimingManager</a></span>. </p>

<p class="definition">Definition at line <a class="el" href="Timing_8cpp_source.html#l00617">617</a> of file <a class="el" href="Timing_8cpp_source.html">Timing.cpp</a>.</p>

<p class="reference">References <a class="el" href="Timing_8cpp_source.html#l00626">createOutputStrategy()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="Timing_8cpp_source.html#l00514">mlir::DefaultTimingManager::setDisplayMode()</a>, <a class="el" href="Timing_8cpp_source.html#l00508">mlir::DefaultTimingManager::setEnabled()</a>, and <a class="el" href="Timing_8cpp_source.html#l00524">mlir::DefaultTimingManager::setOutput()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PassManagerOptions_8cpp_source.html#l00178">applyDefaultTimingPassManagerCLOptions()</a>, and <a class="el" href="MlirOptMain_8cpp_source.html#l00496">performActions()</a>.</p>

</div>
</div>
<a id="acd78ebb9f95cfe7ea3856d9f9c46d030" name="acd78ebb9f95cfe7ea3856d9f9c46d030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd78ebb9f95cfe7ea3856d9f9c46d030">&#9670;&#160;</a></span>applyDefaultTimingPassManagerCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::applyDefaultTimingPassManagerCLOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PassManager.html">PassManager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pm</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply any values provided to the timing manager options that were registered with <span class="tt">registerDefaultTimingManagerOptions</span>. </p>
<p>This is a handy helper function if you do not want to bother creating your own timing manager and passing it to the pass manager. </p>

<p class="definition">Definition at line <a class="el" href="PassManagerOptions_8cpp_source.html#l00178">178</a> of file <a class="el" href="PassManagerOptions_8cpp_source.html">PassManagerOptions.cpp</a>.</p>

<p class="reference">References <a class="el" href="Timing_8cpp_source.html#l00617">applyDefaultTimingManagerCLOptions()</a>, and <a class="el" href="PassTiming_8cpp_source.html#l00147">mlir::PassManager::enableTiming()</a>.</p>

</div>
</div>
<a id="a66e5c50eb8b1daecc9b2ac2f97681685" name="a66e5c50eb8b1daecc9b2ac2f97681685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e5c50eb8b1daecc9b2ac2f97681685">&#9670;&#160;</a></span>applyOpPatternsGreedily()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::applyOpPatternsGreedily </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>ops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a></td>          <td class="paramname"><span class="paramname"><em>config</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> *</td>          <td class="paramname"><span class="paramname"><em>changed</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> *</td>          <td class="paramname"><span class="paramname"><em>allErased</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite the specified ops by repeatedly applying the highest benefit patterns in a greedy worklist driven manner until a fixpoint is reached. </p>
<p>The greedy rewrite may prematurely stop after a maximum number of iterations, which can be configured in the configuration parameter.</p>
<p>Also performs simple dead-code elimination before attempting to match any of the provided patterns.</p>
<p>Newly created ops and other pre-existing ops that use results of rewritten ops or supply operands to such ops are also processed, unless such ops are excluded via <span class="tt">config.strictMode</span>. Any other ops remain unmodified (i.e., regardless of <span class="tt">strictMode</span>).</p>
<p>In addition to strictness, a region scope can be specified. Only ops within the scope are simplified. This is similar to <span class="tt">applyPatternsGreedily</span>, where only ops within the given region/op are simplified by default. If no scope is specified, it is assumed to be the first common enclosing region of the given ops.</p>
<p>Note that ops in <span class="tt">ops</span> could be erased as result of folding, becoming dead, or via pattern rewrites. If more far reaching simplification is desired, <span class="tt">applyPatternsGreedily</span> should be used.</p>
<p>Returns "success" if the iterative process converged (i.e., fixpoint was reached) and no more patterns can be matched. <span class="tt">changed</span> is set to "true" if the IR was modified at all. <span class="tt">allOpsErased</span> is set to "true" if all ops in <span class="tt">ops</span> were erased. </p>

<p class="definition">Definition at line <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l01030">1030</a> of file <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html">GreedyPatternRewriteDriver.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00285">changed</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00284">config</a>, <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00037">findAncestorOpInRegion()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l01005">findCommonAncestor()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>, <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, and <a class="el" href="Verifier_8cpp_source.html#l00423">verify()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00230">mlir::affine::affineForOpBodySkew()</a>, <a class="el" href="ReductionTreePass_8cpp_source.html#l00038">applyPatterns()</a>, and <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l00149">mlir::affine::simplifyAffineMinMaxOps()</a>.</p>

</div>
</div>
<a id="a133398d008de5837d6df9b322b62f5f6" name="a133398d008de5837d6df9b322b62f5f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133398d008de5837d6df9b322b62f5f6">&#9670;&#160;</a></span>applyPassManagerCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::applyPassManagerCLOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PassManager.html">PassManager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pm</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply any values provided to the pass manager options that were registered with 'registerPassManagerOptions'. </p>

<p class="definition">Definition at line <a class="el" href="PassManagerOptions_8cpp_source.html#l00145">145</a> of file <a class="el" href="PassManagerOptions_8cpp_source.html">PassManagerOptions.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00332">emitError()</a>, <a class="el" href="PassCrashRecovery_8cpp_source.html#l00466">mlir::PassManager::enableCrashReproducerGeneration()</a>, <a class="el" href="PassStatistics_8cpp_source.html#l00250">mlir::PassManager::enableStatistics()</a>, <a class="el" href="PassManager_8h_source.html#l00257">mlir::PassManager::getContext()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00597">mlir::MLIRContext::isMultithreadingEnabled()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00496">performActions()</a>.</p>

</div>
</div>
<a id="a7b83dd66e74f4184340fe7684edaf070" name="a7b83dd66e74f4184340fe7684edaf070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b83dd66e74f4184340fe7684edaf070">&#9670;&#160;</a></span>applyPatternsAndFoldGreedily() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::applyPatternsAndFoldGreedily </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a></td>          <td class="paramname"><span class="paramname"><em>config</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> *</td>          <td class="paramname"><span class="paramname"><em>changed</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <span class="tt">applyPatternsGreedily</span> above with folding. </p>
<p>FIXME: Remove this once transition to above is complieted. </p>

<p class="definition">Definition at line <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00236">236</a> of file <a class="el" href="GreedyPatternRewriteDriver_8h_source.html">GreedyPatternRewriteDriver.h</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00184">applyPatternsAndFoldGreedily()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00913">applyPatternsGreedily()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00285">changed</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00284">config</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a98d1a56c5c6dd1c979fb0b0b9abf705f" name="a98d1a56c5c6dd1c979fb0b0b9abf705f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d1a56c5c6dd1c979fb0b0b9abf705f">&#9670;&#160;</a></span>applyPatternsAndFoldGreedily() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::applyPatternsAndFoldGreedily </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>region</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a></td>          <td class="paramname"><span class="paramname"><em>config</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> *</td>          <td class="paramname"><span class="paramname"><em>changed</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <span class="tt">applyPatternsAndGreedily</span> above with folding. </p>
<p>FIXME: Remove this once transition to above is completed. </p>

<p class="definition">Definition at line <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00184">184</a> of file <a class="el" href="GreedyPatternRewriteDriver_8h_source.html">GreedyPatternRewriteDriver.h</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00184">applyPatternsAndFoldGreedily()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00913">applyPatternsGreedily()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00285">changed</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00284">config</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00236">applyPatternsAndFoldGreedily()</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00184">applyPatternsAndFoldGreedily()</a>.</p>

</div>
</div>
<a id="ae3b3798b1636be2aed89590adbb9a4e3" name="ae3b3798b1636be2aed89590adbb9a4e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3b3798b1636be2aed89590adbb9a4e3">&#9670;&#160;</a></span>applyPatternsGreedily() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::applyPatternsGreedily </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a></td>          <td class="paramname"><span class="paramname"><em>config</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> *</td>          <td class="paramname"><span class="paramname"><em>changed</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rewrite ops nested under the given operation, which must be isolated from above, by repeatedly applying the highest benefit patterns in a greedy worklist driven manner until a fixpoint is reached. </p>
<p>The greedy rewrite may prematurely stop after a maximum number of iterations, which can be configured in the configuration parameter.</p>
<p>Also performs simple dead-code elimination before attempting to match any of the provided patterns.</p>
<p>This overload runs a separate greedy rewrite for each region of the specified op. A region scope can be set in the configuration parameter. By default, the scope is set to the region of the current greedy rewrite. Only in-scope ops are added to the worklist and only in-scope ops and the specified op itself are allowed to be modified by the patterns.</p>
<p>Note: The specified op may be modified, but it may not be removed by the patterns.</p>
<p>Returns "success" if the iterative process converged (i.e., fixpoint was reached) and no more patterns can be matched within the region. <span class="tt">changed</span> is set to "true" if the IR was modified at all.</p>
<p>Note: This method does not apply patterns to the given operation itself. </p>

<p class="definition">Definition at line <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00217">217</a> of file <a class="el" href="GreedyPatternRewriteDriver_8h_source.html">GreedyPatternRewriteDriver.h</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00913">applyPatternsGreedily()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00285">changed</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00284">config</a>, <a class="el" href="IR_2Operation_8h_source.html#l00677">mlir::Operation::getRegions()</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a40136aee562026e1f4503e32fb71fa2d" name="a40136aee562026e1f4503e32fb71fa2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40136aee562026e1f4503e32fb71fa2d">&#9670;&#160;</a></span>applyPatternsGreedily() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::applyPatternsGreedily </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>region</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a></td>          <td class="paramname"><span class="paramname"><em>config</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> *</td>          <td class="paramname"><span class="paramname"><em>changed</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite ops in the given region, which must be isolated from above, by repeatedly applying the highest benefit patterns in a greedy worklist driven manner until a fixpoint is reached. </p>
<p>The greedy rewrite may prematurely stop after a maximum number of iterations, which can be configured in the configuration parameter.</p>
<p>Also performs simple dead-code elimination before attempting to match any of the provided patterns.</p>
<p>A region scope can be set in the configuration parameter. By default, the scope is set to the specified region. Only in-scope ops are added to the worklist and only in-scope ops are allowed to be modified by the patterns.</p>
<p>Returns "success" if the iterative process converged (i.e., fixpoint was reached) and no more patterns can be matched within the region. <span class="tt">changed</span> is set to "true" if the IR was modified at all.</p>
<p>Note: This method does not apply patterns to the region's parent operation. </p>

<p class="definition">Definition at line <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00913">913</a> of file <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html">GreedyPatternRewriteDriver.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00285">changed</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00284">config</a>, <a class="el" href="IR_2Region_8cpp_source.html#l00024">mlir::Region::getContext()</a>, <a class="el" href="IR_2Region_8h_source.html#l00200">mlir::Region::getParentOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00749">mlir::Operation::hasTrait()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>, and <a class="el" href="Verifier_8cpp_source.html#l00423">verify()</a>.</p>

<p class="reference">Referenced by <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00236">applyPatternsAndFoldGreedily()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00184">applyPatternsAndFoldGreedily()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00217">applyPatternsGreedily()</a>, <a class="el" href="MaskedloadToLoad_8cpp_source.html#l00249">mlir::amdgpu::impl::AmdgpuMaskedloadToLoadPassBase&lt; DerivedT &gt;::createAmdgpuMaskedloadToLoadPass</a>, <a class="el" href="CAPI_2Transforms_2Rewrite_8cpp_source.html#l00286">mlirApplyPatternsAndFoldGreedily()</a>, <a class="el" href="CAPI_2Transforms_2Rewrite_8cpp_source.html#l00293">mlirApplyPatternsAndFoldGreedilyWithOp()</a>, <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l00241">SimplifyAffineMinMaxPass::runOnOperation()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l01491">mlir::spirv::unrollVectorsInFuncBodies()</a>, and <a class="el" href="SPIRVConversion_8cpp_source.html#l01478">mlir::spirv::unrollVectorsInSignatures()</a>.</p>

</div>
</div>
<a id="a3f2a0eb3232125bb6fa1a65302b8285d" name="a3f2a0eb3232125bb6fa1a65302b8285d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f2a0eb3232125bb6fa1a65302b8285d">&#9670;&#160;</a></span>applyPermutation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; T &gt; mlir::applyPermutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>permutation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8h_source.html#l00201">201</a> of file <a class="el" href="IndexingUtils_8h_source.html">IndexingUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IndexingUtils_8h_source.html#l00215">applyPermutation()</a>, <a class="el" href="IndexingUtils_8h_source.html#l00226">applyPermutationToVector()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00368">mlir::detail::TileOffsetRangeImpl::getDynamicTileOffsets()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00360">mlir::detail::TileOffsetRangeImpl::getStaticTileOffsets()</a>, and <a class="el" href="LinalgOps_8cpp_source.html#l02134">SwapTransposeWithBroadcast::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="aa0b287d644de3e87a4f3e1d7cf31bd5a" name="aa0b287d644de3e87a4f3e1d7cf31bd5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b287d644de3e87a4f3e1d7cf31bd5a">&#9670;&#160;</a></span>applyPermutation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; T &gt; mlir::applyPermutation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>permutation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8h_source.html#l00215">215</a> of file <a class="el" href="IndexingUtils_8h_source.html">IndexingUtils.h</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8h_source.html#l00201">applyPermutation()</a>.</p>

</div>
</div>
<a id="abf34b5ae79f6561558887f2dd8254f94" name="abf34b5ae79f6561558887f2dd8254f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf34b5ae79f6561558887f2dd8254f94">&#9670;&#160;</a></span>applyPermutationMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; T &gt; mlir::applyPermutationMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a permutation from <span class="tt">map</span> to <span class="tt">source</span> and return the result. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00675">675</a> of file <a class="el" href="mlir_2IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00611">mlir::AffineMap::isProjectedPermutation()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l00239">VectorizationState::getCanonicalVecType()</a>, <a class="el" href="VectorOps_8cpp_source.html#l04823">mlir::vector::inferTransferOpMaskType()</a>, and <a class="el" href="MemRefOps_8cpp_source.html#l03543">inferTransposeResultType()</a>.</p>

</div>
</div>
<a id="adbcff71555e8c1965e508f324f43a55a" name="adbcff71555e8c1965e508f324f43a55a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbcff71555e8c1965e508f324f43a55a">&#9670;&#160;</a></span>applyPermutationToVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, <a class="el" href="classunsigned.html">unsigned</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::applyPermutationToVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; T, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>inVec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>permutation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the permutation defined by <span class="tt">permutation</span> to <span class="tt">inVec</span>. </p>
<p>Element <span class="tt">i</span> in <span class="tt">inVec</span> is mapped to location <span class="tt">j = permutation[i]</span>. E.g.: for an input vector &lsquo;inVec = ['a&rsquo;, 'b', 'c']<span class="tt"> and a permutation
    vector </span>permutation = [2, 0, 1]<span class="tt">, this function leaves </span>inVec = ['c', 'a', / 'b']`. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8h_source.html#l00226">226</a> of file <a class="el" href="IndexingUtils_8h_source.html">IndexingUtils.h</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8h_source.html#l00201">applyPermutation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgOps_8cpp_source.html#l05189">mlir::linalg::commonPermutationOfPackAndUnPackOp()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00150">computePackUnPackPerm()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00076">mlir::tensor::computeTransposedType()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l04961">mlir::linalg::getPackedOuterShapeWithoutTransposition()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l05392">mlir::linalg::getPackOpResultTypeShape()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01096">getPackUnpackRankReducedPerm()</a>, <a class="el" href="Interchange_8cpp_source.html#l00045">mlir::linalg::interchangeGenericOp()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00217">mlir::linalg::lowerPack()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00345">mlir::linalg::lowerUnPack()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01271">mlir::linalg::DecomposeOuterUnitDimsUnPackOpPattern::matchAndRewrite()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00598">permuteShape()</a>, <a class="el" href="Tiling_8cpp_source.html#l00433">tileLinalgOpImpl()</a>, and <a class="el" href="IndexingUtils_8cpp_source.html#l00340">mlir::detail::TileOffsetRangeImpl::TileOffsetRangeImpl()</a>.</p>

</div>
</div>
<a id="a2d5371859b520e2bba7334d675f9cad8" name="a2d5371859b520e2bba7334d675f9cad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5371859b520e2bba7334d675f9cad8">&#9670;&#160;</a></span>areAllConstantIntValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::areAllConstantIntValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>ofrs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if all of <span class="tt">ofrs</span> are constant integers equal to <span class="tt">value</span>. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00159">159</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00155">isConstantIntValue()</a>.</p>

</div>
</div>
<a id="a0bd3fa6148f71be3287a672b843f55f1" name="a0bd3fa6148f71be3287a672b843f55f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd3fa6148f71be3287a672b843f55f1">&#9670;&#160;</a></span>areConstantIntValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::areConstantIntValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>ofrs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if all of <span class="tt">ofrs</span> are constant integers equal to the corresponding value in <span class="tt">values</span>. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00164">164</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00142">getConstantIntValues()</a>.</p>

</div>
</div>
<a id="ac680df79552c596c048cd9cb27638c5f" name="ac680df79552c596c048cd9cb27638c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac680df79552c596c048cd9cb27638c5f">&#9670;&#160;</a></span>areValuesDefinedAbove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="structmlir_1_1Range.html">Range</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::areValuesDefinedAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Range.html">Range</a></td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>limit</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if all values in the provided range are defined above the <span class="tt">limit</span> region. </p>
<p>That is, if they are defined in a region that is a proper ancestor of <span class="tt">limit</span>. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8h_source.html#l00026">26</a> of file <a class="el" href="RegionUtils_8h_source.html">RegionUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCFToGPU_8cpp_source.html#l00109">checkAffineLoopNestMappableImpl()</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00994">coalescePerfectlyNestedSCFForLoops()</a>.</p>

</div>
</div>
<a id="a3d1168f4877a1008569deabfdab07fbb" name="a3d1168f4877a1008569deabfdab07fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1168f4877a1008569deabfdab07fbb">&#9670;&#160;</a></span>asMainReturnCode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mlir::asMainReturnCode </td>
          <td>(</td>
          <td class="paramtype">LogicalResult</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper wrapper to return the result of MlirOptMain directly from main. </p>
<p>Example: </p><pre class="fragment">int main(int argc, char **argv) {
  // ...
  return mlir::asMainReturnCode(mlir::MlirOptMain(
      argc, argv, /* ... *&amp;zwj;/);
}
</pre> 
<p class="definition">Definition at line <a class="el" href="MlirOptMain_8h_source.html#l00421">421</a> of file <a class="el" href="MlirOptMain_8h_source.html">MlirOptMain.h</a>.</p>

</div>
</div>
<a id="a0b57be921931a80cdd8e7b0f96fc6e9f" name="a0b57be921931a80cdd8e7b0f96fc6e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b57be921931a80cdd8e7b0f96fc6e9f">&#9670;&#160;</a></span>barePtrFuncArgTypeConverter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::barePtrFuncArgTypeConverter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to convert function argument types. </p>
<p>It converts MemRef function arguments to bare pointers to the MemRef element type. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00826">826</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8cpp_source.html#l00662">mlir::LLVMTypeConverter::convertCallingConventionType()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

</div>
</div>
<a id="a3d147ba82716614172eb7e9b5209d3eb" name="a3d147ba82716614172eb7e9b5209d3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d147ba82716614172eb7e9b5209d3eb">&#9670;&#160;</a></span>bindDims()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... AffineExprTy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::bindDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineExprTy &amp;...</td>          <td class="paramname"><span class="paramname"><em>exprs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a list of <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> references to DimExpr at positions: [0 . </p>
<p>. sizeof...(exprs)] </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">311</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00289">mlir::detail::bindDims()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00088">mlir::tensor::bubbleUpPadSlice()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00080">buildLinearId()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00518">buildLoopIterationCount()</a>, <a class="el" href="Tiling_8cpp_source.html#l00362">calculateTileOffsetsAndSizes()</a>, <a class="el" href="PadTilingInterface_8cpp_source.html#l00099">mlir::linalg::computePaddedShape()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01891">mlir::linalg::computeSliceParameters()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00072">contractSupportsMMAMatrixType()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00023">mlir::tensor::createPadHighOp()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00749">denormalizeInductionVariableForIndexType()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l03788">denormalizeIndVar()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00237">getBoundedTileSize()</a>, <a class="el" href="ReshapePatterns_8cpp_source.html#l00462">mlir::tensor::getCollapsedExtractSliceInfo()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00058">mlir::linalg::getConvolvedExpr()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00474">getTileOffsetAndSizesWithForAllOp()</a>, <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00032">invertSliceIndexing()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00217">mlir::linalg::lowerPack()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01736">CanonicalizeContractMatmulToMMT::matchAndRewrite()</a>, <a class="el" href="MultiBuffer_8cpp_source.html#l00082">mlir::memref::multiBuffer()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l02155">mlir::linalg::offsetIndices()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00748">mlir::linalg::packMatmulGreedily()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00416">mlir::linalg::rewriteInIm2Col()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00550">mlir::linalg::rewriteInIm2Col()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00123">mlir::linalg::rewriteInIm2Col()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00260">mlir::linalg::rewriteInIm2Col()</a>, <a class="el" href="Split_8cpp_source.html#l00067">mlir::linalg::splitOp()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01677">mlir::linalg::updateBoundsForCyclicDistribution()</a>, and <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00730">updateExpandedGenericOpRegion()</a>.</p>

</div>
</div>
<a id="a2c870d90073423151a32e2c0f2afa506" name="a2c870d90073423151a32e2c0f2afa506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c870d90073423151a32e2c0f2afa506">&#9670;&#160;</a></span>bindDimsList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AffineExprTy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::bindDimsList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineExprTy &gt;</td>          <td class="paramname"><span class="paramname"><em>exprs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00316">316</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">References <a class="el" href="#addfd4323ef72147332661606b030d04d">getAffineDimExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PadTilingInterface_8cpp_source.html#l00099">mlir::linalg::computePaddedShape()</a>.</p>

</div>
</div>
<a id="a8df39b3ef750e258dbe3dfe5b251cea5" name="a8df39b3ef750e258dbe3dfe5b251cea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df39b3ef750e258dbe3dfe5b251cea5">&#9670;&#160;</a></span>bindSymbols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... AffineExprTy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::bindSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineExprTy &amp;...</td>          <td class="paramname"><span class="paramname"><em>exprs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a list of <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> references to SymbolExpr at positions: [0 . </p>
<p>. sizeof...(exprs)] </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">325</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00298">mlir::detail::bindSymbols()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00080">buildLinearId()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00518">buildLoopIterationCount()</a>, <a class="el" href="Tiling_8cpp_source.html#l00362">calculateTileOffsetsAndSizes()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01954">composedAffineMultiply()</a>, <a class="el" href="PadTilingInterface_8cpp_source.html#l00099">mlir::linalg::computePaddedShape()</a>, <a class="el" href="MemRefUtils_8cpp_source.html#l00175">mlir::memref::computeSuffixProductIRBlockImpl()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00726">createInitialTensorsForTiling()</a>, <a class="el" href="DistributionUtils_8cpp_source.html#l00104">mlir::gpu::WarpDistributionPattern::delinearizeLaneId()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00749">denormalizeInductionVariableForIndexType()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l03788">denormalizeIndVar()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00688">emitNormalizedLoopBoundsForIndexType()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00237">getBoundedTileSize()</a>, <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00078">getCompressedMaskOp()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00058">mlir::linalg::getConvolvedExpr()</a>, <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00128">getIndicesForLoadOrStore()</a>, <a class="el" href="MemRefUtils_8cpp_source.html#l00113">mlir::memref::getLinearizedMemRefOffsetAndSize()</a>, <a class="el" href="MemRefUtils_8cpp_source.html#l00051">mlir::memref::getLinearizedMemRefOffsetAndSize()</a>, <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00090">getOffsetForBitwidth()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00803">getProductOfIndexes()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00794">getSplitReductionIvs()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00474">getTileOffsetAndSizesWithForAllOp()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00101">getUserTileSizesAndNumThreads()</a>, <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00032">invertSliceIndexing()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00217">mlir::linalg::lowerPack()</a>, <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html#l00017">mlir::affine::mergeOffsetsSizesAndStrides()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l03771">normalizeUpperBounds()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00748">mlir::linalg::packMatmulGreedily()</a>, <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html#l00080">mlir::affine::resolveIndicesIntoOpWithOffsetsAndStrides()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l01034">CopyBuilder::rewrite()</a>, and <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00730">updateExpandedGenericOpRegion()</a>.</p>

</div>
</div>
<a id="af523defc0429b26ab3f85b7023748822" name="af523defc0429b26ab3f85b7023748822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af523defc0429b26ab3f85b7023748822">&#9670;&#160;</a></span>bindSymbolsList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AffineExprTy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::bindSymbolsList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineExprTy &gt;</td>          <td class="paramname"><span class="paramname"><em>exprs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00330">330</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">References <a class="el" href="#aefb7ba5a55b4f16631528884d3617a47">getAffineSymbolExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00994">HopperBuilder::buildBarrierArriveTx()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00973">HopperBuilder::buildTmaAsyncLoad()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00286">computeLinearIndex()</a>, and <a class="el" href="MemRefUtils_8cpp_source.html#l00051">mlir::memref::getLinearizedMemRefOffsetAndSize()</a>.</p>

</div>
</div>
<a id="ab07dda6e0df087e91b18fdb2b8bfe5aa" name="ab07dda6e0df087e91b18fdb2b8bfe5aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07dda6e0df087e91b18fdb2b8bfe5aa">&#9670;&#160;</a></span>clone() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * mlir::clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a></td>          <td class="paramname"><span class="paramname"><em>newResultTypes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>newOperands</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00197">197</a> of file <a class="el" href="StructuredOpsUtils_8cpp_source.html">StructuredOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8cpp_source.html#l00214">mlir::OperationState::addRegion()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="IR_2Region_8h_source.html#l00055">mlir::Region::begin()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00512">mlir::Operation::getAttrs()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00119">mlir::Operation::getName()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00677">mlir::Operation::getRegions()</a>.</p>

<p class="reference">Referenced by <a class="el" href="StructuredOpsUtils_8h_source.html#l00145">clone()</a>, <a class="el" href="IR_2Region_8cpp_source.html#l00076">mlir::Region::cloneInto()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00835">createExpandedOp()</a>, <a class="el" href="Fusion_8cpp_source.html#l00103">fuse()</a>, <a class="el" href="ShardOps_8cpp_source.html#l00769">mlir::shard::Sharding::get()</a>, <a class="el" href="TensorOps_8cpp_source.html#l04107">FoldTensorCastProducerOp::matchAndRewrite()</a>, <a class="el" href="CAPI_2Dialect_2TransformInterpreter_8cpp_source.html#l00076">mlirMergeSymbolsIntoFromClone()</a>, <a class="el" href="IR_8cpp_source.html#l00635">mlirOperationClone()</a>, <a class="el" href="CAPI_2Transforms_2Rewrite_8cpp_source.html#l00108">mlirRewriterBaseClone()</a>, <a class="el" href="PassCrashRecovery_8cpp_source.html#l00091">mlir::detail::RecoveryReproducerContext::RecoveryReproducerContext()</a>, <a class="el" href="PadTilingInterface_8cpp_source.html#l00266">mlir::linalg::rewriteAsPaddedOp()</a>, <a class="el" href="Padding_8cpp_source.html#l00244">mlir::linalg::rewriteAsPaddedOp()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00957">tileAndFuseFirstExtractUse()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00433">tileLinalgOpImpl()</a>.</p>

</div>
</div>
<a id="aa75b562b2c25a3d66295d10efde0b996" name="aa75b562b2c25a3d66295d10efde0b996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75b562b2c25a3d66295d10efde0b996">&#9670;&#160;</a></span>clone() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpT mlir::clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OpT</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a></td>          <td class="paramname"><span class="paramname"><em>newResultTypes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>newOperands</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00145">145</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00197">clone()</a>.</p>

</div>
</div>
<a id="a49429f945b2bca0efdd4c315bb68505b" name="a49429f945b2bca0efdd4c315bb68505b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49429f945b2bca0efdd4c315bb68505b">&#9670;&#160;</a></span>cloneWithoutRegions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * mlir::cloneWithoutRegions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a></td>          <td class="paramname"><span class="paramname"><em>newResultTypes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>newOperands</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00209">209</a> of file <a class="el" href="StructuredOpsUtils_8cpp_source.html">StructuredOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8cpp_source.html#l00214">mlir::OperationState::addRegion()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="IR_2Operation_8h_source.html#l00512">mlir::Operation::getAttrs()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00119">mlir::Operation::getName()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00674">mlir::Operation::getNumRegions()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CAPI_2Transforms_2Rewrite_8cpp_source.html#l00113">mlirRewriterBaseCloneWithoutRegions()</a>.</p>

</div>
</div>
<a id="ad6d3795f1b83fc9e56398102edb81bd4" name="ad6d3795f1b83fc9e56398102edb81bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d3795f1b83fc9e56398102edb81bd4">&#9670;&#160;</a></span>coalesceLoops() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::coalesceLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; scf::ForOp &gt;</td>          <td class="paramname"><span class="paramname"><em>loops</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a perfect nest of "for" loops with a single linearized loop. </p>
<p>Assumes <span class="tt">loops</span> contains a list of perfectly nested loops with bounds and steps independent of any loop induction variable involved in the nest. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00986">986</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00986">coalesceLoops()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00986">coalesceLoops()</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00994">coalescePerfectlyNestedSCFForLoops()</a>.</p>

</div>
</div>
<a id="abfbbec94f6bbf0a536fa87c73dd4c61b" name="abfbbec94f6bbf0a536fa87c73dd4c61b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfbbec94f6bbf0a536fa87c73dd4c61b">&#9670;&#160;</a></span>coalesceLoops() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::coalesceLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; scf::ForOp &gt;</td>          <td class="paramname"><span class="paramname"><em>loops</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00908">908</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00854">delinearizeInductionVariable()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00774">denormalizeInductionVariable()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00703">emitNormalizedLoopBounds()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00155">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00378">mlir::Operation::getOperands()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00818">getProductOfIntsOrIndexes()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00102">getValueOrCreateConstantIntOp()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00290">mlir::RewriterBase::inlineBlockBefore()</a>, <a class="el" href="PatternMatch_8h_source.html#l00638">mlir::RewriterBase::modifyOpInPlace()</a>, <a class="el" href="PatternMatch_8h_source.html#l00710">mlir::RewriterBase::replaceAllUsesExcept()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="Builders_8h_source.html#l00398">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="Builders_8h_source.html#l00431">mlir::OpBuilder::setInsertionPointToStart()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a39a046fcc3a4da7eb0d54f9f6a65c3c5" name="a39a046fcc3a4da7eb0d54f9f6a65c3c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a046fcc3a4da7eb0d54f9f6a65c3c5">&#9670;&#160;</a></span>coalescePerfectlyNestedSCFForLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::coalescePerfectlyNestedSCFForLoops </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk an affine.for to find a band to coalesce. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00994">994</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="RegionUtils_8h_source.html#l00026">areValuesDefinedAbove()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00986">coalesceLoops()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01326">getPerfectlyNestedLoops()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a698165b61870c49ff1d068b7aba57fd6" name="a698165b61870c49ff1d068b7aba57fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a698165b61870c49ff1d068b7aba57fd6">&#9670;&#160;</a></span>collapseParallelLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::collapseParallelLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ParallelOp</td>          <td class="paramname"><span class="paramname"><em>loops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::vector&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>combinedDimensions</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take the ParallelLoop and for each set of dimension indices, combine them into a single dimension. </p>
<p>combinedDimensions must contain each index into loops exactly once. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01069">1069</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00774">denormalizeInductionVariable()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00703">emitNormalizedLoopBounds()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00102">getValueOrCreateConstantIntOp()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00035">replaceAllUsesInRegionWith()</a>, <a class="el" href="Builders_8h_source.html#l00398">mlir::OpBuilder::setInsertionPoint()</a>, and <a class="el" href="Builders_8h_source.html#l00431">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

</div>
</div>
<a id="aab965622bbf0ccdfcb51384517fd3117" name="aab965622bbf0ccdfcb51384517fd3117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab965622bbf0ccdfcb51384517fd3117">&#9670;&#160;</a></span>composeReassociationIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt; &gt; mlir::composeReassociationIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>producerReassociations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>consumerReassociations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compose reassociation maps that are used in pair of reshape ops where one is a producer and other is the consumer. </p>
<p>Only valid to use this method when both the producer and consumer are collapsing dimensions or both are expanding dimensions.</p>
<p>For example, producerReassociation = [[0, 1], [2], [3, 4]] consumerReassociation = [[0, 1], [2]]</p>
<p>is folded into</p>
<p>result = [[0, 1, 2], [3, 4]]. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00360">360</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00262">indices</a>.</p>

</div>
</div>
<a id="ab05caafff59182b2191e4645cdceb5d5" name="ab05caafff59182b2191e4645cdceb5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05caafff59182b2191e4645cdceb5d5">&#9670;&#160;</a></span>compressDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::compressDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;</td>          <td class="paramname"><span class="paramname"><em>unusedDims</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop the dims that are listed in <span class="tt">unusedDims</span>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00710">710</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00899">projectDims()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00715">compressUnusedDims()</a>.</p>

</div>
</div>
<a id="a6de5b9ec7c351db7ed870d0df7248342" name="a6de5b9ec7c351db7ed870d0df7248342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de5b9ec7c351db7ed870d0df7248342">&#9670;&#160;</a></span>compressSymbols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::compressSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;</td>          <td class="paramname"><span class="paramname"><em>unusedSymbols</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop the symbols that are listed in <span class="tt">unusedSymbols</span>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00724">724</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00906">projectSymbols()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00729">compressUnusedSymbols()</a>.</p>

</div>
</div>
<a id="a99f84d2ce14eec6c85a20251582e5cc1" name="a99f84d2ce14eec6c85a20251582e5cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f84d2ce14eec6c85a20251582e5cc1">&#9670;&#160;</a></span>compressUnusedDims() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::compressUnusedDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop the dims that are not used. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00715">715</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00710">compressDims()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00923">getUnusedDimsBitVector()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00719">compressUnusedDims()</a>, <a class="el" href="VectorOps_8cpp_source.html#l04823">mlir::vector::inferTransferOpMaskType()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00595">reindexIndexingMap()</a>.</p>

</div>
</div>
<a id="ae2a3cbce4381f83b710fe6cfc9a867c9" name="ae2a3cbce4381f83b710fe6cfc9a867c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a3cbce4381f83b710fe6cfc9a867c9">&#9670;&#160;</a></span>compressUnusedDims() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; mlir::compressUnusedDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>maps</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop the dims that are not used by any of the individual maps in <span class="tt">maps</span>. </p>
<p>Asserts that all maps in <span class="tt">maps</span> are normalized to the same number of dims and symbols. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00719">719</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00715">compressUnusedDims()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00680">compressUnusedListImpl()</a>.</p>

</div>
</div>
<a id="ae4c401a074fdcc1cb0efb7e5369b2ef3" name="ae4c401a074fdcc1cb0efb7e5369b2ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c401a074fdcc1cb0efb7e5369b2ef3">&#9670;&#160;</a></span>compressUnusedSymbols() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::compressUnusedSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop the symbols that are not used. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00729">729</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00724">compressSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00935">getUnusedSymbolsBitVector()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00733">compressUnusedSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00913">getProjectedMap()</a>, and <a class="el" href="CAPI_2IR_2AffineMap_8cpp_source.html#l00150">mlirAffineMapCompressUnusedSymbols()</a>.</p>

</div>
</div>
<a id="a4a26d1a643586acb4362f535168be129" name="a4a26d1a643586acb4362f535168be129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a26d1a643586acb4362f535168be129">&#9670;&#160;</a></span>compressUnusedSymbols() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; mlir::compressUnusedSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>maps</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop the symbols that are not used by any of the individual maps in <span class="tt">maps</span>. </p>
<p>Asserts that all maps in <span class="tt">maps</span> are normalized to the same number of dims and symbols. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00733">733</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00680">compressUnusedListImpl()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00729">compressUnusedSymbols()</a>.</p>

</div>
</div>
<a id="ad0f77472da918076c9d2a222a501823f" name="ad0f77472da918076c9d2a222a501823f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f77472da918076c9d2a222a501823f">&#9670;&#160;</a></span>computeElementwiseMul() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; mlir::computeElementwiseMul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a vector containing llvm::zip_equal(v1, v2) multiplied elementwise. </p>
<p>It is the caller's responsibility to pass proper <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> kind that result in valid <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> (i.e. cannot multiply 2 <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a> or divide by an <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a>).</p>
<p>Return an empty vector if <span class="tt">v1</span> and <span class="tt">v2</span> are empty. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00144">144</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00033">computeElementwiseMulImpl()</a>.</p>

</div>
</div>
<a id="a1c7ccdb269314ad17ee4550b4bcb608a" name="a1c7ccdb269314ad17ee4550b4bcb608a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7ccdb269314ad17ee4550b4bcb608a">&#9670;&#160;</a></span>computeElementwiseMul() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; mlir::computeElementwiseMul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a vector containing llvm::zip_equal(v1, v2) multiplied elementwise. </p>
<p>Return an empty vector if <span class="tt">v1</span> and <span class="tt">v2</span> are empty. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00079">79</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00033">computeElementwiseMulImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="XeGPUDialect_8cpp_source.html#l00048">mlir::xegpu::genCoordinates()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00368">mlir::detail::TileOffsetRangeImpl::getDynamicTileOffsets()</a>, and <a class="el" href="IndexingUtils_8cpp_source.html#l00360">mlir::detail::TileOffsetRangeImpl::getStaticTileOffsets()</a>.</p>

</div>
</div>
<a id="a19e07ab53e78b29f77777f2ade29c9e8" name="a19e07ab53e78b29f77777f2ade29c9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e07ab53e78b29f77777f2ade29c9e8">&#9670;&#160;</a></span>computeLinearIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt; mlir::computeLinearIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>sourceOffset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00317">317</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00286">computeLinearIndex()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00106">getAsIndexOpFoldResult()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00081">getAsOpFoldResult()</a>, <a class="el" href="OpDefinition_8h_source.html#l00278">mlir::OpFoldResult::getContext()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00262">indices</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02103">ValueRange</a>.</p>

</div>
</div>
<a id="a3eafff30d6e835bda8247cf34463df2c" name="a3eafff30d6e835bda8247cf34463df2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eafff30d6e835bda8247cf34463df2c">&#9670;&#160;</a></span>computeLinearIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt; mlir::computeLinearIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>sourceOffset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute linear index from provided strides and indices, assuming strided layout. </p>
<p>Returns <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> and list of values to apply to it, e.g.:</p>
<p>auto &amp;&amp;[expr, values] = computeLinearIndex(...); offset = affine::makeComposedFoldedAffineApply(builder, loc, expr, values); </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00286">286</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00330">bindSymbolsList()</a>, <a class="el" href="LoopUtils_8cpp.html#a420db562c84b0a026e92385cb33aaf6f">getContext()</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00262">indices</a>.</p>

<p class="reference">Referenced by <a class="el" href="IndexingUtils_8cpp_source.html#l00317">computeLinearIndex()</a>, and <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00714">getCollapsedIndices()</a>.</p>

</div>
</div>
<a id="a9c157bd2c9cf4949b45235593f6ef994" name="a9c157bd2c9cf4949b45235593f6ef994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c157bd2c9cf4949b45235593f6ef994">&#9670;&#160;</a></span>computeMaxLinearIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint64__t.html">int64_t</a> mlir::computeMaxLinearIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of elements of basis (i.e. </p>
<p>the max linear index). Return <span class="tt">0</span> if <span class="tt">basis</span> is empty.</p>
<p><span class="tt">basis</span> elements are asserted to be non-negative.</p>
<p>Return <span class="tt">0</span> if <span class="tt">basis</span> is empty. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8h_source.html#l00069">69</a> of file <a class="el" href="IndexingUtils_8h_source.html">IndexingUtils.h</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00084">computeProduct()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PolynomialApproximation_8cpp_source.html#l00097">handleMultidimensionalVectors()</a>, and <a class="el" href="IndexingUtils_8cpp_source.html#l00340">mlir::detail::TileOffsetRangeImpl::TileOffsetRangeImpl()</a>.</p>

</div>
</div>
<a id="ac2248838afeb293df08c1731f2d12fc2" name="ac2248838afeb293df08c1731f2d12fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2248838afeb293df08c1731f2d12fc2">&#9670;&#160;</a></span>computeMaxLinearIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::computeMaxLinearIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of elements of basis (i.e. </p>
<p>the max linear index). Return <span class="tt">0</span> if <span class="tt">basis</span> is empty.</p>
<p>It is the caller's responsibility to pass proper <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> kind that result in valid <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> (i.e. cannot multiply 2 <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a> or divide by an <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a>).</p>
<p><span class="tt">basis</span> elements are expected to bind to non-negative values.</p>
<p>Return the <span class="tt">0</span> <a class="el" href="classmlir_1_1AffineConstantExpr.html" title="An integer constant appearing in affine expression.">AffineConstantExpr</a> if <span class="tt">basis</span> is empty. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8h_source.html#l00159">159</a> of file <a class="el" href="IndexingUtils_8h_source.html">IndexingUtils.h</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00084">computeProduct()</a>.</p>

</div>
</div>
<a id="a6eab61c26bfef3d7aaf3db051d58230b" name="a6eab61c26bfef3d7aaf3db051d58230b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eab61c26bfef3d7aaf3db051d58230b">&#9670;&#160;</a></span>computePermutationVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; mlir::computePermutationVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>permSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>positions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>desiredPositions</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a permutation vector of size permSize that would result in moving positions into desiredPositions. </p>
<p>For example, permSize == 5, positions = {2, 4}, desiredPositions = {1, 0} would result in a {4, 2, 0, 1, 3} permutation vector. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00217">217</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00150">computePackUnPackPerm()</a>, and <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00748">mlir::linalg::packMatmulGreedily()</a>.</p>

</div>
</div>
<a id="a68e66c407bcfb1b4bbba4693496dbdc6" name="a68e66c407bcfb1b4bbba4693496dbdc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e66c407bcfb1b4bbba4693496dbdc6">&#9670;&#160;</a></span>computeProduct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint64__t.html">int64_t</a> mlir::computeProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Self-explicit. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00084">84</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00973">HopperBuilder::buildTmaAsyncLoad()</a>, <a class="el" href="GPUTransformOps_8cpp_source.html#l00762">checkMappingSpec()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00107">commonLinearIdBuilderFn()</a>, <a class="el" href="IndexingUtils_8h_source.html#l00069">computeMaxLinearIndex()</a>, <a class="el" href="IndexingUtils_8h_source.html#l00159">computeMaxLinearIndex()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00231">laneIdBuilderFn()</a>, and <a class="el" href="NVGPUTransformOps_8cpp_source.html#l01034">CopyBuilder::rewrite()</a>.</p>

</div>
</div>
<a id="ada8d7a2a03264db5a6ac02a351f1e059" name="ada8d7a2a03264db5a6ac02a351f1e059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8d7a2a03264db5a6ac02a351f1e059">&#9670;&#160;</a></span>computeProduct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::computeProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Self-explicit. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00153">153</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="#ab26cdced424aa629fde4150cc8674d50">getAffineConstantExpr()</a>.</p>

</div>
</div>
<a id="ac7e47350637dfbf8ad64f9e3bba17bdd" name="ac7e47350637dfbf8ad64f9e3bba17bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e47350637dfbf8ad64f9e3bba17bdd">&#9670;&#160;</a></span>computeRankReductionMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; llvm::SmallDenseSet&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &gt; mlir::computeRankReductionMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>originalShape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>reducedShape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>matchDynamic</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an <span class="tt">originalShape</span> and a <span class="tt">reducedShape</span> assumed to be a subset of <span class="tt">originalShape</span> with some <span class="tt">1</span> entries erased, return the set of indices that specifies which of the entries of <span class="tt">originalShape</span> are dropped to obtain <span class="tt">reducedShape</span>. </p>
<p>The returned mask can be applied as a projection to <span class="tt">originalShape</span> to obtain the <span class="tt">reducedShape</span>. This mask is useful to track which dimensions must be kept when e.g. compute MemRef strides under rank-reducing operations. Return std::nullopt if reducedShape cannot be obtained by dropping only <span class="tt">1</span> entries in <span class="tt">originalShape</span>. If <span class="tt">matchDynamic</span> is true, then dynamic dims in <span class="tt">originalShape</span> and <span class="tt">reducedShape</span> will be considered matching with non-dynamic dims, unless the non-dynamic dim is from <span class="tt">originalShape</span> and equal to 1. For example, in ([1, 3, ?], [?, 5]), the mask would be {1, 0, 0}, since 3 and 5 will match with the corresponding dynamic dims. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00456">456</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00490">isRankReducedType()</a>.</p>

</div>
</div>
<a id="ad1c2ae63c247a9ba4509c8d1181127b0" name="ad1c2ae63c247a9ba4509c8d1181127b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c2ae63c247a9ba4509c8d1181127b0">&#9670;&#160;</a></span>computeShapeRatio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &gt; mlir::computeShapeRatio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>subShape</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the multi-dimensional integral ratio of <span class="tt">subShape</span> to the trailing dimensions of <span class="tt">shape</span>. </p>
<p>This represents how many times <span class="tt">subShape</span> fits within <span class="tt">shape</span>. If integral division is not possible, return std::nullopt. The trailing <span class="tt">subShape.size()</span> entries of both shapes are assumed (and enforced) to only contain non-negative values.</p>
<p>Examples:</p><ul>
<li>shapeRatio({3, 5, 8}, {2, 5, 2}) returns {3, 2, 1}.</li>
<li>shapeRatio({3, 8}, {2, 5, 2}) returns std::nullopt (subshape has higher rank).</li>
<li>shapeRatio({42, 2, 10, 32}, {2, 5, 2}) returns {42, 1, 2, 16} which is derived as {42(leading shape dim), 2/2, 10/5, 32/2}.</li>
<li>shapeRatio({42, 2, 11, 32}, {2, 5, 2}) returns std::nullopt which is derived as {42(leading shape dim), 2/2, 11/5(not divisible), 32/2}. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00106">106</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="XeGPUUtils_8cpp_source.html#l00292">mlir::xegpu::extractVectorsWithShapeFromValue()</a>, <a class="el" href="VectorUnroll_8cpp_source.html#l00091">getTargetShape()</a>, and <a class="el" href="IndexingUtils_8cpp_source.html#l00340">mlir::detail::TileOffsetRangeImpl::TileOffsetRangeImpl()</a>.</p>

</div>
</div>
<a id="a511690ae218cc4d32852eae4eb1dd0bc" name="a511690ae218cc4d32852eae4eb1dd0bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511690ae218cc4d32852eae4eb1dd0bc">&#9670;&#160;</a></span>computeStrides() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; mlir::computeStrides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8h_source.html#l00129">129</a> of file <a class="el" href="IndexingUtils_8h_source.html">IndexingUtils.h</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00071">computeSuffixProduct()</a>.</p>

</div>
</div>
<a id="a2d431e82eeecb3e976189fdcd8283004" name="a2d431e82eeecb3e976189fdcd8283004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d431e82eeecb3e976189fdcd8283004">&#9670;&#160;</a></span>computeStrides() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; mlir::computeStrides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8h_source.html#l00047">47</a> of file <a class="el" href="IndexingUtils_8h_source.html">IndexingUtils.h</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00071">computeSuffixProduct()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l03434">calculateInsertPosition()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00107">commonLinearIdBuilderFn()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02115">foldDenseElementsAttrSrcExtractOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l04292">foldExtractStridedSliceNonSplatConstant()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00646">foreachIndividualVectorElement()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00097">handleMultidimensionalVectors()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00231">laneIdBuilderFn()</a>, <a class="el" href="AffineExpandIndexOps_8cpp_source.html#l00087">mlir::affine::lowerAffineDelinearizeIndexOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02484">ToElementsOfBroadcast::matchAndRewrite()</a>, and <a class="el" href="IndexingUtils_8cpp_source.html#l00340">mlir::detail::TileOffsetRangeImpl::TileOffsetRangeImpl()</a>.</p>

</div>
</div>
<a id="a530d6a928389d2f4c0234b059442a03a" name="a530d6a928389d2f4c0234b059442a03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a530d6a928389d2f4c0234b059442a03a">&#9670;&#160;</a></span>computeSuffixProduct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; mlir::computeSuffixProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of sizes, return the suffix product. </p>
<p>When applied to slicing, this is the calculation needed to derive the strides (i.e. the number of linear indices to skip along the (k-1) most minor dimensions to get the next k-slice).</p>
<p>This is the basis to linearize an n-D offset confined to <span class="tt">[0 ... sizes]</span>.</p>
<p>Assuming <span class="tt">sizes</span> is <span class="tt">[s0, .. sn]</span>, return the <a class="el" href="namespacemlir_1_1vector.html">vector&lt;AffineExpr&gt;</a> <span class="tt">[s1 * ... * sn, s2 * ... * sn, ..., sn, 1]</span>.</p>
<p>It is the caller's responsibility to pass proper <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> kind that result in valid <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> (i.e. cannot multiply 2 <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a> or divide by an <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a>).</p>
<p><span class="tt">sizes</span> elements are expected to bind to non-negative values.</p>
<p>Return an empty vector if <span class="tt">sizes</span> is empty. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00137">137</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="#ab26cdced424aa629fde4150cc8674d50">getAffineConstantExpr()</a>.</p>

</div>
</div>
<a id="a93db6f545964ed23f06b57618f09b33a" name="a93db6f545964ed23f06b57618f09b33a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93db6f545964ed23f06b57618f09b33a">&#9670;&#160;</a></span>computeSuffixProduct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; mlir::computeSuffixProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of sizes, return the suffix product. </p>
<p>When applied to slicing, this is the calculation needed to derive the strides (i.e. the number of linear indices to skip along the (k-1) most minor dimensions to get the next k-slice).</p>
<p>This is the basis to linearize an n-D offset confined to <span class="tt">[0 ... sizes]</span>.</p>
<p>Assuming <span class="tt">sizes</span> is <span class="tt">[s0, .. sn]</span>, return the <a class="el" href="namespacemlir_1_1vector.html">vector&lt;int64_t&gt;</a> <span class="tt">[s1 * ... * sn, s2 * ... * sn, ..., sn, 1]</span>.</p>
<p><span class="tt">sizes</span> elements <span class="tt">s1</span> to <span class="tt">sn</span> are asserted to be non-negative.</p>
<p>Return an empty vector if <span class="tt">sizes</span> is empty. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00071">71</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="IndexingUtils_8h_source.html#l00129">computeStrides()</a>, <a class="el" href="IndexingUtils_8h_source.html#l00047">computeStrides()</a>, <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00714">getCollapsedIndices()</a>, and <a class="el" href="AMDGPUDialect_8cpp_source.html#l00102">getFatRawBufferTypeLike()</a>.</p>

</div>
</div>
<a id="aea26c0821fa35a09260cd1aeb694d0df" name="aea26c0821fa35a09260cd1aeb694d0df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea26c0821fa35a09260cd1aeb694d0df">&#9670;&#160;</a></span>computeSum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint64__t.html">int64_t</a> mlir::computeSum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Self-explicit. </p>

<p class="reference">Referenced by <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00994">HopperBuilder::buildBarrierArriveTx()</a>.</p>

</div>
</div>
<a id="a4cb1a444a06409db3eedd783e7f9ab0b" name="a4cb1a444a06409db3eedd783e7f9ab0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb1a444a06409db3eedd783e7f9ab0b">&#9670;&#160;</a></span>computeSum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::computeSum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Self-explicit. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00149">149</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="#ab26cdced424aa629fde4150cc8674d50">getAffineConstantExpr()</a>.</p>

</div>
</div>
<a id="a28129a93d39ade2d40077f25a09eb389" name="a28129a93d39ade2d40077f25a09eb389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28129a93d39ade2d40077f25a09eb389">&#9670;&#160;</a></span>computeTopologicalSorting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::computeTopologicalSorting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>ops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td>          <td class="paramname"><span class="paramname"><em>isOperandReady</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a topological ordering of the given ops. </p>
<p>This sort is not stable.</p>
<p>Note: If the specified ops contain incomplete/interrupted SSA use-def chains, the result may not actually be a topological sorting with respect to the entire program. </p>

<p class="definition">Definition at line <a class="el" href="TopologicalSortUtils_8cpp_source.html#l00107">107</a> of file <a class="el" href="TopologicalSortUtils_8cpp_source.html">TopologicalSortUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="TopologicalSortUtils_8cpp_source.html#l00020">isOpReady()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8cpp_source.html#l00087">makeRegionIsolatedFromAbove()</a>.</p>

</div>
</div>
<a id="a0b5c68aa8f528b64d3f4f8990b0b5dde" name="a0b5c68aa8f528b64d3f4f8990b0b5dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b5c68aa8f528b64d3f4f8990b0b5dde">&#9670;&#160;</a></span>concatAffineMaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::concatAffineMaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>maps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates a list of <span class="tt">maps</span> into a single <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a>, stepping over potentially empty maps. </p>
<p>Assumes each of the underlying map has 0 symbols. The resulting map has a number of dims equal to the max of <span class="tt">maps</span>' dims and the concatenated results as its results. Returns an empty map if all input <span class="tt">maps</span> are empty.</p>
<p>Example: When applied to the following list of 3 affine maps,</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  (i, j, k) -&gt; (i, k),</div>
<div class="line">  (i, j, k) -&gt; (k, j),</div>
<div class="line">  (i, j, k) -&gt; (i, j)</div>
<div class="line">}</div>
</div><!-- fragment --><p>Returns the map:</p>
<div class="fragment"><div class="line">(i, j, k) -&gt; (i, k, k, j, i, j)</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00829">829</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgInterfaces_8cpp_source.html#l00040">mlir::linalg::detail::canOpOperandsBeDroppedImpl()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00384">mlir::linalg::dropUnitDims()</a>, and <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00079">isOpOperandCanBeDroppedAfterFusedLinalgs()</a>.</p>

</div>
</div>
<a id="acc3c1de7f45b21ef1f9deddb22b03655" name="acc3c1de7f45b21ef1f9deddb22b03655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3c1de7f45b21ef1f9deddb22b03655">&#9670;&#160;</a></span>configureAMXLegalizeForExportTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::configureAMXLegalizeForExportTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMConversionTarget.html">LLVMConversionTarget</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the target to support lowering AMX ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>

<p class="definition">Definition at line <a class="el" href="AMX_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00049">49</a> of file <a class="el" href="AMX_2Transforms_2LegalizeForLLVMExport_8cpp_source.html">LegalizeForLLVMExport.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02100">target</a>.</p>

</div>
</div>
<a id="ac5fc9cf7db1e6fcc78850ac4ab89742c" name="ac5fc9cf7db1e6fcc78850ac4ab89742c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5fc9cf7db1e6fcc78850ac4ab89742c">&#9670;&#160;</a></span>configureArmSMEToLLVMConversionLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::configureArmSMEToLLVMConversionLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classConversionTarget.html">ConversionTarget</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure target to convert from the ArmSME dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8cpp_source.html#l00938">938</a> of file <a class="el" href="ArmSMEToLLVM_8cpp_source.html">ArmSMEToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02100">target</a>.</p>

</div>
</div>
<a id="a026c18765c0bc2d44d9ab120174d36ae" name="a026c18765c0bc2d44d9ab120174d36ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026c18765c0bc2d44d9ab120174d36ae">&#9670;&#160;</a></span>configureArmSVELegalizeForExportTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::configureArmSVELegalizeForExportTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMConversionTarget.html">LLVMConversionTarget</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the target to support lowering ArmSVE ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>

<p class="definition">Definition at line <a class="el" href="ArmSVE_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00218">218</a> of file <a class="el" href="ArmSVE_2Transforms_2LegalizeForLLVMExport_8cpp_source.html">LegalizeForLLVMExport.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02100">target</a>.</p>

</div>
</div>
<a id="a7fa896c9229c786edc4a7970b960b208" name="a7fa896c9229c786edc4a7970b960b208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa896c9229c786edc4a7970b960b208">&#9670;&#160;</a></span>configureGpuToNVVMConversionLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::configureGpuToNVVMConversionLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classConversionTarget.html">ConversionTarget</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure target to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00432">432</a> of file <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html">LowerGpuOpsToNVVMOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02100">target</a>.</p>

</div>
</div>
<a id="a779a8acdc0bf58163f34a058382fbc75" name="a779a8acdc0bf58163f34a058382fbc75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a779a8acdc0bf58163f34a058382fbc75">&#9670;&#160;</a></span>configureGpuToNVVMTypeConverter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::configureGpuToNVVMTypeConverter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> type convert to convert types and address spaces from the GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00448">448</a> of file <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html">LowerGpuOpsToNVVMOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="WmmaOpsToNvvm_8cpp_source.html#l00407">convertMMAToLLVMType()</a>, and <a class="el" href="GPUOpsLowering_8cpp_source.html#l00818">populateGpuMemorySpaceAttributeConversions()</a>.</p>

</div>
</div>
<a id="a65c490624b02da7c5cb78aa071e0aa2a" name="a65c490624b02da7c5cb78aa071e0aa2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c490624b02da7c5cb78aa071e0aa2a">&#9670;&#160;</a></span>configureGpuToROCDLConversionLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::configureGpuToROCDLConversionLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classConversionTarget.html">ConversionTarget</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure target to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a>. </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html#l00415">415</a> of file <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html">LowerGpuOpsToROCDLOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02100">target</a>.</p>

</div>
</div>
<a id="ab3aae89781697b10e37f29e112251443" name="ab3aae89781697b10e37f29e112251443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3aae89781697b10e37f29e112251443">&#9670;&#160;</a></span>configureOpenMPToLLVMConversionLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::configureOpenMPToLLVMConversionLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classConversionTarget.html">ConversionTarget</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure dynamic conversion legality of regionless operations from OpenMP to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="OpenMPToLLVM_8cpp_source.html#l00122">122</a> of file <a class="el" href="OpenMPToLLVM_8cpp_source.html">OpenMPToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02100">target</a>.</p>

</div>
</div>
<a id="af01d59b73ef695a82338e96055101c16" name="af01d59b73ef695a82338e96055101c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01d59b73ef695a82338e96055101c16">&#9670;&#160;</a></span>configureParallelLoopToGPULegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::configureParallelLoopToGPULegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classConversionTarget.html">ConversionTarget</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the rewrite target such that only <span class="tt">scf.parallel</span> operations that are not rewritten by the provided patterns are legal. </p>

<p class="definition">Definition at line <a class="el" href="SCFToGPU_8cpp_source.html#l00774">774</a> of file <a class="el" href="SCFToGPU_8cpp_source.html">SCFToGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="ParallelLoopMapper_8cpp_source.html#l00031">mlir::gpu::getMappingAttrName()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00057">kVisitedAttrName</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02100">target</a>.</p>

</div>
</div>
<a id="afa8013cee2241cd53aa923b23e4e3575" name="afa8013cee2241cd53aa923b23e4e3575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8013cee2241cd53aa923b23e4e3575">&#9670;&#160;</a></span>configureX86VectorLegalizeForExportTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::configureX86VectorLegalizeForExportTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMConversionTarget.html">LLVMConversionTarget</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the target to support lowering X86Vector ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>

<p class="definition">Definition at line <a class="el" href="X86Vector_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00046">46</a> of file <a class="el" href="X86Vector_2Transforms_2LegalizeForLLVMExport_8cpp_source.html">LegalizeForLLVMExport.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02100">target</a>.</p>

</div>
</div>
<a id="af2c57691c632b0f92b39c265af63a96d" name="af2c57691c632b0f92b39c265af63a96d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c57691c632b0f92b39c265af63a96d">&#9670;&#160;</a></span>constantTripCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; APInt &gt; mlir::constantTripCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>step</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>isSigned</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; std::optional&lt; llvm::APSInt &gt;(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classbool.html">bool</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>computeUbMinusLb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of iterations for a loop with a lower bound <span class="tt">lb</span>, upper bound <span class="tt">ub</span> and step <span class="tt">step</span>. </p>
<p>The <span class="tt">isSigned</span> flag indicates whether the loop comparison between lb and ub is signed or unsigned. A negative step or a lower bound greater than the upper bound are considered invalid and will yield a zero trip count. The <span class="tt">computeUbMinusLb</span> callback is invoked to compute the difference between the upper and lower bound when not constant. It can be used by the client to compute a static difference when the bounds are not constant.</p>
<p>For example, the following code:</p>
<p>ub = arith.addi nsw lb, c16_i32 : i32 %1 = scf.for arg0 = lb to ub ...</p>
<p>where ub is computed as a static offset from lb. Note: the matched addition should be nsw/nuw (matching the loop comparison) to avoid overflow, otherwise an overflow would imply a zero trip count. </p>
<p>Compute the difference between the upper and lower bound: either from the constant value or using the computeUbMinusLb callback.</p>
<p>Non-constant bound, let's try to compute the difference between the upper and lower bound</p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00278">278</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00118">getConstantAPIntValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01563">getConstLoopTripCounts()</a>.</p>

</div>
</div>
<a id="ae63b6955f772ddb5f5250d3b68f2f3d0" name="ae63b6955f772ddb5f5250d3b68f2f3d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae63b6955f772ddb5f5250d3b68f2f3d0">&#9670;&#160;</a></span>constFoldBinaryOp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AttrElementT, class ElementValueT = typename AttrElementT::ValueType, class PoisonAttr = ub::PoisonAttr, class ResultAttrElementT = AttrElementT, class ResultElementValueT = typename ResultAttrElementT::ValueType, class CalculationT = function_ref&lt;ResultElementValueT(ElementValueT, ElementValueT)&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::constFoldBinaryOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CalculationT &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>calculate</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CommonFolders_8h_source.html#l00194">194</a> of file <a class="el" href="CommonFolders_8h_source.html">CommonFolders.h</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="CommonFolders_8h_source.html#l00046">constFoldBinaryOpConditional()</a>.</p>

</div>
</div>
<a id="a3fd9ce44116535930319e01412a23b2b" name="a3fd9ce44116535930319e01412a23b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd9ce44116535930319e01412a23b2b">&#9670;&#160;</a></span>constFoldBinaryOp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AttrElementT, class ElementValueT = typename AttrElementT::ValueType, class PoisonAttr = void, class ResultAttrElementT = AttrElementT, class ResultElementValueT = typename ResultAttrElementT::ValueType, class CalculationT = function_ref&lt;ResultElementValueT(ElementValueT, ElementValueT)&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::constFoldBinaryOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>resultType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CalculationT &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>calculate</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CommonFolders_8h_source.html#l00178">178</a> of file <a class="el" href="CommonFolders_8h_source.html">CommonFolders.h</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="CommonFolders_8h_source.html#l00046">constFoldBinaryOpConditional()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00133">IAddCarryFold::matchAndRewrite()</a>, and <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00213">MulExtendedFold&lt; spirv::SMulExtendedOp, true &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a4943ae31e8f9d07e1c3fcb5c7acd431b" name="a4943ae31e8f9d07e1c3fcb5c7acd431b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4943ae31e8f9d07e1c3fcb5c7acd431b">&#9670;&#160;</a></span>constFoldBinaryOpConditional() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AttrElementT, class ElementValueT = typename AttrElementT::ValueType, class PoisonAttr = ub::PoisonAttr, class ResultAttrElementT = AttrElementT, class ResultElementValueT = typename ResultAttrElementT::ValueType, class CalculationT = function_ref&lt;              std::optional&lt;ResultElementValueT&gt;(ElementValueT, ElementValueT)&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::constFoldBinaryOpConditional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CalculationT &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>calculate</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs constant folding <span class="tt">calculate</span> with element-wise behavior on the two attributes in <span class="tt">operands</span> and returns the result if possible. </p>
<p>Uses the operand element type for the element type of the returned attribute. Optional PoisonAttr template argument allows to specify 'poison' attribute which will be directly propagated to result. </p>

<p class="definition">Definition at line <a class="el" href="CommonFolders_8h_source.html#l00137">137</a> of file <a class="el" href="CommonFolders_8h_source.html">CommonFolders.h</a>.</p>

<p class="reference">References <a class="el" href="CommonFolders_8h_source.html#l00046">constFoldBinaryOpConditional()</a>.</p>

</div>
</div>
<a id="a48b87ab675233fa833a5d5b720635ee3" name="a48b87ab675233fa833a5d5b720635ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b87ab675233fa833a5d5b720635ee3">&#9670;&#160;</a></span>constFoldBinaryOpConditional() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AttrElementT, class ElementValueT = typename AttrElementT::ValueType, class PoisonAttr = ub::PoisonAttr, class ResultAttrElementT = AttrElementT, class ResultElementValueT = typename ResultAttrElementT::ValueType, class CalculationT = function_ref&lt;              std::optional&lt;ResultElementValueT&gt;(ElementValueT, ElementValueT)&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::constFoldBinaryOpConditional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>resultType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CalculationT &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>calculate</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs constant folding <span class="tt">calculate</span> with element-wise behavior on the two attributes in <span class="tt">operands</span> and returns the result if possible. </p>
<p>Uses <span class="tt">resultType</span> for the type of the returned attribute. Optional PoisonAttr template argument allows to specify 'poison' attribute which will be directly propagated to result. </p>

<p class="definition">Definition at line <a class="el" href="CommonFolders_8h_source.html#l00046">46</a> of file <a class="el" href="CommonFolders_8h_source.html">CommonFolders.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00910">mlir::DenseElementsAttr::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>.</p>

<p class="reference">Referenced by <a class="el" href="CommonFolders_8h_source.html#l00194">constFoldBinaryOp()</a>, <a class="el" href="CommonFolders_8h_source.html#l00178">constFoldBinaryOp()</a>, and <a class="el" href="CommonFolders_8h_source.html#l00137">constFoldBinaryOpConditional()</a>.</p>

</div>
</div>
<a id="a2927f15718a47f9dfaa0090c2235e954" name="a2927f15718a47f9dfaa0090c2235e954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2927f15718a47f9dfaa0090c2235e954">&#9670;&#160;</a></span>constFoldCastOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AttrElementT, class TargetAttrElementT, class ElementValueT = typename AttrElementT::ValueType, class TargetElementValueT = typename TargetAttrElementT::ValueType, class PoisonAttr = ub::PoisonAttr, class CalculationT = function_ref&lt;TargetElementValueT(ElementValueT, bool)&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::constFoldCastOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>resType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CalculationT &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>calculate</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CommonFolders_8h_source.html#l00349">349</a> of file <a class="el" href="CommonFolders_8h_source.html">CommonFolders.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00910">mlir::DenseElementsAttr::get()</a>.</p>

</div>
</div>
<a id="a617f90c080cbc282bfc1263ad077070e" name="a617f90c080cbc282bfc1263ad077070e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a617f90c080cbc282bfc1263ad077070e">&#9670;&#160;</a></span>constFoldUnaryOp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AttrElementT, class ElementValueT = typename AttrElementT::ValueType, class PoisonAttr = ub::PoisonAttr, class ResultAttrElementT = AttrElementT, class ResultElementValueT = typename ResultAttrElementT::ValueType, class CalculationT = function_ref&lt;ResultElementValueT(ElementValueT)&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::constFoldUnaryOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CalculationT &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>calculate</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CommonFolders_8h_source.html#l00334">334</a> of file <a class="el" href="CommonFolders_8h_source.html">CommonFolders.h</a>.</p>

<p class="reference">References <a class="el" href="CommonFolders_8h_source.html#l00215">constFoldUnaryOpConditional()</a>.</p>

</div>
</div>
<a id="ad687d33171f30e523f14be6c69555587" name="ad687d33171f30e523f14be6c69555587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad687d33171f30e523f14be6c69555587">&#9670;&#160;</a></span>constFoldUnaryOp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AttrElementT, class ElementValueT = typename AttrElementT::ValueType, class PoisonAttr = ub::PoisonAttr, class ResultAttrElementT = AttrElementT, class ResultElementValueT = typename ResultAttrElementT::ValueType, class CalculationT = function_ref&lt;ResultElementValueT(ElementValueT)&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::constFoldUnaryOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>resultType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CalculationT &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>calculate</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CommonFolders_8h_source.html#l00318">318</a> of file <a class="el" href="CommonFolders_8h_source.html">CommonFolders.h</a>.</p>

<p class="reference">References <a class="el" href="CommonFolders_8h_source.html#l00215">constFoldUnaryOpConditional()</a>.</p>

</div>
</div>
<a id="abe49ca1aa50f0d7946abfe265867bc43" name="abe49ca1aa50f0d7946abfe265867bc43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe49ca1aa50f0d7946abfe265867bc43">&#9670;&#160;</a></span>constFoldUnaryOpConditional() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AttrElementT, class ElementValueT = typename AttrElementT::ValueType, class PoisonAttr = ub::PoisonAttr, class ResultAttrElementT = AttrElementT, class ResultElementValueT = typename ResultAttrElementT::ValueType, class CalculationT = function_ref&lt;std::optional&lt;ResultElementValueT&gt;(ElementValueT)&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::constFoldUnaryOpConditional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CalculationT &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>calculate</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs constant folding <span class="tt">calculate</span> with element-wise behavior on the one attributes in <span class="tt">operands</span> and returns the result if possible. </p>
<p>Uses the operand element type for the element type of the returned attribute. Optional PoisonAttr template argument allows to specify 'poison' attribute which will be directly propagated to result. </p>

<p class="definition">Definition at line <a class="el" href="CommonFolders_8h_source.html#l00282">282</a> of file <a class="el" href="CommonFolders_8h_source.html">CommonFolders.h</a>.</p>

<p class="reference">References <a class="el" href="CommonFolders_8h_source.html#l00215">constFoldUnaryOpConditional()</a>.</p>

</div>
</div>
<a id="a8b937ae50f6f106b6dc607e66d8f492c" name="a8b937ae50f6f106b6dc607e66d8f492c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b937ae50f6f106b6dc607e66d8f492c">&#9670;&#160;</a></span>constFoldUnaryOpConditional() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AttrElementT, class ElementValueT = typename AttrElementT::ValueType, class PoisonAttr = ub::PoisonAttr, class ResultAttrElementT = AttrElementT, class ResultElementValueT = typename ResultAttrElementT::ValueType, class CalculationT = function_ref&lt;std::optional&lt;ResultElementValueT&gt;(ElementValueT)&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::constFoldUnaryOpConditional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>resultType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CalculationT &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>calculate</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs constant folding <span class="tt">calculate</span> with element-wise behavior on the one attributes in <span class="tt">operands</span> and returns the result if possible. </p>
<p>Uses <span class="tt">resultType</span> for the type of the returned attribute. Optional PoisonAttr template argument allows to specify 'poison' attribute which will be directly propagated to result. </p>

<p class="definition">Definition at line <a class="el" href="CommonFolders_8h_source.html#l00215">215</a> of file <a class="el" href="CommonFolders_8h_source.html">CommonFolders.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00910">mlir::DenseElementsAttr::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CommonFolders_8h_source.html#l00334">constFoldUnaryOp()</a>, <a class="el" href="CommonFolders_8h_source.html#l00318">constFoldUnaryOp()</a>, and <a class="el" href="CommonFolders_8h_source.html#l00282">constFoldUnaryOpConditional()</a>.</p>

</div>
</div>
<a id="ac6e826b7dff0a2629197a20d859cd4c7" name="ac6e826b7dff0a2629197a20d859cd4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6e826b7dff0a2629197a20d859cd4c7">&#9670;&#160;</a></span>controlFlowSink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mlir::controlFlowSink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RegionRange.html">RegionRange</a></td>          <td class="paramname"><span class="paramname"><em>regions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>domInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;</td>          <td class="paramname"><span class="paramname"><em>shouldMoveIntoRegion</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;</td>          <td class="paramname"><span class="paramname"><em>moveIntoRegion</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a list of regions, perform control flow sinking on them. </p>
<p>For each region, control-flow sinking moves operations that dominate the region but whose only users are in the region into the regions so that they aren't executed on paths where their results are not needed.</p>
<p>TODO: For the moment, this is a <em>simple</em> control-flow sink, i.e., no duplicating of ops. It should be made to accept a cost model to determine whether duplicating a particular op is profitable.</p>
<p>Example:</p>
<div class="fragment"><div class="line">%0 = arith.addi %arg0, %arg1</div>
<div class="line">scf.if %cond {</div>
<div class="line">  scf.yield %0</div>
<div class="line">} else {</div>
<div class="line">  scf.yield %arg2</div>
<div class="line">}</div>
</div><!-- fragment --><p>After control-flow sink:</p>
<div class="fragment"><div class="line">scf.if %cond {</div>
<div class="line">  %0 = arith.addi %arg0, %arg1</div>
<div class="line">  scf.yield %0</div>
<div class="line">} else {</div>
<div class="line">  scf.yield %arg2</div>
<div class="line">}</div>
</div><!-- fragment --><p>Users must supply a callback <span class="tt">shouldMoveIntoRegion</span> that determines whether the given operation that only has users in the given operation should be moved into that region. If this returns true, <span class="tt">moveIntoRegion</span> is called on the same operation and region.</p>
<p><span class="tt">moveIntoRegion</span> must move the operation into the region such that dominance of the operation is preserved; for example, by moving the operation to the start of the entry block. This ensures the preservation of SSA dominance of the operation's results.</p>
<p>Returns the number of operations sunk. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowSinkUtils_8cpp_source.html#l00132">132</a> of file <a class="el" href="ControlFlowSinkUtils_8cpp_source.html">ControlFlowSinkUtils.cpp</a>.</p>

</div>
</div>
<a id="a4e36f1b7aaec9319e5ba11077079aa4e" name="a4e36f1b7aaec9319e5ba11077079aa4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e36f1b7aaec9319e5ba11077079aa4e">&#9670;&#160;</a></span>convertAffineLoopNestToGPULaunch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::convertAffineLoopNestToGPULaunch </td>
          <td>(</td>
          <td class="paramtype">affine::AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numBlockDims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numThreadDims</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a perfect affine loop nest with the outermost loop identified by <span class="tt">forOp</span> into a gpu::Launch operation. </p>
<p>Map <span class="tt">numBlockDims</span> outer loops to GPU blocks and <span class="tt">numThreadDims</span> to GPU threads. The bounds of the loops that are mapped should be independent of the induction variables of the other mapped loops.</p>
<p>No check on the size of the block or grid, or on the validity of parallelization is performed, it is under the responsibility of the caller to strip-mine the loops and to perform the dependence analysis before calling the conversion. </p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02100">target</a>.</p>

</div>
</div>
<a id="a8def5e235dec49017ed2ab6ca765e96f" name="a8def5e235dec49017ed2ab6ca765e96f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8def5e235dec49017ed2ab6ca765e96f">&#9670;&#160;</a></span>convertFromAttribute() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::convertFromAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>storage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td>          <td class="paramname"><span class="paramname"><em>attr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;</td>          <td class="paramname"><span class="paramname"><em>emitError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the boolean from <span class="tt">attr</span> into <span class="tt">storage</span>. </p>
<p>If <span class="tt">attr</span> is not a <span class="tt"><a class="el" href="classmlir_1_1BoolAttr.html" title="Special case of IntegerAttr to represent boolean integers, i.e., signless i1 integers.">BoolAttr</a></span>, return failure and emit an error into the diagnostic from <span class="tt">emitError</span>. </p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00101">101</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00332">emitError()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="abaaf50aca64f58a65c55414d3f3309d5" name="abaaf50aca64f58a65c55414d3f3309d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaaf50aca64f58a65c55414d3f3309d5">&#9670;&#160;</a></span>convertFromAttribute() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::convertFromAttribute </td>
          <td>(</td>
          <td class="paramtype">int32_t &amp;</td>          <td class="paramname"><span class="paramname"><em>storage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td>          <td class="paramname"><span class="paramname"><em>attr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;</td>          <td class="paramname"><span class="paramname"><em>emitError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an IntegerAttr attribute to an int32_t, or return an error if the attribute isn't an IntegerAttr. </p>
<p>If the optional diagnostic is provided an error message is also emitted. </p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00037">37</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00332">emitError()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="abb62375c248ed1a8f282211f5d0cedd8" name="abb62375c248ed1a8f282211f5d0cedd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb62375c248ed1a8f282211f5d0cedd8">&#9670;&#160;</a></span>convertFromAttribute() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::convertFromAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>storage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td>          <td class="paramname"><span class="paramname"><em>attr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;</td>          <td class="paramname"><span class="paramname"><em>emitError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an IntegerAttr attribute to an <a class="el" href="classint64__t.html">int64_t</a>, or return an error if the attribute isn't an IntegerAttr. </p>
<p>If the optional diagnostic is provided an error message is also emitted. </p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00022">22</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00332">emitError()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a981b42df6743d410432f0e45a378448f" name="a981b42df6743d410432f0e45a378448f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981b42df6743d410432f0e45a378448f">&#9670;&#160;</a></span>convertFromAttribute() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::convertFromAttribute </td>
          <td>(</td>
          <td class="paramtype">int8_t &amp;</td>          <td class="paramname"><span class="paramname"><em>storage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td>          <td class="paramname"><span class="paramname"><em>attr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;</td>          <td class="paramname"><span class="paramname"><em>emitError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an IntegerAttr attribute to an int8_t, or return an error if the attribute isn't an IntegerAttr. </p>
<p>If the optional diagnostic is provided an error message is also emitted. </p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00052">52</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00332">emitError()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a44ed2f9952d1cb1a2eb02252768af95b" name="a44ed2f9952d1cb1a2eb02252768af95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ed2f9952d1cb1a2eb02252768af95b">&#9670;&#160;</a></span>convertFromAttribute() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::convertFromAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>storage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td>          <td class="paramname"><span class="paramname"><em>attr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;</td>          <td class="paramname"><span class="paramname"><em>emitError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="#a8810f74ec6699911bda66ad210693ab9">DenseI32ArrayAttr</a> to the provided storage. </p>
<p>It is expected that the storage has the same size as the array. An error is returned if the attribute isn't a <a class="el" href="#a8810f74ec6699911bda66ad210693ab9">DenseI32ArrayAttr</a> or it does not have the same size. If the optional diagnostic is provided an error message is also emitted. </p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00139">139</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

<p class="reference">References <a class="el" href="ODSSupport_8cpp_source.html#l00116">convertDenseArrayFromAttr()</a>, and <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00332">emitError()</a>.</p>

</div>
</div>
<a id="a7950ff8da3b75555e08167ea5ea94eed" name="a7950ff8da3b75555e08167ea5ea94eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7950ff8da3b75555e08167ea5ea94eed">&#9670;&#160;</a></span>convertFromAttribute() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::convertFromAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>storage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td>          <td class="paramname"><span class="paramname"><em>attr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;</td>          <td class="paramname"><span class="paramname"><em>emitError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="#a12cd3f8e7b8c9f2cac6f17ff1dd80cd8">DenseI64ArrayAttr</a> to the provided storage. </p>
<p>It is expected that the storage has the same size as the array. An error is returned if the attribute isn't a <a class="el" href="#a12cd3f8e7b8c9f2cac6f17ff1dd80cd8">DenseI64ArrayAttr</a> or it does not have the same size. If the optional diagnostic is provided an error message is also emitted. </p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00133">133</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

<p class="reference">References <a class="el" href="ODSSupport_8cpp_source.html#l00116">convertDenseArrayFromAttr()</a>, and <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00332">emitError()</a>.</p>

</div>
</div>
<a id="a588ba679548595723d4e190dd6dc80b9" name="a588ba679548595723d4e190dd6dc80b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a588ba679548595723d4e190dd6dc80b9">&#9670;&#160;</a></span>convertFromAttribute() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::convertFromAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>storage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td>          <td class="paramname"><span class="paramname"><em>attr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;</td>          <td class="paramname"><span class="paramname"><em>emitError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="#a8810f74ec6699911bda66ad210693ab9">DenseI32ArrayAttr</a> to the provided storage, which will be cleared before writing. </p>
<p>It is expected that the storage has the same size as the array. An error is returned and emitted to the optional <span class="tt">emitError</span> function if the attribute isn't a <a class="el" href="#a8810f74ec6699911bda66ad210693ab9">DenseI32ArrayAttr</a>. </p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00166">166</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

<p class="reference">References <a class="el" href="ODSSupport_8cpp_source.html#l00116">convertDenseArrayFromAttr()</a>, and <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00332">emitError()</a>.</p>

</div>
</div>
<a id="ae3dd8a9b554ad036fb40ec639db2b065" name="ae3dd8a9b554ad036fb40ec639db2b065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3dd8a9b554ad036fb40ec639db2b065">&#9670;&#160;</a></span>convertFromAttribute() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::convertFromAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>storage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td>          <td class="paramname"><span class="paramname"><em>attr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;</td>          <td class="paramname"><span class="paramname"><em>emitError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="#a12cd3f8e7b8c9f2cac6f17ff1dd80cd8">DenseI64ArrayAttr</a> to the provided storage, which will be cleared before writing. </p>
<p>An error is returned and emitted to the optional <span class="tt">emitError</span> function if the attribute isn't a <a class="el" href="#a12cd3f8e7b8c9f2cac6f17ff1dd80cd8">DenseI64ArrayAttr</a>. </p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00160">160</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

<p class="reference">References <a class="el" href="ODSSupport_8cpp_source.html#l00116">convertDenseArrayFromAttr()</a>, and <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00332">emitError()</a>.</p>

</div>
</div>
<a id="a9846d2959aaf3565b6e538b320b19c4a" name="a9846d2959aaf3565b6e538b320b19c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9846d2959aaf3565b6e538b320b19c4a">&#9670;&#160;</a></span>convertFromAttribute() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::convertFromAttribute </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>storage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td>          <td class="paramname"><span class="paramname"><em>attr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;</td>          <td class="paramname"><span class="paramname"><em>emitError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the string from <span class="tt">attr</span> into <span class="tt">storage</span>. </p>
<p>If <span class="tt">attr</span> is not a <span class="tt">StringAttr</span>, return failure and emit an error into the diagnostic from <span class="tt">emitError</span>. </p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00086">86</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00332">emitError()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="af70830e5507912cdb5082955f8517fb9" name="af70830e5507912cdb5082955f8517fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70830e5507912cdb5082955f8517fb9">&#9670;&#160;</a></span>convertFromAttribute() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::convertFromAttribute </td>
          <td>(</td>
          <td class="paramtype">uint8_t &amp;</td>          <td class="paramname"><span class="paramname"><em>storage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td>          <td class="paramname"><span class="paramname"><em>attr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;</td>          <td class="paramname"><span class="paramname"><em>emitError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an IntegerAttr attribute to an uint8_t, or return an error if the attribute isn't an IntegerAttr. </p>
<p>If the optional diagnostic is provided an error message is also emitted. </p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00069">69</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00332">emitError()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="ad3e3642b2d41a31bfc58b6ac09b1b7f1" name="ad3e3642b2d41a31bfc58b6ac09b1b7f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e3642b2d41a31bfc58b6ac09b1b7f1">&#9670;&#160;</a></span>convertFuncOpToLLVMFuncOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; LLVM::LLVMFuncOp &gt; mlir::convertFuncOpToLLVMFuncOp </td>
          <td>(</td>
          <td class="paramtype">FunctionOpInterface</td>          <td class="paramname"><span class="paramname"><em>funcOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConversionPatternRewriter &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SymbolTableCollection.html">SymbolTableCollection</a> *</td>          <td class="paramname"><span class="paramname"><em>symbolTables</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert input FunctionOpInterface operation to LLVMFuncOp by using the provided <a class="el" href="classmlir_1_1LLVMTypeConverter.html" title="Conversion from types to the LLVM IR dialect.">LLVMTypeConverter</a>. </p>
<p>Return failure if failed to so. </p>

<p class="definition">Definition at line <a class="el" href="FuncToLLVM_8cpp_source.html#l00291">291</a> of file <a class="el" href="FuncToLLVM_8cpp_source.html">FuncToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1LLVMTypeConverter.html#a47566416cff1df2ff38a4e46e5bddf1b">mlir::LLVMTypeConverter::convertFunctionSignature()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00064">filterFuncAttributes()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00248">mlir::Operation::getParentWithTrait()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l01000">mlir::SymbolTableCollection::getSymbolTable()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00170">mlir::SymbolTable::insert()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00052">linkageAttrName</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00149">mlir::SymbolTable::remove()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00262">restoreByValRefArgumentType()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00056">shouldUseBarePtrCallConv()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00051">varargsAttrName</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00167">wrapExternalFunction()</a>, and <a class="el" href="FuncToLLVM_8cpp_source.html#l00107">wrapForExternalCallers()</a>.</p>

</div>
</div>
<a id="a5f35c4dea09716bdfb53830c5291b4bb" name="a5f35c4dea09716bdfb53830c5291b4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f35c4dea09716bdfb53830c5291b4bb">&#9670;&#160;</a></span>convertMMAToLLVMType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::convertMMAToLLVMType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1gpu_1_1MMAMatrixType.html">gpu::MMAMatrixType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the LLVMStructureType corresponding to the MMAMatrixType <span class="tt">type</span>. </p>

<p class="definition">Definition at line <a class="el" href="WmmaOpsToNvvm_8cpp_source.html#l00407">407</a> of file <a class="el" href="WmmaOpsToNvvm_8cpp_source.html">WmmaOpsToNvvm.cpp</a>.</p>

<p class="reference">References <a class="el" href="LLVMDialect_8cpp_source.html#l03239">getElementType()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00208">mlir::gpu::MMAMatrixType::getOperand()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00202">mlir::gpu::MMAMatrixType::getShape()</a>, and <a class="el" href="namespacemlir_1_1NVVM.html#ad1dbcf4f9a566998482efa3cadfa5bd7">mlir::NVVM::inferMMAType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00448">configureGpuToNVVMTypeConverter()</a>.</p>

</div>
</div>
<a id="a9b2799e8f52860dadc460b88a8f2df32" name="a9b2799e8f52860dadc460b88a8f2df32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b2799e8f52860dadc460b88a8f2df32">&#9670;&#160;</a></span>convertReassociationIndicesToExprs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 2 &gt;, 2 &gt; mlir::convertReassociationIndicesToExprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>reassociationIndices</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert reassociation indices to affine expressions. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00396">396</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="#addfd4323ef72147332661606b030d04d">getAffineDimExpr()</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00262">indices</a>.</p>

</div>
</div>
<a id="a59a9251459ba0d0ff0b94d3084e429c4" name="a59a9251459ba0d0ff0b94d3084e429c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a9251459ba0d0ff0b94d3084e429c4">&#9670;&#160;</a></span>convertReassociationMapsToIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a>, 2 &gt; mlir::convertReassociationMapsToIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#a9d60419b09330b78865818c679695080">ReassociationExprs</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>reassociationExprs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert Array&lt;Array&lt;AffineExpr&gt;&gt; to Array&lt;Array&lt;int64_t&gt;&gt;. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00433">433</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00262">indices</a>.</p>

</div>
</div>
<a id="a10d383da63b1370b9cf5c13c252b391d" name="a10d383da63b1370b9cf5c13c252b391d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d383da63b1370b9cf5c13c252b391d">&#9670;&#160;</a></span>convertScalarToDtype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::convertScalarToDtype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>operand</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>toType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>isUnsignedCast</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a scalar value <span class="tt">operand</span> to type <span class="tt">toType</span>. </p>
<p>If the value doesn't convert, a warning will be issued and the operand is returned as is (which will presumably yield a verification issue downstream). </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00238">238</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00186">convertScalarToComplexDtype()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00166">convertScalarToFpDtype()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00140">convertScalarToIntDtype()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00338">emitWarning()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00041">mlir::linalg::createMul()</a>, and <a class="el" href="CodegenUtils_8cpp_source.html#l00148">mlir::sparse_tensor::genCast()</a>.</p>

</div>
</div>
<a id="a081568ff8bd9ba6a6dc9a023fe5103d3" name="a081568ff8bd9ba6a6dc9a023fe5103d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081568ff8bd9ba6a6dc9a023fe5103d3">&#9670;&#160;</a></span>convertToAttribute() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::convertToAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>storage</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the provided <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;int32_t&gt;</a> to a <a class="el" href="#a8810f74ec6699911bda66ad210693ab9">DenseI32ArrayAttr</a> attribute. </p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00177">177</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html#a07a6e71658d0790d8e265c0bc364923e">mlir::detail::DenseArrayAttrImpl&lt; int32_t &gt;::get()</a>.</p>

</div>
</div>
<a id="abd5c480f463f3ed7b6369caae8c8d366" name="abd5c480f463f3ed7b6369caae8c8d366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd5c480f463f3ed7b6369caae8c8d366">&#9670;&#160;</a></span>convertToAttribute() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::convertToAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>storage</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the provided <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;int64_t&gt;</a> to a <a class="el" href="#a12cd3f8e7b8c9f2cac6f17ff1dd80cd8">DenseI64ArrayAttr</a> attribute. </p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00172">172</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html#a07a6e71658d0790d8e265c0bc364923e">mlir::detail::DenseArrayAttrImpl&lt; int64_t &gt;::get()</a>.</p>

</div>
</div>
<a id="a2aad04a9375046387a3f9a4bea0293ec" name="a2aad04a9375046387a3f9a4bea0293ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aad04a9375046387a3f9a4bea0293ec">&#9670;&#160;</a></span>convertToAttribute() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::convertToAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>storage</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the given string into a BooleanAttr. </p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00110">110</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01138">mlir::BoolAttr::get()</a>.</p>

</div>
</div>
<a id="a68dfe2bb2693d4a826a40b0c0a7cc362" name="a68dfe2bb2693d4a826a40b0c0a7cc362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68dfe2bb2693d4a826a40b0c0a7cc362">&#9670;&#160;</a></span>convertToAttribute() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::convertToAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>storage</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the given string into a StringAttr. </p>
<p>Note that this takes a reference to the storage of a string property, which is an std::string. </p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00095">95</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

</div>
</div>
<a id="adc7fea0a3f8193ef3ab5dd53c78968f6" name="adc7fea0a3f8193ef3ab5dd53c78968f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7fea0a3f8193ef3ab5dd53c78968f6">&#9670;&#160;</a></span>convertToAttribute() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::convertToAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>storage</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the provided int32_t to an IntegerAttr attribute. </p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00047">47</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

</div>
</div>
<a id="ab81e61402439e0b78cd25dc4ad7eb591" name="ab81e61402439e0b78cd25dc4ad7eb591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab81e61402439e0b78cd25dc4ad7eb591">&#9670;&#160;</a></span>convertToAttribute() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::convertToAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>storage</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the provided <a class="el" href="classint64__t.html">int64_t</a> to an IntegerAttr attribute. </p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00032">32</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

</div>
</div>
<a id="abf99f6ed6149460531799878f061456b" name="abf99f6ed6149460531799878f061456b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf99f6ed6149460531799878f061456b">&#9670;&#160;</a></span>convertToAttribute() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::convertToAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>storage</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the provided int8_t to an IntegerAttr attribute. </p>
<p>Convert the provided int8_t to an IntegerAttr attribute.</p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00063">63</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

</div>
</div>
<a id="a985e89e4699d13cf9ff448d0eefdcb43" name="a985e89e4699d13cf9ff448d0eefdcb43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a985e89e4699d13cf9ff448d0eefdcb43">&#9670;&#160;</a></span>convertToAttribute() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::convertToAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>storage</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the provided uint8_t to an IntegerAttr attribute. </p>
<p>Convert the provided uint8_t to an IntegerAttr attribute.</p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00080">80</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

</div>
</div>
<a id="af7d71d5f26ac7f264365e6fb7a6aadff" name="af7d71d5f26ac7f264365e6fb7a6aadff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d71d5f26ac7f264365e6fb7a6aadff">&#9670;&#160;</a></span>convertVectorToMMAOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::convertVectorToMMAOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>rootOp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert vector ops to MMA matrix operations nested under <span class="tt">rootOp</span>. </p>
<p>This will convert slice of operations that can be legally converted to MMA operations. The rest of the vector operations are left untouched. </p>

<p class="definition">Definition at line <a class="el" href="VectorToGPU_8cpp_source.html#l01240">1240</a> of file <a class="el" href="VectorToGPU_8cpp_source.html">VectorToGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorToGPU_8cpp_source.html#l01092">convertBroadcastOp()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l01069">convertConstantOp()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l01025">convertContractOp()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l01201">convertElementwiseOp()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00210">convertElementwiseOpToMMA()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l01143">convertForOp()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00541">convertTransferReadOp()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00593">convertTransferWriteOp()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l01176">convertYieldOp()</a>, and <a class="el" href="VectorToGPU_8cpp_source.html#l00343">getOpToConvert()</a>.</p>

</div>
</div>
<a id="a8d66f364335bd7ca0a98bb53f82f0a77" name="a8d66f364335bd7ca0a98bb53f82f0a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d66f364335bd7ca0a98bb53f82f0a77">&#9670;&#160;</a></span>convertVectorToNVVMCompatibleMMASync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::convertVectorToNVVMCompatibleMMASync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>rootOp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert vector ops ops nested under <span class="tt">rootOp</span> to vector and GPU operaitons compatible with the <span class="tt">nvvm.mma.sync</span> lowering path. </p>
<p>This will convert a slice of operations that can be legally lowered on this path while the rest of the vector operations are left untouched. </p>

<p class="definition">Definition at line <a class="el" href="VectorToGPU_8cpp_source.html#l01273">1273</a> of file <a class="el" href="VectorToGPU_8cpp_source.html">VectorToGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorToGPU_8cpp_source.html#l00638">convertConstantOpMmaSync()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l01046">convertContractOpToMmaSync()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00949">convertExtractStridedSlice()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l01143">convertForOp()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00865">convertTransferReadToLoads()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00897">convertTransferWriteToStores()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l01176">convertYieldOp()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00268">mlir::Operation::emitError()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00668">mlir::Operation::emitOpError()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00343">getOpToConvert()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a9ea4e1449757972b16f5c9d9ebf06f7e" name="a9ea4e1449757972b16f5c9d9ebf06f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea4e1449757972b16f5c9d9ebf06f7e">&#9670;&#160;</a></span>createArithToAMDGPUConversionPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createArithToAMDGPUConversionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArithToAMDGPU_8cpp_source.html#l00183">183</a> of file <a class="el" href="ArithToAMDGPU_8cpp_source.html">ArithToAMDGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

</div>
</div>
<a id="a475550aae81e6526c54a362053611b6d" name="a475550aae81e6526c54a362053611b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a475550aae81e6526c54a362053611b6d">&#9670;&#160;</a></span>createArithToAMDGPUConversionPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createArithToAMDGPUConversionPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ArithToAMDGPUConversionPassOptions.html">ArithToAMDGPUConversionPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArithToAMDGPU_8cpp_source.html#l00187">187</a> of file <a class="el" href="ArithToAMDGPU_8cpp_source.html">ArithToAMDGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

</div>
</div>
<a id="af8b017eb711247a3aedcfd840058d6b0" name="af8b017eb711247a3aedcfd840058d6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b017eb711247a3aedcfd840058d6b0">&#9670;&#160;</a></span>createArithToAPFloatConversionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createArithToAPFloatConversionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="ArithToAPFloat_8cpp_source.html#l00264">264</a> of file <a class="el" href="ArithToAPFloat_8cpp_source.html">ArithToAPFloat.cpp</a>.</p>

</div>
</div>
<a id="af6d2519a4b195cb45c67a4066656a7cd" name="af6d2519a4b195cb45c67a4066656a7cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d2519a4b195cb45c67a4066656a7cd">&#9670;&#160;</a></span>createArithToArmSMEConversionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createArithToArmSMEConversionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="ArithToArmSME_8cpp_source.html#l00339">339</a> of file <a class="el" href="ArithToArmSME_8cpp_source.html">ArithToArmSME.cpp</a>.</p>

</div>
</div>
<a id="a507fcb8184a7ab0f5bfdaf63ee18a046" name="a507fcb8184a7ab0f5bfdaf63ee18a046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a507fcb8184a7ab0f5bfdaf63ee18a046">&#9670;&#160;</a></span>createArithToLLVMConversionPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createArithToLLVMConversionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArithToLLVM_8cpp_source.html#l00430">430</a> of file <a class="el" href="ArithToLLVM_8cpp_source.html">ArithToLLVM.cpp</a>.</p>

</div>
</div>
<a id="a869453b3961a97d0a4c8d8dc00c73ce5" name="a869453b3961a97d0a4c8d8dc00c73ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a869453b3961a97d0a4c8d8dc00c73ce5">&#9670;&#160;</a></span>createArithToLLVMConversionPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createArithToLLVMConversionPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ArithToLLVMConversionPassOptions.html">ArithToLLVMConversionPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArithToLLVM_8cpp_source.html#l00434">434</a> of file <a class="el" href="ArithToLLVM_8cpp_source.html">ArithToLLVM.cpp</a>.</p>

</div>
</div>
<a id="a0e511207789978d6d07a7c8b6aec4c80" name="a0e511207789978d6d07a7c8b6aec4c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e511207789978d6d07a7c8b6aec4c80">&#9670;&#160;</a></span>createAsyncFuncToAsyncRuntimePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createAsyncFuncToAsyncRuntimePass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00085">85</a> of file <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html">AsyncToAsyncRuntime.cpp</a>.</p>

</div>
</div>
<a id="ac97fb57e86e446cb9d52e54f21a194d8" name="ac97fb57e86e446cb9d52e54f21a194d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac97fb57e86e446cb9d52e54f21a194d8">&#9670;&#160;</a></span>createAsyncParallelForPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createAsyncParallelForPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncParallelFor_8cpp_source.html#l00185">185</a> of file <a class="el" href="AsyncParallelFor_8cpp_source.html">AsyncParallelFor.cpp</a>.</p>

</div>
</div>
<a id="aa3335fc8c681130dac811a245e650554" name="aa3335fc8c681130dac811a245e650554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3335fc8c681130dac811a245e650554">&#9670;&#160;</a></span>createAsyncParallelForPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createAsyncParallelForPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1AsyncParallelForPassOptions.html">AsyncParallelForPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncParallelFor_8cpp_source.html#l00189">189</a> of file <a class="el" href="AsyncParallelFor_8cpp_source.html">AsyncParallelFor.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>.</p>

</div>
</div>
<a id="ab6945fc733c7c670fcbf10239e42bb29" name="ab6945fc733c7c670fcbf10239e42bb29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6945fc733c7c670fcbf10239e42bb29">&#9670;&#160;</a></span>createAsyncRuntimePolicyBasedRefCountingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createAsyncRuntimePolicyBasedRefCountingPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="AsyncRuntimeRefCounting_8cpp_source.html#l00264">264</a> of file <a class="el" href="AsyncRuntimeRefCounting_8cpp_source.html">AsyncRuntimeRefCounting.cpp</a>.</p>

</div>
</div>
<a id="abac416dacbf73937288179c2daa2616b" name="abac416dacbf73937288179c2daa2616b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac416dacbf73937288179c2daa2616b">&#9670;&#160;</a></span>createAsyncRuntimeRefCountingOptPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createAsyncRuntimeRefCountingOptPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="AsyncRuntimeRefCountingOpt_8cpp_source.html#l00339">339</a> of file <a class="el" href="AsyncRuntimeRefCountingOpt_8cpp_source.html">AsyncRuntimeRefCountingOpt.cpp</a>.</p>

</div>
</div>
<a id="a9cc934834f9684342d145bd21f653b08" name="a9cc934834f9684342d145bd21f653b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc934834f9684342d145bd21f653b08">&#9670;&#160;</a></span>createAsyncRuntimeRefCountingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createAsyncRuntimeRefCountingPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="AsyncRuntimeRefCounting_8cpp_source.html#l00414">414</a> of file <a class="el" href="AsyncRuntimeRefCounting_8cpp_source.html">AsyncRuntimeRefCounting.cpp</a>.</p>

</div>
</div>
<a id="a82d800b64d126a8337def630902bd683" name="a82d800b64d126a8337def630902bd683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82d800b64d126a8337def630902bd683">&#9670;&#160;</a></span>createAsyncToAsyncRuntimePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createAsyncToAsyncRuntimePass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00491">491</a> of file <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html">AsyncToAsyncRuntime.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a65742d21a48260fffacf848470b9a16a" name="a65742d21a48260fffacf848470b9a16a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65742d21a48260fffacf848470b9a16a">&#9670;&#160;</a></span>createBubbleDownMemorySpaceCasts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createBubbleDownMemorySpaceCasts </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="BubbleDownMemorySpaceCasts_8cpp_source.html#l00099">99</a> of file <a class="el" href="BubbleDownMemorySpaceCasts_8cpp_source.html">BubbleDownMemorySpaceCasts.cpp</a>.</p>

</div>
</div>
<a id="aab0069355214b578476e81bc909f7f13" name="aab0069355214b578476e81bc909f7f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0069355214b578476e81bc909f7f13">&#9670;&#160;</a></span>createCanonicalizerPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createCanonicalizerPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the Canonicalizer pass, configured with default settings (which can be overridden by pass options on the command line). </p>
<p>Create a Canonicalizer pass. </p>

<p class="definition">Definition at line <a class="el" href="Canonicalizer_8cpp_source.html#l00074">74</a> of file <a class="el" href="Canonicalizer_8cpp_source.html">Canonicalizer.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TosaToLinalgPass_8cpp_source.html#l00080">mlir::tosa::addTosaToLinalgPasses()</a>, <a class="el" href="BufferizationPipelines_8cpp_source.html#l00024">mlir::bufferization::buildBufferDeallocationPipeline()</a>, <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00026">mlir::sparse_tensor::buildSparsifier()</a>, and <a class="el" href="InlinerPass_8cpp_source.html#l00033">defaultInlinerOptPipeline()</a>.</p>

</div>
</div>
<a id="a17657c64dc73dfd6016afa019f76ecef" name="a17657c64dc73dfd6016afa019f76ecef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17657c64dc73dfd6016afa019f76ecef">&#9670;&#160;</a></span>createCanonicalizerPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createCanonicalizerPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>config</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt;</td>          <td class="paramname"><span class="paramname"><em>disabledPatterns</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt;</td>          <td class="paramname"><span class="paramname"><em>enabledPatterns</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the Canonicalizer pass with the specified config. </p>
<p><span class="tt">disabledPatterns</span> is a set of labels used to filter out input patterns with a debug label or debug name in this set. <span class="tt">enabledPatterns</span> is a set of labels used to filter out input patterns that do not have one of the labels in this set. Debug labels must be set explicitly on patterns or when adding them with <span class="tt"><a class="el" href="classmlir_1_1RewritePatternSet.html#a835b8c0cf94941fe57446ad7287613f2" title="An overload of the above add method that allows for attaching a set of debug labels to the attached p...">RewritePatternSet::addWithLabel</a></span>. Debug names may be empty, but patterns created with <span class="tt"><a class="el" href="classmlir_1_1RewritePattern.html#a5aae74689f2b6da24f4a24f07efec5a2" title="This method provides a convenient interface for creating and initializing derived rewrite patterns of...">RewritePattern::create</a></span> have their default debug name set to their type name. </p>

<p class="definition">Definition at line <a class="el" href="Canonicalizer_8cpp_source.html#l00080">80</a> of file <a class="el" href="Canonicalizer_8cpp_source.html">Canonicalizer.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00284">config</a>.</p>

</div>
</div>
<a id="ab8e0778cc3708a3881957164fa36c9cb" name="ab8e0778cc3708a3881957164fa36c9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e0778cc3708a3881957164fa36c9cb">&#9670;&#160;</a></span>createCompositeFixedPointPass() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createCompositeFixedPointPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CompositePass_8cpp_source.html#l00354">354</a> of file <a class="el" href="CompositePass_8cpp_source.html">CompositePass.cpp</a>.</p>

</div>
</div>
<a id="a4acd4fb869596eb21c566f05b73c97a6" name="a4acd4fb869596eb21c566f05b73c97a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4acd4fb869596eb21c566f05b73c97a6">&#9670;&#160;</a></span>createCompositeFixedPointPass() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createCompositeFixedPointPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1CompositeFixedPointPassOptions.html">CompositeFixedPointPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CompositePass_8cpp_source.html#l00358">358</a> of file <a class="el" href="CompositePass_8cpp_source.html">CompositePass.cpp</a>.</p>

</div>
</div>
<a id="a60273f83d83a8fb7e5a1ceebb7a8d4a6" name="a60273f83d83a8fb7e5a1ceebb7a8d4a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60273f83d83a8fb7e5a1ceebb7a8d4a6">&#9670;&#160;</a></span>createCompositeFixedPointPass() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createCompositeFixedPointPass </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>populateFunc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxIterations</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create composite pass, which runs provided set of passes until fixed point or maximum number of iterations reached. </p>

<p class="definition">Definition at line <a class="el" href="CompositePass_8cpp_source.html#l00101">101</a> of file <a class="el" href="CompositePass_8cpp_source.html">CompositePass.cpp</a>.</p>

</div>
</div>
<a id="ac1f1d125e949d2172433639f2f31d3e6" name="ac1f1d125e949d2172433639f2f31d3e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f1d125e949d2172433639f2f31d3e6">&#9670;&#160;</a></span>createControlFlowSinkPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createControlFlowSinkPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to perform control-flow sinking. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowSink_8cpp_source.html#l00056">56</a> of file <a class="el" href="ControlFlowSink_8cpp_source.html">ControlFlowSink.cpp</a>.</p>

</div>
</div>
<a id="a65e0082a0c034149c2dc108c8c3a35d5" name="a65e0082a0c034149c2dc108c8c3a35d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e0082a0c034149c2dc108c8c3a35d5">&#9670;&#160;</a></span>createConvertAffineForToGPUPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertAffineForToGPUPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SCFToGPUPass_8cpp_source.html#l00624">624</a> of file <a class="el" href="SCFToGPUPass_8cpp_source.html">SCFToGPUPass.cpp</a>.</p>

</div>
</div>
<a id="a2a918000f7a6ce2a1c73a01b3c9da53b" name="a2a918000f7a6ce2a1c73a01b3c9da53b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a918000f7a6ce2a1c73a01b3c9da53b">&#9670;&#160;</a></span>createConvertAffineForToGPUPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertAffineForToGPUPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConvertAffineForToGPUPassOptions.html">ConvertAffineForToGPUPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SCFToGPUPass_8cpp_source.html#l00628">628</a> of file <a class="el" href="SCFToGPUPass_8cpp_source.html">SCFToGPUPass.cpp</a>.</p>

</div>
</div>
<a id="aa083993aa21f3e0bf1bb1ab0bb8635ab" name="aa083993aa21f3e0bf1bb1ab0bb8635ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa083993aa21f3e0bf1bb1ab0bb8635ab">&#9670;&#160;</a></span>createConvertAMDGPUToROCDLPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertAMDGPUToROCDLPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00526">526</a> of file <a class="el" href="AMDGPUToROCDL_8cpp_source.html">AMDGPUToROCDL.cpp</a>.</p>

</div>
</div>
<a id="a4017e5cc455b5d82071989ef4f2f6c3c" name="a4017e5cc455b5d82071989ef4f2f6c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4017e5cc455b5d82071989ef4f2f6c3c">&#9670;&#160;</a></span>createConvertAMDGPUToROCDLPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertAMDGPUToROCDLPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConvertAMDGPUToROCDLPassOptions.html">ConvertAMDGPUToROCDLPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00530">530</a> of file <a class="el" href="AMDGPUToROCDL_8cpp_source.html">AMDGPUToROCDL.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l01923">load</a>.</p>

</div>
</div>
<a id="ae9e5f085e5bf7b4d6bea4a0eb03eda2b" name="ae9e5f085e5bf7b4d6bea4a0eb03eda2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e5f085e5bf7b4d6bea4a0eb03eda2b">&#9670;&#160;</a></span>createConvertArithToEmitC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertArithToEmitC </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="ArithToEmitCPass_8cpp_source.html#l00703">703</a> of file <a class="el" href="ArithToEmitCPass_8cpp_source.html">ArithToEmitCPass.cpp</a>.</p>

</div>
</div>
<a id="ad4e9ed69e63947b5506617f4f1063f6d" name="ad4e9ed69e63947b5506617f4f1063f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e9ed69e63947b5506617f4f1063f6d">&#9670;&#160;</a></span>createConvertArithToSPIRVPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertArithToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArithToSPIRV_8cpp_source.html#l00797">797</a> of file <a class="el" href="ArithToSPIRV_8cpp_source.html">ArithToSPIRV.cpp</a>.</p>

</div>
</div>
<a id="ad3c1232b682090989b5a5d80a3a919e1" name="ad3c1232b682090989b5a5d80a3a919e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c1232b682090989b5a5d80a3a919e1">&#9670;&#160;</a></span>createConvertArithToSPIRVPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertArithToSPIRVPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConvertArithToSPIRVPassOptions.html">ConvertArithToSPIRVPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArithToSPIRV_8cpp_source.html#l00801">801</a> of file <a class="el" href="ArithToSPIRV_8cpp_source.html">ArithToSPIRV.cpp</a>.</p>

</div>
</div>
<a id="aeada37b101a8a8f4b5b5975caef23708" name="aeada37b101a8a8f4b5b5975caef23708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeada37b101a8a8f4b5b5975caef23708">&#9670;&#160;</a></span>createConvertArmNeon2dToIntrPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertArmNeon2dToIntrPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="ArmNeon2dToIntr_8cpp_source.html#l00877">877</a> of file <a class="el" href="ArmNeon2dToIntr_8cpp_source.html">ArmNeon2dToIntr.cpp</a>.</p>

</div>
</div>
<a id="a0d03e883b6465225cf16db9093a723a4" name="a0d03e883b6465225cf16db9093a723a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d03e883b6465225cf16db9093a723a4">&#9670;&#160;</a></span>createConvertArmSMEToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertArmSMEToLLVMPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>dumpTileLiveRanges</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert from the ArmSME dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8cpp_source.html#l01019">1019</a> of file <a class="el" href="ArmSMEToLLVM_8cpp_source.html">ArmSMEToLLVM.cpp</a>.</p>

</div>
</div>
<a id="aac12f43746d5385a542cd23d12ccb57f" name="aac12f43746d5385a542cd23d12ccb57f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac12f43746d5385a542cd23d12ccb57f">&#9670;&#160;</a></span>createConvertArmSMEToSCFPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertArmSMEToSCFPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="ArmSMEToSCF_8cpp_source.html#l01025">1025</a> of file <a class="el" href="ArmSMEToSCF_8cpp_source.html">ArmSMEToSCF.cpp</a>.</p>

</div>
</div>
<a id="a38c75607baf7328ba37ae32a08f9e009" name="a38c75607baf7328ba37ae32a08f9e009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c75607baf7328ba37ae32a08f9e009">&#9670;&#160;</a></span>createConvertAsyncToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertAsyncToLLVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="AsyncToLLVM_8cpp_source.html#l01103">1103</a> of file <a class="el" href="AsyncToLLVM_8cpp_source.html">AsyncToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="ade3763de82d4fba131f0010992126621" name="ade3763de82d4fba131f0010992126621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade3763de82d4fba131f0010992126621">&#9670;&#160;</a></span>createConvertBufferizationToMemRefPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertBufferizationToMemRefPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="BufferizationToMemRef_8cpp_source.html#l01181">1181</a> of file <a class="el" href="BufferizationToMemRef_8cpp_source.html">BufferizationToMemRef.cpp</a>.</p>

</div>
</div>
<a id="a61fda0d5c3eb200116f60053d59e5528" name="a61fda0d5c3eb200116f60053d59e5528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61fda0d5c3eb200116f60053d59e5528">&#9670;&#160;</a></span>createConvertComplexToLibm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertComplexToLibm </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="ComplexToLibm_8cpp_source.html#l01355">1355</a> of file <a class="el" href="ComplexToLibm_8cpp_source.html">ComplexToLibm.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00026">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="ac4779d7d240bcf47cd9247db82bade76" name="ac4779d7d240bcf47cd9247db82bade76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4779d7d240bcf47cd9247db82bade76">&#9670;&#160;</a></span>createConvertComplexToLLVMPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertComplexToLLVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ComplexToLLVM_8cpp_source.html#l01276">1276</a> of file <a class="el" href="ComplexToLLVM_8cpp_source.html">ComplexToLLVM.cpp</a>.</p>

</div>
</div>
<a id="af53ae6c99a55d97eacebe9bdc552719e" name="af53ae6c99a55d97eacebe9bdc552719e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af53ae6c99a55d97eacebe9bdc552719e">&#9670;&#160;</a></span>createConvertComplexToLLVMPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertComplexToLLVMPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConvertComplexToLLVMPassOptions.html">ConvertComplexToLLVMPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ComplexToLLVM_8cpp_source.html#l01280">1280</a> of file <a class="el" href="ComplexToLLVM_8cpp_source.html">ComplexToLLVM.cpp</a>.</p>

</div>
</div>
<a id="a8ba495abfca808b741f66ce7c705d555" name="a8ba495abfca808b741f66ce7c705d555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba495abfca808b741f66ce7c705d555">&#9670;&#160;</a></span>createConvertComplexToROCDLLibraryCalls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertComplexToROCDLLibraryCalls </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="ComplexToROCDLLibraryCalls_8cpp_source.html#l01430">1430</a> of file <a class="el" href="ComplexToROCDLLibraryCalls_8cpp_source.html">ComplexToROCDLLibraryCalls.cpp</a>.</p>

</div>
</div>
<a id="a3e83041b29f7ab74ae4b3e9f46eed21b" name="a3e83041b29f7ab74ae4b3e9f46eed21b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e83041b29f7ab74ae4b3e9f46eed21b">&#9670;&#160;</a></span>createConvertComplexToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertComplexToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="ComplexToSPIRVPass_8cpp_source.html#l01505">1505</a> of file <a class="el" href="ComplexToSPIRVPass_8cpp_source.html">ComplexToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="af646df22dbb01422dd0b5a4049d6f4e8" name="af646df22dbb01422dd0b5a4049d6f4e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af646df22dbb01422dd0b5a4049d6f4e8">&#9670;&#160;</a></span>createConvertComplexToStandardPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertComplexToStandardPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ComplexToStandard_8cpp_source.html#l01600">1600</a> of file <a class="el" href="ComplexToStandard_8cpp_source.html">ComplexToStandard.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00026">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="a75048af68744f1331c991bdfa8fb34d0" name="a75048af68744f1331c991bdfa8fb34d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75048af68744f1331c991bdfa8fb34d0">&#9670;&#160;</a></span>createConvertComplexToStandardPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertComplexToStandardPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConvertComplexToStandardPassOptions.html">ConvertComplexToStandardPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ComplexToStandard_8cpp_source.html#l01604">1604</a> of file <a class="el" href="ComplexToStandard_8cpp_source.html">ComplexToStandard.cpp</a>.</p>

</div>
</div>
<a id="a186d55a9e0ad2211dd27698e79de89cb" name="a186d55a9e0ad2211dd27698e79de89cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a186d55a9e0ad2211dd27698e79de89cb">&#9670;&#160;</a></span>createConvertControlFlowToLLVMPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertControlFlowToLLVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ControlFlowToLLVM_8cpp_source.html#l01695">1695</a> of file <a class="el" href="ControlFlowToLLVM_8cpp_source.html">ControlFlowToLLVM.cpp</a>.</p>

</div>
</div>
<a id="aed27a49008e48ed98d7bbf0067906b33" name="aed27a49008e48ed98d7bbf0067906b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed27a49008e48ed98d7bbf0067906b33">&#9670;&#160;</a></span>createConvertControlFlowToLLVMPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertControlFlowToLLVMPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConvertControlFlowToLLVMPassOptions.html">ConvertControlFlowToLLVMPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ControlFlowToLLVM_8cpp_source.html#l01699">1699</a> of file <a class="el" href="ControlFlowToLLVM_8cpp_source.html">ControlFlowToLLVM.cpp</a>.</p>

</div>
</div>
<a id="abf1498f0d073cb4c49e5a763b9c3c55f" name="abf1498f0d073cb4c49e5a763b9c3c55f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf1498f0d073cb4c49e5a763b9c3c55f">&#9670;&#160;</a></span>createConvertControlFlowToSPIRVPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertControlFlowToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ControlFlowToSPIRVPass_8cpp_source.html#l01793">1793</a> of file <a class="el" href="ControlFlowToSPIRVPass_8cpp_source.html">ControlFlowToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="ac7c0885f10a7457c587e44c684886a5b" name="ac7c0885f10a7457c587e44c684886a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7c0885f10a7457c587e44c684886a5b">&#9670;&#160;</a></span>createConvertControlFlowToSPIRVPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertControlFlowToSPIRVPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConvertControlFlowToSPIRVPassOptions.html">ConvertControlFlowToSPIRVPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ControlFlowToSPIRVPass_8cpp_source.html#l01797">1797</a> of file <a class="el" href="ControlFlowToSPIRVPass_8cpp_source.html">ControlFlowToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="a87bf9d304f6607cd11c69e7b49340c44" name="a87bf9d304f6607cd11c69e7b49340c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87bf9d304f6607cd11c69e7b49340c44">&#9670;&#160;</a></span>createConvertElementwiseToLinalgPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertElementwiseToLinalgPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseToLinalg_8cpp_source.html#l00093">93</a> of file <a class="el" href="ElementwiseToLinalg_8cpp_source.html">ElementwiseToLinalg.cpp</a>.</p>

</div>
</div>
<a id="a50d94c02c41915a9b99d745c504ab2a3" name="a50d94c02c41915a9b99d745c504ab2a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50d94c02c41915a9b99d745c504ab2a3">&#9670;&#160;</a></span>createConvertFuncToEmitC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertFuncToEmitC </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="FuncToEmitCPass_8cpp_source.html#l01872">1872</a> of file <a class="el" href="FuncToEmitCPass_8cpp_source.html">FuncToEmitCPass.cpp</a>.</p>

</div>
</div>
<a id="a3cd85763bbf05717c6013952a6369f2b" name="a3cd85763bbf05717c6013952a6369f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd85763bbf05717c6013952a6369f2b">&#9670;&#160;</a></span>createConvertFuncToLLVMPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertFuncToLLVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FuncToLLVM_8cpp_source.html#l01966">1966</a> of file <a class="el" href="FuncToLLVM_8cpp_source.html">FuncToLLVM.cpp</a>.</p>

</div>
</div>
<a id="a7ada9b98e2e5412609e62b930fd273e0" name="a7ada9b98e2e5412609e62b930fd273e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ada9b98e2e5412609e62b930fd273e0">&#9670;&#160;</a></span>createConvertFuncToLLVMPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertFuncToLLVMPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConvertFuncToLLVMPassOptions.html">ConvertFuncToLLVMPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FuncToLLVM_8cpp_source.html#l01970">1970</a> of file <a class="el" href="FuncToLLVM_8cpp_source.html">FuncToLLVM.cpp</a>.</p>

</div>
</div>
<a id="acba6fd5ddcaf2a0d3b0e45b107806a02" name="acba6fd5ddcaf2a0d3b0e45b107806a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba6fd5ddcaf2a0d3b0e45b107806a02">&#9670;&#160;</a></span>createConvertFuncToSPIRVPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertFuncToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FuncToSPIRVPass_8cpp_source.html#l02064">2064</a> of file <a class="el" href="FuncToSPIRVPass_8cpp_source.html">FuncToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="a8b5b53cb421dcd6a0dc062b212608465" name="a8b5b53cb421dcd6a0dc062b212608465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5b53cb421dcd6a0dc062b212608465">&#9670;&#160;</a></span>createConvertFuncToSPIRVPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertFuncToSPIRVPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConvertFuncToSPIRVPassOptions.html">ConvertFuncToSPIRVPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FuncToSPIRVPass_8cpp_source.html#l02068">2068</a> of file <a class="el" href="FuncToSPIRVPass_8cpp_source.html">FuncToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="a376a66b8b08ee5a3b605beff24e374c7" name="a376a66b8b08ee5a3b605beff24e374c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a376a66b8b08ee5a3b605beff24e374c7">&#9670;&#160;</a></span>createConvertGpuOpsToLLVMSPVOps() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertGpuOpsToLLVMSPVOps </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GPUToLLVMSPV_8cpp_source.html#l02229">2229</a> of file <a class="el" href="GPUToLLVMSPV_8cpp_source.html">GPUToLLVMSPV.cpp</a>.</p>

</div>
</div>
<a id="a9ad74b2b5a93c7958c4ae4fd1525e293" name="a9ad74b2b5a93c7958c4ae4fd1525e293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad74b2b5a93c7958c4ae4fd1525e293">&#9670;&#160;</a></span>createConvertGpuOpsToLLVMSPVOps() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertGpuOpsToLLVMSPVOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConvertGpuOpsToLLVMSPVOpsOptions.html">ConvertGpuOpsToLLVMSPVOpsOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GPUToLLVMSPV_8cpp_source.html#l02233">2233</a> of file <a class="el" href="GPUToLLVMSPV_8cpp_source.html">GPUToLLVMSPV.cpp</a>.</p>

</div>
</div>
<a id="a7b94a230d24902eee1e12901c6c7d73c" name="a7b94a230d24902eee1e12901c6c7d73c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b94a230d24902eee1e12901c6c7d73c">&#9670;&#160;</a></span>createConvertGpuOpsToNVVMOps() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertGpuOpsToNVVMOps </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l02338">2338</a> of file <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html">LowerGpuOpsToNVVMOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00026">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="abf833dbc1ed830908b1219a3a5493d1b" name="abf833dbc1ed830908b1219a3a5493d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf833dbc1ed830908b1219a3a5493d1b">&#9670;&#160;</a></span>createConvertGpuOpsToNVVMOps() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertGpuOpsToNVVMOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConvertGpuOpsToNVVMOpsOptions.html">ConvertGpuOpsToNVVMOpsOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l02342">2342</a> of file <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html">LowerGpuOpsToNVVMOps.cpp</a>.</p>

</div>
</div>
<a id="a97b88c9831e2b5cd3173dd64fd52bc0b" name="a97b88c9831e2b5cd3173dd64fd52bc0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b88c9831e2b5cd3173dd64fd52bc0b">&#9670;&#160;</a></span>createConvertGpuOpsToROCDLOps() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertGpuOpsToROCDLOps </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html#l02453">2453</a> of file <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html">LowerGpuOpsToROCDLOps.cpp</a>.</p>

</div>
</div>
<a id="a8e949f5ac36d161612dc0a5143e6e2ca" name="a8e949f5ac36d161612dc0a5143e6e2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e949f5ac36d161612dc0a5143e6e2ca">&#9670;&#160;</a></span>createConvertGpuOpsToROCDLOps() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertGpuOpsToROCDLOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConvertGpuOpsToROCDLOpsOptions.html">ConvertGpuOpsToROCDLOpsOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html#l02457">2457</a> of file <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html">LowerGpuOpsToROCDLOps.cpp</a>.</p>

</div>
</div>
<a id="a112698688acfebc3284b59e6ffa4d155" name="a112698688acfebc3284b59e6ffa4d155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a112698688acfebc3284b59e6ffa4d155">&#9670;&#160;</a></span>createConvertGPUToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertGPUToSPIRVPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>mapMemorySpace</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert GPU kernel ops to corresponding SPIR-V ops. </p>
<p>For a gpu.func to be converted, it should have a spirv.entry_point_abi attribute. If <span class="tt">mapMemorySpace</span> is true, performs MemRef memory space to SPIR-V mapping according to default Vulkan rules first. </p>

<p class="definition">Definition at line <a class="el" href="GPUToSPIRVPass_8cpp_source.html#l00190">190</a> of file <a class="el" href="GPUToSPIRVPass_8cpp_source.html">GPUToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="a3f76629f036b1d575042d01a4f1d0de3" name="a3f76629f036b1d575042d01a4f1d0de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f76629f036b1d575042d01a4f1d0de3">&#9670;&#160;</a></span>createConvertIndexToLLVMPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertIndexToLLVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IndexToLLVM_8cpp_source.html#l02548">2548</a> of file <a class="el" href="IndexToLLVM_8cpp_source.html">IndexToLLVM.cpp</a>.</p>

</div>
</div>
<a id="a7125b727c78c0f4da39fd87400420893" name="a7125b727c78c0f4da39fd87400420893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7125b727c78c0f4da39fd87400420893">&#9670;&#160;</a></span>createConvertIndexToLLVMPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertIndexToLLVMPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConvertIndexToLLVMPassOptions.html">ConvertIndexToLLVMPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IndexToLLVM_8cpp_source.html#l02552">2552</a> of file <a class="el" href="IndexToLLVM_8cpp_source.html">IndexToLLVM.cpp</a>.</p>

</div>
</div>
<a id="a5fd0d8a04f6db022c24e51e8d85a35d7" name="a5fd0d8a04f6db022c24e51e8d85a35d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd0d8a04f6db022c24e51e8d85a35d7">&#9670;&#160;</a></span>createConvertIndexToSPIRVPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertIndexToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IndexToSPIRV_8cpp_source.html#l02643">2643</a> of file <a class="el" href="IndexToSPIRV_8cpp_source.html">IndexToSPIRV.cpp</a>.</p>

</div>
</div>
<a id="a64ad1652971668791e6f5ba89c909e46" name="a64ad1652971668791e6f5ba89c909e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ad1652971668791e6f5ba89c909e46">&#9670;&#160;</a></span>createConvertIndexToSPIRVPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertIndexToSPIRVPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConvertIndexToSPIRVPassOptions.html">ConvertIndexToSPIRVPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IndexToSPIRV_8cpp_source.html#l02647">2647</a> of file <a class="el" href="IndexToSPIRV_8cpp_source.html">IndexToSPIRV.cpp</a>.</p>

</div>
</div>
<a id="aa3fa0f0614b756066964736719ed3209" name="aa3fa0f0614b756066964736719ed3209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3fa0f0614b756066964736719ed3209">&#9670;&#160;</a></span>createConvertLinalgToAffineLoopsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertLinalgToAffineLoopsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00170">170</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

</div>
</div>
<a id="aea3a07f65a47ca64033c943bd31687e5" name="aea3a07f65a47ca64033c943bd31687e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3a07f65a47ca64033c943bd31687e5">&#9670;&#160;</a></span>createConvertLinalgToLoopsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertLinalgToLoopsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00247">247</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00026">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="ae26b9d40f9bde7098b22814ca7bf9fc9" name="ae26b9d40f9bde7098b22814ca7bf9fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26b9d40f9bde7098b22814ca7bf9fc9">&#9670;&#160;</a></span>createConvertLinalgToParallelLoopsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertLinalgToParallelLoopsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00325">325</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

</div>
</div>
<a id="aa411ac3594c82f6156e8a0184a9dec33" name="aa411ac3594c82f6156e8a0184a9dec33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa411ac3594c82f6156e8a0184a9dec33">&#9670;&#160;</a></span>createConvertLinalgToStandardPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertLinalgToStandardPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="LinalgToStandard_8cpp_source.html#l02723">2723</a> of file <a class="el" href="LinalgToStandard_8cpp_source.html">LinalgToStandard.cpp</a>.</p>

</div>
</div>
<a id="a9382090f3dedaf4324ac78b2acaf61b6" name="a9382090f3dedaf4324ac78b2acaf61b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9382090f3dedaf4324ac78b2acaf61b6">&#9670;&#160;</a></span>createConvertMathToEmitC() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertMathToEmitC </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MathToEmitCPass_8cpp_source.html#l02817">2817</a> of file <a class="el" href="MathToEmitCPass_8cpp_source.html">MathToEmitCPass.cpp</a>.</p>

</div>
</div>
<a id="aefc28a755eb90665e204d8a5101a1b97" name="aefc28a755eb90665e204d8a5101a1b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc28a755eb90665e204d8a5101a1b97">&#9670;&#160;</a></span>createConvertMathToEmitC() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertMathToEmitC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConvertMathToEmitCOptions.html">ConvertMathToEmitCOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MathToEmitCPass_8cpp_source.html#l02821">2821</a> of file <a class="el" href="MathToEmitCPass_8cpp_source.html">MathToEmitCPass.cpp</a>.</p>

</div>
</div>
<a id="af9f4a684326a0b7e9176f9389522d56c" name="af9f4a684326a0b7e9176f9389522d56c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9f4a684326a0b7e9176f9389522d56c">&#9670;&#160;</a></span>createConvertMathToFuncs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertMathToFuncs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MathToFuncs_8cpp_source.html#l02920">2920</a> of file <a class="el" href="MathToFuncs_8cpp_source.html">MathToFuncs.cpp</a>.</p>

</div>
</div>
<a id="a5cc3bd8947eb1c45ca1d9f0f463d3521" name="a5cc3bd8947eb1c45ca1d9f0f463d3521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc3bd8947eb1c45ca1d9f0f463d3521">&#9670;&#160;</a></span>createConvertMathToFuncs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertMathToFuncs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConvertMathToFuncsOptions.html">ConvertMathToFuncsOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MathToFuncs_8cpp_source.html#l02924">2924</a> of file <a class="el" href="MathToFuncs_8cpp_source.html">MathToFuncs.cpp</a>.</p>

</div>
</div>
<a id="a81462a9b7179f12733bf70e3fdbb18f5" name="a81462a9b7179f12733bf70e3fdbb18f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81462a9b7179f12733bf70e3fdbb18f5">&#9670;&#160;</a></span>createConvertMathToLibmPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertMathToLibmPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="MathToLibm_8cpp_source.html#l03096">3096</a> of file <a class="el" href="MathToLibm_8cpp_source.html">MathToLibm.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00026">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="a20c6992fa94a95d8940091b1ad3e6a84" name="a20c6992fa94a95d8940091b1ad3e6a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c6992fa94a95d8940091b1ad3e6a84">&#9670;&#160;</a></span>createConvertMathToLLVMPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertMathToLLVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MathToLLVM_8cpp_source.html#l03015">3015</a> of file <a class="el" href="MathToLLVM_8cpp_source.html">MathToLLVM.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00026">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="a62c0746839de489fca70914299d3fb8b" name="a62c0746839de489fca70914299d3fb8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62c0746839de489fca70914299d3fb8b">&#9670;&#160;</a></span>createConvertMathToLLVMPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertMathToLLVMPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConvertMathToLLVMPassOptions.html">ConvertMathToLLVMPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MathToLLVM_8cpp_source.html#l03019">3019</a> of file <a class="el" href="MathToLLVM_8cpp_source.html">MathToLLVM.cpp</a>.</p>

</div>
</div>
<a id="afeb08f0c6ed2eeff505cd7f1c0108ff9" name="afeb08f0c6ed2eeff505cd7f1c0108ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeb08f0c6ed2eeff505cd7f1c0108ff9">&#9670;&#160;</a></span>createConvertMathToROCDL() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertMathToROCDL </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MathToROCDL_8cpp_source.html#l03190">3190</a> of file <a class="el" href="MathToROCDL_8cpp_source.html">MathToROCDL.cpp</a>.</p>

</div>
</div>
<a id="ac17d7f9f4357dd23c8f47b9c50b52452" name="ac17d7f9f4357dd23c8f47b9c50b52452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17d7f9f4357dd23c8f47b9c50b52452">&#9670;&#160;</a></span>createConvertMathToROCDL() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertMathToROCDL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConvertMathToROCDLOptions.html">ConvertMathToROCDLOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MathToROCDL_8cpp_source.html#l03194">3194</a> of file <a class="el" href="MathToROCDL_8cpp_source.html">MathToROCDL.cpp</a>.</p>

</div>
</div>
<a id="a86aacb673b7337d20c260608d32bb0cc" name="a86aacb673b7337d20c260608d32bb0cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86aacb673b7337d20c260608d32bb0cc">&#9670;&#160;</a></span>createConvertMathToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertMathToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="MathToSPIRVPass_8cpp_source.html#l03269">3269</a> of file <a class="el" href="MathToSPIRVPass_8cpp_source.html">MathToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="aad4c0e02f0f005e3b081ee3b87994e6f" name="aad4c0e02f0f005e3b081ee3b87994e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4c0e02f0f005e3b081ee3b87994e6f">&#9670;&#160;</a></span>createConvertMathToXeVM() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertMathToXeVM </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MathToXeVM_8cpp_source.html#l03362">3362</a> of file <a class="el" href="MathToXeVM_8cpp_source.html">MathToXeVM.cpp</a>.</p>

</div>
</div>
<a id="a555029f09987c02ffba665df2c413d5e" name="a555029f09987c02ffba665df2c413d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a555029f09987c02ffba665df2c413d5e">&#9670;&#160;</a></span>createConvertMathToXeVM() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertMathToXeVM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConvertMathToXeVMOptions.html">ConvertMathToXeVMOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MathToXeVM_8cpp_source.html#l03366">3366</a> of file <a class="el" href="MathToXeVM_8cpp_source.html">MathToXeVM.cpp</a>.</p>

</div>
</div>
<a id="a289a1a3d1f32d2d642f37fb063962cfe" name="a289a1a3d1f32d2d642f37fb063962cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a289a1a3d1f32d2d642f37fb063962cfe">&#9670;&#160;</a></span>createConvertMemRefToEmitC() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertMemRefToEmitC </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefToEmitCPass_8cpp_source.html#l03457">3457</a> of file <a class="el" href="MemRefToEmitCPass_8cpp_source.html">MemRefToEmitCPass.cpp</a>.</p>

</div>
</div>
<a id="a5ed1c375934742418ad52b06b791ad2a" name="a5ed1c375934742418ad52b06b791ad2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed1c375934742418ad52b06b791ad2a">&#9670;&#160;</a></span>createConvertMemRefToEmitC() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertMemRefToEmitC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConvertMemRefToEmitCOptions.html">ConvertMemRefToEmitCOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefToEmitCPass_8cpp_source.html#l03461">3461</a> of file <a class="el" href="MemRefToEmitCPass_8cpp_source.html">MemRefToEmitCPass.cpp</a>.</p>

</div>
</div>
<a id="aa6db3aed9de7791d0da0aa2e4f627e9b" name="aa6db3aed9de7791d0da0aa2e4f627e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6db3aed9de7791d0da0aa2e4f627e9b">&#9670;&#160;</a></span>createConvertMemRefToSPIRVPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertMemRefToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefToSPIRVPass_8cpp_source.html#l03555">3555</a> of file <a class="el" href="MemRefToSPIRVPass_8cpp_source.html">MemRefToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="a296abbfcc8d594fa36e27896fbd2bf04" name="a296abbfcc8d594fa36e27896fbd2bf04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a296abbfcc8d594fa36e27896fbd2bf04">&#9670;&#160;</a></span>createConvertMemRefToSPIRVPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertMemRefToSPIRVPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConvertMemRefToSPIRVPassOptions.html">ConvertMemRefToSPIRVPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefToSPIRVPass_8cpp_source.html#l03559">3559</a> of file <a class="el" href="MemRefToSPIRVPass_8cpp_source.html">MemRefToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="a57ee6b8b9dd79187b2d9986cd37985a5" name="a57ee6b8b9dd79187b2d9986cd37985a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ee6b8b9dd79187b2d9986cd37985a5">&#9670;&#160;</a></span>createConvertNVGPUToNVVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertNVGPUToNVVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="NVGPUToNVVM_8cpp_source.html#l03637">3637</a> of file <a class="el" href="NVGPUToNVVM_8cpp_source.html">NVGPUToNVVM.cpp</a>.</p>

</div>
</div>
<a id="a76fa8e989ba0f8abf1c504b7c084652d" name="a76fa8e989ba0f8abf1c504b7c084652d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76fa8e989ba0f8abf1c504b7c084652d">&#9670;&#160;</a></span>createConvertNVVMToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertNVVMToLLVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="NVVMToLLVM_8cpp_source.html#l03712">3712</a> of file <a class="el" href="NVVMToLLVM_8cpp_source.html">NVVMToLLVM.cpp</a>.</p>

</div>
</div>
<a id="a9058475349363ddfda744bc75829260d" name="a9058475349363ddfda744bc75829260d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9058475349363ddfda744bc75829260d">&#9670;&#160;</a></span>createConvertOpenACCToSCFPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertOpenACCToSCFPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="OpenACCToSCF_8cpp_source.html#l03788">3788</a> of file <a class="el" href="OpenACCToSCF_8cpp_source.html">OpenACCToSCF.cpp</a>.</p>

</div>
</div>
<a id="a30ec3c126d199afce9a94aebff5145a9" name="a30ec3c126d199afce9a94aebff5145a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ec3c126d199afce9a94aebff5145a9">&#9670;&#160;</a></span>createConvertOpenMPToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertOpenMPToLLVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="OpenMPToLLVM_8cpp_source.html#l03863">3863</a> of file <a class="el" href="OpenMPToLLVM_8cpp_source.html">OpenMPToLLVM.cpp</a>.</p>

</div>
</div>
<a id="a35d80ba8973702e9b7f806ebd262aa23" name="a35d80ba8973702e9b7f806ebd262aa23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35d80ba8973702e9b7f806ebd262aa23">&#9670;&#160;</a></span>createConvertParallelLoopToGpuPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertParallelLoopToGpuPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="SCFToGPUPass_8cpp_source.html#l04014">4014</a> of file <a class="el" href="SCFToGPUPass_8cpp_source.html">SCFToGPUPass.cpp</a>.</p>

</div>
</div>
<a id="acda0a7cd5241463af7837d1e4936c235" name="acda0a7cd5241463af7837d1e4936c235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda0a7cd5241463af7837d1e4936c235">&#9670;&#160;</a></span>createConvertPDLToPDLInterpPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertPDLToPDLInterpPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="PDLToPDLInterp_8cpp_source.html#l03938">3938</a> of file <a class="el" href="PDLToPDLInterp_8cpp_source.html">PDLToPDLInterp.cpp</a>.</p>

</div>
</div>
<a id="a3c5ca7d3759b292e4ef08fa8359f88e4" name="a3c5ca7d3759b292e4ef08fa8359f88e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5ca7d3759b292e4ef08fa8359f88e4">&#9670;&#160;</a></span>createConvertPDLToPDLInterpPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertPDLToPDLInterpPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#abde461319ad5039ddbf5b4e70f47618b">DenseMap</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, PDLPatternConfigSet * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>configMap</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a pass to convert PDL ops to PDL interpreter ops. </p>
<p><span class="tt">configMap</span> holds a map of the configurations for each pattern being compiled. </p>

<p class="definition">Definition at line <a class="el" href="PDLToPDLInterp_8cpp_source.html#l01025">1025</a> of file <a class="el" href="PDLToPDLInterp_8cpp_source.html">PDLToPDLInterp.cpp</a>.</p>

</div>
</div>
<a id="a8d70e3a58d98d19afe19bff5cfaa0869" name="a8d70e3a58d98d19afe19bff5cfaa0869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d70e3a58d98d19afe19bff5cfaa0869">&#9670;&#160;</a></span>createConvertSCFToOpenMPPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertSCFToOpenMPPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SCFToOpenMP_8cpp_source.html#l04107">4107</a> of file <a class="el" href="SCFToOpenMP_8cpp_source.html">SCFToOpenMP.cpp</a>.</p>

</div>
</div>
<a id="a3b89b5ca382d3c5fce0e73dd44376d48" name="a3b89b5ca382d3c5fce0e73dd44376d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b89b5ca382d3c5fce0e73dd44376d48">&#9670;&#160;</a></span>createConvertSCFToOpenMPPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertSCFToOpenMPPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConvertSCFToOpenMPPassOptions.html">ConvertSCFToOpenMPPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SCFToOpenMP_8cpp_source.html#l04111">4111</a> of file <a class="el" href="SCFToOpenMP_8cpp_source.html">SCFToOpenMP.cpp</a>.</p>

</div>
</div>
<a id="a6f1a31b691eb03bce755f599963d47c4" name="a6f1a31b691eb03bce755f599963d47c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f1a31b691eb03bce755f599963d47c4">&#9670;&#160;</a></span>createConvertSCFToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt; mlir::createConvertSCFToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert SCF ops into SPIR-V ops. </p>

</div>
</div>
<a id="aef895a2d27d70f7defd52693777fdb75" name="aef895a2d27d70f7defd52693777fdb75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef895a2d27d70f7defd52693777fdb75">&#9670;&#160;</a></span>createConvertShapeConstraintsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertShapeConstraintsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="ConvertShapeConstraints_8cpp_source.html#l04288">4288</a> of file <a class="el" href="ConvertShapeConstraints_8cpp_source.html">ConvertShapeConstraints.cpp</a>.</p>

</div>
</div>
<a id="a47b87d6362d7fb801d72e60f2803855a" name="a47b87d6362d7fb801d72e60f2803855a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b87d6362d7fb801d72e60f2803855a">&#9670;&#160;</a></span>createConvertShapeToStandardPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertShapeToStandardPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="ShapeToStandard_8cpp_source.html#l04363">4363</a> of file <a class="el" href="ShapeToStandard_8cpp_source.html">ShapeToStandard.cpp</a>.</p>

</div>
</div>
<a id="acd00732d75c96e7fc11bed6aae04fa0d" name="acd00732d75c96e7fc11bed6aae04fa0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd00732d75c96e7fc11bed6aae04fa0d">&#9670;&#160;</a></span>createConvertShardToMPIPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertShardToMPIPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="ShardToMPI_8cpp_source.html#l04443">4443</a> of file <a class="el" href="ShardToMPI_8cpp_source.html">ShardToMPI.cpp</a>.</p>

</div>
</div>
<a id="a451cd8ae03097ce35de8b5b75c82c5f3" name="a451cd8ae03097ce35de8b5b75c82c5f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451cd8ae03097ce35de8b5b75c82c5f3">&#9670;&#160;</a></span>createConvertSPIRVToLLVMPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertSPIRVToLLVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRVToLLVMPass_8cpp_source.html#l04208">4208</a> of file <a class="el" href="SPIRVToLLVMPass_8cpp_source.html">SPIRVToLLVMPass.cpp</a>.</p>

</div>
</div>
<a id="a8740a7a0efd3f81919fb62a6a549e5ba" name="a8740a7a0efd3f81919fb62a6a549e5ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8740a7a0efd3f81919fb62a6a549e5ba">&#9670;&#160;</a></span>createConvertSPIRVToLLVMPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertSPIRVToLLVMPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConvertSPIRVToLLVMPassOptions.html">ConvertSPIRVToLLVMPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRVToLLVMPass_8cpp_source.html#l04212">4212</a> of file <a class="el" href="SPIRVToLLVMPass_8cpp_source.html">SPIRVToLLVMPass.cpp</a>.</p>

</div>
</div>
<a id="ae883c3b90eacd7478cb5930c83ffc3cb" name="ae883c3b90eacd7478cb5930c83ffc3cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae883c3b90eacd7478cb5930c83ffc3cb">&#9670;&#160;</a></span>createConvertTensorToLinalgPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertTensorToLinalgPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="TensorToLinalgPass_8cpp_source.html#l04519">4519</a> of file <a class="el" href="TensorToLinalgPass_8cpp_source.html">TensorToLinalgPass.cpp</a>.</p>

</div>
</div>
<a id="a861fc585debe3765517a0260aa6916ca" name="a861fc585debe3765517a0260aa6916ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861fc585debe3765517a0260aa6916ca">&#9670;&#160;</a></span>createConvertTensorToSPIRVPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertTensorToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TensorToSPIRVPass_8cpp_source.html#l04613">4613</a> of file <a class="el" href="TensorToSPIRVPass_8cpp_source.html">TensorToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="a86c1f41dd07b43b24de016cfc52fa5dc" name="a86c1f41dd07b43b24de016cfc52fa5dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c1f41dd07b43b24de016cfc52fa5dc">&#9670;&#160;</a></span>createConvertTensorToSPIRVPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertTensorToSPIRVPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConvertTensorToSPIRVPassOptions.html">ConvertTensorToSPIRVPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TensorToSPIRVPass_8cpp_source.html#l04617">4617</a> of file <a class="el" href="TensorToSPIRVPass_8cpp_source.html">TensorToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="a8b9fc340e94e7b3e50d093c709ac2844" name="a8b9fc340e94e7b3e50d093c709ac2844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9fc340e94e7b3e50d093c709ac2844">&#9670;&#160;</a></span>createConvertToEmitC() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertToEmitC </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertToEmitCPass_8cpp_source.html#l04708">4708</a> of file <a class="el" href="ConvertToEmitCPass_8cpp_source.html">ConvertToEmitCPass.cpp</a>.</p>

</div>
</div>
<a id="a5448d3f1cb655745c6f05c2102e03bed" name="a5448d3f1cb655745c6f05c2102e03bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5448d3f1cb655745c6f05c2102e03bed">&#9670;&#160;</a></span>createConvertToEmitC() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertToEmitC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConvertToEmitCOptions.html">ConvertToEmitCOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertToEmitCPass_8cpp_source.html#l04712">4712</a> of file <a class="el" href="ConvertToEmitCPass_8cpp_source.html">ConvertToEmitCPass.cpp</a>.</p>

</div>
</div>
<a id="a1a6c9896483080d15f6d5612342989e0" name="a1a6c9896483080d15f6d5612342989e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a6c9896483080d15f6d5612342989e0">&#9670;&#160;</a></span>createConvertToLLVMPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertToLLVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertToLLVMPass_8cpp_source.html#l04809">4809</a> of file <a class="el" href="ConvertToLLVMPass_8cpp_source.html">ConvertToLLVMPass.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00026">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="ae0d44395c549de4fd3db08bed63c481b" name="ae0d44395c549de4fd3db08bed63c481b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d44395c549de4fd3db08bed63c481b">&#9670;&#160;</a></span>createConvertToLLVMPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertToLLVMPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConvertToLLVMPassOptions.html">ConvertToLLVMPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertToLLVMPass_8cpp_source.html#l04813">4813</a> of file <a class="el" href="ConvertToLLVMPass_8cpp_source.html">ConvertToLLVMPass.cpp</a>.</p>

</div>
</div>
<a id="ac252f2fe32faedf77083947e2050c011" name="ac252f2fe32faedf77083947e2050c011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac252f2fe32faedf77083947e2050c011">&#9670;&#160;</a></span>createConvertVectorToAMX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertVectorToAMX </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="VectorToAMX_8cpp_source.html#l04893">4893</a> of file <a class="el" href="VectorToAMX_8cpp_source.html">VectorToAMX.cpp</a>.</p>

</div>
</div>
<a id="a439b223f6baa77288a25ac79053cef08" name="a439b223f6baa77288a25ac79053cef08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439b223f6baa77288a25ac79053cef08">&#9670;&#160;</a></span>createConvertVectorToArmSMEPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertVectorToArmSMEPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="VectorToArmSMEPass_8cpp_source.html#l04969">4969</a> of file <a class="el" href="VectorToArmSMEPass_8cpp_source.html">VectorToArmSMEPass.cpp</a>.</p>

</div>
</div>
<a id="ad3e64d4460362ea3cdb2edc8b746396c" name="ad3e64d4460362ea3cdb2edc8b746396c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e64d4460362ea3cdb2edc8b746396c">&#9670;&#160;</a></span>createConvertVectorToGPUPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertVectorToGPUPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>useNvGpu</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert from vector to GPU ops. </p>

<p class="definition">Definition at line <a class="el" href="VectorToGPU_8cpp_source.html#l01343">1343</a> of file <a class="el" href="VectorToGPU_8cpp_source.html">VectorToGPU.cpp</a>.</p>

</div>
</div>
<a id="a4b8cfccc4312bcc74422c9de79a954a0" name="a4b8cfccc4312bcc74422c9de79a954a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b8cfccc4312bcc74422c9de79a954a0">&#9670;&#160;</a></span>createConvertVectorToLLVMPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertVectorToLLVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertVectorToLLVMPass_8cpp_source.html#l05181">5181</a> of file <a class="el" href="ConvertVectorToLLVMPass_8cpp_source.html">ConvertVectorToLLVMPass.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00026">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="ab6b01c628a160f0063c9508358fb6d78" name="ab6b01c628a160f0063c9508358fb6d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b01c628a160f0063c9508358fb6d78">&#9670;&#160;</a></span>createConvertVectorToLLVMPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertVectorToLLVMPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConvertVectorToLLVMPassOptions.html">ConvertVectorToLLVMPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertVectorToLLVMPass_8cpp_source.html#l05185">5185</a> of file <a class="el" href="ConvertVectorToLLVMPass_8cpp_source.html">ConvertVectorToLLVMPass.cpp</a>.</p>

</div>
</div>
<a id="ac5c71e471d7d8cdda288a27d1ae75642" name="ac5c71e471d7d8cdda288a27d1ae75642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c71e471d7d8cdda288a27d1ae75642">&#9670;&#160;</a></span>createConvertVectorToSCFPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertVectorToSCFPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a>()</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert a subset of vector ops to SCF. </p>

<p class="definition">Definition at line <a class="el" href="VectorToSCF_8cpp_source.html#l01758">1758</a> of file <a class="el" href="VectorToSCF_8cpp_source.html">VectorToSCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00026">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="a0b613bd52abde0fb5a56991828a9821c" name="a0b613bd52abde0fb5a56991828a9821c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b613bd52abde0fb5a56991828a9821c">&#9670;&#160;</a></span>createConvertVectorToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertVectorToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="VectorToSPIRVPass_8cpp_source.html#l05342">5342</a> of file <a class="el" href="VectorToSPIRVPass_8cpp_source.html">VectorToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="a97be68bd81a51548109db1fb737dd7d2" name="a97be68bd81a51548109db1fb737dd7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97be68bd81a51548109db1fb737dd7d2">&#9670;&#160;</a></span>createConvertVectorToXeGPU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertVectorToXeGPU </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="VectorToXeGPU_8cpp_source.html#l05420">5420</a> of file <a class="el" href="VectorToXeGPU_8cpp_source.html">VectorToXeGPU.cpp</a>.</p>

</div>
</div>
<a id="a69cb1b43ebb68e7cc8f2262da0e872f5" name="a69cb1b43ebb68e7cc8f2262da0e872f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69cb1b43ebb68e7cc8f2262da0e872f5">&#9670;&#160;</a></span>createConvertXeGPUToXeVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertXeGPUToXeVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUToXeVM_8cpp_source.html#l05502">5502</a> of file <a class="el" href="XeGPUToXeVM_8cpp_source.html">XeGPUToXeVM.cpp</a>.</p>

</div>
</div>
<a id="ace0bd65d05252efbfe03d52ac07f4558" name="ace0bd65d05252efbfe03d52ac07f4558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace0bd65d05252efbfe03d52ac07f4558">&#9670;&#160;</a></span>createConvertXeVMToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createConvertXeVMToLLVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="XeVMToLLVM_8cpp_source.html#l05577">5577</a> of file <a class="el" href="XeVMToLLVM_8cpp_source.html">XeVMToLLVM.cpp</a>.</p>

</div>
</div>
<a id="a14895da9723acd9c7f910c2694ff9f65" name="a14895da9723acd9c7f910c2694ff9f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14895da9723acd9c7f910c2694ff9f65">&#9670;&#160;</a></span>createCSEPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createCSEPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to perform common sub expression elimination. </p>

<p class="definition">Definition at line <a class="el" href="CSE_8cpp_source.html#l00412">412</a> of file <a class="el" href="CSE_8cpp_source.html">CSE.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizationPipelines_8cpp_source.html#l00024">mlir::bufferization::buildBufferDeallocationPipeline()</a>.</p>

</div>
</div>
<a id="a7c4ce1ebc47dbd367b9b8b19ceeafcb3" name="a7c4ce1ebc47dbd367b9b8b19ceeafcb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4ce1ebc47dbd367b9b8b19ceeafcb3">&#9670;&#160;</a></span>createElementwiseOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::createElementwiseOp </td>
          <td>(</td>
          <td class="paramtype">ConversionPatternRewriter &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpu::SubgroupMmaElementwiseOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>coopType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>operands</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a SPIR-V op to replace the given GPU subgroup mma elementwise op when the elementwise op directly supports with cooperative matrix type. </p>
<p>Returns false if cannot.</p>
<p>See SPV_KHR_cooperative_matrix for supported elementwise ops. </p>

<p class="definition">Definition at line <a class="el" href="WmmaOpsToSPIRV_8cpp_source.html#l00040">40</a> of file <a class="el" href="WmmaOpsToSPIRV_8cpp_source.html">WmmaOpsToSPIRV.cpp</a>.</p>

</div>
</div>
<a id="aa5473e3f81c5179664339b3ee0ecd719" name="aa5473e3f81c5179664339b3ee0ecd719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5473e3f81c5179664339b3ee0ecd719">&#9670;&#160;</a></span>createFinalizeMemRefToLLVMConversionPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createFinalizeMemRefToLLVMConversionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefToLLVM_8cpp_source.html#l05674">5674</a> of file <a class="el" href="MemRefToLLVM_8cpp_source.html">MemRefToLLVM.cpp</a>.</p>

</div>
</div>
<a id="a0a7aed2191eed4b1afa5cffb19cbbc2c" name="a0a7aed2191eed4b1afa5cffb19cbbc2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7aed2191eed4b1afa5cffb19cbbc2c">&#9670;&#160;</a></span>createFinalizeMemRefToLLVMConversionPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createFinalizeMemRefToLLVMConversionPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1FinalizeMemRefToLLVMConversionPassOptions.html">FinalizeMemRefToLLVMConversionPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefToLLVM_8cpp_source.html#l05678">5678</a> of file <a class="el" href="MemRefToLLVM_8cpp_source.html">MemRefToLLVM.cpp</a>.</p>

</div>
</div>
<a id="a20e00e282baf336b34a2bb6252d163b3" name="a20e00e282baf336b34a2bb6252d163b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e00e282baf336b34a2bb6252d163b3">&#9670;&#160;</a></span>createForallToForLoopPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createForallToForLoopPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that converts SCF forall loops to SCF for loops. </p>

<p class="definition">Definition at line <a class="el" href="ForallToFor_8cpp_source.html#l00071">71</a> of file <a class="el" href="ForallToFor_8cpp_source.html">ForallToFor.cpp</a>.</p>

</div>
</div>
<a id="a0fe217f8821de800b3899f931875c1c4" name="a0fe217f8821de800b3899f931875c1c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe217f8821de800b3899f931875c1c4">&#9670;&#160;</a></span>createForallToParallelLoopPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createForallToParallelLoopPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that converts SCF forall loops to SCF parallel loops. </p>

<p class="definition">Definition at line <a class="el" href="ForallToParallel_8cpp_source.html#l00081">81</a> of file <a class="el" href="ForallToParallel_8cpp_source.html">ForallToParallel.cpp</a>.</p>

</div>
</div>
<a id="a7acfeadb8fff74a53be77ccf540be99b" name="a7acfeadb8fff74a53be77ccf540be99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7acfeadb8fff74a53be77ccf540be99b">&#9670;&#160;</a></span>createForLoopPeelingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createForLoopPeelingPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that peels for loops at their upper bounds for better vectorization. </p>

<p class="definition">Definition at line <a class="el" href="LoopSpecialization_8cpp_source.html#l00364">364</a> of file <a class="el" href="LoopSpecialization_8cpp_source.html">LoopSpecialization.cpp</a>.</p>

</div>
</div>
<a id="a2a6597022fdb6de5a99b895b2bfc9e0a" name="a2a6597022fdb6de5a99b895b2bfc9e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6597022fdb6de5a99b895b2bfc9e0a">&#9670;&#160;</a></span>createForLoopRangeFoldingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createForLoopRangeFoldingPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which folds arith ops on induction variable into loop range. </p>

<p class="definition">Definition at line <a class="el" href="LoopRangeFolding_8cpp_source.html#l00091">91</a> of file <a class="el" href="LoopRangeFolding_8cpp_source.html">LoopRangeFolding.cpp</a>.</p>

</div>
</div>
<a id="a1d49e4ae28aeaaa552466850cc5e04ec" name="a1d49e4ae28aeaaa552466850cc5e04ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d49e4ae28aeaaa552466850cc5e04ec">&#9670;&#160;</a></span>createForLoopSpecializationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createForLoopSpecializationPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that specializes for loop for unrolling and vectorization. </p>

<p class="definition">Definition at line <a class="el" href="LoopSpecialization_8cpp_source.html#l00360">360</a> of file <a class="el" href="LoopSpecialization_8cpp_source.html">LoopSpecialization.cpp</a>.</p>

</div>
</div>
<a id="a76018eef454fd668d103ea3cc6afc52a" name="a76018eef454fd668d103ea3cc6afc52a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76018eef454fd668d103ea3cc6afc52a">&#9670;&#160;</a></span>createForToWhileLoopPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createForToWhileLoopPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ForToWhile_8cpp_source.html#l00123">123</a> of file <a class="el" href="ForToWhile_8cpp_source.html">ForToWhile.cpp</a>.</p>

</div>
</div>
<a id="a6fdd2528f381177f9ded6de5eba9900b" name="a6fdd2528f381177f9ded6de5eba9900b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fdd2528f381177f9ded6de5eba9900b">&#9670;&#160;</a></span>createGenerateRuntimeVerificationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createGenerateRuntimeVerificationPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that generates IR to verify ops at runtime. </p>

<p class="definition">Definition at line <a class="el" href="GenerateRuntimeVerification_8cpp_source.html#l00103">103</a> of file <a class="el" href="GenerateRuntimeVerification_8cpp_source.html">GenerateRuntimeVerification.cpp</a>.</p>

</div>
</div>
<a id="a501e9247e75ceaa26398973e8ba2ac50" name="a501e9247e75ceaa26398973e8ba2ac50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a501e9247e75ceaa26398973e8ba2ac50">&#9670;&#160;</a></span>createGpuAsyncRegionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createGpuAsyncRegionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="AsyncRegionRewriter_8cpp_source.html#l00089">89</a> of file <a class="el" href="AsyncRegionRewriter_8cpp_source.html">AsyncRegionRewriter.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00069">copy()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00067">mlir::Operation::create()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00534">mlir::Operation::erase()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00501">mlir::Operation::getDiscardableAttrDictionary()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00119">mlir::Operation::getName()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00674">mlir::Operation::getNumRegions()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00404">mlir::Operation::getNumResults()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00378">mlir::Operation::getOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00900">mlir::Operation::getPropertiesStorage()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00677">mlir::Operation::getRegions()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00428">mlir::Operation::getResultTypes()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00703">mlir::Operation::getSuccessors()</a>, <a class="el" href="Builders_8h_source.html#l00091">mlir::Builder::getType()</a>, <a class="el" href="Builders_8cpp_source.html#l00421">mlir::OpBuilder::insert()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00272">mlir::Operation::replaceAllUsesWith()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a8303d57a9212db2fcb7a96de8138b627" name="a8303d57a9212db2fcb7a96de8138b627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8303d57a9212db2fcb7a96de8138b627">&#9670;&#160;</a></span>createGpuDecomposeMemrefsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createGpuDecomposeMemrefsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="DecomposeMemRefs_8cpp_source.html#l00166">166</a> of file <a class="el" href="DecomposeMemRefs_8cpp_source.html">DecomposeMemRefs.cpp</a>.</p>

</div>
</div>
<a id="a82921858a4c71b9795162bd2fe5fce82" name="a82921858a4c71b9795162bd2fe5fce82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82921858a4c71b9795162bd2fe5fce82">&#9670;&#160;</a></span>createGpuEliminateBarriers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createGpuEliminateBarriers </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="EliminateBarriers_8cpp_source.html#l00243">243</a> of file <a class="el" href="EliminateBarriers_8cpp_source.html">EliminateBarriers.cpp</a>.</p>

<p class="reference">References <a class="el" href="EliminateBarriers_8cpp_source.html#l00073">addAllValuelessEffects()</a>, <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>, <a class="el" href="EliminateBarriers_8cpp_source.html#l00086">collectEffects()</a>, <a class="el" href="Block_8h_source.html#l00153">mlir::Block::front()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, <a class="el" href="EliminateBarriers_8cpp_source.html#l00243">getEffectsAfter()</a>, <a class="el" href="EliminateBarriers_8cpp_source.html#l00217">getEffectsAfterInBlock()</a>, <a class="el" href="Block_8cpp_source.html#l00027">mlir::Block::getParent()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>, <a class="el" href="IR_2Region_8h_source.html#l00068">mlir::Region::hasOneBlock()</a>, <a class="el" href="EliminateBarriers_8cpp_source.html#l00060">hasSingleExecutionBody()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00749">mlir::Operation::hasTrait()</a>, <a class="el" href="WalkResult_8h_source.html#l00046">mlir::WalkResult::interrupt()</a>, <a class="el" href="EliminateBarriers_8cpp_source.html#l00046">isParallelRegionBoundary()</a>, <a class="el" href="EliminateBarriers_8cpp_source.html#l00055">isSequentialLoopLike()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00797">mlir::Operation::walk()</a>.</p>

</div>
</div>
<a id="af89bf1dcbff14236cbbb02bf9ca6acd3" name="af89bf1dcbff14236cbbb02bf9ca6acd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af89bf1dcbff14236cbbb02bf9ca6acd3">&#9670;&#160;</a></span>createGpuKernelOutliningPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createGpuKernelOutliningPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="KernelOutlining_8cpp_source.html#l00335">335</a> of file <a class="el" href="KernelOutlining_8cpp_source.html">KernelOutlining.cpp</a>.</p>

<p class="reference">References <a class="el" href="#a6658f887276425945e0ebe6fcc194c23">parseAttribute()</a>.</p>

</div>
</div>
<a id="a283c0d12766f8664ad7c01a2f61a6c32" name="a283c0d12766f8664ad7c01a2f61a6c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a283c0d12766f8664ad7c01a2f61a6c32">&#9670;&#160;</a></span>createGpuKernelOutliningPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createGpuKernelOutliningPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1GpuKernelOutliningPassOptions.html">GpuKernelOutliningPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="KernelOutlining_8cpp_source.html#l00339">339</a> of file <a class="el" href="KernelOutlining_8cpp_source.html">KernelOutlining.cpp</a>.</p>

</div>
</div>
<a id="af1068af4f216444681166b6fcf01c40f" name="af1068af4f216444681166b6fcf01c40f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1068af4f216444681166b6fcf01c40f">&#9670;&#160;</a></span>createGpuLaunchSinkIndexComputationsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createGpuLaunchSinkIndexComputationsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="KernelOutlining_8cpp_source.html#l00414">414</a> of file <a class="el" href="KernelOutlining_8cpp_source.html">KernelOutlining.cpp</a>.</p>

</div>
</div>
<a id="a2a1ca46fd37bc796f482ab4620d95642" name="a2a1ca46fd37bc796f482ab4620d95642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a1ca46fd37bc796f482ab4620d95642">&#9670;&#160;</a></span>createGpuMapParallelLoopsPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createGpuMapParallelLoopsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ParallelLoopMapper_8cpp_source.html#l00505">505</a> of file <a class="el" href="ParallelLoopMapper_8cpp_source.html">ParallelLoopMapper.cpp</a>.</p>

</div>
</div>
<a id="ab4d005bd13585ac6ce5ec48e6d729c61" name="ab4d005bd13585ac6ce5ec48e6d729c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4d005bd13585ac6ce5ec48e6d729c61">&#9670;&#160;</a></span>createGpuMapParallelLoopsPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createGpuMapParallelLoopsPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1GpuMapParallelLoopsPassOptions.html">GpuMapParallelLoopsPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ParallelLoopMapper_8cpp_source.html#l00509">509</a> of file <a class="el" href="ParallelLoopMapper_8cpp_source.html">ParallelLoopMapper.cpp</a>.</p>

</div>
</div>
<a id="abd46abfc961058869f991e26e19a622d" name="abd46abfc961058869f991e26e19a622d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd46abfc961058869f991e26e19a622d">&#9670;&#160;</a></span>createGpuModuleToBinaryPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createGpuModuleToBinaryPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleToBinary_8cpp_source.html#l00612">612</a> of file <a class="el" href="ModuleToBinary_8cpp_source.html">ModuleToBinary.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00026">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="ac36d1b32d002fc1c91b34c4474596b21" name="ac36d1b32d002fc1c91b34c4474596b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac36d1b32d002fc1c91b34c4474596b21">&#9670;&#160;</a></span>createGpuModuleToBinaryPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createGpuModuleToBinaryPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1GpuModuleToBinaryPassOptions.html">GpuModuleToBinaryPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleToBinary_8cpp_source.html#l00616">616</a> of file <a class="el" href="ModuleToBinary_8cpp_source.html">ModuleToBinary.cpp</a>.</p>

</div>
</div>
<a id="a659763d266f0cb16406ad2faba74c158" name="a659763d266f0cb16406ad2faba74c158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659763d266f0cb16406ad2faba74c158">&#9670;&#160;</a></span>createGpuNVVMAttachTarget() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createGpuNVVMAttachTarget </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NVVMAttachTarget_8cpp_source.html#l00731">731</a> of file <a class="el" href="NVVMAttachTarget_8cpp_source.html">NVVMAttachTarget.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00026">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="a08c2b400d025a2d8f1757f4b23c05fcc" name="a08c2b400d025a2d8f1757f4b23c05fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c2b400d025a2d8f1757f4b23c05fcc">&#9670;&#160;</a></span>createGpuNVVMAttachTarget() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createGpuNVVMAttachTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1GpuNVVMAttachTargetOptions.html">GpuNVVMAttachTargetOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NVVMAttachTarget_8cpp_source.html#l00735">735</a> of file <a class="el" href="NVVMAttachTarget_8cpp_source.html">NVVMAttachTarget.cpp</a>.</p>

</div>
</div>
<a id="a846a0d18cb1e8e4ee88a39a73c411ef3" name="a846a0d18cb1e8e4ee88a39a73c411ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a846a0d18cb1e8e4ee88a39a73c411ef3">&#9670;&#160;</a></span>createGpuROCDLAttachTarget() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createGpuROCDLAttachTarget </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ROCDLAttachTarget_8cpp_source.html#l00862">862</a> of file <a class="el" href="ROCDLAttachTarget_8cpp_source.html">ROCDLAttachTarget.cpp</a>.</p>

</div>
</div>
<a id="a043a0b34b5ba663cc71af65273744891" name="a043a0b34b5ba663cc71af65273744891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043a0b34b5ba663cc71af65273744891">&#9670;&#160;</a></span>createGpuROCDLAttachTarget() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createGpuROCDLAttachTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1GpuROCDLAttachTargetOptions.html">GpuROCDLAttachTargetOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ROCDLAttachTarget_8cpp_source.html#l00866">866</a> of file <a class="el" href="ROCDLAttachTarget_8cpp_source.html">ROCDLAttachTarget.cpp</a>.</p>

</div>
</div>
<a id="a0904453d137ead66dfc9532afc1c5643" name="a0904453d137ead66dfc9532afc1c5643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0904453d137ead66dfc9532afc1c5643">&#9670;&#160;</a></span>createGpuSPIRVAttachTarget() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createGpuSPIRVAttachTarget </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRVAttachTarget_8cpp_source.html#l00978">978</a> of file <a class="el" href="SPIRVAttachTarget_8cpp_source.html">SPIRVAttachTarget.cpp</a>.</p>

</div>
</div>
<a id="abac4fa2e5d211942a4b1e2c841dff92a" name="abac4fa2e5d211942a4b1e2c841dff92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac4fa2e5d211942a4b1e2c841dff92a">&#9670;&#160;</a></span>createGpuSPIRVAttachTarget() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createGpuSPIRVAttachTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1GpuSPIRVAttachTargetOptions.html">GpuSPIRVAttachTargetOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRVAttachTarget_8cpp_source.html#l00982">982</a> of file <a class="el" href="SPIRVAttachTarget_8cpp_source.html">SPIRVAttachTarget.cpp</a>.</p>

</div>
</div>
<a id="ab713f3ebdfd529788867c3b1d7d94f7b" name="ab713f3ebdfd529788867c3b1d7d94f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab713f3ebdfd529788867c3b1d7d94f7b">&#9670;&#160;</a></span>createGpuToLLVMConversionPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createGpuToLLVMConversionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l05776">5776</a> of file <a class="el" href="GPUToLLVMConversion_8cpp_source.html">GPUToLLVMConversion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00026">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="ace1669c25cb81206ee3dd3c36998c0b3" name="ace1669c25cb81206ee3dd3c36998c0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace1669c25cb81206ee3dd3c36998c0b3">&#9670;&#160;</a></span>createGpuToLLVMConversionPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createGpuToLLVMConversionPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1GpuToLLVMConversionPassOptions.html">GpuToLLVMConversionPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l05780">5780</a> of file <a class="el" href="GPUToLLVMConversion_8cpp_source.html">GPUToLLVMConversion.cpp</a>.</p>

</div>
</div>
<a id="a7f8af4ad927ba4ff2e1263c27b4042f7" name="a7f8af4ad927ba4ff2e1263c27b4042f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f8af4ad927ba4ff2e1263c27b4042f7">&#9670;&#160;</a></span>createGpuXeVMAttachTarget() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createGpuXeVMAttachTarget </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeVMAttachTarget_8cpp_source.html#l01088">1088</a> of file <a class="el" href="XeVMAttachTarget_8cpp_source.html">XeVMAttachTarget.cpp</a>.</p>

</div>
</div>
<a id="af7f37c09444f9e376c704cf103b665ea" name="af7f37c09444f9e376c704cf103b665ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f37c09444f9e376c704cf103b665ea">&#9670;&#160;</a></span>createGpuXeVMAttachTarget() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createGpuXeVMAttachTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1GpuXeVMAttachTargetOptions.html">GpuXeVMAttachTargetOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeVMAttachTarget_8cpp_source.html#l01092">1092</a> of file <a class="el" href="XeVMAttachTarget_8cpp_source.html">XeVMAttachTarget.cpp</a>.</p>

</div>
</div>
<a id="a6c6ad0644a283c257d1fbc15be6adc18" name="a6c6ad0644a283c257d1fbc15be6adc18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6ad0644a283c257d1fbc15be6adc18">&#9670;&#160;</a></span>createInlinerPass() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createInlinerPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which inlines calls and callable operations as defined by the <a class="el" href="classmlir_1_1CallGraph.html">CallGraph</a>. </p>

<p class="definition">Definition at line <a class="el" href="InlinerPass_8cpp_source.html#l00186">186</a> of file <a class="el" href="InlinerPass_8cpp_source.html">InlinerPass.cpp</a>.</p>

</div>
</div>
<a id="a1372ce1294d9b98b652930aa6baf1386" name="a1372ce1294d9b98b652930aa6baf1386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1372ce1294d9b98b652930aa6baf1386">&#9670;&#160;</a></span>createInlinerPass() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createInlinerPass </td>
          <td>(</td>
          <td class="paramtype">llvm::StringMap&lt; <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>opPipelines</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the inliner pass, and use the provided pass managers when optimizing callable operations with names matching the key type. </p>
<p>Callable operations with a name not within the provided map will use the default inliner pipeline during optimization. </p>

<p class="definition">Definition at line <a class="el" href="InlinerPass_8cpp_source.html#l00190">190</a> of file <a class="el" href="InlinerPass_8cpp_source.html">InlinerPass.cpp</a>.</p>

<p class="reference">References <a class="el" href="InlinerPass_8cpp_source.html#l00033">defaultInlinerOptPipeline()</a>.</p>

</div>
</div>
<a id="a282d4666d1a10f4c41e6b114bf5e6a7f" name="a282d4666d1a10f4c41e6b114bf5e6a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a282d4666d1a10f4c41e6b114bf5e6a7f">&#9670;&#160;</a></span>createInlinerPass() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createInlinerPass </td>
          <td>(</td>
          <td class="paramtype">llvm::StringMap&lt; <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>opPipelines</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>defaultPipelineBuilder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the inliner pass, and use the provided pass managers when optimizing callable operations with names matching the key type. </p>
<p>Callable operations with a name not within the provided map will use the provided default pipeline builder. </p>

<p class="definition">Definition at line <a class="el" href="InlinerPass_8cpp_source.html#l00194">194</a> of file <a class="el" href="InlinerPass_8cpp_source.html">InlinerPass.cpp</a>.</p>

</div>
</div>
<a id="a4dde99c58353877e9c1c659bfb65753e" name="a4dde99c58353877e9c1c659bfb65753e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dde99c58353877e9c1c659bfb65753e">&#9670;&#160;</a></span>createLiftControlFlowToSCFPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createLiftControlFlowToSCFPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowToSCF_8cpp_source.html#l05858">5858</a> of file <a class="el" href="ControlFlowToSCF_8cpp_source.html">ControlFlowToSCF.cpp</a>.</p>

</div>
</div>
<a id="ad2b5e1e5d3d9050938167540a8e15b86" name="ad2b5e1e5d3d9050938167540a8e15b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b5e1e5d3d9050938167540a8e15b86">&#9670;&#160;</a></span>createLinalgBlockPackMatmul() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createLinalgBlockPackMatmul </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BlockPackMatmul_8cpp_source.html#l00438">438</a> of file <a class="el" href="BlockPackMatmul_8cpp_source.html">BlockPackMatmul.cpp</a>.</p>

</div>
</div>
<a id="a9aefb54fcfdb352c964103b342389226" name="a9aefb54fcfdb352c964103b342389226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aefb54fcfdb352c964103b342389226">&#9670;&#160;</a></span>createLinalgBlockPackMatmul() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createLinalgBlockPackMatmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1LinalgBlockPackMatmulOptions.html">LinalgBlockPackMatmulOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BlockPackMatmul_8cpp_source.html#l00442">442</a> of file <a class="el" href="BlockPackMatmul_8cpp_source.html">BlockPackMatmul.cpp</a>.</p>

</div>
</div>
<a id="ad39c9d48e1d88cd29793051b0e77f332" name="ad39c9d48e1d88cd29793051b0e77f332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39c9d48e1d88cd29793051b0e77f332">&#9670;&#160;</a></span>createLinalgDetensorizePass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createLinalgDetensorizePass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Detensorize_8cpp_source.html#l00533">533</a> of file <a class="el" href="Detensorize_8cpp_source.html">Detensorize.cpp</a>.</p>

</div>
</div>
<a id="a7914ade3a6157a066379b2c5e5a40fa8" name="a7914ade3a6157a066379b2c5e5a40fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7914ade3a6157a066379b2c5e5a40fa8">&#9670;&#160;</a></span>createLinalgDetensorizePass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createLinalgDetensorizePass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1LinalgDetensorizePassOptions.html">LinalgDetensorizePassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Detensorize_8cpp_source.html#l00537">537</a> of file <a class="el" href="Detensorize_8cpp_source.html">Detensorize.cpp</a>.</p>

</div>
</div>
<a id="a736979a5a4ca50383d3cde235bd30d6b" name="a736979a5a4ca50383d3cde235bd30d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736979a5a4ca50383d3cde235bd30d6b">&#9670;&#160;</a></span>createLinalgElementwiseOpFusionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createLinalgElementwiseOpFusionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00614">614</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00026">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="a6a817e4caaf87f1eba1ac390cba4194c" name="a6a817e4caaf87f1eba1ac390cba4194c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a817e4caaf87f1eba1ac390cba4194c">&#9670;&#160;</a></span>createLinalgFoldIntoElementwisePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createLinalgFoldIntoElementwisePass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="FoldIntoElementwise_8cpp_source.html#l00689">689</a> of file <a class="el" href="FoldIntoElementwise_8cpp_source.html">FoldIntoElementwise.cpp</a>.</p>

</div>
</div>
<a id="a8cf37093e30cc4df97e31c368130dcb9" name="a8cf37093e30cc4df97e31c368130dcb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf37093e30cc4df97e31c368130dcb9">&#9670;&#160;</a></span>createLinalgFoldUnitExtentDimsPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createLinalgFoldUnitExtentDimsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DropUnitDims_8cpp_source.html#l00782">782</a> of file <a class="el" href="DropUnitDims_8cpp_source.html">DropUnitDims.cpp</a>.</p>

</div>
</div>
<a id="a8823373c20a1362001318f3ae888db4c" name="a8823373c20a1362001318f3ae888db4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8823373c20a1362001318f3ae888db4c">&#9670;&#160;</a></span>createLinalgFoldUnitExtentDimsPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createLinalgFoldUnitExtentDimsPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1LinalgFoldUnitExtentDimsPassOptions.html">LinalgFoldUnitExtentDimsPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DropUnitDims_8cpp_source.html#l00786">786</a> of file <a class="el" href="DropUnitDims_8cpp_source.html">DropUnitDims.cpp</a>.</p>

</div>
</div>
<a id="a9ba4519efdc52e99dd87577a5e69cc30" name="a9ba4519efdc52e99dd87577a5e69cc30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba4519efdc52e99dd87577a5e69cc30">&#9670;&#160;</a></span>createLinalgGeneralizeNamedOpsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createLinalgGeneralizeNamedOpsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="Generalization_8cpp_source.html#l00861">861</a> of file <a class="el" href="Generalization_8cpp_source.html">Generalization.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00026">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="a959c568ee9ce0287a2b1f9faf7e838e8" name="a959c568ee9ce0287a2b1f9faf7e838e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a959c568ee9ce0287a2b1f9faf7e838e8">&#9670;&#160;</a></span>createLinalgInlineScalarOperandsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createLinalgInlineScalarOperandsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="InlineScalarOperands_8cpp_source.html#l00936">936</a> of file <a class="el" href="InlineScalarOperands_8cpp_source.html">InlineScalarOperands.cpp</a>.</p>

</div>
</div>
<a id="a2554cb9a09cbf183334c4189d83762d1" name="a2554cb9a09cbf183334c4189d83762d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2554cb9a09cbf183334c4189d83762d1">&#9670;&#160;</a></span>createLinalgMorphOpsPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createLinalgMorphOpsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MorphOps_8cpp_source.html#l01036">1036</a> of file <a class="el" href="MorphOps_8cpp_source.html">MorphOps.cpp</a>.</p>

</div>
</div>
<a id="a23775595aa7aed4b62df6d1bc09c968f" name="a23775595aa7aed4b62df6d1bc09c968f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23775595aa7aed4b62df6d1bc09c968f">&#9670;&#160;</a></span>createLinalgMorphOpsPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createLinalgMorphOpsPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1LinalgMorphOpsPassOptions.html">LinalgMorphOpsPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MorphOps_8cpp_source.html#l01040">1040</a> of file <a class="el" href="MorphOps_8cpp_source.html">MorphOps.cpp</a>.</p>

</div>
</div>
<a id="a16a9896bf6e005f7b001530d3e32877c" name="a16a9896bf6e005f7b001530d3e32877c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a9896bf6e005f7b001530d3e32877c">&#9670;&#160;</a></span>createLinalgSpecializeGenericOpsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createLinalgSpecializeGenericOpsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="Specialize_8cpp_source.html#l01115">1115</a> of file <a class="el" href="Specialize_8cpp_source.html">Specialize.cpp</a>.</p>

</div>
</div>
<a id="a0198faa21d50db185dfacef5304045a7" name="a0198faa21d50db185dfacef5304045a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0198faa21d50db185dfacef5304045a7">&#9670;&#160;</a></span>createLocationSnapshot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createLocationSnapshot </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LocationSnapshot_8cpp_source.html#l00674">674</a> of file <a class="el" href="LocationSnapshot_8cpp_source.html">LocationSnapshot.cpp</a>.</p>

</div>
</div>
<a id="a4b927d064f79b5cfafba62a5da8ea2b0" name="a4b927d064f79b5cfafba62a5da8ea2b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b927d064f79b5cfafba62a5da8ea2b0">&#9670;&#160;</a></span>createLocationSnapshot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createLocationSnapshot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1LocationSnapshotOptions.html">LocationSnapshotOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LocationSnapshot_8cpp_source.html#l00678">678</a> of file <a class="el" href="LocationSnapshot_8cpp_source.html">LocationSnapshot.cpp</a>.</p>

</div>
</div>
<a id="a319fde65e573dbc3a947d58196cb2b3a" name="a319fde65e573dbc3a947d58196cb2b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319fde65e573dbc3a947d58196cb2b3a">&#9670;&#160;</a></span>createLoopInvariantCodeMotionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLoopInvariantCodeMotionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a loop invariant code motion pass that hoists loop invariant instructions out of the loop. </p>

<p class="definition">Definition at line <a class="el" href="LoopInvariantCodeMotion_8cpp_source.html#l00059">59</a> of file <a class="el" href="LoopInvariantCodeMotion_8cpp_source.html">LoopInvariantCodeMotion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00125">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="acf61282117a610660819cb15624637d6" name="acf61282117a610660819cb15624637d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf61282117a610660819cb15624637d6">&#9670;&#160;</a></span>createLoopInvariantSubsetHoistingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLoopInvariantSubsetHoistingPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that hoists loop-invariant subset ops. </p>

<p class="definition">Definition at line <a class="el" href="LoopInvariantCodeMotion_8cpp_source.html#l00063">63</a> of file <a class="el" href="LoopInvariantCodeMotion_8cpp_source.html">LoopInvariantCodeMotion.cpp</a>.</p>

</div>
</div>
<a id="a7c0757d46861a68cf91c622169d1d598" name="a7c0757d46861a68cf91c622169d1d598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0757d46861a68cf91c622169d1d598">&#9670;&#160;</a></span>createLowerAffinePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createLowerAffinePass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="AffineToStandard_8cpp_source.html#l05936">5936</a> of file <a class="el" href="AffineToStandard_8cpp_source.html">AffineToStandard.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00026">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="aaa0dbcff2285d9b5fc43c67189e783d6" name="aaa0dbcff2285d9b5fc43c67189e783d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0dbcff2285d9b5fc43c67189e783d6">&#9670;&#160;</a></span>createLowerForeachToSCFPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLowerForeachToSCFPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00476">476</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00125">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="a102fc0d70d243e6feb2490715c31ffe0" name="a102fc0d70d243e6feb2490715c31ffe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a102fc0d70d243e6feb2490715c31ffe0">&#9670;&#160;</a></span>createLowerHostCodeToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createLowerHostCodeToLLVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l06011">6011</a> of file <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html">ConvertLaunchFuncToLLVMCalls.cpp</a>.</p>

</div>
</div>
<a id="ab956888e7892e8d37b40f660d2ab3222" name="ab956888e7892e8d37b40f660d2ab3222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab956888e7892e8d37b40f660d2ab3222">&#9670;&#160;</a></span>createLowerSparseIterationToSCFPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLowerSparseIterationToSCFPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00480">480</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00125">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="a0c927ead951ebddddb979353f1ddda9e" name="a0c927ead951ebddddb979353f1ddda9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c927ead951ebddddb979353f1ddda9e">&#9670;&#160;</a></span>createLowerSparseOpsToForeachPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLowerSparseOpsToForeachPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00467">467</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00125">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="a93efca2366cbf131cf7359f94cc5f2a5" name="a93efca2366cbf131cf7359f94cc5f2a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93efca2366cbf131cf7359f94cc5f2a5">&#9670;&#160;</a></span>createLowerSparseOpsToForeachPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLowerSparseOpsToForeachPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>enableRT</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>enableConvert</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00472">472</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

</div>
</div>
<a id="a0c5b68602e237b1c1c3209ae71184cd2" name="a0c5b68602e237b1c1c3209ae71184cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5b68602e237b1c1c3209ae71184cd2">&#9670;&#160;</a></span>createMapMemRefStorageClassPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt; mlir::createMapMemRefStorageClassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to map numeric MemRef memory spaces to symbolic SPIR-V storage classes. </p>
<p>The mapping is read from the command-line option. </p>

<p class="definition">Definition at line <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html#l00327">327</a> of file <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html">MapMemRefStorageClassPass.cpp</a>.</p>

</div>
</div>
<a id="aa8c2a04f26396fa91ab5ecea346e142c" name="aa8c2a04f26396fa91ab5ecea346e142c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c2a04f26396fa91ab5ecea346e142c">&#9670;&#160;</a></span>createMem2Reg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createMem2Reg </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Mem2Reg_8cpp_source.html#l00895">895</a> of file <a class="el" href="Mem2Reg_8cpp_source.html">Mem2Reg.cpp</a>.</p>

</div>
</div>
<a id="ab10eb132c1b16749670ba793d22856da" name="ab10eb132c1b16749670ba793d22856da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10eb132c1b16749670ba793d22856da">&#9670;&#160;</a></span>createMem2Reg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createMem2Reg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Mem2RegOptions.html">Mem2RegOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Mem2Reg_8cpp_source.html#l00899">899</a> of file <a class="el" href="Mem2Reg_8cpp_source.html">Mem2Reg.cpp</a>.</p>

</div>
</div>
<a id="ab6588ae12002d371fd6b5c1afa41dc9e" name="ab6588ae12002d371fd6b5c1afa41dc9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6588ae12002d371fd6b5c1afa41dc9e">&#9670;&#160;</a></span>createOptReductionPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createOptReductionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OptReductionPass_8cpp_source.html#l00102">102</a> of file <a class="el" href="OptReductionPass_8cpp_source.html">OptReductionPass.cpp</a>.</p>

</div>
</div>
<a id="a755d1f9cb439d725bf5fb1ac1fdb5365" name="a755d1f9cb439d725bf5fb1ac1fdb5365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a755d1f9cb439d725bf5fb1ac1fdb5365">&#9670;&#160;</a></span>createOptReductionPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createOptReductionPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OptReductionPassOptions.html">OptReductionPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OptReductionPass_8cpp_source.html#l00106">106</a> of file <a class="el" href="OptReductionPass_8cpp_source.html">OptReductionPass.cpp</a>.</p>

</div>
</div>
<a id="add898725653f18825c4a1b441e55a5ae" name="add898725653f18825c4a1b441e55a5ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add898725653f18825c4a1b441e55a5ae">&#9670;&#160;</a></span>createOutlineShapeComputationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createOutlineShapeComputationPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="OutlineShapeComputation_8cpp_source.html#l00081">81</a> of file <a class="el" href="OutlineShapeComputation_8cpp_source.html">OutlineShapeComputation.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>.</p>

</div>
</div>
<a id="aba4430e6a611255c7e2c879fd42b49ec" name="aba4430e6a611255c7e2c879fd42b49ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4430e6a611255c7e2c879fd42b49ec">&#9670;&#160;</a></span>createOutputStrategy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OutputStrategy.html">OutputStrategy</a> &gt; mlir::createOutputStrategy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DefaultTimingManager.html#adf35dcb59c4c28f4d5e9ae5ca4c57f83">DefaultTimingManager::OutputFormat</a></td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an output strategy for the specified format, to be passed to <a class="el" href="classmlir_1_1DefaultTimingManager.html#a2570c6d75a6fd314ec646db5cbf69293" title="Change the stream where the output will be printed to.">DefaultTimingManager::setOutput()</a>. </p>

<p class="definition">Definition at line <a class="el" href="Timing_8cpp_source.html#l00626">626</a> of file <a class="el" href="Timing_8cpp_source.html">Timing.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Timing_8cpp_source.html#l00617">applyDefaultTimingManagerCLOptions()</a>.</p>

</div>
</div>
<a id="a65a7635ac9704a17a904bb138eb09b5e" name="a65a7635ac9704a17a904bb138eb09b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a7635ac9704a17a904bb138eb09b5e">&#9670;&#160;</a></span>createParallelForToNestedForsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createParallelForToNestedForsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that converts SCF forall loops to SCF parallel loops. </p>

<p class="definition">Definition at line <a class="el" href="ParallelForToNestedFors_8cpp_source.html#l00083">83</a> of file <a class="el" href="ParallelForToNestedFors_8cpp_source.html">ParallelForToNestedFors.cpp</a>.</p>

</div>
</div>
<a id="ad00701d01638289dd08ec9e255076f50" name="ad00701d01638289dd08ec9e255076f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad00701d01638289dd08ec9e255076f50">&#9670;&#160;</a></span>createParallelLoopFusionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createParallelLoopFusionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a loop fusion pass which fuses parallel loops. </p>

<p class="definition">Definition at line <a class="el" href="ParallelLoopFusion_8cpp_source.html#l00286">286</a> of file <a class="el" href="ParallelLoopFusion_8cpp_source.html">ParallelLoopFusion.cpp</a>.</p>

</div>
</div>
<a id="a16b9f8678ec66eed9c66536834540184" name="a16b9f8678ec66eed9c66536834540184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b9f8678ec66eed9c66536834540184">&#9670;&#160;</a></span>createParallelLoopSpecializationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createParallelLoopSpecializationPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that specializes parallel loop for unrolling and vectorization. </p>

<p class="definition">Definition at line <a class="el" href="LoopSpecialization_8cpp_source.html#l00356">356</a> of file <a class="el" href="LoopSpecialization_8cpp_source.html">LoopSpecialization.cpp</a>.</p>

</div>
</div>
<a id="a213571bc56b32e75bc35cf02098982a1" name="a213571bc56b32e75bc35cf02098982a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213571bc56b32e75bc35cf02098982a1">&#9670;&#160;</a></span>createParallelLoopTilingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createParallelLoopTilingPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>tileSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>noMinMaxBounds</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which tiles innermost parallel loops. </p>
<p>If noMinMaxBounds, the upper bound of the inner loop will be a same value among different outter loop iterations, and an additional inbound check will be emitted inside the internal loops. </p>

</div>
</div>
<a id="aa6abc74515648dc477ae4f5af8cbf310" name="aa6abc74515648dc477ae4f5af8cbf310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6abc74515648dc477ae4f5af8cbf310">&#9670;&#160;</a></span>createPreSparsificationRewritePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createPreSparsificationRewritePass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00450">450</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00125">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="a0a84c3fae02e7540b0db48350b738be1" name="a0a84c3fae02e7540b0db48350b738be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a84c3fae02e7540b0db48350b738be1">&#9670;&#160;</a></span>createPrintIRPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createPrintIRPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1PrintIRPassOptions.html">PrintIRPassOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to print IR on the debug stream. </p>

<p class="definition">Definition at line <a class="el" href="PrintIR_8cpp_source.html#l00034">34</a> of file <a class="el" href="PrintIR_8cpp_source.html">PrintIR.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="a045e1f32a8d90260d292aad61149c0ef" name="a045e1f32a8d90260d292aad61149c0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a045e1f32a8d90260d292aad61149c0ef">&#9670;&#160;</a></span>createPrintOpGraphPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createPrintOpGraphPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span><span class="paramdefsep"> = </span><span class="paramdefval">llvm::errs()</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to print op graphs. </p>

<p class="definition">Definition at line <a class="el" href="ViewOpGraph_8cpp_source.html#l00462">462</a> of file <a class="el" href="ViewOpGraph_8cpp_source.html">ViewOpGraph.cpp</a>.</p>

</div>
</div>
<a id="a738190b0f29ddc52ba6847cb310eb60d" name="a738190b0f29ddc52ba6847cb310eb60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a738190b0f29ddc52ba6847cb310eb60d">&#9670;&#160;</a></span>createPrintOpStatsPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createPrintOpStatsPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>printAsJSON</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which prints the list of ops and the number of occurrences in the module with the output format option. </p>

<p class="definition">Definition at line <a class="el" href="OpStats_8cpp_source.html#l00118">118</a> of file <a class="el" href="OpStats_8cpp_source.html">OpStats.cpp</a>.</p>

</div>
</div>
<a id="ab56d49b89c1f203d6fa20f126bf4d900" name="ab56d49b89c1f203d6fa20f126bf4d900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab56d49b89c1f203d6fa20f126bf4d900">&#9670;&#160;</a></span>createPrintOpStatsPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createPrintOpStatsPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span><span class="paramdefsep"> = </span><span class="paramdefval">llvm::errs()</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which prints the list of ops and the number of occurrences in the module. </p>

<p class="definition">Definition at line <a class="el" href="OpStats_8cpp_source.html#l00114">114</a> of file <a class="el" href="OpStats_8cpp_source.html">OpStats.cpp</a>.</p>

</div>
</div>
<a id="a45af0d9851224c09391b386d5fef60c2" name="a45af0d9851224c09391b386d5fef60c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45af0d9851224c09391b386d5fef60c2">&#9670;&#160;</a></span>createReconcileUnrealizedCastsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createReconcileUnrealizedCastsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="ReconcileUnrealizedCasts_8cpp_source.html#l06155">6155</a> of file <a class="el" href="ReconcileUnrealizedCasts_8cpp_source.html">ReconcileUnrealizedCasts.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00026">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="a4b89c742e753afbb6502b61b2c79732b" name="a4b89c742e753afbb6502b61b2c79732b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b89c742e753afbb6502b61b2c79732b">&#9670;&#160;</a></span>createReductionTreePass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createReductionTreePass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ReductionTreePass_8cpp_source.html#l00203">203</a> of file <a class="el" href="ReductionTreePass_8cpp_source.html">ReductionTreePass.cpp</a>.</p>

</div>
</div>
<a id="af2effc06aa98d551670ed273542853d6" name="af2effc06aa98d551670ed273542853d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2effc06aa98d551670ed273542853d6">&#9670;&#160;</a></span>createReductionTreePass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createReductionTreePass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ReductionTreePassOptions.html">ReductionTreePassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ReductionTreePass_8cpp_source.html#l00207">207</a> of file <a class="el" href="ReductionTreePass_8cpp_source.html">ReductionTreePass.cpp</a>.</p>

</div>
</div>
<a id="ab17b2f115a7d8025fb9d5eacf14368b3" name="ab17b2f115a7d8025fb9d5eacf14368b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17b2f115a7d8025fb9d5eacf14368b3">&#9670;&#160;</a></span>createRemoveDeadValuesPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createRemoveDeadValuesPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an optimization pass to remove dead values. </p>

<p class="definition">Definition at line <a class="el" href="RemoveDeadValues_8cpp_source.html#l00959">959</a> of file <a class="el" href="RemoveDeadValues_8cpp_source.html">RemoveDeadValues.cpp</a>.</p>

</div>
</div>
<a id="a4eb08a2d2939d0043d471ea4ff5745f6" name="a4eb08a2d2939d0043d471ea4ff5745f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb08a2d2939d0043d471ea4ff5745f6">&#9670;&#160;</a></span>createRemoveShapeConstraintsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createRemoveShapeConstraintsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="RemoveShapeConstraints_8cpp_source.html#l00156">156</a> of file <a class="el" href="RemoveShapeConstraints_8cpp_source.html">RemoveShapeConstraints.cpp</a>.</p>

</div>
</div>
<a id="acd7b8f0656a50e3147f888f41325b8bb" name="acd7b8f0656a50e3147f888f41325b8bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7b8f0656a50e3147f888f41325b8bb">&#9670;&#160;</a></span>createScalarOrSplatConstant() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::createScalarOrSplatConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const APFloat &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00295">295</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00526">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00910">mlir::DenseElementsAttr::get()</a>, and <a class="el" href="Builders_8cpp_source.html#l00254">mlir::Builder::getFloatAttr()</a>.</p>

</div>
</div>
<a id="a147eacb98e107c587492012f9981cd62" name="a147eacb98e107c587492012f9981cd62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147eacb98e107c587492012f9981cd62">&#9670;&#160;</a></span>createScalarOrSplatConstant() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::createScalarOrSplatConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const APInt &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a constant of type <span class="tt">type</span> at location <span class="tt">loc</span> whose value is <span class="tt">value</span> (an APInt or APFloat whose type must match the element type of <span class="tt">type</span>). </p>
<p>If <span class="tt">type</span> is a shaped type, create a splat constant of the given value. Constants are folded if possible. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00270">270</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00910">mlir::DenseElementsAttr::get()</a>, and <a class="el" href="Builders_8cpp_source.html#l00228">mlir::Builder::getIntegerAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArithToAMDGPU_8cpp_source.html#l00217">clampInput()</a>, and <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00283">createScalarOrSplatConstant()</a>.</p>

</div>
</div>
<a id="a083c2c253d760b0fb021e6ce396105ed" name="a083c2c253d760b0fb021e6ce396105ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a083c2c253d760b0fb021e6ce396105ed">&#9670;&#160;</a></span>createScalarOrSplatConstant() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::createScalarOrSplatConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00283">283</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00270">createScalarOrSplatConstant()</a>.</p>

</div>
</div>
<a id="a6119493f8c83de427f34658e5e39cbfe" name="a6119493f8c83de427f34658e5e39cbfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6119493f8c83de427f34658e5e39cbfe">&#9670;&#160;</a></span>createSCCPPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSCCPPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which performs sparse conditional constant propagation over nested operations. </p>

<p class="definition">Definition at line <a class="el" href="SCCP_8cpp_source.html#l00133">133</a> of file <a class="el" href="SCCP_8cpp_source.html">SCCP.cpp</a>.</p>

</div>
</div>
<a id="ac7f8ebf7a2133d1c68cea6e20fba0ea8" name="ac7f8ebf7a2133d1c68cea6e20fba0ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f8ebf7a2133d1c68cea6e20fba0ea8">&#9670;&#160;</a></span>createSCFForLoopCanonicalizationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSCFForLoopCanonicalizationPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that canonicalizes affine.min and affine.max operations inside of scf.for loops with known lower and upper bounds. </p>

<p class="definition">Definition at line <a class="el" href="LoopCanonicalization_8cpp_source.html#l00187">187</a> of file <a class="el" href="LoopCanonicalization_8cpp_source.html">LoopCanonicalization.cpp</a>.</p>

</div>
</div>
<a id="a1bda9f9dfebc7056b41f414d91593372" name="a1bda9f9dfebc7056b41f414d91593372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bda9f9dfebc7056b41f414d91593372">&#9670;&#160;</a></span>createSCFToControlFlowPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createSCFToControlFlowPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SCFToControlFlow_8cpp_source.html#l06246">6246</a> of file <a class="el" href="SCFToControlFlow_8cpp_source.html">SCFToControlFlow.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00026">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="a4e7b85b406277d3cf5ee6e4f3049e9c4" name="a4e7b85b406277d3cf5ee6e4f3049e9c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e7b85b406277d3cf5ee6e4f3049e9c4">&#9670;&#160;</a></span>createSCFToControlFlowPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createSCFToControlFlowPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1SCFToControlFlowPassOptions.html">SCFToControlFlowPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SCFToControlFlow_8cpp_source.html#l06250">6250</a> of file <a class="el" href="SCFToControlFlow_8cpp_source.html">SCFToControlFlow.cpp</a>.</p>

</div>
</div>
<a id="ab9c9a79ce37e1b1c3a2938ddb659b888" name="ab9c9a79ce37e1b1c3a2938ddb659b888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c9a79ce37e1b1c3a2938ddb659b888">&#9670;&#160;</a></span>createSCFToEmitC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createSCFToEmitC </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="SCFToEmitC_8cpp_source.html#l06325">6325</a> of file <a class="el" href="SCFToEmitC_8cpp_source.html">SCFToEmitC.cpp</a>.</p>

</div>
</div>
<a id="a3123bb0bda65317a1439fa33a0f511ca" name="a3123bb0bda65317a1439fa33a0f511ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3123bb0bda65317a1439fa33a0f511ca">&#9670;&#160;</a></span>createSCFToSPIRV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createSCFToSPIRV </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="SCFToSPIRVPass_8cpp_source.html#l06400">6400</a> of file <a class="el" href="SCFToSPIRVPass_8cpp_source.html">SCFToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="aa5869d9c7c1c0f38587ea9c7c3f17abd" name="aa5869d9c7c1c0f38587ea9c7c3f17abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5869d9c7c1c0f38587ea9c7c3f17abd">&#9670;&#160;</a></span>createSetLLVMModuleDataLayoutPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createSetLLVMModuleDataLayoutPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FuncToLLVM_8cpp_source.html#l06491">6491</a> of file <a class="el" href="FuncToLLVM_8cpp_source.html">FuncToLLVM.cpp</a>.</p>

</div>
</div>
<a id="a0cd888dc1fe162499039e04fb50a808d" name="a0cd888dc1fe162499039e04fb50a808d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cd888dc1fe162499039e04fb50a808d">&#9670;&#160;</a></span>createSetLLVMModuleDataLayoutPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createSetLLVMModuleDataLayoutPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1SetLLVMModuleDataLayoutPassOptions.html">SetLLVMModuleDataLayoutPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FuncToLLVM_8cpp_source.html#l06495">6495</a> of file <a class="el" href="FuncToLLVM_8cpp_source.html">FuncToLLVM.cpp</a>.</p>

</div>
</div>
<a id="a3bc1ef32acaa89b19ce4b38dbc626801" name="a3bc1ef32acaa89b19ce4b38dbc626801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc1ef32acaa89b19ce4b38dbc626801">&#9670;&#160;</a></span>createShapeToShapeLoweringPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createShapeToShapeLoweringPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="ShapeToShapeLowering_8cpp_source.html#l00231">231</a> of file <a class="el" href="ShapeToShapeLowering_8cpp_source.html">ShapeToShapeLowering.cpp</a>.</p>

</div>
</div>
<a id="ae999b87c3439f4e65c006ba97b7c5be4" name="ae999b87c3439f4e65c006ba97b7c5be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae999b87c3439f4e65c006ba97b7c5be4">&#9670;&#160;</a></span>createSimplifyDepthwiseConvPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createSimplifyDepthwiseConvPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="SimplifyDepthwiseConv_8cpp_source.html#l01191">1191</a> of file <a class="el" href="SimplifyDepthwiseConv_8cpp_source.html">SimplifyDepthwiseConv.cpp</a>.</p>

</div>
</div>
<a id="a07377f22cc6146bebe3a32a4a13c00bb" name="a07377f22cc6146bebe3a32a4a13c00bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07377f22cc6146bebe3a32a4a13c00bb">&#9670;&#160;</a></span>createSparseAssembler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseAssembler </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00427">427</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

</div>
</div>
<a id="ac113f2b89a3f2ad9abce500e0c48d9f4" name="ac113f2b89a3f2ad9abce500e0c48d9f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac113f2b89a3f2ad9abce500e0c48d9f4">&#9670;&#160;</a></span>createSparseAssembler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseAssembler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>directOut</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l00063">mlir::sparse_tensor::kDefault</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a52922b4f9a9b71d07318a65565e1d95d" name="a52922b4f9a9b71d07318a65565e1d95d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52922b4f9a9b71d07318a65565e1d95d">&#9670;&#160;</a></span>createSparseBufferRewritePass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseBufferRewritePass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00499">499</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00125">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="aa9c5d254155d499befa419181f2539ea" name="aa9c5d254155d499befa419181f2539ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c5d254155d499befa419181f2539ea">&#9670;&#160;</a></span>createSparseBufferRewritePass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseBufferRewritePass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>enableBufferInitialization</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00504">504</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

</div>
</div>
<a id="a2fa7d8a0754783f37e6e38a77c7e8116" name="a2fa7d8a0754783f37e6e38a77c7e8116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa7d8a0754783f37e6e38a77c7e8116">&#9670;&#160;</a></span>createSparseGPUCodegenPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseGPUCodegenPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00520">520</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00026">mlir::sparse_tensor::buildSparsifier()</a>, and <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00125">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="ab19ebeb6aa5cf97ebbb73f3b7cd8c6c1" name="ab19ebeb6aa5cf97ebbb73f3b7cd8c6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19ebeb6aa5cf97ebbb73f3b7cd8c6c1">&#9670;&#160;</a></span>createSparseGPUCodegenPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseGPUCodegenPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numThreads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>enableRT</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00524">524</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

</div>
</div>
<a id="a3968e0a16a255017c133162badae2da2" name="a3968e0a16a255017c133162badae2da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3968e0a16a255017c133162badae2da2">&#9670;&#160;</a></span>createSparseReinterpretMapPass() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseReinterpretMapPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00431">431</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00125">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="ac6f3748b0d302eac21bac48a9887146b" name="ac6f3748b0d302eac21bac48a9887146b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f3748b0d302eac21bac48a9887146b">&#9670;&#160;</a></span>createSparseReinterpretMapPass() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseReinterpretMapPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a855a7d93430958efaaf3a6f69e3dac1c">ReinterpretMapScope</a></td>          <td class="paramname"><span class="paramname"><em>scope</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00436">436</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="a51d5d032337b816f2fa52e45893536e1" name="a51d5d032337b816f2fa52e45893536e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d5d032337b816f2fa52e45893536e1">&#9670;&#160;</a></span>createSparseReinterpretMapPass() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseReinterpretMapPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a855a7d93430958efaaf3a6f69e3dac1c">ReinterpretMapScope</a></td>          <td class="paramname"><span class="paramname"><em>scope</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a831cb9fe0506a02a0ad7a9babfba8eb7">sparse_tensor::LoopOrderingStrategy</a></td>          <td class="paramname"><span class="paramname"><em>strategy</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00442">442</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="a3110b4f58e57c2f284923d882d45cff4" name="a3110b4f58e57c2f284923d882d45cff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3110b4f58e57c2f284923d882d45cff4">&#9670;&#160;</a></span>createSparseSpaceCollapsePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseSpaceCollapsePass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseSpaceCollapse_8cpp_source.html#l00197">197</a> of file <a class="el" href="SparseSpaceCollapse_8cpp_source.html">SparseSpaceCollapse.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00125">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="a1444af92cb6556316a97dbd17dc10ea4" name="a1444af92cb6556316a97dbd17dc10ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1444af92cb6556316a97dbd17dc10ea4">&#9670;&#160;</a></span>createSparseTensorCodegenPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseTensorCodegenPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00488">488</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00125">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="ad11d8839f833db69a07242adf6894472" name="ad11d8839f833db69a07242adf6894472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11d8839f833db69a07242adf6894472">&#9670;&#160;</a></span>createSparseTensorCodegenPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseTensorCodegenPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>createSparseDeallocs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>enableBufferInitialization</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00493">493</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

</div>
</div>
<a id="a50fe6af993ee7df395f88312234f0dc0" name="a50fe6af993ee7df395f88312234f0dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50fe6af993ee7df395f88312234f0dc0">&#9670;&#160;</a></span>createSparseTensorConversionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseTensorConversionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00484">484</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00125">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="a06a9ca41ccfad286cda8688e8d66f588" name="a06a9ca41ccfad286cda8688e8d66f588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a9ca41ccfad286cda8688e8d66f588">&#9670;&#160;</a></span>createSparseVectorizationPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseVectorizationPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00508">508</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00125">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="a3399bec16625e6af75488bb739d48d4c" name="a3399bec16625e6af75488bb739d48d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3399bec16625e6af75488bb739d48d4c">&#9670;&#160;</a></span>createSparseVectorizationPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseVectorizationPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>vectorLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>enableVLAVectorization</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>enableSIMDIndex32</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00513">513</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

</div>
</div>
<a id="a5328b60bddf5d222bef6d92658019b9d" name="a5328b60bddf5d222bef6d92658019b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5328b60bddf5d222bef6d92658019b9d">&#9670;&#160;</a></span>createSparsificationAndBufferizationPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">mlir::Pass</a> &gt; mlir::createSparsificationAndBufferizationPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00241">241</a> of file <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html">SparsificationAndBufferizationPass.cpp</a>.</p>

<p class="reference">References <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00218">getBufferizationOptionsForSparsification()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00026">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="af312c1b22096f10a3123c5136824b691" name="af312c1b22096f10a3123c5136824b691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af312c1b22096f10a3123c5136824b691">&#9670;&#160;</a></span>createSparsificationAndBufferizationPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">mlir::Pass</a> &gt; mlir::createSparsificationAndBufferizationPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">bufferization::OneShotBufferizationOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bufferizationOptions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sparsificationOptions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>createSparseDeallocs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>enableRuntimeLibrary</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>enableBufferInitialization</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>vectorLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>enableVLAVectorization</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>enableSIMDIndex32</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>enableGPULibgen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a90f3feaa61d2ade78f26489cc92061c9">SparseEmitStrategy</a></td>          <td class="paramname"><span class="paramname"><em>emitStrategy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a781474aef998ccce168b69ae973cd832">SparseParallelizationStrategy</a></td>          <td class="paramname"><span class="paramname"><em>parallelizationStrategy</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00252">252</a> of file <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html">SparsificationAndBufferizationPass.cpp</a>.</p>

</div>
</div>
<a id="ae0be4f778219bfb3917a2c7d3e7e1bd0" name="ae0be4f778219bfb3917a2c7d3e7e1bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0be4f778219bfb3917a2c7d3e7e1bd0">&#9670;&#160;</a></span>createSparsificationPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparsificationPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00454">454</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00125">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="a11b0dcc4a707e4e560a7a2f69a95a7c9" name="a11b0dcc4a707e4e560a7a2f69a95a7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b0dcc4a707e4e560a7a2f69a95a7c9">&#9670;&#160;</a></span>createSparsificationPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparsificationPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00459">459</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="a5c2b3959a06b08009c762f8612c813c7" name="a5c2b3959a06b08009c762f8612c813c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c2b3959a06b08009c762f8612c813c7">&#9670;&#160;</a></span>createSROA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createSROA </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01239">1239</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

</div>
</div>
<a id="adfa7974cf8032ae0d38f7fcc16387d3a" name="adfa7974cf8032ae0d38f7fcc16387d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa7974cf8032ae0d38f7fcc16387d3a">&#9670;&#160;</a></span>createStageSparseOperationsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createStageSparseOperationsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00463">463</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00125">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="aa52fe837d33ee51beba517a1d44dbea3" name="aa52fe837d33ee51beba517a1d44dbea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa52fe837d33ee51beba517a1d44dbea3">&#9670;&#160;</a></span>createStorageSpecifierToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createStorageSpecifierToLLVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00529">529</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00026">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="a3b152134b4d44a148dac8bfc24070dcd" name="a3b152134b4d44a148dac8bfc24070dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b152134b4d44a148dac8bfc24070dcd">&#9670;&#160;</a></span>createStripDebugInfoPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createStripDebugInfoPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to strip debug information from a function. </p>

<p class="definition">Definition at line <a class="el" href="StripDebugInfo_8cpp_source.html#l00045">45</a> of file <a class="el" href="StripDebugInfo_8cpp_source.html">StripDebugInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00026">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="a69605e45210627de9b7fde4644fa50c1" name="a69605e45210627de9b7fde4644fa50c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69605e45210627de9b7fde4644fa50c1">&#9670;&#160;</a></span>createSymbolDCEPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSymbolDCEPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which delete symbol operations that are unreachable. </p>
<p>This pass may <em>only</em> be scheduled on an operation that defines a <a class="el" href="classmlir_1_1SymbolTable.html" title="This class allows for representing and managing the symbol table used by operations with the &#39;SymbolT...">SymbolTable</a>. </p>

<p class="definition">Definition at line <a class="el" href="SymbolDCE_8cpp_source.html#l00190">190</a> of file <a class="el" href="SymbolDCE_8cpp_source.html">SymbolDCE.cpp</a>.</p>

</div>
</div>
<a id="ae0b0f8a089ed821a240c7dd4e5573573" name="ae0b0f8a089ed821a240c7dd4e5573573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b0f8a089ed821a240c7dd4e5573573">&#9670;&#160;</a></span>createSymbolPrivatizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSymbolPrivatizePass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt;</td>          <td class="paramname"><span class="paramname"><em>excludeSymbols</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which marks top-level symbol operations as <span class="tt">private</span> unless listed in <span class="tt">excludeSymbols</span>. </p>

<p class="definition">Definition at line <a class="el" href="SymbolPrivatize_8cpp_source.html#l00061">61</a> of file <a class="el" href="SymbolPrivatize_8cpp_source.html">SymbolPrivatize.cpp</a>.</p>

</div>
</div>
<a id="ab03de4687b73fcc63bfde7e0dda6b741" name="ab03de4687b73fcc63bfde7e0dda6b741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03de4687b73fcc63bfde7e0dda6b741">&#9670;&#160;</a></span>createTestSCFParallelLoopCollapsingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createTestSCFParallelLoopCollapsingPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that transforms a single ParallelLoop over N induction variables into another ParallelLoop over less than N induction variables. </p>

<p class="definition">Definition at line <a class="el" href="ParallelLoopCollapsing_8cpp_source.html#l00107">107</a> of file <a class="el" href="ParallelLoopCollapsing_8cpp_source.html">ParallelLoopCollapsing.cpp</a>.</p>

</div>
</div>
<a id="a4480ae6dd145482f88ec81d28df3bca8" name="a4480ae6dd145482f88ec81d28df3bca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4480ae6dd145482f88ec81d28df3bca8">&#9670;&#160;</a></span>createTopologicalSortPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createTopologicalSortPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that recursively sorts nested regions without SSA dominance topologically such that, as much as possible, users of values appear after their producers. </p>

<p class="definition">Definition at line <a class="el" href="TopologicalSort_8cpp_source.html#l00038">38</a> of file <a class="el" href="TopologicalSort_8cpp_source.html">TopologicalSort.cpp</a>.</p>

</div>
</div>
<a id="a708574e1a513815d1dddafdcbfd75582" name="a708574e1a513815d1dddafdcbfd75582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708574e1a513815d1dddafdcbfd75582">&#9670;&#160;</a></span>createTosaToArithPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createTosaToArithPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TosaToArithPass_8cpp_source.html#l06589">6589</a> of file <a class="el" href="TosaToArithPass_8cpp_source.html">TosaToArithPass.cpp</a>.</p>

</div>
</div>
<a id="a6fbe05fcf9d84a4d747a1c049385907f" name="a6fbe05fcf9d84a4d747a1c049385907f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbe05fcf9d84a4d747a1c049385907f">&#9670;&#160;</a></span>createTosaToArithPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createTosaToArithPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1TosaToArithPassOptions.html">TosaToArithPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TosaToArithPass_8cpp_source.html#l06593">6593</a> of file <a class="el" href="TosaToArithPass_8cpp_source.html">TosaToArithPass.cpp</a>.</p>

</div>
</div>
<a id="a4cd1a0721d00a16eadd381ead335654d" name="a4cd1a0721d00a16eadd381ead335654d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd1a0721d00a16eadd381ead335654d">&#9670;&#160;</a></span>createTosaToMLProgram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createTosaToMLProgram </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="TosaToMLProgramPass_8cpp_source.html#l06809">6809</a> of file <a class="el" href="TosaToMLProgramPass_8cpp_source.html">TosaToMLProgramPass.cpp</a>.</p>

</div>
</div>
<a id="abf02e342480b3a71ea8b0e92a1b5f630" name="abf02e342480b3a71ea8b0e92a1b5f630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf02e342480b3a71ea8b0e92a1b5f630">&#9670;&#160;</a></span>createTosaToSCFPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createTosaToSCFPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="TosaToSCFPass_8cpp_source.html#l06884">6884</a> of file <a class="el" href="TosaToSCFPass_8cpp_source.html">TosaToSCFPass.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TosaToSCFPass_8cpp_source.html#l00049">mlir::tosa::addTosaToSCFPasses()</a>.</p>

</div>
</div>
<a id="a192401f191b85e709a050ea54d730182" name="a192401f191b85e709a050ea54d730182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a192401f191b85e709a050ea54d730182">&#9670;&#160;</a></span>createTosaToTensorPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createTosaToTensorPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="TosaToTensorPass_8cpp_source.html#l06959">6959</a> of file <a class="el" href="TosaToTensorPass_8cpp_source.html">TosaToTensorPass.cpp</a>.</p>

</div>
</div>
<a id="a637be7379cf3e49297cb8b1c64c982ab" name="a637be7379cf3e49297cb8b1c64c982ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a637be7379cf3e49297cb8b1c64c982ab">&#9670;&#160;</a></span>createUBToLLVMConversionPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createUBToLLVMConversionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="UBToLLVM_8cpp_source.html#l07050">7050</a> of file <a class="el" href="UBToLLVM_8cpp_source.html">UBToLLVM.cpp</a>.</p>

</div>
</div>
<a id="a3d860247511080f9c387ccbc9c588f65" name="a3d860247511080f9c387ccbc9c588f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d860247511080f9c387ccbc9c588f65">&#9670;&#160;</a></span>createUBToLLVMConversionPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createUBToLLVMConversionPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1UBToLLVMConversionPassOptions.html">UBToLLVMConversionPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="UBToLLVM_8cpp_source.html#l07054">7054</a> of file <a class="el" href="UBToLLVM_8cpp_source.html">UBToLLVM.cpp</a>.</p>

</div>
</div>
<a id="a0f5e8bfd97c09cfa3b16ff9ab7c37860" name="a0f5e8bfd97c09cfa3b16ff9ab7c37860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f5e8bfd97c09cfa3b16ff9ab7c37860">&#9670;&#160;</a></span>createUBToSPIRVConversionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::createUBToSPIRVConversionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="UBToSPIRV_8cpp_source.html#l07129">7129</a> of file <a class="el" href="UBToSPIRV_8cpp_source.html">UBToSPIRV.cpp</a>.</p>

</div>
</div>
<a id="a54881321f630a119cdee5af076de868d" name="a54881321f630a119cdee5af076de868d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54881321f630a119cdee5af076de868d">&#9670;&#160;</a></span>debugString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string mlir::debugString </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DebugStringHelper_8h_source.html#l00028">28</a> of file <a class="el" href="DebugStringHelper_8h_source.html">DebugStringHelper.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Inliner_8cpp_source.html#l00351">getNodeName()</a>, <a class="el" href="IntegerRangeAnalysis_8cpp_source.html#l00062">mlir::dataflow::IntegerValueRangeLattice::onUpdate()</a>, and <a class="el" href="Deserializer_8cpp_source.html#l03024">mlir::spirv::Deserializer::processDebugString()</a>.</p>

</div>
</div>
<a id="af97b84cc5405247356b5af71ef661d9b" name="af97b84cc5405247356b5af71ef661d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97b84cc5405247356b5af71ef661d9b">&#9670;&#160;</a></span>decomposeMixedValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt; mlir::decomposeMixedValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>mixedValues</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decompose a vector of mixed static or dynamic values into the corresponding pair of arrays. </p>
<p>This is the inverse function of <span class="tt">getMixedValues</span>. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00226">226</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l01718">foldExtractFromBroadcast()</a>, and <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00687">getExpandedShapeAndType()</a>.</p>

</div>
</div>
<a id="a1041856e784cdbf7811cd10bc5a5ffd6" name="a1041856e784cdbf7811cd10bc5a5ffd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1041856e784cdbf7811cd10bc5a5ffd6">&#9670;&#160;</a></span>delinearize() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; mlir::delinearize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>linearIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the strides together with a linear index in the dimension space, return the vector-space offsets in each dimension for a de-linearized index. </p>
<p>Let <span class="tt">li = linearIndex</span>, assuming <span class="tt">strides</span> are <span class="tt">[s0, .. sn]</span>, return the vector of <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> <span class="tt">[li % s0, (li / s0) % s1, ..., (li / s0 / .. / sn-1) % sn]</span></p>
<p>It is the caller's responsibility to pass proper <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> kind that result in valid <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> (i.e. cannot multiply 2 <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a> or divide by an <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a>).</p>
<p><span class="tt">strides</span> elements are expected to bind to non-negative values. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00169">169</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00055">delinearizeImpl()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00959">mlir::AffineExpr::floorDiv()</a>.</p>

</div>
</div>
<a id="a2830e5f60c269c339ef24c33d8f7fbf0" name="a2830e5f60c269c339ef24c33d8f7fbf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2830e5f60c269c339ef24c33d8f7fbf0">&#9670;&#160;</a></span>delinearize() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; mlir::delinearize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>linearIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00176">176</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00097">delinearize()</a>, <a class="el" href="#ace395202c24e4dc75013296cf46ed692">getAffineConstantExprs()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00031">mlir::AffineExpr::getContext()</a>.</p>

</div>
</div>
<a id="a448d2cc69bc47c1304f4f1608937c3c4" name="a448d2cc69bc47c1304f4f1608937c3c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448d2cc69bc47c1304f4f1608937c3c4">&#9670;&#160;</a></span>delinearize() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; mlir::delinearize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>linearIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the strides together with a linear index in the dimension space, return the vector-space offsets in each dimension for a de-linearized index. </p>
<p><span class="tt">strides</span> elements are asserted to be non-negative.</p>
<p>Let <span class="tt">li = linearIndex</span>, assuming <span class="tt">strides</span> are <span class="tt">[s0, .. sn]</span>, return the vector of <a class="el" href="classint64__t.html">int64_t</a> <span class="tt">[li % s0, (li / s0) % s1, ..., (li / s0 / .. / sn-1) % sn]</span> </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00097">97</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00055">delinearizeImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00107">commonLinearIdBuilderFn()</a>, <a class="el" href="AsyncParallelFor_8cpp_source.html#l00241">createParallelComputeFunction()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00176">delinearize()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01815">foldExtractFromShapeCast()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00646">foreachIndividualVectorElement()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00368">mlir::detail::TileOffsetRangeImpl::getDynamicTileOffsets()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00360">mlir::detail::TileOffsetRangeImpl::getStaticTileOffsets()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00097">handleMultidimensionalVectors()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00231">laneIdBuilderFn()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02484">ToElementsOfBroadcast::matchAndRewrite()</a>, <a class="el" href="MemRefUtils_8cpp_source.html#l00253">mlir::memref::resolveSourceIndicesCollapseShape()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00416">mlir::linalg::rewriteInIm2Col()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00550">mlir::linalg::rewriteInIm2Col()</a>, and <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00123">mlir::linalg::rewriteInIm2Col()</a>.</p>

</div>
</div>
<a id="acad9612c1d4f11375369c3d1b2029b5c" name="acad9612c1d4f11375369c3d1b2029b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad9612c1d4f11375369c3d1b2029b5c">&#9670;&#160;</a></span>denormalizeInductionVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::denormalizeInductionVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>normalizedIv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>origLb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>origStep</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get back the original induction variable values after loop normalization. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00774">774</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00749">denormalizeInductionVariableForIndexType()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00304">getType()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00102">getValueOrCreateConstantIntOp()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00022">isOneInteger()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00020">isZeroInteger()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00710">mlir::RewriterBase::replaceAllUsesExcept()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00908">coalesceLoops()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01069">collapseParallelLoops()</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01479">normalizeForallOp()</a>.</p>

</div>
</div>
<a id="abf9a8d86f0213b02a553c01aea31e6e4" name="abf9a8d86f0213b02a553c01aea31e6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9a8d86f0213b02a553c01aea31e6e4">&#9670;&#160;</a></span>dispatchIndexOpFoldResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::dispatchIndexOpFoldResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>ofr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dynamicVec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>staticVec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to dispatch an <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> into <span class="tt">staticVec</span> if: a) it is an IntegerAttr In other cases, the <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> is dispached to the <span class="tt">dynamicVec</span>. </p>
<p>In such dynamic cases, ShapedType::kDynamic is also pushed to <span class="tt">staticVec</span>. This is useful to extract mixed static and dynamic entries that come from an AttrSizedOperandSegments trait.</p>
<p>In such dynamic cases, a copy of the <span class="tt">sentinel</span> value is also pushed to <span class="tt">staticVec</span>. This is useful to extract mixed static and dynamic entries that come from an AttrSizedOperandSegments trait. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00045">45</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="StaticValueUtils_8cpp_source.html#l00072">dispatchIndexOpFoldResults()</a>.</p>

</div>
</div>
<a id="a923d05c8f39df57cf19f1ec709bbe5a5" name="a923d05c8f39df57cf19f1ec709bbe5a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923d05c8f39df57cf19f1ec709bbe5a5">&#9670;&#160;</a></span>dispatchIndexOpFoldResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::dispatchIndexOpFoldResults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>ofrs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dynamicVec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>staticVec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to dispatch multiple OpFoldResults according to the behavior of <span class="tt">dispatchIndexOpFoldResult(<a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> ofr</span> for a single <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a>. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00072">72</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00045">dispatchIndexOpFoldResult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00088">mlir::tensor::bubbleUpPadSlice()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l05064">mlir::linalg::getStaticTilesImpl()</a>, and <a class="el" href="DecomposeMemRefs_8cpp_source.html#l00030">inferCastResultType()</a>.</p>

</div>
</div>
<a id="aeaf688b845e36e8284034d28fe9899bc" name="aeaf688b845e36e8284034d28fe9899bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf688b845e36e8284034d28fe9899bc">&#9670;&#160;</a></span>dropDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; mlir::dropDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>inputPerm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>dropPositions</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a permutation vector that drop the input dims in dropPositions from inputPerm. </p>
<p>For example, inputPerm = {2, 4, 0, 1, 3} and dropPositions= {1, 2} would result in a {2, 0, 1} permutation vector. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00237">237</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00095">mlir::tensor::dropGivenUnitDims()</a>, and <a class="el" href="LinalgOps_8cpp_source.html#l02134">SwapTransposeWithBroadcast::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="ab05e50dddc61ab840dee2a99add961d8" name="ab05e50dddc61ab840dee2a99add961d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05e50dddc61ab840dee2a99add961d8">&#9670;&#160;</a></span>eliminateCommonSubExpressions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::eliminateCommonSubExpressions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>domInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> *</td>          <td class="paramname"><span class="paramname"><em>changed</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eliminate common subexpressions within the given operation. </p>
<p>This transform looks for and deduplicates equivalent operations.</p>
<p><span class="tt">changed</span> indicates whether the IR was modified or not. </p>

<p class="definition">Definition at line <a class="el" href="CSE_8cpp_source.html#l00378">378</a> of file <a class="el" href="CSE_8cpp_source.html">CSE.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00285">changed</a>.</p>

</div>
</div>
<a id="a7739fe988f31077f0005b73f457eb373" name="a7739fe988f31077f0005b73f457eb373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7739fe988f31077f0005b73f457eb373">&#9670;&#160;</a></span>emitDefiniteFailure() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DiagnosedDefiniteFailure.html">DiagnosedDefiniteFailure</a> mlir::emitDefiniteFailure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;</td>          <td class="paramname"><span class="paramname"><em>message</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emits a definite failure with the given message. </p>
<p>The returned object allows for last-minute modification to the error message, such as attaching notes and completing the message. It will be reported when the object is destructed or converted. </p>

<p class="definition">Definition at line <a class="el" href="DiagnosedSilenceableFailure_8h_source.html#l00243">243</a> of file <a class="el" href="DiagnosedSilenceableFailure_8h_source.html">DiagnosedSilenceableFailure.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="MatchInterfaces_8h_source.html#l00086">mlir::transform::AtMostOneOpMatcherOpTrait&lt; OpTy &gt;::apply()</a>, <a class="el" href="MatchInterfaces_8h_source.html#l00115">mlir::transform::SingleOpMatcherOpTrait&lt; OpTy &gt;::apply()</a>, <a class="el" href="MatchInterfaces_8h_source.html#l00150">mlir::transform::SingleValueMatcherOpTrait&lt; OpTy &gt;::apply()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l00809">mlir::transform::TransformState::applyTransform()</a>, <a class="el" href="GPUTransformOps_8cpp_source.html#l00321">definiteFailureHelper()</a>, and <a class="el" href="TransformOps_8cpp_source.html#l01086">matchBlock()</a>.</p>

</div>
</div>
<a id="a1f82005038ea404596c74643db0d564f" name="a1f82005038ea404596c74643db0d564f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f82005038ea404596c74643db0d564f">&#9670;&#160;</a></span>emitDefiniteFailure() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DiagnosedDefiniteFailure.html">DiagnosedDefiniteFailure</a> mlir::emitDefiniteFailure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;</td>          <td class="paramname"><span class="paramname"><em>message</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DiagnosedSilenceableFailure_8h_source.html#l00247">247</a> of file <a class="el" href="DiagnosedSilenceableFailure_8h_source.html">DiagnosedSilenceableFailure.h</a>.</p>

</div>
</div>
<a id="a4e96b0c437652eb5a4890734bb6bcee7" name="a4e96b0c437652eb5a4890734bb6bcee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e96b0c437652eb5a4890734bb6bcee7">&#9670;&#160;</a></span>emitError() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to emit an error message using this location. </p>
<p>Emit an error message using this location. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00332">332</a> of file <a class="el" href="IR_2Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00332">emitError()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PassManagerOptions_8cpp_source.html#l00145">applyPassManagerCLOptions()</a>, <a class="el" href="LLVM_2ROCDL_2Target_8cpp_source.html#l00281">mlir::ROCDL::SerializeGPUModuleBase::assembleIsa()</a>, <a class="el" href="SPIRVAttributes_8h_source.html#l00078">mlir::spirv::attributeName&lt; ImageFormat &gt;()</a>, <a class="el" href="SPIRVAttributes_8h_source.html#l00130">mlir::spirv::attributeName&lt; ImageSamplingInfo &gt;()</a>, <a class="el" href="namespacemlir_1_1affine.html#addef193d35d8d7990addced6bcb731c1">mlir::affine::boundCheckLoadOrStoreOp()</a>, <a class="el" href="TosaOps_8cpp_source.html#l01325">buildAvgPool2dOpWithQuantInfo()</a>, <a class="el" href="TosaOps_8cpp_source.html#l01370">buildNegateOpWithQuantInfo()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00320">buildSequentialConstant()</a>, <a class="el" href="TosaOps_8cpp_source.html#l01424">buildVariableOp()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l01444">mlir::transform::detail::checkApplyToOne()</a>, <a class="el" href="OpenACC_8cpp_source.html#l04083">checkDeclareOperands()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l01422">mlir::transform::detail::checkNestedConsumption()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00337">checkTensorElementType()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01746">cleanupPrivateVars()</a>, <a class="el" href="LLVM_2XeVM_2Target_8cpp_source.html#l00111">mlir::xevm::SerializeGPUModuleBase::compileToBinary()</a>, <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00038">mlir::detail::constructContainerOpForParserIfNecessary()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01033">mlir::LLVM::ModuleImport::convertAliases()</a>, <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00145">convertCallLLVMIntrinsicOp()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01053">mlir::LLVM::ModuleImport::convertDataLayout()</a>, <a class="el" href="ODSSupport_8cpp_source.html#l00116">convertDenseArrayFromAttr()</a>, <a class="el" href="ODSSupport_8cpp_source.html#l00147">convertDenseArrayFromAttr()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00472">convertDenseResourceElementsAttr()</a>, <a class="el" href="ODSSupport_8cpp_source.html#l00101">convertFromAttribute()</a>, <a class="el" href="ODSSupport_8cpp_source.html#l00037">convertFromAttribute()</a>, <a class="el" href="ODSSupport_8cpp_source.html#l00022">convertFromAttribute()</a>, <a class="el" href="ODSSupport_8cpp_source.html#l00052">convertFromAttribute()</a>, <a class="el" href="ODSSupport_8cpp_source.html#l00139">convertFromAttribute()</a>, <a class="el" href="ODSSupport_8cpp_source.html#l00133">convertFromAttribute()</a>, <a class="el" href="ODSSupport_8cpp_source.html#l00166">convertFromAttribute()</a>, <a class="el" href="ODSSupport_8cpp_source.html#l00160">convertFromAttribute()</a>, <a class="el" href="ODSSupport_8cpp_source.html#l00086">convertFromAttribute()</a>, <a class="el" href="ODSSupport_8cpp_source.html#l00069">convertFromAttribute()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01015">mlir::LLVM::ModuleImport::convertGlobals()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01043">mlir::LLVM::ModuleImport::convertIFuncs()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l01131">convertMLIRAttributesToLLVM()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l01098">convertMLIRAttributeToLLVM()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l01728">convertParameterAttr()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01874">mlir::LLVM::ModuleImport::convertValue()</a>, <a class="el" href="NVVMDialect_8cpp_source.html#l00099">cpAsyncBulkTensorCommonVerifier()</a>, <a class="el" href="Deserializer_8cpp_source.html#l02193">mlir::spirv::Deserializer::createGraphBlock()</a>, <a class="el" href="ControlFlowToSCF_8cpp_source.html#l00134">mlir::ControlFlowToSCFTransformation::createUnreachableTerminator()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00232">deserializeCacheControlDecoration()</a>, <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00039">deserializeModule()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00500">mlir::spirv::Deserializer::processOp&lt; spirv::CopyMemoryOp &gt;()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00374">mlir::spirv::Deserializer::processOp&lt; spirv::EntryPointOp &gt;()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00424">mlir::spirv::Deserializer::processOp&lt; spirv::ExecutionModeOp &gt;()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00458">mlir::spirv::Deserializer::processOp&lt; spirv::FunctionCallOp &gt;()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00573">mlir::spirv::Deserializer::processOp&lt; spirv::GenericCastToPtrExplicitOp &gt;()</a>, <a class="el" href="AsmParser_2Parser_8cpp_source.html#l00201">mlir::detail::Parser::emitError()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00332">emitError()</a>, <a class="el" href="Builders_8h_source.html#l00701">mlir::ImplicitLocOpBuilder::emitError()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00268">mlir::Operation::emitError()</a>, <a class="el" href="OpenACCSupport_8cpp_source.html#l00038">mlir::acc::OpenACCSupport::emitNYI()</a>, <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00499">emitOptionalError()</a>, <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00039">mlir::transform::detail::expandPathsToMLIRFiles()</a>, <a class="el" href="FakeQuantSupport_8cpp_source.html#l00108">mlir::quant::fakeQuantAttrsToType()</a>, <a class="el" href="FakeQuantSupport_8cpp_source.html#l00139">mlir::quant::fakeQuantAttrsToType()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00125">fillStructuredOpRegion()</a>, <a class="el" href="PassCrashRecovery_8cpp_source.html#l00235">mlir::detail::PassCrashReproducerGenerator::finalize()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00239">mlir::detail::OpPassManagerImpl::finalizePassList()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00126">mlir::DynamicType::get()</a>, <a class="el" href="IRDLLoading_8cpp_source.html#l00431">getAttrOrTypeVerifier()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00251">mlir::DynamicAttr::getChecked()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00136">mlir::DynamicType::getChecked()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00193">mlir::gpu::MMAMatrixType::getChecked()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00251">mlir::quant::AnyQuantizedType::getChecked()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00532">mlir::quant::CalibratedQuantizedType::getChecked()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00345">mlir::quant::UniformQuantizedPerAxisType::getChecked()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00420">mlir::quant::UniformQuantizedSubChannelType::getChecked()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00289">mlir::quant::UniformQuantizedType::getChecked()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l01177">mlir::spirv::MatrixType::getChecked()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00761">mlir::spirv::SampledImageType::getChecked()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01275">mlir::detail::getDefaultDiagnosticEmitFn()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01271">mlir::detail::getDefaultDiagnosticEmitFn()</a>, <a class="el" href="MemoryOps_8cpp_source.html#l00263">mlir::spirv::getElementPtrType()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01853">getInsertExtractValueElementType()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00564">mlir::LLVM::detail::getLLVMConstant()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00486">mlir::LLVMTypeConverter::getMemRefDescriptorFields()</a>, <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html#l00185">mlir::bufferization::DeallocationState::getMemrefsAndConditionsToDeallocate()</a>, <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00077">getOverloadedDeclaration()</a>, <a class="el" href="BasicPtxBuilderInterface_8cpp_source.html#l00041">getRegisterType()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01220">getScalarConstantAsAttr()</a>, <a class="el" href="CLOptionsSetup_8cpp_source.html#l00085">mlir::tracing::InstallDebugHandler::Impl::Impl()</a>, <a class="el" href="IR_8cpp_source.html#l00534">inferOperationTypes()</a>, <a class="el" href="LLVMImportInterface_8h_source.html#l00112">mlir::LLVMImportInterface::initializeImport()</a>, <a class="el" href="IRDLLoading_8cpp_source.html#l00031">irdlAttrOrTypeVerifier()</a>, <a class="el" href="IRDLLoading_8cpp_source.html#l00190">irdlOpVerifier()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00161">isScaleInExpressedTypeRange()</a>, <a class="el" href="XeGPUOps_8cpp_source.html#l00125">isValidGatherScatterBufferParams()</a>, <a class="el" href="XeGPUOps_8cpp_source.html#l00078">isValidGatherScatterParams()</a>, <a class="el" href="LLVMAttrs_8cpp_source.html#l00060">mlir::LLVM::detail::isValidLoadStoreImpl()</a>, <a class="el" href="XeGPUOps_8cpp_source.html#l00177">IsValidMatrixOpParams()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00385">loadIRDLDialects()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l01651">mlir::transform::detail::mapPossibleTopLevelTransformOpBlockArguments()</a>, <a class="el" href="IR_8cpp_source.html#l00178">mlirAsmStateCreateForValue()</a>, <a class="el" href="CAPI_2IR_2Diagnostics_8cpp_source.html#l00078">mlirEmitError()</a>, <a class="el" href="LLVM_8cpp_source.html#l00117">mlirLLVMStructTypeLiteralGetChecked()</a>, <a class="el" href="MlirReduceMain_8cpp_source.html#l00045">mlirReduceMain()</a>, <a class="el" href="AffineParser_8cpp_source.html#l00720">mlir::detail::Parser::parseAffineMapReference()</a>, <a class="el" href="SMTAttributes_8cpp_source.html#l00052">parseBitVectorString()</a>, <a class="el" href="Dialect_2EmitC_2IR_2EmitC_8cpp_source.html#l00179">parseFormatString()</a>, <a class="el" href="AffineParser_8cpp_source.html#l00733">mlir::detail::Parser::parseIntegerSetReference()</a>, <a class="el" href="OpDefinition_8h_source.html#l02009">mlir::Op&lt; ConcreteType, Traits &gt;::parseProperties()</a>, <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00088">mlir::transform::detail::parseTransformModuleFromFile()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00496">performActions()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01222">mlir::spirv::Deserializer::processArrayType()</a>, <a class="el" href="Deserializer_8cpp_source.html#l02116">mlir::spirv::Deserializer::processBranch()</a>, <a class="el" href="Deserializer_8cpp_source.html#l02137">mlir::spirv::Deserializer::processBranchConditional()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01636">mlir::spirv::Deserializer::processConstant()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01754">mlir::spirv::Deserializer::processConstantBool()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01777">mlir::spirv::Deserializer::processConstantComposite()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01833">mlir::spirv::Deserializer::processConstantCompositeReplicateEXT()</a>, <a class="el" href="Deserializer_8cpp_source.html#l02036">mlir::spirv::Deserializer::processConstantNull()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01280">mlir::spirv::Deserializer::processCooperativeMatrixTypeKHR()</a>, <a class="el" href="Deserializer_8cpp_source.html#l03009">mlir::spirv::Deserializer::processDebugLine()</a>, <a class="el" href="Deserializer_8cpp_source.html#l03024">mlir::spirv::Deserializer::processDebugString()</a>, <a class="el" href="Serializer_8cpp_source.html#l00281">mlir::spirv::processDecorationList()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00353">mlir::spirv::Deserializer::processExtInst()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l02958">mlir::LLVM::ModuleImport::processFunction()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00481">mlir::spirv::Deserializer::processFunction()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00649">mlir::spirv::Deserializer::processFunctionEnd()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01255">mlir::spirv::Deserializer::processFunctionType()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00938">mlir::spirv::Deserializer::processGlobalVariable()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00714">mlir::spirv::Deserializer::processGraphARM()</a>, <a class="el" href="Deserializer_8cpp_source.html#l02069">mlir::spirv::Deserializer::processGraphConstantARM()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00846">mlir::spirv::Deserializer::processGraphEndARM()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00674">mlir::spirv::Deserializer::processGraphEntryPointARM()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01528">mlir::spirv::Deserializer::processGraphTypeARM()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01570">mlir::spirv::Deserializer::processImageType()</a>, <a class="el" href="Deserializer_8cpp_source.html#l02170">mlir::spirv::Deserializer::processLabel()</a>, <a class="el" href="Deserializer_8cpp_source.html#l02238">mlir::spirv::Deserializer::processLoopMerge()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01459">mlir::spirv::Deserializer::processMatrixType()</a>, <a class="el" href="Deserializer_8h_source.html#l00560">mlir::spirv::Deserializer::processOp()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00822">mlir::spirv::Deserializer::processOpGraphSetOutputARM()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01167">mlir::spirv::Deserializer::processOpTypePointer()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00261">mlir::spirv::Deserializer::processOpWithoutGrammarAttr()</a>, <a class="el" href="Deserializer_8cpp_source.html#l02264">mlir::spirv::Deserializer::processPhi()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01341">mlir::spirv::Deserializer::processRuntimeArrayType()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01618">mlir::spirv::Deserializer::processSampledImageType()</a>, <a class="el" href="Deserializer_8cpp_source.html#l02212">mlir::spirv::Deserializer::processSelectionMerge()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01881">mlir::spirv::Deserializer::processSpecConstantComposite()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01916">mlir::spirv::Deserializer::processSpecConstantCompositeReplicateEXT()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01952">mlir::spirv::Deserializer::processSpecConstantOperation()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01357">mlir::spirv::Deserializer::processStructType()</a>, <a class="el" href="Deserializer_8cpp_source.html#l02296">mlir::spirv::Deserializer::processSwitch()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01479">mlir::spirv::Deserializer::processTensorARMType()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01046">mlir::spirv::Deserializer::processType()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01557">mlir::spirv::Deserializer::processTypeForwardPointer()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00341">mlir::spirv::Deserializer::processUndef()</a>, <a class="el" href="DLTI_8cpp_source.html#l00537">mlir::dlti::query()</a>, <a class="el" href="DLTI_8cpp_source.html#l00595">mlir::dlti::query()</a>, <a class="el" href="BytecodeReader_8cpp_source.html#l02815">readBytecodeFileImpl()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00027">registerFromLLVMIRTranslation()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l01035">mlir::PassManager::run()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00425">mlir::spirv::Deserializer::setFunctionArgAttrs()</a>, <a class="el" href="OperationSupport_8h_source.html#l00437">mlir::OperationName::setOpPropertiesFromAttribute()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00353">mlir::MlirOptMainConfig::setPassPipelineParser()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00195">mlir::OperationState::setProperties()</a>, <a class="el" href="ExtensibleDialect_8h_source.html#l00489">mlir::DynamicOpDefinition::setPropertiesFromAttr()</a>, <a class="el" href="structmlir_1_1OperationName_1_1InterfaceConcept.html#a7550cfe299169ccc5776f048f287fda3">mlir::OperationName::InterfaceConcept::setPropertiesFromAttr()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00916">mlir::OperationName::UnregisteredOpModel::setPropertiesFromAttr()</a>, <a class="el" href="OperationSupport_8h_source.html#l00635">mlir::RegisteredOperationName::Model&lt; ConcreteOp &gt;::setPropertiesFromAttr()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00099">mlir::spirv::Deserializer::sliceInstruction()</a>, <a class="el" href="Deserializer_8cpp_source.html#l02918">mlir::spirv::Deserializer::structurizeControlFlow()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00176">translateDataLayout()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l03335">mlir::LLVM::ModuleImport::translateDereferenceableAttr()</a>, <a class="el" href="ExtensibleDialect_8h_source.html#l00086">mlir::DynamicAttrDefinition::verify()</a>, <a class="el" href="ExtensibleDialect_8h_source.html#l00242">mlir::DynamicTypeDefinition::verify()</a>, <a class="el" href="IRDLVerifiers_8cpp_source.html#l00197">mlir::irdl::AllOfConstraint::verify()</a>, <a class="el" href="IRDLVerifiers_8cpp_source.html#l00209">mlir::irdl::AnyAttributeConstraint::verify()</a>, <a class="el" href="IRDLVerifiers_8cpp_source.html#l00181">mlir::irdl::AnyOfConstraint::verify()</a>, <a class="el" href="IRDLVerifiers_8cpp_source.html#l00069">mlir::irdl::BaseAttrConstraint::verify()</a>, <a class="el" href="IRDLVerifiers_8cpp_source.html#l00082">mlir::irdl::BaseTypeConstraint::verify()</a>, <a class="el" href="classmlir_1_1irdl_1_1Constraint.html#acf973f18a1f39e59127fe6ee0e223b41">mlir::irdl::Constraint::verify()</a>, <a class="el" href="IRDLVerifiers_8cpp_source.html#l00032">mlir::irdl::ConstraintVerifier::verify()</a>, <a class="el" href="IRDLVerifiers_8cpp_source.html#l00101">mlir::irdl::DynParametricAttrConstraint::verify()</a>, <a class="el" href="IRDLVerifiers_8cpp_source.html#l00137">mlir::irdl::DynParametricTypeConstraint::verify()</a>, <a class="el" href="IRDLVerifiers_8cpp_source.html#l00056">mlir::irdl::IsConstraint::verify()</a>, <a class="el" href="IRDLVerifiers_8cpp_source.html#l00215">mlir::irdl::RegionConstraint::verify()</a>, <a class="el" href="BuiltinAttributeInterfaces_8cpp_source.html#l00077">mlir::detail::verifyAffineMapAsLayout()</a>, <a class="el" href="PtrDialect_8cpp_source.html#l00049">verifyAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00797">mlir::detail::verifyDataLayoutSpec()</a>, <a class="el" href="ShardOps_8cpp_source.html#l01011">verifyDimensionCompatibility()</a>, <a class="el" href="DLTI_8cpp_source.html#l00134">verifyEntries()</a>, <a class="el" href="ShardOps_8cpp_source.html#l01027">verifyGatherOperandAndResultShape()</a>, <a class="el" href="ShardOps_8cpp_source.html#l00177">verifyGridAxes()</a>, <a class="el" href="ShardOps_8cpp_source.html#l00985">verifyInGroupDevice()</a>, <a class="el" href="ExtensibleDialect_8h_source.html#l00477">mlir::DynamicOpDefinition::verifyInherentAttrs()</a>, <a class="el" href="structmlir_1_1OperationName_1_1InterfaceConcept.html#ad3954ee41077f8514d5785007bbf6dab">mlir::OperationName::InterfaceConcept::verifyInherentAttrs()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00896">mlir::OperationName::UnregisteredOpModel::verifyInherentAttrs()</a>, <a class="el" href="OperationSupport_8h_source.html#l00407">mlir::OperationName::verifyInherentAttrs()</a>, <a class="el" href="OperationSupport_8h_source.html#l00596">mlir::RegisteredOperationName::Model&lt; ConcreteOp &gt;::verifyInherentAttrs()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00217">mlir::gpu::MMAMatrixType::verifyInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00261">mlir::quant::AnyQuantizedType::verifyInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00539">mlir::quant::CalibratedQuantizedType::verifyInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00045">mlir::quant::QuantizedType::verifyInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00355">mlir::quant::UniformQuantizedPerAxisType::verifyInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00432">mlir::quant::UniformQuantizedSubChannelType::verifyInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00298">mlir::quant::UniformQuantizedType::verifyInvariants()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00166">mlir::spirv::InterfaceVarABIAttr::verifyInvariants()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l01184">mlir::spirv::MatrixType::verifyInvariants()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00769">mlir::spirv::SampledImageType::verifyInvariants()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l01290">mlir::spirv::TensorArmType::verifyInvariants()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00261">mlir::spirv::VerCapExtAttr::verifyInvariants()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l01991">verifyMapClause()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l02060">verifyPrivateVarsMapping()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l01036">verifyRegionAttribute()</a>, <a class="el" href="ShardOps_8cpp_source.html#l01099">verifyScatterOrSliceOperandAndResultShape()</a>, <a class="el" href="TargetEnv_8cpp_source.html#l00072">mlir::tosa::TargetEnv::verifyTargetInformation()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00887">mlir::detail::verifyTargetSystemSpec()</a>, <a class="el" href="NVVMDialect_8cpp_source.html#l05185">verifyTcgen05MMABlockScaleOp()</a>, <a class="el" href="NVVMDialect_8cpp_source.html#l04920">verifyTcgen05MMAOp()</a>, <a class="el" href="NVVMDialect_8cpp_source.html#l00158">verifyTMALoadParams()</a>, <a class="el" href="Deserializer_8cpp_source.html#l02775">mlir::spirv::Deserializer::wireUpBlockArgument()</a>, <a class="el" href="classmlir_1_1irdl_1_1AllOfConstraint.html#a2a556935d3e548ac27b6c5e4e94bdbfd">mlir::irdl::AllOfConstraint::~AllOfConstraint()</a>, <a class="el" href="classmlir_1_1irdl_1_1AnyAttributeConstraint.html#a95c916e901b1c2ac8a034d95fee630c2">mlir::irdl::AnyAttributeConstraint::~AnyAttributeConstraint()</a>, <a class="el" href="classmlir_1_1irdl_1_1AnyOfConstraint.html#a9a2a926d0b60bdfb1a62fbba22167198">mlir::irdl::AnyOfConstraint::~AnyOfConstraint()</a>, <a class="el" href="classmlir_1_1irdl_1_1BaseAttrConstraint.html#a8cade942b410494de524685b1769439a">mlir::irdl::BaseAttrConstraint::~BaseAttrConstraint()</a>, <a class="el" href="classmlir_1_1irdl_1_1BaseTypeConstraint.html#a7c7ce2972c3ceac355af837d2a498c69">mlir::irdl::BaseTypeConstraint::~BaseTypeConstraint()</a>, <a class="el" href="classmlir_1_1irdl_1_1DynParametricAttrConstraint.html#a013f297b972caaefe15d2cbb44c978ef">mlir::irdl::DynParametricAttrConstraint::~DynParametricAttrConstraint()</a>, <a class="el" href="classmlir_1_1irdl_1_1DynParametricTypeConstraint.html#a036f4e1608ccdd64eb648061c0f7ab04">mlir::irdl::DynParametricTypeConstraint::~DynParametricTypeConstraint()</a>, and <a class="el" href="classmlir_1_1irdl_1_1IsConstraint.html#ada112835cf744f2f66017d1badc975d7">mlir::irdl::IsConstraint::~IsConstraint()</a>.</p>

</div>
</div>
<a id="a2dc4e9418ff63ebea20c7f709ebcb0f8" name="a2dc4e9418ff63ebea20c7f709ebcb0f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc4e9418ff63ebea20c7f709ebcb0f8">&#9670;&#160;</a></span>emitError() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;</td>          <td class="paramname"><span class="paramname"><em>message</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00333">333</a> of file <a class="el" href="IR_2Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00310">emitDiag()</a>, and <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00044">Error</a>.</p>

</div>
</div>
<a id="aecf5a29768872240e0bbd49d969f084b" name="aecf5a29768872240e0bbd49d969f084b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf5a29768872240e0bbd49d969f084b">&#9670;&#160;</a></span>emitNormalizedLoopBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1Range.html">Range</a> mlir::emitNormalizedLoopBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>step</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Materialize bounds and step of a zero-based and unit-step loop derived by normalizing the specified bounds and step. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00703">703</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00526">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00688">emitNormalizedLoopBoundsForIndexType()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">getConstantIntValue()</a>, <a class="el" href="Builders_8cpp_source.html#l00342">mlir::Builder::getOneAttr()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00304">getType()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00102">getValueOrCreateConstantIntOp()</a>, and <a class="el" href="Builders_8cpp_source.html#l00324">mlir::Builder::getZeroAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00908">coalesceLoops()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01069">collapseParallelLoops()</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01479">normalizeForallOp()</a>.</p>

</div>
</div>
<a id="a45deee4eed2b998fbde1d3573325bc6e" name="a45deee4eed2b998fbde1d3573325bc6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45deee4eed2b998fbde1d3573325bc6e">&#9670;&#160;</a></span>emitOptionalError()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::emitOptionalError </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads of the above emission functions that take an optionally null location. </p>
<p>If the location is null, no diagnostic is emitted and a failure is returned. Given that the provided location may be null, these methods take the diagnostic arguments directly instead of relying on the returned <a class="el" href="classmlir_1_1InFlightDiagnostic.html" title="This class represents a diagnostic that is inflight and set to be reported.">InFlightDiagnostic</a>. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00499">499</a> of file <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

<p class="reference">References <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00342">mlir::InFlightDiagnostic::append()</a>, and <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00332">emitError()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArithOps_8cpp_source.html#l02666">mlir::arith::getIdentityValueAttr()</a>, <a class="el" href="ArithOps_8cpp_source.html#l02786">mlir::arith::getReductionOp()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l00684">mlir::vector::getVectorReductionOp()</a>.</p>

</div>
</div>
<a id="a3f5cd384eee5c5c8a7125233ade78eea" name="a3f5cd384eee5c5c8a7125233ade78eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5cd384eee5c5c8a7125233ade78eea">&#9670;&#160;</a></span>emitOptionalRemark()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::emitOptionalRemark </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00511">511</a> of file <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

<p class="reference">References <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00342">mlir::InFlightDiagnostic::append()</a>, and <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00346">emitRemark()</a>.</p>

</div>
</div>
<a id="ac03c4337fa32d3045568e4dc6eef60ca" name="ac03c4337fa32d3045568e4dc6eef60ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac03c4337fa32d3045568e4dc6eef60ca">&#9670;&#160;</a></span>emitOptionalWarning()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::emitOptionalWarning </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00505">505</a> of file <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

<p class="reference">References <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00342">mlir::InFlightDiagnostic::append()</a>, and <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00338">emitWarning()</a>.</p>

</div>
</div>
<a id="a8a9ca6fe9d5aab498bf090db3e878c87" name="a8a9ca6fe9d5aab498bf090db3e878c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9ca6fe9d5aab498bf090db3e878c87">&#9670;&#160;</a></span>emitRemark() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitRemark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to emit a remark message using this location. </p>
<p>Emit a remark message using this location. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00346">346</a> of file <a class="el" href="IR_2Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00346">emitRemark()</a>.</p>

<p class="reference">Referenced by <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00511">emitOptionalRemark()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00346">emitRemark()</a>, <a class="el" href="Builders_8h_source.html#l00709">mlir::ImplicitLocOpBuilder::emitRemark()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00289">mlir::Operation::emitRemark()</a>, and <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00259">mlir::detail::reportFatalInferReturnTypesError()</a>.</p>

</div>
</div>
<a id="a391c4b4ea9dc95fbcfbfdab8a49547a3" name="a391c4b4ea9dc95fbcfbfdab8a49547a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391c4b4ea9dc95fbcfbfdab8a49547a3">&#9670;&#160;</a></span>emitRemark() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitRemark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;</td>          <td class="paramname"><span class="paramname"><em>message</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00349">349</a> of file <a class="el" href="IR_2Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00310">emitDiag()</a>, and <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00045">Remark</a>.</p>

</div>
</div>
<a id="a428b91d18eabd5b259a3ed6e0f27f60c" name="a428b91d18eabd5b259a3ed6e0f27f60c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428b91d18eabd5b259a3ed6e0f27f60c">&#9670;&#160;</a></span>emitSilenceableFailure() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DiagnosedSilenceableFailure.html">DiagnosedSilenceableFailure</a> mlir::emitSilenceableFailure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;</td>          <td class="paramname"><span class="paramname"><em>message</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emits a silenceable failure with the given message. </p>
<p>A silenceable failure must be either suppressed or converted into a definite failure and reported to the user. </p>

<p class="definition">Definition at line <a class="el" href="DiagnosedSilenceableFailure_8h_source.html#l00256">256</a> of file <a class="el" href="DiagnosedSilenceableFailure_8h_source.html">DiagnosedSilenceableFailure.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgMatchOps_8cpp_source.html#l00321">containsAll()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l00133">dispatchMappedValues()</a>, <a class="el" href="MatchInterfaces_8cpp_source.html#l00104">mlir::transform::expandTargetSpecification()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l01199">mlir::transform::TrackingListener::findReplacementOp()</a>, <a class="el" href="SCFTransformOps_8cpp_source.html#l00501">isOpSibling()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00349">pipelineForSharedCopies()</a>, <a class="el" href="TransformOps_8cpp_source.html#l02470">verifyNamedSequenceOp()</a>, and <a class="el" href="TransformOps_8cpp_source.html#l02418">verifyYieldingSingleBlockOp()</a>.</p>

</div>
</div>
<a id="a078c07e9f16a6122a56bae420ce94308" name="a078c07e9f16a6122a56bae420ce94308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078c07e9f16a6122a56bae420ce94308">&#9670;&#160;</a></span>emitSilenceableFailure() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DiagnosedSilenceableFailure.html">DiagnosedSilenceableFailure</a> mlir::emitSilenceableFailure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;</td>          <td class="paramname"><span class="paramname"><em>message</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DiagnosedSilenceableFailure_8h_source.html#l00262">262</a> of file <a class="el" href="DiagnosedSilenceableFailure_8h_source.html">DiagnosedSilenceableFailure.h</a>.</p>

</div>
</div>
<a id="a0768c8a572dc71b0b00d57414b56b60d" name="a0768c8a572dc71b0b00d57414b56b60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0768c8a572dc71b0b00d57414b56b60d">&#9670;&#160;</a></span>emitWarning() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitWarning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to emit a warning message using this location. </p>
<p>Emit a warning message using this location. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00338">338</a> of file <a class="el" href="IR_2Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00338">emitWarning()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleImport_8cpp_source.html#l01053">mlir::LLVM::ModuleImport::convertDataLayout()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00604">convertInt64FromKeyValueTuple()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00847">mlir::LLVM::ModuleImport::convertModuleFlagsMetadata()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00651">convertProfileSummaryDetailed()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00622">convertProfileSummaryFormat()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00705">convertProfileSummaryModuleFlagValue()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00238">convertScalarToDtype()</a>, <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00505">emitOptionalWarning()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00338">emitWarning()</a>, <a class="el" href="Builders_8h_source.html#l00705">mlir::ImplicitLocOpBuilder::emitWarning()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00280">mlir::Operation::emitWarning()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00582">getConstantMDFromKeyValueTuple()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00569">getTwoElementMDTuple()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00078">mlir::GPUFuncOpLowering::matchAndRewrite()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l02958">mlir::LLVM::ModuleImport::processFunction()</a>, <a class="el" href="LoopAnnotationImporter_8cpp_source.html#l00487">mlir::LLVM::detail::LoopAnnotationImporter::translateAccessGroup()</a>, and <a class="el" href="TransformOps_8cpp_source.html#l01464">verifyFunctionLikeConsumeAnnotations()</a>.</p>

</div>
</div>
<a id="a5e96e5ea091fb5bea539cef6ea7c5624" name="a5e96e5ea091fb5bea539cef6ea7c5624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e96e5ea091fb5bea539cef6ea7c5624">&#9670;&#160;</a></span>emitWarning() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitWarning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;</td>          <td class="paramname"><span class="paramname"><em>message</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00341">341</a> of file <a class="el" href="IR_2Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00310">emitDiag()</a>, and <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00043">Warning</a>.</p>

</div>
</div>
<a id="ab8075944125730fed529e3b93dcfed5b" name="ab8075944125730fed529e3b93dcfed5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8075944125730fed529e3b93dcfed5b">&#9670;&#160;</a></span>encodeBindAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::encodeBindAttribute </td>
          <td>(</td>
          <td class="paramtype">ModuleOp</td>          <td class="paramname"><span class="paramname"><em>module</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes global variable's descriptor set and binding into its name if they both exist. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVToLLVM_8cpp_source.html#l01973">1973</a> of file <a class="el" href="SPIRVToLLVM_8cpp_source.html">SPIRVToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVToLLVM_8cpp_source.html#l01971">kBinding</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l01972">kDescriptorSet</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00934">mlir::SymbolTable::replaceAllSymbolUses()</a>, and <a class="el" href="SymbolTable_8cpp_source.html#l00298">mlir::SymbolTable::setSymbolName()</a>.</p>

</div>
</div>
<a id="a6ab9585c8607c12142232e0f58ebcc8b" name="a6ab9585c8607c12142232e0f58ebcc8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab9585c8607c12142232e0f58ebcc8b">&#9670;&#160;</a></span>eraseUnreachableBlocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::eraseUnreachableBlocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>regions</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase the unreachable blocks within the provided regions. </p>
<p>Returns success if any blocks were erased, failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00186">186</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00060">mlir::Region::empty()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00232">mlir::RewriterBase::eraseBlock()</a>, <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="IR_2Region_8h_source.html#l00045">mlir::Region::getBlocks()</a>, <a class="el" href="IR_2Region_8h_source.html#l00200">mlir::Region::getParentOp()</a>, <a class="el" href="IR_2Region_8h_source.html#l00068">mlir::Region::hasOneBlock()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8cpp_source.html#l01069">simplifyRegions()</a>.</p>

</div>
</div>
<a id="a0bbb3252a45b5feab49c0bac2a68779c" name="a0bbb3252a45b5feab49c0bac2a68779c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bbb3252a45b5feab49c0bac2a68779c">&#9670;&#160;</a></span>expandDimsToRank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::expandDimsToRank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>rank</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;</td>          <td class="paramname"><span class="paramname"><em>projectedDimensions</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand <span class="tt">map</span> to operate on <span class="tt">rank</span> dims while projecting out the dims in <span class="tt">projectedDimensions</span>. </p>
<p>This amounts to composing <span class="tt">map</span> with <span class="tt">id(rank).dropResults(projectedDimensions)</span>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00948">948</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00552">mlir::AffineMap::compose()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00299">mlir::AffineMap::dropResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">mlir::AffineMap::getContext()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00330">mlir::AffineMap::getMultiDimIdentityMap()</a>.</p>

</div>
</div>
<a id="aecdaa20d0acb7aec0f05cb700b1e09df" name="aecdaa20d0acb7aec0f05cb700b1e09df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecdaa20d0acb7aec0f05cb700b1e09df">&#9670;&#160;</a></span>extractFixedOuterLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5510ab947817d6f0bf6617e367113963">TileLoops</a> mlir::extractFixedOuterLoops </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp</td>          <td class="paramname"><span class="paramname"><em>rootFOrOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01331">1331</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00265">ceilDivPositive()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01227">getPerfectlyNestedLoopsImpl()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01293">tile()</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01205">tryIsolateBands()</a>.</p>

</div>
</div>
<a id="ad6a57f568be3df657740d74ad2fa382f" name="ad6a57f568be3df657740d74ad2fa382f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a57f568be3df657740d74ad2fa382f">&#9670;&#160;</a></span>extractFromIntegerArrayAttr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntTy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; IntTy &gt; mlir::extractFromIntegerArrayAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td>          <td class="paramname"><span class="paramname"><em>attr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract integer values from the assumed ArrayAttr of IntegerAttr. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8h_source.html#l00086">86</a> of file <a class="el" href="StaticValueUtils_8h_source.html">StaticValueUtils.h</a>.</p>

</div>
</div>
<a id="a3083728e72d361c987c5e5a0e8d2f39a" name="a3083728e72d361c987c5e5a0e8d2f39a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3083728e72d361c987c5e5a0e8d2f39a">&#9670;&#160;</a></span>failableParallelForEach() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorT, typename FuncT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::failableParallelForEach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncT &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the given function on the elements between [begin, end) asynchronously. </p>
<p>If the given function returns a failure when processing any of the elements, execution is stopped and a failure is returned from this function. This means that in the case of failure, not all elements of the range will be processed. Diagnostics emitted during processing are ordered relative to the element's position within [begin, end). If the provided context does not have multi-threading enabled, this function always processes elements sequentially. </p>

<p class="definition">Definition at line <a class="el" href="Threading_8h_source.html#l00036">36</a> of file <a class="el" href="Threading_8h_source.html">Threading.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l01071">mlir::ParallelDiagnosticHandler::eraseOrderIDForThread()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00655">mlir::MLIRContext::getThreadPool()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00597">mlir::MLIRContext::isMultithreadingEnabled()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l01065">mlir::ParallelDiagnosticHandler::setOrderIDForThread()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Threading_8h_source.html#l00090">failableParallelForEach()</a>, <a class="el" href="Threading_8h_source.html#l00105">failableParallelForEachN()</a>, and <a class="el" href="Threading_8h_source.html#l00117">parallelForEach()</a>.</p>

</div>
</div>
<a id="a98aa0f01173a481075d9d5a2ca50d8ab" name="a98aa0f01173a481075d9d5a2ca50d8ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98aa0f01173a481075d9d5a2ca50d8ab">&#9670;&#160;</a></span>failableParallelForEach() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT, typename FuncT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::failableParallelForEach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RangeT &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncT &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the given function on the elements in the provided range asynchronously. </p>
<p>If the given function returns a failure when processing any of the elements, execution is stopped and a failure is returned from this function. This means that in the case of failure, not all elements of the range will be processed. Diagnostics emitted during processing are ordered relative to the element's position within the range. If the provided context does not have multi-threading enabled, this function always processes elements sequentially. </p>

<p class="definition">Definition at line <a class="el" href="Threading_8h_source.html#l00090">90</a> of file <a class="el" href="Threading_8h_source.html">Threading.h</a>.</p>

<p class="reference">References <a class="el" href="Threading_8h_source.html#l00036">failableParallelForEach()</a>.</p>

</div>
</div>
<a id="af5aa5179ec6f13db4eaa8fa255bde665" name="af5aa5179ec6f13db4eaa8fa255bde665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5aa5179ec6f13db4eaa8fa255bde665">&#9670;&#160;</a></span>failableParallelForEachN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FuncT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::failableParallelForEachN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncT &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the given function on the elements between [begin, end) asynchronously. </p>
<p>If the given function returns a failure when processing any of the elements, execution is stopped and a failure is returned from this function. This means that in the case of failure, not all elements of the range will be processed. Diagnostics emitted during processing are ordered relative to the element's position within [begin, end). If the provided context does not have multi-threading enabled, this function always processes elements sequentially. </p>

<p class="definition">Definition at line <a class="el" href="Threading_8h_source.html#l00105">105</a> of file <a class="el" href="Threading_8h_source.html">Threading.h</a>.</p>

<p class="reference">References <a class="el" href="Threading_8h_source.html#l00036">failableParallelForEach()</a>.</p>

</div>
</div>
<a id="a6ceb7a2611f873431057e03992432701" name="a6ceb7a2611f873431057e03992432701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ceb7a2611f873431057e03992432701">&#9670;&#160;</a></span>filterTypesOut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> mlir::filterTypesOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a></td>          <td class="paramname"><span class="paramname"><em>types</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BitVector &amp;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>storage</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters out any elements referenced by <span class="tt">indices</span>. </p>
<p>If any types are removed, <span class="tt">storage</span> is used to hold the new type list. Returns the new type list. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00194">194</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00262">indices</a>.</p>

</div>
</div>
<a id="a04b8cb2bfcf870fb9909b4805c0aad13" name="a04b8cb2bfcf870fb9909b4805c0aad13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b8cb2bfcf870fb9909b4805c0aad13">&#9670;&#160;</a></span>finalizeParallelLoopToGPUConversion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::finalizeParallelLoopToGPUConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean up after applyPartialConversion/applyFullConversion call. </p>

<p class="definition">Definition at line <a class="el" href="SCFToGPU_8cpp_source.html#l00782">782</a> of file <a class="el" href="SCFToGPU_8cpp_source.html">SCFToGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="SCFToGPU_8cpp_source.html#l00057">kVisitedAttrName</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00797">mlir::Operation::walk()</a>.</p>

</div>
</div>
<a id="adb672e2258ecd8657ec36b0fd391208a" name="adb672e2258ecd8657ec36b0fd391208a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb672e2258ecd8657ec36b0fd391208a">&#9670;&#160;</a></span>findPositionsOfType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::findPositionsOfType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; utils::IteratorType &gt;</td>          <td class="paramname"><span class="paramname"><em>iteratorTypes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utils::IteratorType</td>          <td class="paramname"><span class="paramname"><em>iteratorTypeName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>res</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return positions in <span class="tt">iteratorTypes</span> that match <span class="tt">iteratorTypeName</span>. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00077">77</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

</div>
</div>
<a id="a465b98f3a320b384f6141df0ae267afb" name="a465b98f3a320b384f6141df0ae267afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a465b98f3a320b384f6141df0ae267afb">&#9670;&#160;</a></span>findReachableBlocks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::findReachableBlocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>region</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a4aa33aa05f4fcff8a40613b43fb06f01">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Block.html">Block</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>reachableBlocks</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="WalkPatternRewriteDriver_8cpp_source.html#l00032">32</a> of file <a class="el" href="WalkPatternRewriteDriver_8cpp_source.html">WalkPatternRewriteDriver.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00152">mlir::Block::back()</a>, <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00703">mlir::Operation::getSuccessors()</a>.</p>

<p class="reference">Referenced by <a class="el" href="WalkPatternRewriteDriver_8cpp_source.html#l00093">walkAndApplyPatterns()</a>.</p>

</div>
</div>
<a id="ae92bdb36e3e6eeecc32f23923e58d973" name="ae92bdb36e3e6eeecc32f23923e58d973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae92bdb36e3e6eeecc32f23923e58d973">&#9670;&#160;</a></span>foldAttributesIntoMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::foldAttributesIntoMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>remainingValues</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fold all attributes among the given operands into the affine map. </p>
<p>Return the folded affine map. Return all remaining values via <span class="tt">remainingValues</span>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00738">738</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00496">mlir::AffineMap::replaceDimsAndSymbols()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00826">mlir::ValueBoundsConstraintSet::areOverlappingSlices()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01416">mlir::affine::makeComposedAffineApply()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01525">makeComposedMinMax()</a>.</p>

</div>
</div>
<a id="afccef918a87cccab273bba3cb00beed7" name="afccef918a87cccab273bba3cb00beed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afccef918a87cccab273bba3cb00beed7">&#9670;&#160;</a></span>foldDynamicIndexList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::foldDynamicIndexList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ofrs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>onlyNonNegative</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>onlyNonZero</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns "success" when any of the elements in <span class="tt">ofrs</span> is a constant value. </p>
<p>In that case the value is replaced by an attribute. Returns "failure" when no folding happened. If <span class="tt">onlyNonNegative</span> and <span class="tt">onlyNonZero</span> are set, only non-negative and non-zero constant values are folded respectively. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00395">395</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">getConstantIntValue()</a>, <a class="el" href="Matchers_8h_source.html#l00369">m_Constant()</a>, <a class="el" href="Matchers_8h_source.html#l00490">matchPattern()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="StaticValueUtils_8cpp_source.html#l00416">foldDynamicOffsetSizeList()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00421">foldDynamicStrideList()</a>, <a class="el" href="ViewLikeInterface_8h_source.html#l00085">mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder&lt; OpType, ResultTypeFn, CastOpFunc &gt;::matchAndRewrite()</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01479">normalizeForallOp()</a>.</p>

</div>
</div>
<a id="af04a9037c5785dac1e037c025297c4da" name="af04a9037c5785dac1e037c025297c4da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04a9037c5785dac1e037c025297c4da">&#9670;&#160;</a></span>foldDynamicOffsetSizeList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::foldDynamicOffsetSizeList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>offsetsOrSizes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns "success" when any of the elements in <span class="tt">offsetsOrSizes</span> is a constant value. </p>
<p>In that case the value is replaced by an attribute. Returns "failure" when no folding happened. Invalid values are not folded to avoid canonicalization crashes. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00416">416</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00395">foldDynamicIndexList()</a>.</p>

</div>
</div>
<a id="a26f1eae6696c52c728b7109da9e8ceb8" name="a26f1eae6696c52c728b7109da9e8ceb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f1eae6696c52c728b7109da9e8ceb8">&#9670;&#160;</a></span>foldDynamicStrideList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::foldDynamicStrideList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>strides</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns "success" when any of the elements in <span class="tt">strides</span> is a constant value. </p>
<p>In that case the value is replaced by an attribute. Returns "failure" when no folding happened. Invalid values are not folded to avoid canonicalization crashes. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00421">421</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00395">foldDynamicIndexList()</a>.</p>

</div>
</div>
<a id="a2b0271e4a2b1e694242618a6e91a9c37" name="a2b0271e4a2b1e694242618a6e91a9c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0271e4a2b1e694242618a6e91a9c37">&#9670;&#160;</a></span>foldReshapeOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReshapeOpTy, typename InverseReshapeOpTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::foldReshapeOp </td>
          <td>(</td>
          <td class="paramtype">ReshapeOpTy</td>          <td class="paramname"><span class="paramname"><em>reshapeOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8h_source.html#l00087">87</a> of file <a class="el" href="ReshapeOpsUtils_8h_source.html">ReshapeOpsUtils.h</a>.</p>

</div>
</div>
<a id="acdfbb5ad3709577536fd8002ed734921" name="acdfbb5ad3709577536fd8002ed734921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdfbb5ad3709577536fd8002ed734921">&#9670;&#160;</a></span>fuseIndependentSiblingForallLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scf::ForallOp mlir::fuseIndependentSiblingForallLoops </td>
          <td>(</td>
          <td class="paramtype">scf::ForallOp</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ForallOp</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given two scf.forall loops, <span class="tt">target</span> and <span class="tt">source</span>, fuses <span class="tt">target</span> into <span class="tt">source</span>. </p>
<p>Assumes that the given loops are siblings and are independent of each other.</p>
<p>This function does not perform any legality checks and simply fuses the loops. The caller is responsible for ensuring that the loops are legal to fuse. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01373">1373</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00562">mlir::OpBuilder::clone()</a>, <a class="el" href="IRMapping_8h_source.html#l00030">mlir::IRMapping::map()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="Builders_8h_source.html#l00412">mlir::OpBuilder::setInsertionPointAfter()</a>, <a class="el" href="Builders_8h_source.html#l00431">mlir::OpBuilder::setInsertionPointToStart()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02100">target</a>.</p>

</div>
</div>
<a id="ad7634eaf008502f8ebca317ec4a1ad84" name="ad7634eaf008502f8ebca317ec4a1ad84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7634eaf008502f8ebca317ec4a1ad84">&#9670;&#160;</a></span>fuseIndependentSiblingForLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scf::ForOp mlir::fuseIndependentSiblingForLoops </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ForOp</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given two scf.for loops, <span class="tt">target</span> and <span class="tt">source</span>, fuses <span class="tt">target</span> into <span class="tt">source</span>. </p>
<p>Assumes that the given loops are siblings and are independent of each other.</p>
<p>This function does not perform any legality checks and simply fuses the loops. The caller is responsible for ensuring that the loops are legal to fuse. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01426">1426</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00562">mlir::OpBuilder::clone()</a>, <a class="el" href="IRMapping_8h_source.html#l00065">mlir::IRMapping::lookupOrDefault()</a>, <a class="el" href="IRMapping_8h_source.html#l00030">mlir::IRMapping::map()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="Builders_8h_source.html#l00412">mlir::OpBuilder::setInsertionPointAfter()</a>, <a class="el" href="Builders_8h_source.html#l00431">mlir::OpBuilder::setInsertionPointToStart()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02100">target</a>.</p>

</div>
</div>
<a id="a2d3bd1afbf84ef9cca6c336a104d7280" name="a2d3bd1afbf84ef9cca6c336a104d7280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3bd1afbf84ef9cca6c336a104d7280">&#9670;&#160;</a></span>generateLocationsFromIR() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::generateLocationsFromIR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>fileName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates new locations from the given IR by snapshotting the IR to the given stream, and using the printed locations within that stream. </p>
<p>The generated locations replace the current operation locations. </p>

<p class="definition">Definition at line <a class="el" href="LocationSnapshot_8cpp_source.html#l00102">102</a> of file <a class="el" href="LocationSnapshot_8cpp_source.html">LocationSnapshot.cpp</a>.</p>

<p class="reference">References <a class="el" href="LocationSnapshot_8cpp_source.html#l00102">generateLocationsFromIR()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LocationSnapshot_8cpp_source.html#l00072">generateLocationsFromIR()</a>, <a class="el" href="LocationSnapshot_8cpp_source.html#l00102">generateLocationsFromIR()</a>, and <a class="el" href="LocationSnapshot_8cpp_source.html#l00118">generateLocationsFromIR()</a>.</p>

</div>
</div>
<a id="a94e9bde94caabba0feba96a044a09afc" name="a94e9bde94caabba0feba96a044a09afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e9bde94caabba0feba96a044a09afc">&#9670;&#160;</a></span>generateLocationsFromIR() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::generateLocationsFromIR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>fileName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates new locations from the given IR by snapshotting the IR to the given stream, and using the printed locations within that stream. </p>
<p>The generated locations are represented as a NameLoc with the given tag as the name, and then fused with the existing locations. </p>

<p class="definition">Definition at line <a class="el" href="LocationSnapshot_8cpp_source.html#l00118">118</a> of file <a class="el" href="LocationSnapshot_8cpp_source.html">LocationSnapshot.cpp</a>.</p>

<p class="reference">References <a class="el" href="LocationSnapshot_8cpp_source.html#l00102">generateLocationsFromIR()</a>.</p>

</div>
</div>
<a id="af16c6823f94d6ce99fa7da7547658345" name="af16c6823f94d6ce99fa7da7547658345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af16c6823f94d6ce99fa7da7547658345">&#9670;&#160;</a></span>generateLocationsFromIR() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::generateLocationsFromIR </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>fileName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates new locations from the given IR by snapshotting the IR to the given file, and using the printed locations within that file. </p>
<p>If <span class="tt">filename</span> is empty, a temporary file is generated instead. </p>

<p class="definition">Definition at line <a class="el" href="LocationSnapshot_8cpp_source.html#l00109">109</a> of file <a class="el" href="LocationSnapshot_8cpp_source.html">LocationSnapshot.cpp</a>.</p>

</div>
</div>
<a id="ab170389f5f17475f89037e332018b4f8" name="ab170389f5f17475f89037e332018b4f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab170389f5f17475f89037e332018b4f8">&#9670;&#160;</a></span>generateLocationsFromIR() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::generateLocationsFromIR </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>fileName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates new locations from the given IR by snapshotting the IR to the given file, and using the printed locations within that file. </p>
<p>If <span class="tt">filename</span> is empty, a temporary file is generated instead. </p>

<p class="definition">Definition at line <a class="el" href="LocationSnapshot_8cpp_source.html#l00126">126</a> of file <a class="el" href="LocationSnapshot_8cpp_source.html">LocationSnapshot.cpp</a>.</p>

</div>
</div>
<a id="a3ddb0c1a5398951747604e655e4eb371" name="a3ddb0c1a5398951747604e655e4eb371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ddb0c1a5398951747604e655e4eb371">&#9670;&#160;</a></span>generateUnrolledLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::generateUnrolledLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>loopBodyBlock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>iv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unrollFactor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>(<a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>ivRemapFn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>annotateFn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>iterArgs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>yieldedValues</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> *</td>          <td class="paramname"><span class="paramname"><em>clonedToSrcOpsMap</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate unrolled copies of an scf loop's 'loopBodyBlock', with 'iterArgs' and 'yieldedValues' as the block arguments and yielded values of the loop. </p>
<p>The content of the loop body is replicated 'unrollFactor' times, calling 'ivRemapFn' to remap 'iv' for each unrolled body. If specified, annotates the Ops in each unrolled iteration using annotateFn. If provided, 'clonedToSrcOpsMap' is populated with the mappings from the cloned ops to the original op. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00294">294</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00252">mlir::OpBuilder::atBlockTerminator()</a>, <a class="el" href="Block_8h_source.html#l00143">mlir::Block::begin()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00714">mlir::Operation::clone()</a>, <a class="el" href="IRMapping_8h_source.html#l00051">mlir::IRMapping::contains()</a>, <a class="el" href="Block_8h_source.html#l00144">mlir::Block::end()</a>, <a class="el" href="Block_8cpp_source.html#l00244">mlir::Block::getTerminator()</a>, <a class="el" href="IRMapping_8h_source.html#l00072">mlir::IRMapping::lookup()</a>, <a class="el" href="IRMapping_8h_source.html#l00065">mlir::IRMapping::lookupOrDefault()</a>, <a class="el" href="IRMapping_8h_source.html#l00030">mlir::IRMapping::map()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00237">mlir::Operation::setOperands()</a>, and <a class="el" href="Value_8h_source.html#l00208">mlir::Value::use_empty()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00995">mlir::affine::loopUnrollByFactor()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00367">loopUnrollByFactor()</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01580">parallelLoopUnrollByFactors()</a>.</p>

</div>
</div>
<a id="ab4871db68c59a176135e0e35a3625e73" name="ab4871db68c59a176135e0e35a3625e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4871db68c59a176135e0e35a3625e73">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>params</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method that injects context only if needed, this helps unify some of the attribute construction methods. </p>

<p class="definition">Definition at line <a class="el" href="BytecodeImplementation_8h_source.html#l00509">509</a> of file <a class="el" href="BytecodeImplementation_8h_source.html">BytecodeImplementation.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVTypes_8cpp_source.html#l00149">mlir::spirv::detail::ArrayTypeStorage::ArrayTypeStorage()</a>, <a class="el" href="OpImplementation_8h_source.html#l00084">mlir::AsmDialectResourceHandleBase&lt; DerivedT, ResourceT, DialectT &gt;::AsmDialectResourceHandleBase()</a>, <a class="el" href="TransformInterfaces_8h_source.html#l01419">mlir::transform::ApplyToEachResultList::assign()</a>, <a class="el" href="PredicateTree_8cpp_source.html#l01040">mlir::pdl_to_pdl_interp::BoolNode::BoolNode()</a>, <a class="el" href="BreakpointManager_8h_source.html#l00057">mlir::tracing::BreakpointBase&lt; Derived &gt;::BreakpointBase()</a>, <a class="el" href="BreakpointManager_8h_source.html#l00084">mlir::tracing::BreakpointManagerBase&lt; Derived &gt;::BreakpointManagerBase()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00257">mlir::spirv::detail::CooperativeMatrixTypeStorage::CooperativeMatrixTypeStorage()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00232">deserializeCacheControlDecoration()</a>, <a class="el" href="PredicateTree_8h_source.html#l00141">mlir::pdl_to_pdl_interp::ExitNode::ExitNode()</a>, <a class="el" href="GPUCommonPass_8h_source.html#l00051">mlir::FunctionCallBuilder::FunctionCallBuilder()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00910">mlir::DenseElementsAttr::get()</a>, <a class="el" href="Tools_2PDLL_2AST_2Types_8cpp_source.html#l00149">mlir::pdll::ast::TupleType::get()</a>, <a class="el" href="IRCore_8cpp_source.html#l00900">mlir::python::PyDialects::getDialectForKey()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00373">mlir::spirv::detail::ImageTypeStorage::ImageTypeStorage()</a>, <a class="el" href="BytecodeReader_8cpp_source.html#l01518">mlir::BytecodeReader::Impl::Impl()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00799">mlir::OperationName::Impl::Impl()</a>, <a class="el" href="Dialect_2LLVMIR_2IR_2TypeDetail_8h_source.html#l00369">mlir::LLVM::detail::LLVMTypeAndSizeStorage::LLVMTypeAndSizeStorage()</a>, <a class="el" href="DataFlowFramework_8h_source.html#l00715">mlir::DataFlowSolver::load()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00107">mlirDictionaryAttrGetElementByName()</a>, <a class="el" href="IR_8cpp_source.html#l01220">mlirOpOperandGetValue()</a>, <a class="el" href="OperationSupport_8h_source.html#l00531">mlir::RegisteredOperationName::Model&lt; ConcreteOp &gt;::Model()</a>, <a class="el" href="Nodes_8h_source.html#l00123">mlir::pdll::ast::Node::NodeBase&lt; T, BaseT &gt;::NodeBase()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00110">mlir::bufferization::OneShotAnalysisState::OneShotAnalysisState()</a>, <a class="el" href="FoldUtils_8h_source.html#l00035">mlir::OperationFolder::OperationFolder()</a>, <a class="el" href="PatternMatch_8h_source.html#l00354">mlir::OpTraitRewritePattern&lt; TraitType &gt;::OpTraitRewritePattern()</a>, <a class="el" href="include_2mlir_2Pass_2Pass_8h_source.html#l00479">mlir::PassWrapper&lt; PassT, BaseT &gt;::PassWrapper()</a>, <a class="el" href="IRCore_8cpp_source.html#l01562">PyOpResultList::PyOpResultList()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l01034">CopyBuilder::rewrite()</a>, <a class="el" href="Padding_8cpp_source.html#l00244">mlir::linalg::rewriteAsPaddedOp()</a>, <a class="el" href="SparseTensorType_8h_source.html#l00059">mlir::sparse_tensor::SparseTensorType::SparseTensorType()</a>, <a class="el" href="StateStack_8h_source.html#l00049">mlir::StateStackFrameBase&lt; Derived &gt;::StateStackFrameBase()</a>, <a class="el" href="PredicateTree_8cpp_source.html#l01051">mlir::pdl_to_pdl_interp::SuccessNode::SuccessNode()</a>, <a class="el" href="PredicateTree_8cpp_source.html#l01061">mlir::pdl_to_pdl_interp::SwitchNode::SwitchNode()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l02650">mlir::gpu::TargetOptions::TargetOptions()</a>, <a class="el" href="TransformDialect_8h_source.html#l00065">mlir::transform::TransformDialectData&lt; DerivedTy &gt;::TransformDialectData()</a>, and <a class="el" href="Tools_2PDLL_2AST_2Types_8h_source.html#l00110">mlir::pdll::ast::detail::TypeStorageBase&lt; ConcreteT, KeyT &gt;::TypeStorageBase()</a>.</p>

</div>
</div>
<a id="a6e8a0f44c623301035b6151ca51cca4d" name="a6e8a0f44c623301035b6151ca51cca4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e8a0f44c623301035b6151ca51cca4d">&#9670;&#160;</a></span>getAffineBinaryOpExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::getAffineBinaryOpExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a6d3b7fd763c24274db6c115579084133">AffineExprKind</a></td>          <td class="paramname"><span class="paramname"><em>kind</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00068">68</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00041">Add</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00050">CeilDiv</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00048">FloorDiv</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00046">Mod</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00043">Mul</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01610">createDimSizeExprForTiledLayout()</a>, <a class="el" href="DecomposeAffineOps_8cpp_source.html#l00095">mlir::affine::decompose()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l01056">mlir::sparse_tensor::inverseBlockSparsity()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00137">mlirAffineAddExprGet()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00190">mlirAffineCeilDivExprGet()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00176">mlirAffineFloorDivExprGet()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00163">mlirAffineModExprGet()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00150">mlirAffineMulExprGet()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00155">mlir::AffineExpr::replace()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00087">mlir::AffineExpr::replaceDimsAndSymbols()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00822">simplifyExprAndOperands()</a>, and <a class="el" href="SparseReinterpretMap_8cpp_source.html#l00242">translateMap()</a>.</p>

</div>
</div>
<a id="ab26cdced424aa629fde4150cc8674d50" name="ab26cdced424aa629fde4150cc8674d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26cdced424aa629fde4150cc8674d50">&#9670;&#160;</a></span>getAffineConstantExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::getAffineConstantExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>constant</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01682">canonicalizeMapOrSetAndOperands()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01006">mlir::AffineExpr::ceilDiv()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00576">mlir::AffineMap::compose()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01336">composeAffineMapAndOperands()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00153">computeProduct()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00137">computeSuffixProduct()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00149">computeSum()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00629">computeUnknownVars()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00587">detectAsExpr()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00417">detectAsFloorDiv()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00301">detectAsMod()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00384">mlir::linalg::dropUnitDims()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00959">mlir::AffineExpr::floorDiv()</a>, <a class="el" href="Builders_8cpp_source.html#l00372">mlir::Builder::getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01090">getAffineExprFromFlatForm()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00913">getAsExpr()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01087">mlir::FlatLinearConstraints::getAsIntegerSet()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01160">mlir::affine::MemRefRegion::getConstantBoundingSizeAndShape()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00124">mlir::AffineMap::getConstantMap()</a>, <a class="el" href="mlir_2IR_2IntegerSet_8h_source.html#l00056">mlir::IntegerSet::getEmptySet()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01133">getSemiAffineExprFromFlatForm()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00700">mlir::FlatLinearConstraints::getSliceBounds()</a>, <a class="el" href="BuiltinAttributeInterfaces_8cpp_source.html#l00161">getStridesAndOffset()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00189">mlir::vector::getTransferMinorIdentityMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00808">inverseAndBroadcastProjectedPermutation()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00157">linearize()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00855">makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00124">makePermutationMap()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01808">makeStridedLinearLayoutMap()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00121">mlirAffineConstantExprGet()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01064">mlir::AffineExpr::operator%()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00888">mlir::AffineExpr::operator*()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00903">mlir::AffineExpr::operator-()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00449">mlir::AffineMap::partialConstantFold()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00853">projectCommonImpl()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01190">replaceAffineDelinearizeIndexInverseExpression()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01061">replaceAffineMinBoundingBoxExpression()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00972">simplifyCeilDiv()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00822">simplifyExprAndOperands()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00913">simplifyFloorDiv()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00925">simplifyMinOrMaxExprWithOperands()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01019">simplifyMod()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00836">simplifyMul()</a>, <a class="el" href="VectorUnroll_8cpp_source.html#l00030">sliceTransferIndices()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00140">transferReadSupportsMMAMatrixType()</a>, <a class="el" href="SparseReinterpretMap_8cpp_source.html#l00242">translateMap()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01166">vectorizeTensorExtract()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00945">verifyOutputShape()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01371">mlir::SimpleAffineExprFlattener::visitModExpr()</a>.</p>

</div>
</div>
<a id="ace395202c24e4dc75013296cf46ed692" name="ace395202c24e4dc75013296cf46ed692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace395202c24e4dc75013296cf46ed692">&#9670;&#160;</a></span>getAffineConstantExprs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; mlir::getAffineConstantExprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>constants</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>.</p>

<p class="reference">Referenced by <a class="el" href="IndexingUtils_8cpp_source.html#l00176">delinearize()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00368">mlir::detail::TileOffsetRangeImpl::getDynamicTileOffsets()</a>, and <a class="el" href="IndexingUtils_8cpp_source.html#l00163">linearize()</a>.</p>

</div>
</div>
<a id="addfd4323ef72147332661606b030d04d" name="addfd4323ef72147332661606b030d04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfd4323ef72147332661606b030d04d">&#9670;&#160;</a></span>getAffineDimExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::getAffineDimExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>position</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These free functions allow clients of the API to not use classes in detail. </p>

<p class="reference">Referenced by <a class="el" href="LowerVectorContract_8cpp_source.html#l00058">adjustMap()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00292">mlir::detail::bindDims()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00316">bindDimsList()</a>, <a class="el" href="VectorDistribute_8cpp_source.html#l00042">calculateImplicitMap()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01682">canonicalizeMapOrSetAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01588">canonicalizePromotedSymbols()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00195">common3DIdBuilderFn()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00107">commonLinearIdBuilderFn()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00552">mlir::AffineMap::compose()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01336">composeAffineMapAndOperands()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l02944">computeIteratorTypesAndIndexingMaps()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00879">mlir::FlatLinearConstraints::computeLocalVars()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l02022">mlir::linalg::computeTileSizes()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00629">computeUnknownVars()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00396">convertReassociationIndicesToExprs()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00333">createPrivateMemRef()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::ConvMatcherBuilder::dim()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00384">mlir::linalg::dropUnitDims()</a>, <a class="el" href="SparseReinterpretMap_8cpp_source.html#l00151">genReplaceDimToLvlMap()</a>, <a class="el" href="Builders_8cpp_source.html#l00364">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01090">getAffineExprFromFlatForm()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01153">getDimMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00330">mlir::AffineMap::getMultiDimIdentityMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00276">mlir::AffineMap::getMultiDimMapWithTargets()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01133">getSemiAffineExprFromFlatForm()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00230">insertParallelDim()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00808">inverseAndBroadcastProjectedPermutation()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l01056">mlir::sparse_tensor::inverseBlockSparsity()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00784">inversePermutation()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00314">mlir::AffineExpr::isFunctionOfDim()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01591">isNormalizedMemRefDynamicDim()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00231">laneIdBuilderFn()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01636">legalizeDemotedDims()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l02465">mlir::linalg::makeAffineDimExprs()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00887">makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00124">makePermutationMap()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01808">makeStridedLinearLayoutMap()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00089">mlirAffineDimExprGet()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00853">projectCommonImpl()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01190">replaceAffineDelinearizeIndexInverseExpression()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01061">replaceAffineMinBoundingBoxExpression()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01275">replaceDimOrSym()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00215">scaleReductionDim()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00131">mlir::AffineExpr::shiftDims()</a>, <a class="el" href="VectorUnroll_8cpp_source.html#l00030">sliceTransferIndices()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00241">mlir::linalg::splitReductionByScaling()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00140">transferReadSupportsMMAMatrixType()</a>, and <a class="el" href="SparseReinterpretMap_8cpp_source.html#l00242">translateMap()</a>.</p>

</div>
</div>
<a id="a8ad71c14bebce843758768ff160e2283" name="a8ad71c14bebce843758768ff160e2283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad71c14bebce843758768ff160e2283">&#9670;&#160;</a></span>getAffineExprFromFlatForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::getAffineExprFromFlatForm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>flatExprs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numDims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numSymbols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>localExprs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an affine expression from a flat <a class="el" href="classmlir_1_1ArrayRef.html">ArrayRef</a>. </p>
<p>Constructs an affine expression from a flat <a class="el" href="classmlir_1_1ArrayRef.html">ArrayRef</a>. If there are local identifiers (neither dimensional nor symbolic) that appear in the sum of products expression, <span class="tt">localExprs</span> is expected to have the <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> for it, and is substituted into. The <a class="el" href="classmlir_1_1ArrayRef.html">ArrayRef</a> <span class="tt">flatExprs</span> is expected to be in the format [dims, symbols, locals, constant term].</p>
<p>If there are local identifiers (neither dimensional nor symbolic) that appear in the sum of products expression, 'localExprs' is expected to have the <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> for it, and is substituted into. The <a class="el" href="classmlir_1_1ArrayRef.html">ArrayRef</a> 'eq' is expected to be in the format [dims, symbols, locals, constant term]. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01090">1090</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="#ab26cdced424aa629fde4150cc8674d50">getAffineConstantExpr()</a>, <a class="el" href="#addfd4323ef72147332661606b030d04d">getAffineDimExpr()</a>, and <a class="el" href="#aefb7ba5a55b4f16631528884d3617a47">getAffineSymbolExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01087">mlir::FlatLinearConstraints::getAsIntegerSet()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00319">mlir::affine::FlatAffineValueConstraints::getIneqAsAffineValueMap()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00499">mlir::FlatLinearConstraints::getLowerAndUpperBound()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01612">simplifyAffineExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01371">mlir::SimpleAffineExprFlattener::visitModExpr()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01320">mlir::SimpleAffineExprFlattener::visitMulExpr()</a>.</p>

</div>
</div>
<a id="aefb7ba5a55b4f16631528884d3617a47" name="aefb7ba5a55b4f16631528884d3617a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb7ba5a55b4f16631528884d3617a47">&#9670;&#160;</a></span>getAffineSymbolExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::getAffineSymbolExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>position</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00301">mlir::detail::bindSymbols()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00330">bindSymbolsList()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01682">canonicalizeMapOrSetAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01588">canonicalizePromotedSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00552">mlir::AffineMap::compose()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01336">composeAffineMapAndOperands()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00879">mlir::FlatLinearConstraints::computeLocalVars()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01891">mlir::linalg::computeSliceParameters()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00629">computeUnknownVars()</a>, <a class="el" href="DecomposeAffineOps_8cpp_source.html#l00095">mlir::affine::decompose()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01090">getAffineExprFromFlatForm()</a>, <a class="el" href="Builders_8cpp_source.html#l00368">mlir::Builder::getAffineSymbolExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01133">getSemiAffineExprFromFlatForm()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00325">mlir::AffineExpr::isFunctionOfSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01636">legalizeDemotedDims()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00855">makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01808">makeStridedLinearLayoutMap()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00105">mlirAffineSymbolExprGet()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00853">projectCommonImpl()</a>, <a class="el" href="DecomposeAffineOps_8cpp_source.html#l00041">mlir::affine::reorderOperandsByHoistability()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01190">replaceAffineDelinearizeIndexInverseExpression()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01061">replaceAffineMinBoundingBoxExpression()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01275">replaceDimOrSym()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00143">mlir::AffineExpr::shiftSymbols()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01677">mlir::linalg::updateBoundsForCyclicDistribution()</a>.</p>

</div>
</div>
<a id="aa18214f3aabbab8c3e5197b719ba72dc" name="aa18214f3aabbab8c3e5197b719ba72dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18214f3aabbab8c3e5197b719ba72dc">&#9670;&#160;</a></span>getAsIndexOpFoldResult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::getAsIndexOpFoldResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00110">110</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00106">getAsIndexOpFoldResult()</a>.</p>

</div>
</div>
<a id="a0c18958fe34840cfafad41a1226f7a68" name="a0c18958fe34840cfafad41a1226f7a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c18958fe34840cfafad41a1226f7a68">&#9670;&#160;</a></span>getAsIndexOpFoldResult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::getAsIndexOpFoldResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert <a class="el" href="classint64__t.html">int64_t</a> to integer attributes of index type and return them as <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a>. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00106">106</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00884">HopperBuilder::buildPredicateLoadsOnThread0()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00107">commonLinearIdBuilderFn()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00317">computeLinearIndex()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00110">getAsIndexOpFoldResult()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00231">laneIdBuilderFn()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01061">replaceAffineMinBoundingBoxExpression()</a>.</p>

</div>
</div>
<a id="a622f03f8cb8e4cfde7e34c30e9aa02b6" name="a622f03f8cb8e4cfde7e34c30e9aa02b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622f03f8cb8e4cfde7e34c30e9aa02b6">&#9670;&#160;</a></span>getAsOpFoldResult() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::getAsOpFoldResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a></td>          <td class="paramname"><span class="paramname"><em>arrayAttr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert <span class="tt">arrayAttr</span> to a vector of <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a>. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00098">98</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr()</a>.</p>

</div>
</div>
<a id="ac19b7af1333485b34ebfe4bf6300c362" name="ac19b7af1333485b34ebfe4bf6300c362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac19b7af1333485b34ebfe4bf6300c362">&#9670;&#160;</a></span>getAsOpFoldResult() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::getAsOpFoldResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a value, try to extract a constant <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>. </p>
<p>If this fails, return the original value. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00081">81</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00369">m_Constant()</a>, and <a class="el" href="Matchers_8h_source.html#l00490">matchPattern()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BlockPackMatmul_8cpp_source.html#l00138">mlir::linalg::blockPackMatmul()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00317">computeLinearIndex()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01366">foldExtractAfterInsert()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00092">getAsOpFoldResult()</a>, <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00078">getCompressedMaskOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00057">getDimValue()</a>, <a class="el" href="DecomposeMemRefs_8cpp_source.html#l00105">getFlatMemref()</a>, <a class="el" href="FlattenMemRefs_8cpp_source.html#l00051">getFlattenMemrefAndOffset()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00818">getProductOfIntsOrIndexes()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00277">getTileOffsetAndSizes()</a>, <a class="el" href="FoldTensorSubsetOps_8cpp_source.html#l00178">InsertSliceOfInsertSliceFolder&lt; OpTy &gt;::matchAndRewrite()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01393">replaceConstantUsesOf()</a>, <a class="el" href="ViewLikeInterfaceUtils_8h_source.html#l00082">mlir::affine::resolveIndicesIntoOpWithOffsetsAndStrides()</a>, <a class="el" href="Tiling_8cpp_source.html#l00433">tileLinalgOpImpl()</a>, <a class="el" href="Tiling_8cpp_source.html#l00794">tileLinalgOpImpl()</a>, <a class="el" href="Tiling_8cpp_source.html#l00588">mlir::linalg::tileReductionUsingForall()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00073">mlir::linalg::transformIndexOps()</a>.</p>

</div>
</div>
<a id="a0f4688956ac5cd539b0b3e134af30248" name="a0f4688956ac5cd539b0b3e134af30248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f4688956ac5cd539b0b3e134af30248">&#9670;&#160;</a></span>getAsOpFoldResult() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::getAsOpFoldResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>values</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an array of values, try to extract a constant <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> from each value. </p>
<p>If this fails, return the original value. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00092">92</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00081">getAsOpFoldResult()</a>.</p>

</div>
</div>
<a id="a1735b1e89665db98941b6b483419b739" name="a1735b1e89665db98941b6b483419b739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1735b1e89665db98941b6b483419b739">&#9670;&#160;</a></span>getBackwardSlice() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::getBackwardSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *</td>          <td class="paramname"><span class="paramname"><em>backwardSlice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1BackwardSliceOptions.html">BackwardSliceOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills <span class="tt">backwardSlice</span> with the computed backward slice (i.e. </p>
<p>all the transitive defs of op), <b>without</b> including that operation.</p>
<p>This additionally takes a <a class="el" href="#a9a2a446f58dd14edfbb77bb2f0ea8818">TransitiveFilter</a> which acts as a frontier: when looking at defs transitively, an operation that does not pass the filter is never propagated through. This allows in particular to carve out the scope within a ForOp or the scope within an IfOp.</p>
<p>The implementation traverses the def chains in postorder traversal for efficiency reasons: if an operation is already in <span class="tt">backwardSlice</span>, no need to traverse its definitions again. In the presence of use-def cycles in a graph region, the traversal stops at the first operation that was already visited (which is not added to the slice anymore).</p>
<p>Upon return to the root call, <span class="tt">backwardSlice</span> is filled with a postorder list of defs. This happens to be a topological order, from the point of view of the use-def chains.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md1"></a>
Example starting from node 8</h1>
<p>1 2 3 4 |_______| |______| | | | | 5 6 |___|_____________| | | 7 8 |_______________| | 9</p>
<p>Assuming all local orders match the numbering order: {1, 2, 5, 3, 4, 6}</p>
<p>This function returns whether the backwards slice was able to be successfully computed, and failure if it was unable to determine the slice. </p>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8cpp_source.html#l00179">179</a> of file <a class="el" href="SliceAnalysis_8cpp_source.html">SliceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="SliceAnalysis_8cpp_source.html#l00108">getBackwardSliceImpl()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l01952">checkAssumptionForLoop()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00110">computeBackwardSlice()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00235">dependsOnCarriedVals()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00195">getBackwardSlice()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00275">getPipelineStages()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00206">getSlice()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00303">getSliceContract()</a>, <a class="el" href="SliceMatchers_8h_source.html#l00136">mlir::query::matcher::PredicateBackwardSliceMatcher&lt; BaseMatcher, Filter &gt;::match()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l01089">moveOperationDependencies()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l01145">moveValueDefinitions()</a>.</p>

</div>
</div>
<a id="a07959f71ddade1e05fae69aadfc54be6" name="a07959f71ddade1e05fae69aadfc54be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07959f71ddade1e05fae69aadfc54be6">&#9670;&#160;</a></span>getBackwardSlice() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::getBackwardSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *</td>          <td class="paramname"><span class="paramname"><em>backwardSlice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1BackwardSliceOptions.html">BackwardSliceOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value-rooted version of <span class="tt">getBackwardSlice</span>. </p>
<p>Return the union of all backward slices for the op defining or owning the value <span class="tt">root</span>. </p>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8cpp_source.html#l00195">195</a> of file <a class="el" href="SliceAnalysis_8cpp_source.html">SliceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="SliceAnalysis_8cpp_source.html#l00179">getBackwardSlice()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="a1ee8e54b17fecc4eaad55779facd0068" name="a1ee8e54b17fecc4eaad55779facd0068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee8e54b17fecc4eaad55779facd0068">&#9670;&#160;</a></span>getBlocksSortedByDominance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classmlir_1_1Block.html">Block</a> * &gt; mlir::getBlocksSortedByDominance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>region</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a list of blocks that is sorted according to dominance. </p>
<p>This sort is stable. </p>

<p class="definition">Definition at line <a class="el" href="TopologicalSortUtils_8cpp_source.html#l00147">147</a> of file <a class="el" href="TopologicalSortUtils_8cpp_source.html">TopologicalSortUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="IR_2Region_8h_source.html#l00045">mlir::Region::getBlocks()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00260">convertDataOp()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00529">convertOmpOpRegions()</a>, and <a class="el" href="Mem2Reg_8cpp_source.html#l00528">getOrCreateBlockIndices()</a>.</p>

</div>
</div>
<a id="a40cdc27e9612cb7a782faea9ead39aec" name="a40cdc27e9612cb7a782faea9ead39aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40cdc27e9612cb7a782faea9ead39aec">&#9670;&#160;</a></span>getBoundForAffineExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; mlir::getBoundForAffineExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numDims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numSymbols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>constLowerBounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>constUpperBounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>isUpper</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a lower or upper (depending on <span class="tt">isUpper</span>) bound for <span class="tt">expr</span> while using the constant lower and upper bounds for its inputs provided in <span class="tt">constLowerBounds</span> and <span class="tt">constUpperBounds</span>. </p>
<p>Return std::nullopt if such a bound can't be computed. This method only handles simple sum of product expressions (w.r.t constant coefficients) so as to not depend on anything heavyweight in <span class="tt">Analysis</span>. Expressions of the form: c0*d0 + c1*d1 + c2*s0 + ... + c_n are handled. Expressions involving floordiv, ceildiv, mod or semi-affine ones will lead a none being returned. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01641">1641</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00050">CeilDiv</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00048">FloorDiv</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01641">getBoundForAffineExpr()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00046">Mod</a>, <a class="el" href="AffineExprVisitor_8h_source.html#l00368">mlir::SimpleAffineExprFlattener::numLocals</a>, <a class="el" href="AffineExprVisitor_8h_source.html#l00362">mlir::SimpleAffineExprFlattener::operandExprStack</a>, and <a class="el" href="AffineExprVisitor_8h_source.html#l00150">mlir::AffineExprVisitor&lt; SubClass, RetTy &gt;::walkPostOrder()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01641">getBoundForAffineExpr()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00798">getLowerBound()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00775">getUpperBound()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00925">simplifyMinOrMaxExprWithOperands()</a>.</p>

</div>
</div>
<a id="a3775f03f9a65464fefb370229adcac95" name="a3775f03f9a65464fefb370229adcac95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3775f03f9a65464fefb370229adcac95">&#9670;&#160;</a></span>getBufferizationOptionsForSparsification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">mlir::bufferization::OneShotBufferizationOptions</a> mlir::getBufferizationOptionsForSparsification </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>analysisOnly</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00218">218</a> of file <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html">SparsificationAndBufferizationPass.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00026">mlir::sparse_tensor::buildSparsifier()</a>, and <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00241">createSparsificationAndBufferizationPass()</a>.</p>

</div>
</div>
<a id="a7335030e42a74c6badff43ebf110d896" name="a7335030e42a74c6badff43ebf110d896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7335030e42a74c6badff43ebf110d896">&#9670;&#160;</a></span>getConstantAPIntValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::pair&lt; APInt, <a class="el" href="classbool.html">bool</a> &gt; &gt; mlir::getConstantAPIntValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>ofr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If ofr is a constant integer or an IntegerAttr, return the integer. </p>
<p>The second return value indicates whether the value is an index type and thus the bitwidth is not defined (the APInt will be set with 64bits).</p>
<p>The boolean indicates whether the value is an index type. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00118">118</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00527">m_ConstantInt()</a>, and <a class="el" href="Matchers_8h_source.html#l00490">matchPattern()</a>.</p>

<p class="reference">Referenced by <a class="el" href="StaticValueUtils_8cpp_source.html#l00278">constantTripCount()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">getConstantIntValue()</a>.</p>

</div>
</div>
<a id="a22bfcc5fa9deffb32e7c39183f732c90" name="a22bfcc5fa9deffb32e7c39183f732c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22bfcc5fa9deffb32e7c39183f732c90">&#9670;&#160;</a></span>getConstantIntValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; mlir::getConstantIntValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>ofr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If ofr is a constant integer or an IntegerAttr, return the integer. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">134</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00118">getConstantAPIntValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00033">mlir::affine::FlatAffineValueConstraints::addInductionVarOrTerminalSymbol()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00077">mlir::scf::addLoopRangeConstraints()</a>, <a class="el" href="Promotion_8cpp_source.html#l00043">allocBuffer()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l05512">mlir::linalg::areTilesAndTiledDimsAllConstant()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l05377">mlir::linalg::asShapeWithAnyValueAsDynamic()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03035">buildAffineLoopFromValues()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00262">canOmitTileOffsetInBoundsCheck()</a>, <a class="el" href="Tiling_8cpp_source.html#l00333">canOmitTileOffsetInBoundsCheck()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00155">checkTileSizes()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01257">mlir::affine::MemRefRegion::compute()</a>, <a class="el" href="Tiling_8cpp_source.html#l00156">mlir::linalg::computeContinuousTileSizes()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01891">mlir::linalg::computeSliceParameters()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00096">constifyIndexValues()</a>, <a class="el" href="CreateAsyncGroups_8cpp_source.html#l00152">mlir::nvgpu::createAsyncGroups()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00036">createInBoundsCond()</a>, <a class="el" href="XeGPUOptimizeBlockLoads_8cpp_source.html#l00241">mlir::xegpu::createXeGPUOptimizeBlockLoads()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00854">delinearizeInductionVariable()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01646">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00703">emitNormalizedLoopBounds()</a>, <a class="el" href="AffineOps_8cpp_source.html#l04965">foldCstValueToCstAttrBasis()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00395">foldDynamicIndexList()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00180">foldDynamicToStaticDimSizes()</a>, <a class="el" href="TensorOps_8cpp_source.html#l02733">foldIdentityOffsetSizeAndStrideOpInterface()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00898">mlir::affine::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00237">getBoundedTileSize()</a>, <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00714">getCollapsedIndices()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00142">getConstantIntValues()</a>, <a class="el" href="BlockPackMatmul_8cpp_source.html#l00029">getConstantRange()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00385">mlir::vector::getConstantVscaleMultiplier()</a>, <a class="el" href="ReshapePatterns_8cpp_source.html#l00582">mlir::tensor::getExpandedExtractSliceInfo()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00252">mlir::ValueBoundsConstraintSet::getExpr()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00203">mlir::ValueBoundsConstraintSet::getExpr()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l04989">mlir::linalg::getNewMixedTileSizes()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01018">getPackOpSourceOrPaddedSource()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00818">getProductOfIntsOrIndexes()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00059">getSimplifiedOfrAndStaticSizePair()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00532">getSlicedDimensions()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00155">isConstantIntValue()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00368">isDimOpValidSymbol()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00251">mlir::vector::isDisjointTransferIndices()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00176">isEqualConstantIntOrValue()</a>, <a class="el" href="VectorOps_8cpp_source.html#l04978">isInBounds()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01613">isMaskTriviallyFoldable()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l03272">isTrivialSubViewOp()</a>, <a class="el" href="SCFTransformOps_8cpp_source.html#l00298">loopScheduling()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00367">loopUnrollByFactor()</a>, <a class="el" href="Tiling_8cpp_source.html#l00044">mlir::linalg::makeTiledLoopRanges()</a>, <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l04684">FoldConstantCase::matchAndRewrite()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00260">mlir::ComposeCollapseOfExpandOp&lt; CollapseOpTy, ExpandOpTy, CastOpTy, DimOpTy, TensorTy &gt;::matchAndRewrite()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00463">mlir::linalg::pack()</a>, <a class="el" href="PadTilingInterface_8cpp_source.html#l00227">padOperand()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01580">parallelLoopUnrollByFactors()</a>, <a class="el" href="ReifyResultShapes_8cpp_source.html#l00041">reifyOpResultShapes()</a>, <a class="el" href="OpenACCUtilsTiling_8cpp_source.html#l00023">resolveAndCastTileSize()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00197">mlir::scf::rewritePeeledMinMaxOp()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02286">mlir::affine::simplifyConstrainedMinMaxOp()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00222">tileDividesIterationDomain()</a>, <a class="el" href="Tiling_8cpp_source.html#l00433">tileLinalgOpImpl()</a>, <a class="el" href="LoopEmitter_8cpp_source.html#l00084">unFoldOpIntResult()</a>, <a class="el" href="BlockPackMatmul_8cpp_source.html#l00043">validateFullTilesOnDims()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00088">mlir::ValueBoundsConstraintSet::Variable::Variable()</a>.</p>

</div>
</div>
<a id="addda9c80b032fe1ec781a4317d45725f" name="addda9c80b032fe1ec781a4317d45725f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addda9c80b032fe1ec781a4317d45725f">&#9670;&#160;</a></span>getConstantIntValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &gt; mlir::getConstantIntValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>ofrs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If all ofrs are constant integers or IntegerAttrs, return the integers. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00142">142</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">getConstantIntValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="StaticValueUtils_8cpp_source.html#l00164">areConstantIntValues()</a>, <a class="el" href="GPUTransformOps_8cpp_source.html#l00788">getThreadIdBuilder()</a>, <a class="el" href="GPUTransformOps_8cpp_source.html#l00464">rewriteOneForallCommonImpl()</a>, and <a class="el" href="GPUTransformOps_8cpp_source.html#l00408">verifyGpuMapping()</a>.</p>

</div>
</div>
<a id="a4960f3e0f3dfa808af78990b8e395d40" name="a4960f3e0f3dfa808af78990b8e395d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4960f3e0f3dfa808af78990b8e395d40">&#9670;&#160;</a></span>getConstLoopTripCounts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">llvm::SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; mlir::getConstLoopTripCounts </td>
          <td>(</td>
          <td class="paramtype">mlir::LoopLikeOpInterface</td>          <td class="paramname"><span class="paramname"><em>loopOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get constant trip counts for each of the induction variables of the given loop operation. </p>
<p>If any of the loop's trip counts is not constant, return an empty vector. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01563">1563</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00115">mlir::scf::computeUbMinusLb()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00278">constantTripCount()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01580">parallelLoopUnrollByFactors()</a>.</p>

</div>
</div>
<a id="a20b466301e036ddc2e72c55838139324" name="a20b466301e036ddc2e72c55838139324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b466301e036ddc2e72c55838139324">&#9670;&#160;</a></span>getControlFlowPredecessors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt; mlir::getControlFlowPredecessors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a vector of all control predecessors of <span class="tt">value</span>. </p>
<p>Relies on RegionBranchOpInterface, BranchOpInterface, and SelectLikeOpInterface to determine predecessors. Returns nullopt if <span class="tt">value</span> has no predecessors or when the relevant operations are missing the interface implementations. </p>

<p class="definition">Definition at line <a class="el" href="SliceWalk_8cpp_source.html#l00106">106</a> of file <a class="el" href="SliceWalk_8cpp_source.html">SliceWalk.cpp</a>.</p>

<p class="reference">References <a class="el" href="SliceWalk_8cpp_source.html#l00084">getBlockPredecessorOperands()</a>, <a class="el" href="Block_8cpp_source.html#l00031">mlir::Block::getParentOp()</a>, <a class="el" href="SliceWalk_8cpp_source.html#l00038">getRegionPredecessorOperands()</a>, and <a class="el" href="Block_8cpp_source.html#l00036">mlir::Block::isEntryBlock()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InlinerInterfaceImpl_8cpp_source.html#l00233">getUnderlyingObjectSet()</a>.</p>

</div>
</div>
<a id="abd4e8ec066bf4a2025b81d2a8c0c9ebe" name="abd4e8ec066bf4a2025b81d2a8c0c9ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4e8ec066bf4a2025b81d2a8c0c9ebe">&#9670;&#160;</a></span>getEffectsRecursively()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">llvm::SmallVector</a>&lt; <a class="el" href="namespacemlir_1_1MemoryEffects.html#aba14da80da7a4a192a129fecdb0ac624">MemoryEffects::EffectInstance</a> &gt; &gt; mlir::getEffectsRecursively </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>rootOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the side effects of an operation. </p>
<p>If the operation has RecursiveMemoryEffects, include all side effects of child operations.</p>
<p>std::nullopt indicates that an option did not have a memory effect interface and so no result could be obtained. An empty vector indicates that there were no memory effects found (but every operation implemented the memory effect interface or has RecursiveMemoryEffects). If the vector contains multiple effects, these effects may be duplicates. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00346">346</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00677">mlir::Operation::getRegions()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00749">mlir::Operation::hasTrait()</a>.</p>

</div>
</div>
<a id="a252aee27751e05d584d0b1a8e793ecf0" name="a252aee27751e05d584d0b1a8e793ecf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252aee27751e05d584d0b1a8e793ecf0">&#9670;&#160;</a></span>getElementTypeOrSelf() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::getElementTypeOrSelf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td>          <td class="paramname"><span class="paramname"><em>attr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the element type or return the type itself. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00033">33</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeUtilities_8cpp_source.html#l00023">getElementTypeOrSelf()</a>.</p>

</div>
</div>
<a id="a82686ceb29eb0f78b59e29021f1b2cdd" name="a82686ceb29eb0f78b59e29021f1b2cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82686ceb29eb0f78b59e29021f1b2cdd">&#9670;&#160;</a></span>getElementTypeOrSelf() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::getElementTypeOrSelf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the element type or return the type itself. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00023">23</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgOps_8cpp_source.html#l01070">buildGenericRegion()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00772">MmaSyncBuilder::buildMmaSync()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00730">buildVectorWrite()</a>, <a class="el" href="ArithToAMDGPU_8cpp_source.html#l00107">castF32To()</a>, <a class="el" href="ArithToAMDGPU_8cpp_source.html#l00217">clampInput()</a>, <a class="el" href="Math_2Transforms_2ExpandOps_8cpp_source.html#l00472">convertCtlzOp()</a>, <a class="el" href="Math_2Transforms_2ExpandOps_8cpp_source.html#l00255">convertFPowIOp()</a>, <a class="el" href="Math_2Transforms_2ExpandOps_8cpp_source.html#l00326">convertPowfOp()</a>, <a class="el" href="Math_2Transforms_2ExpandOps_8cpp_source.html#l00515">convertRoundEvenOp()</a>, <a class="el" href="Math_2Transforms_2ExpandOps_8cpp_source.html#l00412">convertRoundOp()</a>, <a class="el" href="Math_2Transforms_2ExpandOps_8cpp_source.html#l00647">convertRsqrtOp()</a>, <a class="el" href="Arith_2Transforms_2ExpandOps_8cpp_source.html#l00027">createConst()</a>, <a class="el" href="Math_2Transforms_2ExpandOps_8cpp_source.html#l00029">createFloatConst()</a>, <a class="el" href="Arith_2Transforms_2ExpandOps_8cpp_source.html#l00038">createFloatConst()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00082">createLinalgBodyCalculationForElementwiseOp()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00594">mlir::tosa::createPadConstTensor()</a>, <a class="el" href="QuantUtils_8cpp_source.html#l00162">mlir::tosa::createZPsAsConst()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00268">exp2I32()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00125">fillStructuredOpRegion()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00227">frexp()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00281">genBuffers()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00371">genInsertionLoad()</a>, <a class="el" href="Traits_8cpp_source.html#l00132">mlir::OpTrait::util::getBroadcastedType()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00033">getElementTypeOrSelf()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00029">getElementTypeOrSelf()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00129">getScalarOrElementWidth()</a>, <a class="el" href="InferIntRangeInterface_8cpp_source.html#l00031">mlir::ConstantIntRanges::getStorageBitwidth()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00563">getStorageElementTypeOrSelf()</a>, <a class="el" href="ArithOps_8cpp_source.html#l01348">getUnderlyingType()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00380">mlir::arith::getZeroConstant()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00318">insertCasts()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02924">mlir::vector::isBroadcastableTo()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01070">isFillInterfaceImpl()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00217">mlir::linalg::lowerPack()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l01139">mlir::math::ErfcPolynomialApproximation::matchAndRewrite()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l01018">mlir::math::ErfPolynomialApproximation::matchAndRewrite()</a>, <a class="el" href="lib_2Conversion_2SPIRVCommon_2Pattern_8h_source.html#l00027">mlir::spirv::ElementwiseOpPattern&lt; Op, SPIRVOp &gt;::matchAndRewrite()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00061">materializeBinaryNanCheckIfRequired()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00784">mfmaOpToIntrinsic()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00947">mfmaOpToScaledIntrinsic()</a>, <a class="el" href="Linalg_8cpp_source.html#l00019">mlirLinalgFillBuiltinNamedOpRegion()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00463">mlir::linalg::pack()</a>, <a class="el" href="PadTilingInterface_8cpp_source.html#l00227">padOperand()</a>, <a class="el" href="Padding_8cpp_source.html#l00187">padOperandToSmallestStaticBoundingBox()</a>, <a class="el" href="EmulateAtomics_8cpp_source.html#l00166">mlir::amdgpu::populateAmdgpuEmulateAtomicsPatterns()</a>, <a class="el" href="PadTilingInterface_8cpp_source.html#l00266">mlir::linalg::rewriteAsPaddedOp()</a>, <a class="el" href="Padding_8cpp_source.html#l00244">mlir::linalg::rewriteAsPaddedOp()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01452">vectorizeAsLinalgGeneric()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01337">vectorizeOneOp()</a>, <a class="el" href="ArithOps_8cpp_source.html#l01398">verifyExtOp()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01091">mlir::linalg::detail::verifyFillInterface()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l01076">mlir::OpTrait::impl::verifySameOperandsAndResultElementType()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l01100">mlir::OpTrait::impl::verifySameOperandsAndResultType()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l01062">mlir::OpTrait::impl::verifySameOperandsElementType()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01261">mlir::linalg::detail::verifyStructuredOpInterface()</a>, <a class="el" href="TosaOps_8h_source.html#l00069">mlir::OpTrait::tosa::MulOperandsAndResultElementType&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="ArithOps_8cpp_source.html#l01412">verifyTruncateOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l02375">verifyYield()</a>, <a class="el" href="TosaOps_8cpp_source.html#l02629">verifyZeroPoint()</a>, and <a class="el" href="TosaOps_8cpp_source.html#l02644">verifyZeroPoint()</a>.</p>

</div>
</div>
<a id="ae81d443c449b61825fb2c2ec6aa90d35" name="ae81d443c449b61825fb2c2ec6aa90d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae81d443c449b61825fb2c2ec6aa90d35">&#9670;&#160;</a></span>getElementTypeOrSelf() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::getElementTypeOrSelf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00029">29</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeUtilities_8cpp_source.html#l00023">getElementTypeOrSelf()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="a59222c6d1f54e57a5f71291f205911da" name="a59222c6d1f54e57a5f71291f205911da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59222c6d1f54e57a5f71291f205911da">&#9670;&#160;</a></span>getEnclosingRepetitiveRegion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Region.html">Region</a> * mlir::getEnclosingRepetitiveRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the first enclosing region of the given op that may be executed repetitively as per RegionBranchOpInterface or <span class="tt">nullptr</span> if no such region exists. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00482">482</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00119">mlir::Operation::getName()</a>, <a class="el" href="IR_2Region_8h_source.html#l00200">mlir::Region::getParentOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00230">mlir::Operation::getParentRegion()</a>, and <a class="el" href="IR_2Region_8cpp_source.html#l00062">mlir::Region::getRegionNumber()</a>.</p>

</div>
</div>
<a id="abea4281da1b0006e0c9622cff14858a7" name="abea4281da1b0006e0c9622cff14858a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea4281da1b0006e0c9622cff14858a7">&#9670;&#160;</a></span>getEnclosingRepetitiveRegion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Region.html">Region</a> * mlir::getEnclosingRepetitiveRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the first enclosing region of the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> that may be executed repetitively as per RegionBranchOpInterface or <span class="tt">nullptr</span> if no such region exists. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00507">507</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00119">mlir::Operation::getName()</a>, <a class="el" href="IR_2Region_8h_source.html#l00200">mlir::Region::getParentOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00230">mlir::Operation::getParentRegion()</a>, <a class="el" href="Value_8cpp_source.html#l00039">mlir::Value::getParentRegion()</a>, and <a class="el" href="IR_2Region_8cpp_source.html#l00062">mlir::Region::getRegionNumber()</a>.</p>

</div>
</div>
<a id="ac0e1219853f339da1b9caa57a9503c5c" name="ac0e1219853f339da1b9caa57a9503c5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e1219853f339da1b9caa57a9503c5c">&#9670;&#160;</a></span>getFlattenedAffineExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::getFlattenedAffineExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numDims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numSymbols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>flattenedExpr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatLinearConstraints.html">FlatLinearConstraints</a> *</td>          <td class="paramname"><span class="paramname"><em>cst</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>addConservativeSemiAffineBounds</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flattens 'expr' into 'flattenedExpr', which contains the coefficients of the dimensions, symbols, and additional variables that represent floor divisions of dimensions, symbols, and in turn other floor divisions. </p>
<p>Returns failure if 'expr' could not be flattened (i.e., an unhandled semi-affine was found). 'cst' contains constraints that connect newly introduced local variables to existing dimensional and symbolic variables. See documentation for AffineExprFlattener on how mod's and div's are flattened. </p>

<p class="definition">Definition at line <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00177">177</a> of file <a class="el" href="FlatLinearValueConstraints_8cpp_source.html">FlatLinearValueConstraints.cpp</a>.</p>

<p class="reference">References <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00191">getFlattenedAffineExprs()</a>.</p>

</div>
</div>
<a id="ab7adf1265cb39d0279d643deeacdc6f2" name="ab7adf1265cb39d0279d643deeacdc6f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7adf1265cb39d0279d643deeacdc6f2">&#9670;&#160;</a></span>getFlattenedAffineExprs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::getFlattenedAffineExprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a>, 8 &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>flattenedExprs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatLinearConstraints.html">FlatLinearConstraints</a> *</td>          <td class="paramname"><span class="paramname"><em>localVarCst</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>addConservativeSemiAffineBounds</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flattens the result expressions of the map to their corresponding flattened forms and set in 'flattenedExprs'. </p>
<p>Flattens the expressions in map.</p>
<p>Returns failure if any expression in the map could not be flattened (i.e., an unhandled semi-affine was found). 'cst' contains constraints that connect newly introduced local variables to existing dimensional and / symbolic variables. See documentation for AffineExprFlattener on how mod's and div's are flattened. For all affine expressions that share the same operands (like those of an affine map), this method should be used instead of repeatedly calling getFlattenedAffineExpr since local variables added to deal with div's and mod's will be reused across expressions.</p>
<p>Returns failure if 'expr' was unable to be flattened (i.e., an unhandled semi-affine was found). </p>

<p class="definition">Definition at line <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00191">191</a> of file <a class="el" href="FlatLinearValueConstraints_8cpp_source.html">FlatLinearValueConstraints.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01145">mlir::FlatLinearValueConstraints::FlatLinearValueConstraints()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00788">mlir::FlatLinearConstraints::flattenAlignedMapAndMergeLocals()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00177">getFlattenedAffineExpr()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01563">getMultiAffineFunctionFromMap()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00498">mlir::affine::getRelationFromMap()</a>.</p>

</div>
</div>
<a id="a1110cddfcdc3f16a8fa36ef974b58b29" name="a1110cddfcdc3f16a8fa36ef974b58b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1110cddfcdc3f16a8fa36ef974b58b29">&#9670;&#160;</a></span>getFlattenedAffineExprs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::getFlattenedAffineExprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a></td>          <td class="paramname"><span class="paramname"><em>set</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a>, 8 &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>flattenedExprs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatLinearConstraints.html">FlatLinearConstraints</a> *</td>          <td class="paramname"><span class="paramname"><em>cst</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00205">205</a> of file <a class="el" href="FlatLinearValueConstraints_8cpp_source.html">FlatLinearValueConstraints.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00041">mlir::IntegerSet::getConstraints()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00021">mlir::IntegerSet::getNumConstraints()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00015">mlir::IntegerSet::getNumDims()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00016">mlir::IntegerSet::getNumSymbols()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a46bbb7497276c5ea7e8ed4ad1315bf40" name="a46bbb7497276c5ea7e8ed4ad1315bf40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46bbb7497276c5ea7e8ed4ad1315bf40">&#9670;&#160;</a></span>getFlattenedTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a>, 10 &gt; mlir::getFlattenedTypes </td>
          <td>(</td>
          <td class="paramtype">TupleType</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the types within a nested Tuple. </p>
<p>A helper for the class method that handles storage concerns, which is tricky to do in tablegen. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00039">39</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

</div>
</div>
<a id="afffe695e75923a7c364bceee778826a9" name="afffe695e75923a7c364bceee778826a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afffe695e75923a7c364bceee778826a9">&#9670;&#160;</a></span>getForwardSlice() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getForwardSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *</td>          <td class="paramname"><span class="paramname"><em>forwardSlice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a73be93fbd86b265d1dafe07fe73e807e">ForwardSliceOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills <span class="tt">forwardSlice</span> with the computed forward slice (i.e. </p>
<p>all the transitive uses of op), <b>without</b> including that operation.</p>
<p>This additionally takes a <a class="el" href="#a9a2a446f58dd14edfbb77bb2f0ea8818">TransitiveFilter</a> which acts as a frontier: when looking at uses transitively, an operation that does not pass the filter is never propagated through. This allows in particular to carve out the scope within a ForOp or the scope within an IfOp.</p>
<p>The implementation traverses the use chains in postorder traversal for efficiency reasons: if an operation is already in <span class="tt">forwardSlice</span>, no need to traverse its uses again. In the presence of use-def cycles in a graph region, the traversal stops at the first operation that was already visited (which is not added to the slice anymore).</p>
<p>Upon return to the root call, <span class="tt">forwardSlice</span> is filled with a postorder list of uses (i.e. a reverse topological order). To get a proper topological order, we just reverse the order in <span class="tt">forwardSlice</span> before returning.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md0"></a>
Example starting from node 0</h1>
<pre class="fragment">          0
</pre><p> ___________|___________ 1 2 3 4 |_______| |______| | | | | 5 6 |___|_____________| | | 7 8 |_______________| | 9</p>
<p>Assuming all local orders match the numbering order:</p><ol type="1">
<li>after getting back to the root getForwardSlice, <span class="tt">forwardSlice</span> may contain: {9, 7, 8, 5, 1, 2, 6, 3, 4}</li>
<li>reversing the result of 1. gives: {4, 3, 6, 2, 1, 5, 8, 7, 9} </li>
</ol>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8cpp_source.html#l00074">74</a> of file <a class="el" href="SliceAnalysis_8cpp_source.html">SliceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="SliceAnalysis_8cpp_source.html#l00029">getForwardSliceImpl()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l00048">computeDestructuringInfo()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00206">getSlice()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00303">getSliceContract()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01161">hoistOpsBetween()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00198">mlir::linalg::hoistRedundantVectorTransfers()</a>, <a class="el" href="SliceMatchers_8h_source.html#l00173">mlir::query::matcher::PredicateForwardSliceMatcher&lt; BaseMatcher, Filter &gt;::match()</a>, and <a class="el" href="LoopFusionUtils_8cpp_source.html#l00357">promoteSingleIterReductionLoop()</a>.</p>

</div>
</div>
<a id="a54d503b65f87b6cab0452ff97122cbff" name="a54d503b65f87b6cab0452ff97122cbff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54d503b65f87b6cab0452ff97122cbff">&#9670;&#160;</a></span>getForwardSlice() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getForwardSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *</td>          <td class="paramname"><span class="paramname"><em>forwardSlice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a73be93fbd86b265d1dafe07fe73e807e">ForwardSliceOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value-rooted version of <span class="tt">getForwardSlice</span>. </p>
<p>Return the union of all forward slices for the uses of the value <span class="tt">root</span>. </p>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8cpp_source.html#l00092">92</a> of file <a class="el" href="SliceAnalysis_8cpp_source.html">SliceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="SliceAnalysis_8cpp_source.html#l00029">getForwardSliceImpl()</a>, <a class="el" href="Value_8h_source.html#l00218">mlir::Value::getUsers()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="a84637d8636fade36ebdd466b38527c23" name="a84637d8636fade36ebdd466b38527c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84637d8636fade36ebdd466b38527c23">&#9670;&#160;</a></span>getI64SubArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; mlir::getI64SubArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a></td>          <td class="paramname"><span class="paramname"><em>arrayAttr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>dropFront</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>dropBack</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper to return a subset of <span class="tt">arrayAttr</span> as a vector of <a class="el" href="classint64__t.html">int64_t</a>. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00263">263</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="CRunnerUtils_8h_source.html#l00118">dropFront()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l04292">foldExtractStridedSliceNonSplatConstant()</a>, <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html#l00095">ConvertSameRankInsertStridedSliceIntoShuffle::matchAndRewrite()</a>, <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html#l00039">DecomposeDifferentRankInsertStridedSlice::matchAndRewrite()</a>, and <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html#l00282">DecomposeNDExtractStridedSlice::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a820f3296c3cd59eaed418f42f874a217" name="a820f3296c3cd59eaed418f42f874a217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820f3296c3cd59eaed418f42f874a217">&#9670;&#160;</a></span>getInnermostParallelLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::getInnermostParallelLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>rootOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; scf::ParallelOp &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of innermost parallel loops contained in <span class="tt">rootOp</span>. </p>
<p>Innermost parallel loops are those that do not contain further parallel loops themselves. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00240">240</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00240">getInnermostParallelLoops()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00677">mlir::Operation::getRegions()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00240">getInnermostParallelLoops()</a>.</p>

</div>
</div>
<a id="a781931f0aa43382f928cd17998c615c3" name="a781931f0aa43382f928cd17998c615c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781931f0aa43382f928cd17998c615c3">&#9670;&#160;</a></span>getIntValueRanges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1IntegerValueRange.html">IntegerValueRange</a> &gt; mlir::getIntValueRanges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#afbe7bd7ebed80ba2be13ab5e9387f3fe">GetIntRangeFn</a></td>          <td class="paramname"><span class="paramname"><em>getIntRange</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>indexBitwidth</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to collect the integer range values of an array of op fold results. </p>

<p class="definition">Definition at line <a class="el" href="InferIntRangeInterface_8cpp_source.html#l00150">150</a> of file <a class="el" href="InferIntRangeInterface_8cpp_source.html">InferIntRangeInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="InferIntRangeInterface_8cpp_source.html#l00045">mlir::ConstantIntRanges::constant()</a>.</p>

</div>
</div>
<a id="ace39a548030ae8416f5ae52af1eb24e1" name="ace39a548030ae8416f5ae52af1eb24e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace39a548030ae8416f5ae52af1eb24e1">&#9670;&#160;</a></span>getLinearizedDimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::SmallBitVector mlir::getLinearizedDimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>reassociationIndices</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine which dimensions are linearized by a <span class="tt">tensor.collapse_shape</span> op by inspecting its reassociation indices. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00549">549</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00078">mlir::tensor::ExtractSliceFromCollapseHelper::create()</a>.</p>

</div>
</div>
<a id="a74485bec820f2186ce852a09f45ebd47" name="a74485bec820f2186ce852a09f45ebd47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74485bec820f2186ce852a09f45ebd47">&#9670;&#160;</a></span>getMaxDimAndSymbol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AffineExprContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getMaxDimAndSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineExprContainer &gt;</td>          <td class="paramname"><span class="paramname"><em>exprsList</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>maxDim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>maxSym</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates maximum dimension and symbol positions from the expressions in <span class="tt">exprsLists</span> and stores them in <span class="tt">maxDim</span> and <span class="tt">maxSym</span> respectively. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00697">697</a> of file <a class="el" href="mlir_2IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00293">inferFromExprList()</a>, <a class="el" href="Var_8cpp_source.html#l00057">mlir::sparse_tensor::ir_detail::Ranks::isValid()</a>, and <a class="el" href="MLIRContext_8cpp_source.html#l01208">willBeValidAffineMap()</a>.</p>

</div>
</div>
<a id="abe07ed04a2b4a8d370ba318bb94316a2" name="abe07ed04a2b4a8d370ba318bb94316a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe07ed04a2b4a8d370ba318bb94316a2">&#9670;&#160;</a></span>getMixedValues() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::getMixedValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>staticValues</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>dynamicValues</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00218">218</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00198">getMixedValues()</a>.</p>

</div>
</div>
<a id="a05b6893963209031e53537629a129df5" name="a05b6893963209031e53537629a129df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b6893963209031e53537629a129df5">&#9670;&#160;</a></span>getMixedValues() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::getMixedValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>staticValues</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>dynamicValues</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a vector of OpFoldResults with the same size a staticValues, but all elements for which ShapedType::isDynamic is true, will be replaced by dynamicValues. </p>
<p>Return a vector of OpFoldResults with the same size as staticValues, but all elements for which ShapedType::isDynamic is true, will be replaced by dynamicValues. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00198">198</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="StaticValueUtils_8cpp_source.html#l00218">getMixedValues()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00023">inferExpandShapeOutputShape()</a>, and <a class="el" href="ReshapeOpsUtils_8h_source.html#l00361">mlir::ComposeExpandOfCollapseOp&lt; ExpandOpTy, CollapseOpTy &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="aeb248e9fd529c9528e4e235a52941e67" name="aeb248e9fd529c9528e4e235a52941e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb248e9fd529c9528e4e235a52941e67">&#9670;&#160;</a></span>getMultiAffineFunctionFromMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::getMultiAffineFunctionFromMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1presburger_1_1MultiAffineFunction.html">presburger::MultiAffineFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>multiAff</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01563">1563</a> of file <a class="el" href="FlatLinearValueConstraints_8cpp_source.html">FlatLinearValueConstraints.cpp</a>.</p>

<p class="reference">References <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00191">getFlattenedAffineExprs()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01023">mlir::presburger::IntegerRelation::getLocalReprs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="Analysis_2Presburger_2Utils_8h_source.html#l00125">mlir::presburger::DivisionRepr::getNumDivs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="PresburgerSpace_8h_source.html#l00163">mlir::presburger::PresburgerSpace::getRelationSpace()</a>, <a class="el" href="Analysis_2Presburger_2Utils_8h_source.html#l00133">mlir::presburger::DivisionRepr::hasAllReprs()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a0d96a98d184d13853b53c410d814775c" name="a0d96a98d184d13853b53c410d814775c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d96a98d184d13853b53c410d814775c">&#9670;&#160;</a></span>getOffsetsSizesAndStrides()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt; mlir::getOffsetsSizesAndStrides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>ranges</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an array of <a class="el" href="structmlir_1_1Range.html" title="Represents a range (offset, size, and stride) where each element of the triple may be dynamic or stat...">Range</a> values, return a tuple of (offset vector, sizes vector, and strides vector) formed by separating out the individual elements of each range. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00026">26</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

</div>
</div>
<a id="a45e134959101de052e7dbfd12610b5d6" name="a45e134959101de052e7dbfd12610b5d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e134959101de052e7dbfd12610b5d6">&#9670;&#160;</a></span>getOrCreateRanges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a>, 8 &gt; mlir::getOrCreateRanges </td>
          <td>(</td>
          <td class="paramtype">OffsetSizeAndStrideOpInterface</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the list of <a class="el" href="structmlir_1_1Range.html" title="Represents a range (offset, size, and stride) where each element of the triple may be dynamic or stat...">Range</a> (i.e. </p>
<p>offset, size, stride). Each <a class="el" href="structmlir_1_1Range.html" title="Represents a range (offset, size, and stride) where each element of the triple may be dynamic or stat...">Range</a> entry contains either the dynamic value or a ConstantIndexOp constructed with <span class="tt">b</span> at location <span class="tt">loc</span>. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l03175">3175</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>.</p>

</div>
</div>
<a id="af5581571a04b2bd6b89abce0a4ae85dd" name="af5581571a04b2bd6b89abce0a4ae85dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5581571a04b2bd6b89abce0a4ae85dd">&#9670;&#160;</a></span>getOrCreateStringConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LLVM::GlobalOp mlir::getOrCreateStringConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>moduleOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>llvmI8</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>namePrefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>alignment</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>addrSpace</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a global that contains the given string. </p>
<p>If a global with the same string already exists in the module, return that global. </p>

<p class="definition">Definition at line <a class="el" href="GPUOpsLowering_8cpp_source.html#l00048">48</a> of file <a class="el" href="GPUOpsLowering_8cpp_source.html">GPUOpsLowering.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="IR_2Region_8h_source.html#l00172">mlir::Region::getOps()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00686">mlir::Operation::getRegion()</a>, and <a class="el" href="GPUOpsLowering_8cpp_source.html#l00036">getUniqueSymbolName()</a>.</p>

<p class="reference">Referenced by <a class="el" href="GPUOpsLowering_8cpp_source.html#l00391">mlir::GPUPrintfOpToHIPLowering::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00492">mlir::GPUPrintfOpToLLVMCallLowering::matchAndRewrite()</a>, and <a class="el" href="GPUOpsLowering_8cpp_source.html#l00540">mlir::GPUPrintfOpToVPrintfLowering::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a696b120da9a342a4bada4e5ba2da1bbe" name="a696b120da9a342a4bada4e5ba2da1bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a696b120da9a342a4bada4e5ba2da1bbe">&#9670;&#160;</a></span>getOrDefineFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LLVM::LLVMFuncOp mlir::getOrDefineFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>moduleOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LLVM::LLVMFunctionType</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Note that these functions don't take a <span class="tt"><a class="el" href="classmlir_1_1SymbolTable.html" title="This class allows for representing and managing the symbol table used by operations with the &#39;SymbolT...">SymbolTable</a></span> because GPU module lowerings can have name collisions as an intermediate state. </p>
<p>Find or create an external function declaration in the given module. </p>

<p class="definition">Definition at line <a class="el" href="GPUOpsLowering_8cpp_source.html#l00023">23</a> of file <a class="el" href="GPUOpsLowering_8cpp_source.html">GPUOpsLowering.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00686">mlir::Operation::getRegion()</a>, and <a class="el" href="SymbolTable_8cpp_source.html#l00384">mlir::SymbolTable::lookupSymbolIn()</a>.</p>

<p class="reference">Referenced by <a class="el" href="GPUOpsLowering_8cpp_source.html#l00391">mlir::GPUPrintfOpToHIPLowering::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00492">mlir::GPUPrintfOpToLLVMCallLowering::matchAndRewrite()</a>, and <a class="el" href="GPUOpsLowering_8cpp_source.html#l00540">mlir::GPUPrintfOpToVPrintfLowering::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a002c6258ba17b3a08e25cde241861c3f" name="a002c6258ba17b3a08e25cde241861c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a002c6258ba17b3a08e25cde241861c3f">&#9670;&#160;</a></span>getPerfectlyNestedLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getPerfectlyNestedLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; scf::ForOp &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nestedLoops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ForOp</td>          <td class="paramname"><span class="paramname"><em>root</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get perfectly nested sequence of loops starting at root of loop nest (the first op being another AffineFor, and the second op - a terminator). </p>
<p>A loop is perfectly nested iff: the first op in the loop's body is another AffineForOp, and the second op is a terminator). </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01326">1326</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01227">getPerfectlyNestedLoopsImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00994">coalescePerfectlyNestedSCFForLoops()</a>.</p>

</div>
</div>
<a id="ac1bdf7e87740dbe0f603efdbc83c0a68" name="ac1bdf7e87740dbe0f603efdbc83c0a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1bdf7e87740dbe0f603efdbc83c0a68">&#9670;&#160;</a></span>getPositionsOfShapeOne()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::SmallBitVector mlir::getPositionsOfShapeOne </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>rank</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00090">90</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<a id="ab45e3ce76869b05848f96a5f8b97fc90" name="ab45e3ce76869b05848f96a5f8b97fc90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab45e3ce76869b05848f96a5f8b97fc90">&#9670;&#160;</a></span>getProjectedMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::getProjectedMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;</td>          <td class="paramname"><span class="paramname"><em>projectedDimensions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>compressDimsFlag</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>compressSymbolsFlag</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls <span class="tt">projectDims(map, projectedDimensions, compressDimsFlag)</span>. </p>
<p>If <span class="tt">compressSymbolsFlag</span> is true, additionally call <span class="tt">compressUnusedSymbols</span>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00913">913</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00729">compressUnusedSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00899">projectDims()</a>.</p>

</div>
</div>
<a id="aeba376b9b63ed400e64bb041e459a62e" name="aeba376b9b63ed400e64bb041e459a62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba376b9b63ed400e64bb041e459a62e">&#9670;&#160;</a></span>getPrunedAttributeList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a> &gt; mlir::getPrunedAttributeList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt;</td>          <td class="paramname"><span class="paramname"><em>elidedAttrs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00220">220</a> of file <a class="el" href="StructuredOpsUtils_8cpp_source.html">StructuredOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00512">mlir::Operation::getAttrs()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00088">mlir::tensor::bubbleUpPadSlice()</a>.</p>

</div>
</div>
<a id="a12acf2020ef95ce0a5d7c3f2bbb6af14" name="a12acf2020ef95ce0a5d7c3f2bbb6af14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12acf2020ef95ce0a5d7c3f2bbb6af14">&#9670;&#160;</a></span>getReassociationAttrName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StringRef mlir::getReassociationAttrName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> name for the ArrayAttr which encodes reassociation indices. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8h_source.html#l00032">32</a> of file <a class="el" href="ReshapeOpsUtils_8h_source.html">ReshapeOpsUtils.h</a>.</p>

</div>
</div>
<a id="ae7220b1ee91536560d8599b5aceaea71" name="ae7220b1ee91536560d8599b5aceaea71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7220b1ee91536560d8599b5aceaea71">&#9670;&#160;</a></span>getReassociationIndicesAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a> mlir::getReassociationIndicesAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>reassociation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps a list of reassociations in an ArrayAttr. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00423">423</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00262">indices</a>.</p>

</div>
</div>
<a id="a76b303e750705222900d23e44f2a22ce" name="a76b303e750705222900d23e44f2a22ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b303e750705222900d23e44f2a22ce">&#9670;&#160;</a></span>getReassociationIndicesForCollapse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt; &gt; mlir::getReassociationIndicesForCollapse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sourceShape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>targetShape</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the reassociation maps to collapse <span class="tt">sourceShape</span> to <span class="tt">targetShape</span> if possible. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00291">291</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00201">findReassociationRangesForCollapse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00023">getReassociationIndicesForReshape()</a>.</p>

</div>
</div>
<a id="a6783c78835273b8062a5b5e2a710d863" name="a6783c78835273b8062a5b5e2a710d863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6783c78835273b8062a5b5e2a710d863">&#9670;&#160;</a></span>getReassociationIndicesForReshape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt; &gt; mlir::getReassociationIndicesForReshape </td>
          <td>(</td>
          <td class="paramtype">ShapedType</td>          <td class="paramname"><span class="paramname"><em>sourceType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ShapedType</td>          <td class="paramname"><span class="paramname"><em>targetType</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the reassociations maps to use to reshape given the source type and the target type when possible. </p>
<p>Return std::nullopt when this computation failed. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00023">23</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00291">getReassociationIndicesForCollapse()</a>.</p>

</div>
</div>
<a id="acb4551ba2eb907b65cc0fb1800d98d28" name="acb4551ba2eb907b65cc0fb1800d98d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb4551ba2eb907b65cc0fb1800d98d28">&#9670;&#160;</a></span>getSCFMinMaxExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::pair&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &gt; mlir::getSCFMinMaxExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>symbols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td>          <td class="paramname"><span class="paramname"><em>loopFilter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the min/max expressions for <span class="tt">value</span> if it is an induction variable from scf.for or scf.parallel loop. </p>
<p>if <span class="tt">loopFilter</span> is passed, the filter determines which loop to consider. Other induction variables are ignored. </p>

</div>
</div>
<a id="ad533bd7ca28e9b550e615d21e6ac2c8b" name="ad533bd7ca28e9b550e615d21e6ac2c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad533bd7ca28e9b550e615d21e6ac2c8b">&#9670;&#160;</a></span>getSimplifiedOfrAndStaticSizePair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classint64__t.html">int64_t</a>, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::getSimplifiedOfrAndStaticSizePair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>ofr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> representing dim size value (*), generates a pair of sizes: </p>
<ul>
<li>1st result, static value, contains an <a class="el" href="classint64__t.html">int64_t</a> dim size that can be used to build ShapedType (ShapedType::kDynamic is used for truly dynamic dims),</li>
<li>2nd result, dynamic value, contains <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> encapsulating the actual dim size (either original or updated input value). For input sizes for which it is possible to extract a constant <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>, replaces the original size value with an integer attribute (unless it's already a constant <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>). The 1st return value also becomes the actual integer size (as opposed ShapedType::kDynamic).</li>
</ul>
<p>(*) This hook is usually used when, given input sizes as <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a>, it's required to generate two vectors:</p><ul>
<li>sizes as <a class="el" href="classint64__t.html">int64_t</a> to generate a shape,</li>
<li>sizes as <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> for sizes-like attribute. Please update this comment if you identify other use cases. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00059">59</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">getConstantIntValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01135">mlir::linalg::DecomposeOuterUnitDimsPackOpPattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a03521cb5a2e00b91574ef1df705310bd" name="a03521cb5a2e00b91574ef1df705310bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03521cb5a2e00b91574ef1df705310bd">&#9670;&#160;</a></span>getSinglyExecutedRegionsToSink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getSinglyExecutedRegionsToSink </td>
          <td>(</td>
          <td class="paramtype">RegionBranchOpInterface</td>          <td class="paramname"><span class="paramname"><em>branch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>regions</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <span class="tt">regions</span> with regions of the provided region branch op that are executed at most once at that are reachable given the current operands of the op. </p>
<p>These regions can be passed to <span class="tt">controlFlowSink</span> to perform sinking on the regions of the operation. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowSinkUtils_8cpp_source.html#l00140">140</a> of file <a class="el" href="ControlFlowSinkUtils_8cpp_source.html">ControlFlowSinkUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="ControlFlowInterfaces_8h_source.html#l00312">mlir::InvocationBounds::getUpperBound()</a>, <a class="el" href="Matchers_8h_source.html#l00369">m_Constant()</a>, and <a class="el" href="Matchers_8h_source.html#l00490">matchPattern()</a>.</p>

</div>
</div>
<a id="acd9f91ff576a4cb961289ea2f9e3dd0f" name="acd9f91ff576a4cb961289ea2f9e3dd0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9f91ff576a4cb961289ea2f9e3dd0f">&#9670;&#160;</a></span>getSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::getSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1BackwardSliceOptions.html">BackwardSliceOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>backwardSliceOptions</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a73be93fbd86b265d1dafe07fe73e807e">ForwardSliceOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>forwardSliceOptions</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iteratively computes backward slices and forward slices until a fixed point is reached. </p>
<p>Returns an <span class="tt"><a class="el" href="#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt;<a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> *&gt;</span> which <b>includes</b> the original operation.</p>
<p>This allows building a slice (i.e. multi-root DAG where everything that is reachable from an <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> in forward and backward direction is contained in the slice). This is the abstraction we need to materialize all the operations for supervectorization without worrying about orderings and <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> replacements.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md2"></a>
Example starting from any node</h1>
<p>1 2 3 4 |_______| |______| | | | | | 5 6___| |___|_____________| | | | | 7 8 | |_______________| | | | 9 10</p>
<p>Return the whole DAG in some topological order.</p>
<p>The implementation works by just filling up a worklist with iterative alternate calls to <span class="tt">getBackwardSlice</span> and <span class="tt">getForwardSlice</span>.</p>
<p>The following section describes some additional implementation considerations for a potentially more efficient implementation but they are just an intuition without proof, we still use a worklist for now.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md3"></a>
Additional implementation considerations</h1>
<p>Consider the defs-op-uses hourglass. </p><hr  />
<p> \ / defs (in some topological order) \/ op /\ / \ uses (in some topological order) /____\</p>
<p>We want to iteratively apply <span class="tt">getSlice</span> to construct the whole list of <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> that are reachable by (use|def)+ from op. We want the resulting slice in topological order. Ideally we would like the ordering to be maintained in-place to avoid copying <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> at each step. Keeping this ordering by construction seems very unclear, so we list invariants in the hope of seeing whether useful properties pop up.</p>
<p>In the following: we use |= for set inclusion; we use &lt;&lt; for set topological ordering (i.e. each pair is ordered).</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md4"></a>
Assumption:</h1>
<p>We wish to maintain the following property by a recursive argument: """
     defs &lt;&lt; {op} &lt;&lt;uses are in topological order.
  """ The property clearly holds for 0 and 1-sized uses and defs;</p>
<p>Invariants:</p><ol type="1">
<li>defs and uses are in topological order internally, by construction;</li>
<li>for any {x} |= defs, defs(x) |= defs; because all go through op</li>
<li>for any {x} |= uses, defs |= defs(x); because all go through op</li>
<li>for any {x} |= defs, uses |= uses(x); because all go through op</li>
<li>for any {x} |= uses, uses(x) |= uses; because all go through op</li>
</ol>
<p>Intuitively, we should be able to recurse like: preorder(defs) - op - postorder(uses) and keep things ordered but this is still hand-wavy and not worth the trouble for now: punt to a simple worklist-based solution. </p>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8cpp_source.html#l00206">206</a> of file <a class="el" href="SliceAnalysis_8cpp_source.html">SliceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="SliceAnalysis_8cpp_source.html#l00179">getBackwardSlice()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00074">getForwardSlice()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, and <a class="el" href="TopologicalSortUtils_8cpp_source.html#l00275">topologicalSort()</a>.</p>

</div>
</div>
<a id="a10337918edd90e6a270db09d71d66dc5" name="a10337918edd90e6a270db09d71d66dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10337918edd90e6a270db09d71d66dc5">&#9670;&#160;</a></span>getSlicedDimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::SmallBitVector mlir::getSlicedDimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sliceInputShape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sliceParams</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The input parameters <span class="tt">offsets</span>, <span class="tt">sizes</span>, <span class="tt">strides</span> specify a rectangular non rank-reducing slice of the collapse_shape output. </p>
<p>Try to find which dimensions have been sliced and which dimensions are not sliced (offset = 0, size = dim, size = 1). Note that this conservative as it cannot detect if a dynamic size corresponds to the full tensor dimension or not. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00532">532</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">getConstantIntValue()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00176">isEqualConstantIntOrValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00078">mlir::tensor::ExtractSliceFromCollapseHelper::create()</a>.</p>

</div>
</div>
<a id="a561d5231fcefc471a4c9069fce2eaf87" name="a561d5231fcefc471a4c9069fce2eaf87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561d5231fcefc471a4c9069fce2eaf87">&#9670;&#160;</a></span>getSymbolLessAffineMaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, 4 &gt; mlir::getSymbolLessAffineMaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#a9d60419b09330b78865818c679695080">ReassociationExprs</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>reassociation</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs affine maps out of Array&lt;Array&lt;AffineExpr&gt;&gt;. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00447">447</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="LoopUtils_8cpp.html#a420db562c84b0a026e92385cb33aaf6f">getContext()</a>, and <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00410">getMaxPosOfType()</a>.</p>

</div>
</div>
<a id="a348ed9fcbefe1f5094cc571c346c7080" name="a348ed9fcbefe1f5094cc571c346c7080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348ed9fcbefe1f5094cc571c346c7080">&#9670;&#160;</a></span>getType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::getType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>ofr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the int type of the integer in ofr. </p>
<p>Other attribute types are not supported. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00304">304</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="NVVMDialect_8cpp_source.html#l01690">addInferredMultiplicandTypes()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00378">mlir::sparse_tensor::allocaBuffer()</a>, <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00178">mlir::memref::allocToAlloca()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01267">mlir::DenseElementsAttr::bitcast()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l01201">convertElementwiseOp()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00911">mlir::LLVM::detail::createIntrinsicCall()</a>, <a class="el" href="CFGToSCF_8cpp_source.html#l00552">createSingleExitingLatch()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00329">mlir::xegpu::createVectorWithShapeFromValues()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00774">denormalizeInductionVariable()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00458">mlir::spirv::Deserializer::processOp&lt; spirv::FunctionCallOp &gt;()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00573">mlir::spirv::Deserializer::processOp&lt; spirv::GenericCastToPtrExplicitOp &gt;()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00539">mlir::linalg::dropUnitDims()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00703">emitNormalizedLoopBounds()</a>, <a class="el" href="Fusion_8cpp_source.html#l00103">fuse()</a>, <a class="el" href="AffineOps_8h_source.html#l00186">mlir::affine::AffineDmaStartOp::getDstMemorySpace()</a>, <a class="el" href="AffineOps_8h_source.html#l00181">mlir::affine::AffineDmaStartOp::getDstMemRefRank()</a>, <a class="el" href="AffineOps_8h_source.html#l00176">mlir::affine::AffineDmaStartOp::getDstMemRefType()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01297">mlir::DenseElementsAttr::getElementType()</a>, <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00167">mlir::sparse_tensor::getMemRefType()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01301">mlir::DenseElementsAttr::getNumElements()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00818">getProductOfIntsOrIndexes()</a>, <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00160">mlir::sparse_tensor::getRankedTensorType()</a>, <a class="el" href="AffineOps_8h_source.html#l00162">mlir::affine::AffineDmaStartOp::getSrcMemorySpace()</a>, <a class="el" href="AffineOps_8h_source.html#l00140">mlir::affine::AffineDmaStartOp::getSrcMemRefType()</a>, <a class="el" href="AffineOps_8h_source.html#l00219">mlir::affine::AffineDmaStartOp::getTagMemRefRank()</a>, <a class="el" href="AffineOps_8h_source.html#l00367">mlir::affine::AffineDmaWaitOp::getTagMemRefRank()</a>, <a class="el" href="AffineOps_8h_source.html#l00214">mlir::affine::AffineDmaStartOp::getTagMemRefType()</a>, <a class="el" href="AffineOps_8h_source.html#l00349">mlir::affine::AffineDmaWaitOp::getTagMemRefType()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00097">handleMultidimensionalVectors()</a>, <a class="el" href="CreateAsyncGroups_8cpp_source.html#l00023">isContiguousXferOp()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01499">mlir::DenseFPElementsAttr::mapValues()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01519">mlir::DenseIntElementsAttr::mapValues()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00323">ConsolidateTransposeOptimization::matchAndRewrite()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01978">mlir::spirv::Deserializer::materializeSpecConstantOperation()</a>, <a class="el" href="LLVM_8cpp_source.html#l00375">mlirLLVMDISubprogramAttrGetType()</a>, <a class="el" href="Transform_8cpp_source.html#l00106">mlirTransformParamTypeGetType()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00589">mlirTupleTypeGetType()</a>, <a class="el" href="IR_8cpp_source.html#l01151">mlirValueGetType()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01222">mlir::spirv::Deserializer::processArrayType()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01636">mlir::spirv::Deserializer::processConstant()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01777">mlir::spirv::Deserializer::processConstantComposite()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01833">mlir::spirv::Deserializer::processConstantCompositeReplicateEXT()</a>, <a class="el" href="Deserializer_8cpp_source.html#l02036">mlir::spirv::Deserializer::processConstantNull()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01280">mlir::spirv::Deserializer::processCooperativeMatrixTypeKHR()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00481">mlir::spirv::Deserializer::processFunction()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01255">mlir::spirv::Deserializer::processFunctionType()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00938">mlir::spirv::Deserializer::processGlobalVariable()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00714">mlir::spirv::Deserializer::processGraphARM()</a>, <a class="el" href="Deserializer_8cpp_source.html#l02069">mlir::spirv::Deserializer::processGraphConstantARM()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01528">mlir::spirv::Deserializer::processGraphTypeARM()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01570">mlir::spirv::Deserializer::processImageType()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01459">mlir::spirv::Deserializer::processMatrixType()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01167">mlir::spirv::Deserializer::processOpTypePointer()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00261">mlir::spirv::Deserializer::processOpWithoutGrammarAttr()</a>, <a class="el" href="Deserializer_8cpp_source.html#l02264">mlir::spirv::Deserializer::processPhi()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01341">mlir::spirv::Deserializer::processRuntimeArrayType()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01618">mlir::spirv::Deserializer::processSampledImageType()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01881">mlir::spirv::Deserializer::processSpecConstantComposite()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01916">mlir::spirv::Deserializer::processSpecConstantCompositeReplicateEXT()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01952">mlir::spirv::Deserializer::processSpecConstantOperation()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01357">mlir::spirv::Deserializer::processStructType()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01479">mlir::spirv::Deserializer::processTensorARMType()</a>, <a class="el" href="Deserializer_8cpp_source.html#l01046">mlir::spirv::Deserializer::processType()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00341">mlir::spirv::Deserializer::processUndef()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l01156">reduceMatchAndRewriteHelper()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00172">reifyMixedParamAndHandleResults()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01239">mlir::DenseElementsAttr::reshape()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01251">mlir::DenseElementsAttr::resizeSplat()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00416">mlir::linalg::rewriteInIm2Col()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00550">mlir::linalg::rewriteInIm2Col()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00123">mlir::linalg::rewriteInIm2Col()</a>, <a class="el" href="StructBuilder_8cpp_source.html#l00020">mlir::StructBuilder::StructBuilder()</a>, <a class="el" href="OpenACCUtilsTiling_8cpp_source.html#l00136">mlir::acc::tileACCLoops()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01213">mlir::DenseElementsAttr::tryGetComplexFloatValues()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01193">mlir::DenseElementsAttr::tryGetComplexIntValues()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01202">mlir::DenseElementsAttr::tryGetFloatValues()</a>, <a class="el" href="PredicateTree_8cpp_source.html#l00531">useOperandGroup()</a>, <a class="el" href="ImageOps_8cpp_source.html#l00023">verifyImageOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02012">mlir::affine::AffineDmaStartOp::verifyInvariantsImpl()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02148">mlir::affine::AffineDmaWaitOp::verifyInvariantsImpl()</a>, and <a class="el" href="LoopLikeInterface_8cpp_source.html#l00055">mlir::detail::verifyLoopLikeOpInterface()</a>.</p>

</div>
</div>
<a id="ac61c6bb6068af953a0711cf404a99645" name="ac61c6bb6068af953a0711cf404a99645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac61c6bb6068af953a0711cf404a99645">&#9670;&#160;</a></span>getUnusedDimsBitVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::SmallBitVector mlir::getUnusedDimsBitVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>maps</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00923">923</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00715">compressUnusedDims()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l00945">verifyOutputShape()</a>.</p>

</div>
</div>
<a id="a2798707e1d2321021e16802305d3c152" name="a2798707e1d2321021e16802305d3c152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2798707e1d2321021e16802305d3c152">&#9670;&#160;</a></span>getUnusedSymbolsBitVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::SmallBitVector mlir::getUnusedSymbolsBitVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>maps</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00935">935</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00729">compressUnusedSymbols()</a>.</p>

</div>
</div>
<a id="a2c45b388f069e9396c50660f41a7eacf" name="a2c45b388f069e9396c50660f41a7eacf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c45b388f069e9396c50660f41a7eacf">&#9670;&#160;</a></span>getUsedValuesDefinedAbove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getUsedValuesDefinedAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>regions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill <span class="tt">values</span> with a list of values used within any of the regions provided but defined in one of the ancestors. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00077">77</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="RegionUtils_8cpp_source.html#l00070">getUsedValuesDefinedAbove()</a>.</p>

</div>
</div>
<a id="a98f08e970a346cd42559db87f97f0b91" name="a98f08e970a346cd42559db87f97f0b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98f08e970a346cd42559db87f97f0b91">&#9670;&#160;</a></span>getUsedValuesDefinedAbove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getUsedValuesDefinedAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>region</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>limit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill <span class="tt">values</span> with a list of values defined at the ancestors of the <span class="tt">limit</span> region and used within <span class="tt">region</span> or its descendants. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00070">70</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l00043">visitUsedValuesDefinedAbove()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PassDetail_8cpp_source.html#l00020">mlir::async::cloneConstantsIntoTheRegion()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00110">computeBackwardSlice()</a>, <a class="el" href="AsyncParallelFor_8cpp_source.html#l00204">getParallelComputeFunctionType()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00077">getUsedValuesDefinedAbove()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00087">makeRegionIsolatedFromAbove()</a>, <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00295">outlineExecuteOp()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00177">outlineKernelFuncImpl()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00114">outlineSingleBlockRegion()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00122">sinkOperationsIntoLaunchOp()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l01452">vectorizeAsLinalgGeneric()</a>.</p>

</div>
</div>
<a id="a7d8bbfc3d0c15e92f5cba28e5ef447b5" name="a7d8bbfc3d0c15e92f5cba28e5ef447b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8bbfc3d0c15e92f5cba28e5ef447b5">&#9670;&#160;</a></span>getValueOrCreateCastToIndexLike()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::getValueOrCreateCastToIndexLike </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>targetType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a cast from an index-like value (index or integer) to another index-like value. </p>
<p>If the value type and the target type are the same, it returns the original value. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00119">119</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00054">mlir::Type::isIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpenACCUtilsTiling_8cpp_source.html#l00023">resolveAndCastTileSize()</a>.</p>

</div>
</div>
<a id="ab09c62516a7b31fc96892014feeae832" name="ab09c62516a7b31fc96892014feeae832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09c62516a7b31fc96892014feeae832">&#9670;&#160;</a></span>getValueOrCreateConstantIndexOp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::getValueOrCreateConstantIndexOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>valueOrAttrVec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to the other overload, but converts multiple OpFoldResults into Values. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00262">262</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">getValueOrCreateConstantIndexOp()</a>.</p>

</div>
</div>
<a id="aa058eb9c12d3b97deb073543c1372195" name="aa058eb9c12d3b97deb073543c1372195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa058eb9c12d3b97deb073543c1372195">&#9670;&#160;</a></span>getValueOrCreateConstantIndexOp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::getValueOrCreateConstantIndexOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>ofr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> to a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>
<p>Returns the fold result if it casts to a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> or creates a ConstantIndexOp if it casts to an Integer <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>. Other attribute types are not supported. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">111</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>.</p>

<p class="reference">Referenced by <a class="el" href="XeGPUUtils_8cpp_source.html#l00520">mlir::xegpu::addElementwise()</a>, <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00088">mlir::tensor::bubbleUpPadSlice()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00929">HopperBuilder::buildAndInitBarrierInSharedMemory()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00994">HopperBuilder::buildBarrierArriveTx()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00944">HopperBuilder::buildGlobalMemRefDescriptor()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00080">buildLinearId()</a>, <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00202">calculateExpandedAccessIndices()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00107">commonLinearIdBuilderFn()</a>, <a class="el" href="Tiling_8cpp_source.html#l00156">mlir::linalg::computeContinuousTileSizes()</a>, <a class="el" href="Tiling_8cpp_source.html#l00262">mlir::linalg::computeMultiTileSizes()</a>, <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00078">mlir::tensor::ExtractSliceFromCollapseHelper::create()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00036">createInBoundsCond()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00749">denormalizeInductionVariableForIndexType()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l03788">denormalizeIndVar()</a>, <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00327">dynamicallyInsertSubVector()</a>, <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00364">emulatedVectorLoad()</a>, <a class="el" href="XeGPUDialect_8cpp_source.html#l00956">mlir::xegpu::genBinOp()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00281">genBuffers()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00388">generateLoopNestUsingForOp()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00237">getBoundedTileSize()</a>, <a class="el" href="ReshapePatterns_8cpp_source.html#l00462">mlir::tensor::getCollapsedExtractSliceInfo()</a>, <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00078">getCompressedMaskOp()</a>, <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00128">getIndicesForLoadOrStore()</a>, <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00090">getOffsetForBitwidth()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00818">getProductOfIntsOrIndexes()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00262">getValueOrCreateConstantIndexOp()</a>, <a class="el" href="MultiBuffer_8cpp_source.html#l00082">mlir::memref::multiBuffer()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01479">normalizeForallOp()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l02155">mlir::linalg::offsetIndices()</a>, <a class="el" href="Promotion_8cpp_source.html#l00237">mlir::linalg::promoteSubviewAsNewBuffer()</a>, <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html#l00080">mlir::affine::resolveIndicesIntoOpWithOffsetsAndStrides()</a>, <a class="el" href="MemRefUtils_8cpp_source.html#l00253">mlir::memref::resolveSourceIndicesCollapseShape()</a>, <a class="el" href="Tiling_8cpp_source.html#l00588">mlir::linalg::tileReductionUsingForall()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00126">unpackRanges()</a>, and <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00730">updateExpandedGenericOpRegion()</a>.</p>

</div>
</div>
<a id="a4654f8a83dcd16f99ce83a6a991fa348" name="a4654f8a83dcd16f99ce83a6a991fa348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4654f8a83dcd16f99ce83a6a991fa348">&#9670;&#160;</a></span>getValueOrCreateConstantIntOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::getValueOrCreateConstantIntOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>ofr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> to a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>
<p>Returns the fold result if it casts to a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> or creates a ConstantOp if it casts to an Integer <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>. Other attribute types are not supported. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00102">102</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00908">coalesceLoops()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01069">collapseParallelLoops()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00774">denormalizeInductionVariable()</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00703">emitNormalizedLoopBounds()</a>.</p>

</div>
</div>
<a id="ad2bf7271ea0c5e95377e621f7923baa7" name="ad2bf7271ea0c5e95377e621f7923baa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2bf7271ea0c5e95377e621f7923baa7">&#9670;&#160;</a></span>getValuesSortedByKey() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; mlir::getValuesSortedByKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>keys</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>compare</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00271">271</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00243">getValuesSortedByKeyImpl()</a>.</p>

</div>
</div>
<a id="af3ec25d896f63f835649e57fa1156deb" name="af3ec25d896f63f835649e57fa1156deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ec25d896f63f835649e57fa1156deb">&#9670;&#160;</a></span>getValuesSortedByKey() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::getValuesSortedByKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>keys</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>compare</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00265">265</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00243">getValuesSortedByKeyImpl()</a>.</p>

</div>
</div>
<a id="ae8b5c05e14ade6108624f49c4c8bf104" name="ae8b5c05e14ade6108624f49c4c8bf104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b5c05e14ade6108624f49c4c8bf104">&#9670;&#160;</a></span>getValuesSortedByKey() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::getValuesSortedByKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>keys</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>compare</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper to sort <span class="tt">values</span> according to matching <span class="tt">keys</span>. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00259">259</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00243">getValuesSortedByKeyImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="GPUTransformOps_8cpp_source.html#l00464">rewriteOneForallCommonImpl()</a>.</p>

</div>
</div>
<a id="a58c1a102a79cae901d44e104d0299da3" name="a58c1a102a79cae901d44e104d0299da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c1a102a79cae901d44e104d0299da3">&#9670;&#160;</a></span>getValuesSortedByKeyImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; V &gt; mlir::getValuesSortedByKeyImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; K &gt;</td>          <td class="paramname"><span class="paramname"><em>keys</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; V &gt;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(K, K)&gt;</td>          <td class="paramname"><span class="paramname"><em>compare</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to sort <span class="tt">values</span> according to matching <span class="tt">keys</span>. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00243">243</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00262">indices</a>.</p>

<p class="reference">Referenced by <a class="el" href="StaticValueUtils_8cpp_source.html#l00271">getValuesSortedByKey()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00265">getValuesSortedByKey()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00259">getValuesSortedByKey()</a>.</p>

</div>
</div>
<a id="ac155ca106ea75d1bf8f9b995d7e2d99d" name="ac155ca106ea75d1bf8f9b995d7e2d99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac155ca106ea75d1bf8f9b995d7e2d99d">&#9670;&#160;</a></span>hasEffect() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... EffectTys&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::hasEffect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns "true" if <span class="tt">op</span> has an effect of type <span class="tt">EffectTy</span>. </p>
<p>Returns "false" if <span class="tt">op</span> has unknown effects. Recursive effects are not taken into account. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00217">217</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="SideEffectInterfaces_8h_source.html#l00212">mlir::SideEffects::EffectInstance&lt; EffectT &gt;::getEffect()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00043">mlir::affine::LoopNestStateCollector::collect()</a>, <a class="el" href="MemRefDialect_8cpp_source.html#l00064">mlir::memref::findDealloc()</a>, <a class="el" href="BufferDeallocationSimplification_8cpp_source.html#l00072">mlir::bufferization::impl::BufferDeallocationSimplificationPassBase&lt; DerivedT &gt;::getDependentDialects()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00078">mlir::affine::MemRefDependenceGraph::Node::getLoadOpCount()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00093">mlir::affine::MemRefDependenceGraph::Node::getStoreOpCount()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00109">mlir::affine::MemRefDependenceGraph::Node::hasStore()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l01812">mlir::transform::isHandleConsumed()</a>, <a class="el" href="AffineLoopInvariantCodeMotion_8cpp_source.html#l00063">isOpLoopInvariant()</a>, <a class="el" href="SideEffectInterfaces_8h_source.html#l00431">mightHaveEffect()</a>, <a class="el" href="SideEffectInterfaces_8h_source.html#l00439">mightHaveEffect()</a>, <a class="el" href="SideEffectInterfaces_8h_source.html#l00447">mightHaveEffect()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#a311b8efdcc381f9d75560b0515ed112b">mlir::hasEffect&lt; BlockArgument, MemoryEffects::Allocate &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#a7ccdd515db00dabbb87f5ea873c60985">mlir::hasEffect&lt; BlockArgument, MemoryEffects::Free &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#ae4d791caa1afae98dae716d388f02110">mlir::hasEffect&lt; BlockArgument, MemoryEffects::Read &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#a1fc84f6f0a54f23d1f7869144a8a988c">mlir::hasEffect&lt; BlockArgument, MemoryEffects::Write &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#a9182b27fe344a044acc1a583c4403872">mlir::hasEffect&lt; BlockArgument, MemoryEffects::Write, MemoryEffects::Free &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#adac7981e02eb65f2ef5782ff5a0c911c">mlir::hasEffect&lt; MemoryEffects::Allocate &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#a979b13d176bb5e1d1d525a6995b8c5db">mlir::hasEffect&lt; MemoryEffects::Allocate &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#af205338dc00c1597669dba9c5f01a5e1">mlir::hasEffect&lt; MemoryEffects::Free &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#a2aa74a293c3638d5a5f6dc94e149d9fa">mlir::hasEffect&lt; MemoryEffects::Free &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#a3b75e5872659443726903d290db864fe">mlir::hasEffect&lt; MemoryEffects::Read &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#a4828f63beddd025b2ebc8aaf1f1fca37">mlir::hasEffect&lt; MemoryEffects::Read &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#a3cc25513d8c75583c1e299e24d001c4c">mlir::hasEffect&lt; MemoryEffects::Write &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#a62d9d3e633d93dc0ba764e60b26f7755">mlir::hasEffect&lt; MemoryEffects::Write &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#a44f690c8bb52c2cd85e4c06c16f8bf6c">mlir::hasEffect&lt; MemoryEffects::Write, MemoryEffects::Free &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#a7e34f937f32bf528cc9dbe2fdec44fa7">mlir::hasEffect&lt; MemoryEffects::Write, MemoryEffects::Free &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#a8b00fe64987111af23ed437ba11d1c30">mlir::hasEffect&lt; OpOperand *, MemoryEffects::Allocate &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#a4188dadd6602b73f6c79f98e657a8229">mlir::hasEffect&lt; OpOperand *, MemoryEffects::Free &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#ae08ef2f44109dc43546512256df700f8">mlir::hasEffect&lt; OpOperand *, MemoryEffects::Read &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#a622700625c3e7228fc39b0147a6187df">mlir::hasEffect&lt; OpOperand *, MemoryEffects::Write &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#a8a1e93e88b3b1dedb7785933b4f8a305">mlir::hasEffect&lt; OpOperand *, MemoryEffects::Write, MemoryEffects::Free &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#a2a67e69c0c542255589c00e5038c1869">mlir::hasEffect&lt; OpResult, MemoryEffects::Allocate &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#a3e5bf443bd17d62b8fe686be6e4b0122">mlir::hasEffect&lt; OpResult, MemoryEffects::Free &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#a30b42b19f5c1cee698166191f0b62bb7">mlir::hasEffect&lt; OpResult, MemoryEffects::Read &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#aad99b6562eb8efe84f2d3dae14cd6ba9">mlir::hasEffect&lt; OpResult, MemoryEffects::Write &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#a9735b88c5a3a878a6479bb2711d8035b">mlir::hasEffect&lt; OpResult, MemoryEffects::Write, MemoryEffects::Free &gt;()</a>, <a class="el" href="MemRefUtils_8cpp_source.html#l00139">mlir::memref::resultIsNotRead()</a>, and <a class="el" href="TransformInterfaces_8cpp_source.html#l01925">mlir::transform::detail::verifyTransformOpInterface()</a>.</p>

</div>
</div>
<a id="ae27d7e4ff6226389cfa4a4a5129caea0" name="ae27d7e4ff6226389cfa4a4a5129caea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27d7e4ff6226389cfa4a4a5129caea0">&#9670;&#160;</a></span>hasEffect() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... EffectTys&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::hasEffect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns "true" if <span class="tt">op</span> has an effect of type <span class="tt">EffectTy</span> on <span class="tt">value</span>. </p>
<p>Returns "false" if <span class="tt">op</span> has unknown effects. Recursive effects are not taken into account. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00235">235</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="SideEffectInterfaces_8h_source.html#l00212">mlir::SideEffects::EffectInstance&lt; EffectT &gt;::getEffect()</a>, and <a class="el" href="SideEffectInterfaces_8h_source.html#l00216">mlir::SideEffects::EffectInstance&lt; EffectT &gt;::getValue()</a>.</p>

</div>
</div>
<a id="a4bc8a79e07b7e048723a9fbfe9bc914e" name="a4bc8a79e07b7e048723a9fbfe9bc914e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc8a79e07b7e048723a9fbfe9bc914e">&#9670;&#160;</a></span>hasEffect() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueTy, typename... EffectTys&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::hasEffect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueTy</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns "true" if <span class="tt">op</span> has an effect of type <span class="tt">EffectTy</span> on <span class="tt">value</span> of type <span class="tt">ValueTy</span>. </p>
<p>Returns "false" if <span class="tt">op</span> has unknown effects. Recursive effects are not taken into account. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00257">257</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="SideEffectInterfaces_8h_source.html#l00212">mlir::SideEffects::EffectInstance&lt; EffectT &gt;::getEffect()</a>, and <a class="el" href="SideEffectInterfaces_8h_source.html#l00235">mlir::SideEffects::EffectInstance&lt; EffectT &gt;::getEffectValue()</a>.</p>

</div>
</div>
<a id="ad9141d8b586a68549d2ecaccbce99a69" name="ad9141d8b586a68549d2ecaccbce99a69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9141d8b586a68549d2ecaccbce99a69">&#9670;&#160;</a></span>hash_value() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> hashable. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00247">247</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00196">mlir::AffineExpr::expr</a>.</p>

<p class="reference">Referenced by <a class="el" href="OperationSupport_8h_source.html#l01353">mlir::OperationEquivalence::directHashValue()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00365">llvm::DenseMapInfo&lt; mlir::AffineExpr &gt;::getHashValue()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00726">llvm::DenseMapInfo&lt; mlir::AffineMap &gt;::getHashValue()</a>, <a class="el" href="Attributes_8h_source.html#l00313">llvm::DenseMapInfo&lt; mlir::Attribute &gt;::getHashValue()</a>, <a class="el" href="mlir_2IR_2IntegerSet_8h_source.html#l00142">llvm::DenseMapInfo&lt; mlir::IntegerSet &gt;::getHashValue()</a>, <a class="el" href="Location_8h_source.html#l00239">llvm::DenseMapInfo&lt; mlir::Location &gt;::getHashValue()</a>, <a class="el" href="Attributes_8h_source.html#l00358">llvm::DenseMapInfo&lt; mlir::NamedAttribute &gt;::getHashValue()</a>, <a class="el" href="IR_2Types_8h_source.html#l00321">llvm::DenseMapInfo&lt; mlir::Type &gt;::getHashValue()</a>, <a class="el" href="TypeID_8h_source.html#l00405">llvm::DenseMapInfo&lt; mlir::TypeID &gt;::getHashValue()</a>, <a class="el" href="Value_8h_source.html#l00514">llvm::DenseMapInfo&lt; mlir::Value &gt;::getHashValue()</a>, and <a class="el" href="Location_8h_source.html#l00122">hash_value()</a>.</p>

</div>
</div>
<a id="a032c893ca9a2fff3b16e5a7cb6d413cd" name="a032c893ca9a2fff3b16e5a7cb6d413cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032c893ca9a2fff3b16e5a7cb6d413cd">&#9670;&#160;</a></span>hash_value() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00425">425</a> of file <a class="el" href="mlir_2IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

</div>
</div>
<a id="a68bae84b1d7cdba11b048d9af3478a07" name="a68bae84b1d7cdba11b048d9af3478a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68bae84b1d7cdba11b048d9af3478a07">&#9670;&#160;</a></span>hash_value() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Attributes_8h_source.html#l00155">155</a> of file <a class="el" href="Attributes_8h_source.html">Attributes.h</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00147">mlir::Attribute::impl</a>.</p>

</div>
</div>
<a id="aac18c17aca8d8a8549fef55a52af5393" name="aac18c17aca8d8a8549fef55a52af5393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac18c17aca8d8a8549fef55a52af5393">&#9670;&#160;</a></span>hash_value() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1AsmDialectResourceHandle.html">AsmDialectResourceHandle</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>param</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00110">110</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="OpImplementation_8h_source.html#l00057">mlir::AsmDialectResourceHandle::getResource()</a>.</p>

</div>
</div>
<a id="aa4b795f2f972c070efff53082563f976" name="aa4b795f2f972c070efff53082563f976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b795f2f972c070efff53082563f976">&#9670;&#160;</a></span>hash_value() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Attributes_8h_source.html#l00214">214</a> of file <a class="el" href="Attributes_8h_source.html">Attributes.h</a>.</p>

</div>
</div>
<a id="a655bb0e17a21ea2c35194f7c822c9ca5" name="a655bb0e17a21ea2c35194f7c822c9ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655bb0e17a21ea2c35194f7c822c9ca5">&#9670;&#160;</a></span>hash_value() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2IntegerSet_8h_source.html#l00124">124</a> of file <a class="el" href="mlir_2IR_2IntegerSet_8h_source.html">IntegerSet.h</a>.</p>

</div>
</div>
<a id="aa6261878bc5197cfcc003e5b3fa735ea" name="aa6261878bc5197cfcc003e5b3fa735ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6261878bc5197cfcc003e5b3fa735ea">&#9670;&#160;</a></span>hash_value() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Location_8h_source.html#l00122">122</a> of file <a class="el" href="Location_8h_source.html">Location.h</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00247">hash_value()</a>, and <a class="el" href="Location_8h_source.html#l00113">mlir::Location::impl</a>.</p>

</div>
</div>
<a id="ad93109842c1b05424c5052d9bd9a4394" name="ad93109842c1b05424c5052d9bd9a4394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93109842c1b05424c5052d9bd9a4394">&#9670;&#160;</a></span>hash_value() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperationName.html">OperationName</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OperationSupport_8h_source.html#l00513">513</a> of file <a class="el" href="OperationSupport_8h_source.html">OperationSupport.h</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8h_source.html#l00483">mlir::OperationName::getAsOpaquePointer()</a>.</p>

</div>
</div>
<a id="a31eede9183d3fdae566e18d94a5ef51b" name="a31eede9183d3fdae566e18d94a5ef51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31eede9183d3fdae566e18d94a5ef51b">&#9670;&#160;</a></span>hash_value() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00302">302</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00234">mlir::Type::impl</a>.</p>

</div>
</div>
<a id="aafb3bcc9d23b2cfd1367b84f5b00b7c1" name="aafb3bcc9d23b2cfd1367b84f5b00b7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb3bcc9d23b2cfd1367b84f5b00b7c1">&#9670;&#160;</a></span>hash_value() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a></td>          <td class="paramname"><span class="paramname"><em>id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable hashing <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type.">TypeID</a>. </p>

<p class="definition">Definition at line <a class="el" href="TypeID_8h_source.html#l00152">152</a> of file <a class="el" href="TypeID_8h_source.html">TypeID.h</a>.</p>

</div>
</div>
<a id="abb322b17530b4289c3e3ec1f4ad2ecce" name="abb322b17530b4289c3e3ec1f4ad2ecce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb322b17530b4289c3e3ec1f4ad2ecce">&#9670;&#160;</a></span>hash_value() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make <a class="el" href="classmlir_1_1TypeRange.html" title="This class provides an abstraction over the various different ranges of value types.">TypeRange</a> hashable. </p>

<p class="definition">Definition at line <a class="el" href="TypeRange_8h_source.html#l00074">74</a> of file <a class="el" href="TypeRange_8h_source.html">TypeRange.h</a>.</p>

</div>
</div>
<a id="ab710b1f6f21f3f35197575b609aae4b4" name="ab710b1f6f21f3f35197575b609aae4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab710b1f6f21f3f35197575b609aae4b4">&#9670;&#160;</a></span>hash_value() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> hashable. </p>

<p class="definition">Definition at line <a class="el" href="Value_8h_source.html#l00490">490</a> of file <a class="el" href="Value_8h_source.html">Value.h</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00237">mlir::Value::getImpl()</a>.</p>

</div>
</div>
<a id="a54bdf3d5eaaef529cc7cf1ea0fa1808b" name="a54bdf3d5eaaef529cc7cf1ea0fa1808b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54bdf3d5eaaef529cc7cf1ea0fa1808b">&#9670;&#160;</a></span>hasSingleEffect() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EffectTy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::hasSingleEffect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns "true" if <span class="tt">op</span> has only an effect of type <span class="tt">EffectTy</span>. </p>
<p>Returns "false" if <span class="tt">op</span> has unknown effects or other/additional effects. Recursive effects are not taken into account. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00113">113</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00185">isEscapingMemref()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#a8882e300f3666fabb300a96a9fe0f94b">mlir::hasSingleEffect&lt; BlockArgument, MemoryEffects::Allocate &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#aaf6368833f8e20c2ad20473867e984e6">mlir::hasSingleEffect&lt; BlockArgument, MemoryEffects::Free &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#a8ad9e26a67070537194ada11d7fb943e">mlir::hasSingleEffect&lt; BlockArgument, MemoryEffects::Read &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#a530a99524ea2af7aad6e56cb6f728c7c">mlir::hasSingleEffect&lt; BlockArgument, MemoryEffects::Write &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#aa8b04d71acabbb634461694c099d26f4">mlir::hasSingleEffect&lt; MemoryEffects::Allocate &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#a0a2e64861e36a14d130e90a092a0bdf0">mlir::hasSingleEffect&lt; MemoryEffects::Allocate &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#ab51b751e0098a50fb5ed75698c386975">mlir::hasSingleEffect&lt; MemoryEffects::Free &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#afddcb441ffe61a77dff942598c49eb3c">mlir::hasSingleEffect&lt; MemoryEffects::Free &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#a4e88dfd638fe270aed238ce8a4f573cb">mlir::hasSingleEffect&lt; MemoryEffects::Read &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#aabaeb4a31784ab33ed6d4b479c4ce7b6">mlir::hasSingleEffect&lt; MemoryEffects::Read &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#a9d05b98b31d3544f669eb6e98d271f5b">mlir::hasSingleEffect&lt; MemoryEffects::Write &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#a97b219d817125911cfb165b666d076ee">mlir::hasSingleEffect&lt; MemoryEffects::Write &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#a742ee5f0d7ae15084efa38f1d7a3e150">mlir::hasSingleEffect&lt; OpOperand *, MemoryEffects::Allocate &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#a0b06f312bbc25e2a27b01bc3b5e84f8c">mlir::hasSingleEffect&lt; OpOperand *, MemoryEffects::Free &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#ac2286c57e7c3db64e1248e6e3b4ceb8b">mlir::hasSingleEffect&lt; OpOperand *, MemoryEffects::Read &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#a55aa0e0b7b2785245512cf99a7fa781c">mlir::hasSingleEffect&lt; OpOperand *, MemoryEffects::Write &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#aaa882ad3e73a460a74443a8038f7a46e">mlir::hasSingleEffect&lt; OpResult, MemoryEffects::Allocate &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#a509a1f41341debaa9ea9de187ef63011">mlir::hasSingleEffect&lt; OpResult, MemoryEffects::Free &gt;()</a>, <a class="el" href="SideEffectInterfaces_8cpp.html#ac84d9402de14c2e8bf624764bc5adece">mlir::hasSingleEffect&lt; OpResult, MemoryEffects::Read &gt;()</a>, and <a class="el" href="SideEffectInterfaces_8cpp.html#a2273b7656e76c213011aaeedcc13b21d">mlir::hasSingleEffect&lt; OpResult, MemoryEffects::Write &gt;()</a>.</p>

</div>
</div>
<a id="a4e5c028078f8fdc86950f374b834cb07" name="a4e5c028078f8fdc86950f374b834cb07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5c028078f8fdc86950f374b834cb07">&#9670;&#160;</a></span>hasSingleEffect() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EffectTy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::hasSingleEffect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns "true" if <span class="tt">op</span> has only an effect of type <span class="tt">EffectTy</span> on <span class="tt">value</span>. </p>
<p>Returns "false" if <span class="tt">op</span> has unknown effects or other/additional effects. Recursive effects are not taken into account. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00135">135</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

</div>
</div>
<a id="a1879b99cadf0d3c0c5de98b33412b650" name="a1879b99cadf0d3c0c5de98b33412b650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1879b99cadf0d3c0c5de98b33412b650">&#9670;&#160;</a></span>hasSingleEffect() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueTy, typename EffectTy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::hasSingleEffect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueTy</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns "true" if <span class="tt">op</span> has only an effect of type <span class="tt">EffectTy</span> on <span class="tt">value</span> of type <span class="tt">ValueTy</span>. </p>
<p>Returns "false" if <span class="tt">op</span> has unknown effects or other/additional effects. Recursive effects are not taken into account. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00164">164</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

</div>
</div>
<a id="ad9b46b5604ddc7a8a370d1064ad5108c" name="ad9b46b5604ddc7a8a370d1064ad5108c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9b46b5604ddc7a8a370d1064ad5108c">&#9670;&#160;</a></span>hasUnknownEffects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::hasUnknownEffects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return "true" if <span class="tt">op</span> has unknown effects. </p>
<p>I.e., the effects of the operation itself are unknown and the operation does not derive its effects from its nested operations. (<span class="tt">HasRecursiveMemoryEffects</span> trait is not implemented or it is unknown whether it is implemented or not.) </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00307">307</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00749">mlir::Operation::hasTrait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SideEffectInterfaces_8h_source.html#l00431">mightHaveEffect()</a>, <a class="el" href="SideEffectInterfaces_8h_source.html#l00439">mightHaveEffect()</a>, and <a class="el" href="SideEffectInterfaces_8h_source.html#l00447">mightHaveEffect()</a>.</p>

</div>
</div>
<a id="a653bf589569eab36eb696bc4db3371c6" name="a653bf589569eab36eb696bc4db3371c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a653bf589569eab36eb696bc4db3371c6">&#9670;&#160;</a></span>hasValidSizesOffsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::hasValidSizesOffsets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sizesOrOffsets</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to check whether the passed in <span class="tt">sizes</span> or <span class="tt">offsets</span> are valid. </p>
<p>This can be used to re-check whether dimensions are still valid after constant folding the dynamic dimensions. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00383">383</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

</div>
</div>
<a id="a88795bccdeef2b7388f2bbd6d1c15ae7" name="a88795bccdeef2b7388f2bbd6d1c15ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88795bccdeef2b7388f2bbd6d1c15ae7">&#9670;&#160;</a></span>hasValidStrides()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::hasValidStrides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>strides</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to check whether the passed in <span class="tt">strides</span> are valid. </p>
<p>This can be used to re-check whether dimensions are still valid after constant folding the dynamic dimensions. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00389">389</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

</div>
</div>
<a id="a249488f6fe37fa1e0175eed93494136d" name="a249488f6fe37fa1e0175eed93494136d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a249488f6fe37fa1e0175eed93494136d">&#9670;&#160;</a></span>hoistLoopInvariantSubsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LoopLikeOpInterface mlir::hoistLoopInvariantSubsets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LoopLikeOpInterface</td>          <td class="paramname"><span class="paramname"><em>loopLike</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hoist loop-invariant tensor subsets (subset extraction and subset insertion ops) from loop-like ops. </p>
<p>Extraction ops are moved before the loop. Insertion ops are moved after the loop. The loop body operates on newly added region iter_args (one per extraction-insertion pair).</p>
<p>A subset extraction op (<span class="tt">SubsetExtractionOpInterface</span>) extracts from a tensor value at a subset. The result of the op may have an arbitrary type, i.e., not necessarily a tensor type. Example: "tensor.extract_slice".</p>
<p>A subset insertion op (<span class="tt">SubsetInsertionOpInterface</span>) inserts into a tensor value ("destination") at a subset. Example: "tensor.insert_slice".</p>
<p>Matching extraction-insertion subset ops can be hoisted from a loop if there are no other ops within the loop that operate on the same or on an overlapping subset. In particular, non-subset ops can prevent hoisting because the analysis does not know what subset they operate on.</p>
<p>Example: </p><div class="fragment"><div class="line">%r = <a class="code hl_namespace" href="namespacemlir_1_1scf.html">scf</a>.for ... iter_args(%t = %a) -&gt; (<a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;?xf32&gt;</a>) {</div>
<div class="line">  %0 = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.extract_slice %t[0][5][1] : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;?xf32&gt;</a> to <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;5xf32&gt;</a></div>
<div class="line">  %1 = <span class="stringliteral">&quot;test.foo&quot;</span>(%0) : (<a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>&lt;5xf32&gt;) -&gt; (<a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>&lt;5xf32&gt;)</div>
<div class="line">  %2 = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.insert_slice %1 into %t[0][5][1]</div>
<div class="line">      : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>&lt;5xf32&gt; into <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>&lt;?xf32&gt;</div>
<div class="line">  <a class="code hl_namespace" href="namespacemlir_1_1scf.html">scf</a>.yield %2 : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>&lt;?xf32&gt;</div>
<div class="line">}</div>
<div class="ttc" id="anamespacemlir_1_1scf_html"><div class="ttname"><a href="namespacemlir_1_1scf.html">mlir::scf</a></div><div class="ttdef"><b>Definition</b> <a href="SCFToGPU_8h_source.html#l00024">SCFToGPU.h:24</a></div></div>
<div class="ttc" id="anamespacemlir_1_1tensor_html"><div class="ttname"><a href="namespacemlir_1_1tensor.html">mlir::tensor</a></div><div class="ttdef"><b>Definition</b> <a href="BufferizationTransformOps_8h_source.html#l00019">BufferizationTransformOps.h:19</a></div></div>
</div><!-- fragment --><p> Is rewritten to: </p><div class="fragment"><div class="line">%0 = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.extract_slice %a[0][5][1] : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;?xf32&gt;</a> to <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;5xf32&gt;</a></div>
<div class="line">%new_loop:2 = <a class="code hl_namespace" href="namespacemlir_1_1scf.html">scf</a>.for ... iter_args(%t = %a, %h = %0) -&gt; (<a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;?xf32&gt;</a>) {</div>
<div class="line">  %1 = <span class="stringliteral">&quot;test.foo&quot;</span>(%h) : (<a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>&lt;5xf32&gt;) -&gt; (<a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>&lt;5xf32&gt;)</div>
<div class="line">  <a class="code hl_namespace" href="namespacemlir_1_1scf.html">scf</a>.yield %t, %2 : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>&lt;?xf32&gt;, <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>&lt;5xf32&gt;</div>
<div class="line">}</div>
<div class="line">%r = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.insert_slice %new_loop#1 into %new_loop#0</div>
<div class="line">    : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>&lt;5xf32&gt; into <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>&lt;?xf32&gt;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html#l00395">395</a> of file <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html">LoopInvariantCodeMotionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html#l00324">hoistSubsetAtIterArg()</a>.</p>

</div>
</div>
<a id="aa23862ef78a8ff63b4f6a3c344448e16" name="aa23862ef78a8ff63b4f6a3c344448e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa23862ef78a8ff63b4f6a3c344448e16">&#9670;&#160;</a></span>inferExpandShapeOutputShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt; mlir::inferExpandShapeOutputShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ShapedType</td>          <td class="paramname"><span class="paramname"><em>expandedType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>reassociation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>inputShape</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer the output shape for a {memref|tensor}.expand_shape when it is possible to do so. </p>
<p>Note: This should <em>only</em> be used to implement <span class="tt">ExpandShapeOp::inferOutputShape</span> in both the memref and tensor namespaces. If you need to infer the output shape you should use the static method of <span class="tt">ExpandShapeOp</span> instead of calling this.</p>
<p><span class="tt">inputShape</span> is the shape of the tensor or memref being expanded as a sequence of SSA values or constants. <span class="tt">expandedType</span> is the output shape of the expand_shape operation. <span class="tt">reassociation</span> is the reassociation denoting the output dims each input dim is mapped to.</p>
<p>Returns the output shape in <span class="tt">outputShape</span> and <span class="tt">staticOutputShape</span>, following the conventions for the output_shape and static_output_shape inputs to the expand_shape ops. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00023">23</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00198">getMixedValues()</a>.</p>

</div>
</div>
<a id="a6bfae453ee10ef0c61c70b258633a407" name="a6bfae453ee10ef0c61c70b258633a407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bfae453ee10ef0c61c70b258633a407">&#9670;&#160;</a></span>inlineCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::inlineCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>interface</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InlinerInterface.html#a8fc732997e895e237723efbd0a1e0e5f">InlinerInterface::CloneCallbackSigTy</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>cloneCallback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallOpInterface</td>          <td class="paramname"><span class="paramname"><em>call</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallableOpInterface</td>          <td class="paramname"><span class="paramname"><em>callable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>shouldCloneInlinedRegion</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function inlines a given region, 'src', of a callable operation, 'callable', into the location defined by the given call operation. </p>
<p>This function returns failure if inlining is not possible, success otherwise. On failure, no changes are made to the module. 'shouldCloneInlinedRegion' corresponds to whether the source region should be cloned into the 'call' or spliced directly. </p>

<p class="definition">Definition at line <a class="el" href="InliningUtils_8cpp_source.html#l00479">479</a> of file <a class="el" href="InliningUtils_8cpp_source.html">InliningUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00060">mlir::Region::empty()</a>, <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="DialectInterface_8h_source.html#l00170">mlir::DialectInterfaceCollection&lt; InterfaceType &gt;::getInterfaceFor()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00271">inlineRegionImpl()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00100">mlir::InlinerInterface::isLegalToInline()</a>, <a class="el" href="IRMapping_8h_source.html#l00030">mlir::IRMapping::map()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00453">materializeConversion()</a>, <a class="el" href="Value_8h_source.html#l00149">mlir::Value::replaceAllUsesWith()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00227">mlir::Operation::replaceUsesOfWith()</a>, <a class="el" href="Builders_8h_source.html#l00412">mlir::OpBuilder::setInsertionPointAfter()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a2472c1d6da7b6e4441ca98ffb3b31520" name="a2472c1d6da7b6e4441ca98ffb3b31520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2472c1d6da7b6e4441ca98ffb3b31520">&#9670;&#160;</a></span>inlineRegion() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::inlineRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>interface</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InlinerInterface.html#a8fc732997e895e237723efbd0a1e0e5f">InlinerInterface::CloneCallbackSigTy</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>cloneCallback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>inlineBlock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a></td>          <td class="paramname"><span class="paramname"><em>inlinePoint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mapper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>resultsToReplace</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a></td>          <td class="paramname"><span class="paramname"><em>regionResultTypes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>inlineLoc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>shouldCloneInlinedRegion</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InliningUtils_8cpp_source.html#l00418">418</a> of file <a class="el" href="InliningUtils_8cpp_source.html">InliningUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="InliningUtils_8cpp_source.html#l00271">inlineRegionImpl()</a>.</p>

</div>
</div>
<a id="a87891d50879cd33cefdec62a06ea07e8" name="a87891d50879cd33cefdec62a06ea07e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87891d50879cd33cefdec62a06ea07e8">&#9670;&#160;</a></span>inlineRegion() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::inlineRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>interface</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InlinerInterface.html#a8fc732997e895e237723efbd0a1e0e5f">InlinerInterface::CloneCallbackSigTy</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>cloneCallback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>inlineBlock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a></td>          <td class="paramname"><span class="paramname"><em>inlinePoint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>inlinedOperands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>resultsToReplace</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>inlineLoc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>shouldCloneInlinedRegion</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InliningUtils_8cpp_source.html#l00440">440</a> of file <a class="el" href="InliningUtils_8cpp_source.html">InliningUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="InliningUtils_8cpp_source.html#l00271">inlineRegionImpl()</a>.</p>

</div>
</div>
<a id="aea91e88bdb26082865bd45419644d99f" name="aea91e88bdb26082865bd45419644d99f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea91e88bdb26082865bd45419644d99f">&#9670;&#160;</a></span>inlineRegion() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::inlineRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>interface</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InlinerInterface.html#a8fc732997e895e237723efbd0a1e0e5f">InlinerInterface::CloneCallbackSigTy</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>cloneCallback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>inlinePoint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mapper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>resultsToReplace</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a></td>          <td class="paramname"><span class="paramname"><em>regionResultTypes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>inlineLoc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>shouldCloneInlinedRegion</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function inlines a region, 'src', into another. </p>
<p>This function returns failure if it is not possible to inline this function. If the function returned failure, then no changes to the module have been made.</p>
<p>The provided 'inlinePoint' must be within a region, and corresponds to the location where the 'src' region should be inlined. 'mapping' contains any remapped operands that are used within the region, and <em>must</em> include remappings for the entry arguments to the region. 'resultsToReplace' corresponds to any results that should be replaced by terminators within the inlined region. 'regionResultTypes' specifies the expected return types of the terminators in the region. 'inlineLoc' is an optional <a class="el" href="classmlir_1_1Location.html" title="This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...">Location</a> that, if provided, will be used to update the inlined operations' location information. 'shouldCloneInlinedRegion' corresponds to whether the source region should be cloned into the 'inlinePoint' or spliced directly. </p>

<p class="definition">Definition at line <a class="el" href="InliningUtils_8cpp_source.html#l00407">407</a> of file <a class="el" href="InliningUtils_8cpp_source.html">InliningUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, and <a class="el" href="InliningUtils_8cpp_source.html#l00407">inlineRegion()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InliningUtils_8cpp_source.html#l00407">inlineRegion()</a>, and <a class="el" href="InliningUtils_8cpp_source.html#l00429">inlineRegion()</a>.</p>

</div>
</div>
<a id="a1c7096b9aadeeeca00d054ab6d9eede0" name="a1c7096b9aadeeeca00d054ab6d9eede0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7096b9aadeeeca00d054ab6d9eede0">&#9670;&#160;</a></span>inlineRegion() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::inlineRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>interface</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InlinerInterface.html#a8fc732997e895e237723efbd0a1e0e5f">InlinerInterface::CloneCallbackSigTy</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>cloneCallback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>inlinePoint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>inlinedOperands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>resultsToReplace</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>inlineLoc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>shouldCloneInlinedRegion</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is an overload of the above 'inlineRegion' that allows for providing the set of operands ('inlinedOperands') that should be used in-favor of the region arguments when inlining. </p>

<p class="definition">Definition at line <a class="el" href="InliningUtils_8cpp_source.html#l00429">429</a> of file <a class="el" href="InliningUtils_8cpp_source.html">InliningUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, and <a class="el" href="InliningUtils_8cpp_source.html#l00407">inlineRegion()</a>.</p>

</div>
</div>
<a id="ae873ed9c30ada4ee5e87cf53a550c610" name="ae873ed9c30ada4ee5e87cf53a550c610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae873ed9c30ada4ee5e87cf53a550c610">&#9670;&#160;</a></span>insertTypesInto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> mlir::insertTypesInto </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a></td>          <td class="paramname"><span class="paramname"><em>oldTypes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a></td>          <td class="paramname"><span class="paramname"><em>newTypes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>storage</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a set of <span class="tt">newTypes</span> into <span class="tt">oldTypes</span> at the given <span class="tt">indices</span>. </p>
<p>If any types are inserted, <span class="tt">storage</span> is used to hold the new type list. The new type list is returned. <span class="tt">indices</span> must be sorted by increasing index. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00175">175</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00262">indices</a>.</p>

</div>
</div>
<a id="a426b7e62d7400b01d368a3db835df9d3" name="a426b7e62d7400b01d368a3db835df9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426b7e62d7400b01d368a3db835df9d3">&#9670;&#160;</a></span>insideMutuallyExclusiveRegions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::insideMutuallyExclusiveRegions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <span class="tt">true</span> if <span class="tt">a</span> and <span class="tt">b</span> are in mutually exclusive regions as per RegionBranchOpInterface. </p>
<p>Return <span class="tt">true</span> if <span class="tt">a</span> and <span class="tt">b</span> are in mutually exclusive regions.</p>
<ol type="1">
<li>Find the first common of <span class="tt">a</span> and <span class="tt">b</span> (ancestor) that implements RegionBranchOpInterface.</li>
<li>Determine the regions <span class="tt">regionA</span> and <span class="tt">regionB</span> in which <span class="tt">a</span> and <span class="tt">b</span> are contained.</li>
<li>Check if <span class="tt">regionA</span> and <span class="tt">regionB</span> are mutually exclusive. They are mutually exclusive if they are not reachable from each other as per RegionBranchOpInterface::getSuccessorRegions. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00106">106</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00106">insideMutuallyExclusiveRegions()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00106">insideMutuallyExclusiveRegions()</a>.</p>

</div>
</div>
<a id="a39612be2ef116102866d3bb9c6a8ca88" name="a39612be2ef116102866d3bb9c6a8ca88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39612be2ef116102866d3bb9c6a8ca88">&#9670;&#160;</a></span>inverseAndBroadcastProjectedPermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::inverseAndBroadcastProjectedPermutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the reverse map of a projected permutation where the projected dimensions are transformed into 0s. </p>
<p>Prerequisites: <span class="tt">map</span> must be a projected permutation.</p>
<p>Example 1:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0, d1, d2, d3) -&gt; (d2, d0)&gt;</div>
</div><!-- fragment --><p>returns:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0, d1) -&gt; (d1, 0, d0, 0)&gt;</div>
</div><!-- fragment --><p>Example 2:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0, d1, d2, d3) -&gt; (d0, d3)&gt;</div>
</div><!-- fragment --><p>returns:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0, d1) -&gt; (d0, 0, 0, d1)&gt;</div>
</div><!-- fragment --><p>Example 3:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0, d1, d2, d3) -&gt; (d2)&gt;</div>
</div><!-- fragment --><p>returns:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0) -&gt; (0, 0, d0, 0)&gt;</div>
</div><!-- fragment --><p> Example 4:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0, d1, d2) -&gt; (d0, 0)&gt;</div>
</div><!-- fragment --><p>returns:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0, d1) -&gt; (d0, 0, 0)&gt;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00808">808</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="#ab26cdced424aa629fde4150cc8674d50">getAffineConstantExpr()</a>, <a class="el" href="#addfd4323ef72147332661606b030d04d">getAffineDimExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00411">mlir::AffineMap::getDimPosition()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00611">mlir::AffineMap::isProjectedPermutation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l01452">vectorizeAsLinalgGeneric()</a>.</p>

</div>
</div>
<a id="a52b322818d83a2256d4e4391acbf78a2" name="a52b322818d83a2256d4e4391acbf78a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b322818d83a2256d4e4391acbf78a2">&#9670;&#160;</a></span>inversePermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::inversePermutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a map of codomain to domain dimensions such that the first codomain dimension for a particular domain dimension is selected. </p>
<p>Returns an empty map if the input map is empty. Returns null map (not empty map) if <span class="tt">map</span> is not invertible (i.e. <span class="tt">map</span> does not contain a subset that is a permutation of full domain rank).</p>
<p>Prerequisites:</p><ol type="1">
<li><span class="tt">map</span> has no symbols.</li>
</ol>
<p>Example 1:</p>
<div class="fragment"><div class="line">(d0, d1, d2) -&gt; (d1, d1, d0, d2, d1, d2, d1, d0)</div>
<div class="line">                  0       2   3</div>
</div><!-- fragment --><p>returns:</p>
<div class="fragment"><div class="line">(d0, d1, d2, d3, d4, d5, d6, d7) -&gt; (d2, d0, d3)</div>
</div><!-- fragment --><p>Example 2:</p>
<div class="fragment"><div class="line">(d0, d1, d2) -&gt; (d1, d0 + d1, d0, d2, d1, d2, d1, d0)</div>
<div class="line">                  0            2   3</div>
</div><!-- fragment --><p>returns:</p>
<div class="fragment"><div class="line">(d0, d1, d2, d3, d4, d5, d6, d7) -&gt; (d2, d0, d3)</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00784">784</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="#addfd4323ef72147332661606b030d04d">getAffineDimExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00365">mlir::AffineMap::isEmpty()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l00730">buildVectorWrite()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00040">mlir::linalg::detail::canOpOperandsBeDroppedImpl()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00384">mlir::linalg::dropUnitDims()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00339">mlir::linalg::fuseElementwiseOps()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00047">getIndexingMapOfProducerOperandsInCoordinatesOfFusedOp()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l01041">mlir::sparse_tensor::inferLvlToDim()</a>, <a class="el" href="VectorOps_8cpp_source.html#l04823">mlir::vector::inferTransferOpMaskType()</a>, <a class="el" href="Interchange_8cpp_source.html#l00045">mlir::linalg::interchangeGenericOp()</a>, <a class="el" href="Interchange_8cpp_source.html#l00031">interchangeGenericOpPrecondition()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00079">isOpOperandCanBeDroppedAfterFusedLinalgs()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00260">mlir::linalg::rewriteInIm2Col()</a>, <a class="el" href="Tiling_8cpp_source.html#l00433">tileLinalgOpImpl()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l01452">vectorizeAsLinalgGeneric()</a>.</p>

</div>
</div>
<a id="afc254f56cba37671e1e5b2b933c6a090" name="afc254f56cba37671e1e5b2b933c6a090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc254f56cba37671e1e5b2b933c6a090">&#9670;&#160;</a></span>invertPermutationVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; mlir::invertPermutationVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>permutation</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to apply to inverse a permutation. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00187">187</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00789">createExpandedTransposeOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l04961">mlir::linalg::getPackedOuterShapeWithoutTransposition()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01082">getPackUnpackNormalizedPerm()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l05584">mlir::linalg::inferStaticShape()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l05905">mlir::linalg::inferStaticShape()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00217">mlir::linalg::lowerPack()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01271">mlir::linalg::DecomposeOuterUnitDimsUnPackOpPattern::matchAndRewrite()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l02134">SwapTransposeWithBroadcast::matchAndRewrite()</a>, and <a class="el" href="IndexingUtils_8cpp_source.html#l00340">mlir::detail::TileOffsetRangeImpl::TileOffsetRangeImpl()</a>.</p>

</div>
</div>
<a id="a2823559fb2fadd8959a578eecc499342" name="a2823559fb2fadd8959a578eecc499342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2823559fb2fadd8959a578eecc499342">&#9670;&#160;</a></span>isBatchMatvec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::isBatchMatvec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a></td>          <td class="paramname"><span class="paramname"><em>indexingMaps</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether the given maps describe a batch matrix vector multiplication. </p>
<p>The test is permutation-invariant. Note that this only checks the affine maps from an operation, so does not perform any checks on the math being performed within the reduction. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00172">172</a> of file <a class="el" href="StructuredOpsUtils_8cpp_source.html">StructuredOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>.</p>

</div>
</div>
<a id="a9c3a18535f4146298157c782e5254e94" name="a9c3a18535f4146298157c782e5254e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3a18535f4146298157c782e5254e94">&#9670;&#160;</a></span>isBatchVecmat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::isBatchVecmat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a></td>          <td class="paramname"><span class="paramname"><em>indexingMaps</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether the given maps describe a batch vector matrix multiplication. </p>
<p>The test is permutation-invariant. Note that this only checks the affine maps from an operation, so does not perform any checks on the math being performed within the reduction. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00123">123</a> of file <a class="el" href="StructuredOpsUtils_8cpp_source.html">StructuredOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>.</p>

</div>
</div>
<a id="a336eaa1f1417cbe1468e56b34ce866a1" name="a336eaa1f1417cbe1468e56b34ce866a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336eaa1f1417cbe1468e56b34ce866a1">&#9670;&#160;</a></span>isBytecode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::isBytecode </td>
          <td>(</td>
          <td class="paramtype">llvm::MemoryBufferRef</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given buffer starts with the magic bytes that signal MLIR bytecode. </p>

<p class="definition">Definition at line <a class="el" href="BytecodeReader_8cpp_source.html#l02807">2807</a> of file <a class="el" href="BytecodeReader_8cpp_source.html">BytecodeReader.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="BytecodeReader_8cpp_source.html#l02815">readBytecodeFileImpl()</a>.</p>

</div>
</div>
<a id="a0dfea8ee2dd0eba944b0cd299591ccf9" name="a0dfea8ee2dd0eba944b0cd299591ccf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dfea8ee2dd0eba944b0cd299591ccf9">&#9670;&#160;</a></span>isColumnMajorMatmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::isColumnMajorMatmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a></td>          <td class="paramname"><span class="paramname"><em>indexingMaps</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether the given maps describe a column major matmul. </p>
<p>The test is permutation-invariant. Note that this only checks the affine maps from an operation, so does not perform any checks on the math being performed within the reduction. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00046">46</a> of file <a class="el" href="StructuredOpsUtils_8cpp_source.html">StructuredOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>.</p>

</div>
</div>
<a id="a043789541ff1881513700b717bf5491d" name="a043789541ff1881513700b717bf5491d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043789541ff1881513700b717bf5491d">&#9670;&#160;</a></span>isConstantIntValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::isConstantIntValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>ofr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if <span class="tt">ofr</span> is constant integer equal to <span class="tt">value</span>. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00155">155</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">getConstantIntValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="StaticValueUtils_8cpp_source.html#l00159">areAllConstantIntValue()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00155">checkTileSizes()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00726">createInitialTensorsForTiling()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00210">getSanitizedReductionDims()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00022">isOneInteger()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00020">isZeroInteger()</a>.</p>

</div>
</div>
<a id="a2ee77c6f0feb82212b1b817785f95f48" name="a2ee77c6f0feb82212b1b817785f95f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee77c6f0feb82212b1b817785f95f48">&#9670;&#160;</a></span>isEqualConstantIntOrValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::isEqualConstantIntOrValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>ofr1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>ofr2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if ofr1 and ofr2 are the same integer constant attribute values or the same SSA value. </p>
<p>Ignore integer bitwitdh and type mismatch that come from the fact there is no IndexAttr and that IndexType have no bitwidth.</p>
<p>Ignore integer bitwidth and type mismatch that come from the fact there is no IndexAttr and that IndexType has no bitwidth. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00176">176</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">getConstantIntValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html#l00070">mlir::bufferization::Ownership::getCombined()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00532">getSlicedDimensions()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l05557">mlir::linalg::haveSameTiles()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00185">isEqualConstantIntOrValueArray()</a>.</p>

</div>
</div>
<a id="ab03d63917414f04e985c804f24086b76" name="ab03d63917414f04e985c804f24086b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03d63917414f04e985c804f24086b76">&#9670;&#160;</a></span>isEqualConstantIntOrValueArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::isEqualConstantIntOrValueArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>ofrs1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>ofrs2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00185">185</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00176">isEqualConstantIntOrValue()</a>.</p>

</div>
</div>
<a id="a6cf90202d2d87692ea1b8d22068bffa7" name="a6cf90202d2d87692ea1b8d22068bffa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf90202d2d87692ea1b8d22068bffa7">&#9670;&#160;</a></span>isIdentityPermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::isIdentityPermutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>permutation</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <span class="tt">permutation</span> is an identity permutation. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00197">197</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgOps_8cpp_source.html#l05543">mlir::linalg::hasSameInnerOuterAttribute()</a>.</p>

</div>
</div>
<a id="af57575f33d64fcef5f5027164a59d87d" name="af57575f33d64fcef5f5027164a59d87d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af57575f33d64fcef5f5027164a59d87d">&#9670;&#160;</a></span>isLegalForBranchOpInterfaceTypeConversionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::isLegalForBranchOpInterfaceTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if op is a BranchOpInterface op whose operands are all legal according to converter. </p>

<p class="definition">Definition at line <a class="el" href="FuncConversions_8cpp_source.html#l00148">148</a> of file <a class="el" href="FuncConversions_8cpp_source.html">FuncConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, and <a class="el" href="Block_8cpp_source.html#l00265">mlir::Block::getNumSuccessors()</a>.</p>

</div>
</div>
<a id="a0a4d325aad6186114a919156b25b29bc" name="a0a4d325aad6186114a919156b25b29bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4d325aad6186114a919156b25b29bc">&#9670;&#160;</a></span>isLegalForReturnOpTypeConversionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::isLegalForReturnOpTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>returnOpAlwaysLegal</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For ReturnLike ops (except <span class="tt">return</span>), return True. </p>
<p>If op is a <span class="tt">return</span> &amp;&amp; returnOpAlwaysLegal is false, legalize op according to converter. Otherwise, return false. </p>

<p class="definition">Definition at line <a class="el" href="FuncConversions_8cpp_source.html#l00171">171</a> of file <a class="el" href="FuncConversions_8cpp_source.html">FuncConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00749">mlir::Operation::hasTrait()</a>.</p>

</div>
</div>
<a id="a50aeecdfac818acb74f464b9f19a030e" name="a50aeecdfac818acb74f464b9f19a030e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50aeecdfac818acb74f464b9f19a030e">&#9670;&#160;</a></span>isMatvec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::isMatvec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a></td>          <td class="paramname"><span class="paramname"><em>indexingMaps</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether the given maps describe a matrix vector multiplication. </p>
<p>The test is permutation-invariant. Note that this only checks the affine maps from an operation, so does not perform any checks on the math being performed within the reduction. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00148">148</a> of file <a class="el" href="StructuredOpsUtils_8cpp_source.html">StructuredOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>.</p>

</div>
</div>
<a id="a5799849a369b839d27241c96a9572de7" name="a5799849a369b839d27241c96a9572de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5799849a369b839d27241c96a9572de7">&#9670;&#160;</a></span>isMemoryEffectFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::isMemoryEffectFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given operation is free of memory effects. </p>
<p>An operation is free of memory effects if its implementation of <span class="tt">MemoryEffectOpInterface</span> indicates that it has no memory effects. For example, it may implement <span class="tt">NoMemoryEffect</span> in ODS. Alternatively, if the operation has the <span class="tt">HasRecursiveMemoryEffects</span> trait, then it is free of memory effects if all of its nested operations are free of memory effects.</p>
<p>If the operation has both, then it is free of memory effects if both conditions are satisfied. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00320">320</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00677">mlir::Operation::getRegions()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00749">mlir::Operation::hasTrait()</a>, and <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00320">isMemoryEffectFree()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Bufferize_8cpp_source.html#l00277">mlir::bufferization::bufferizeOp()</a>, <a class="el" href="VectorDistribute_8cpp_source.html#l02308">canBeHoisted()</a>, <a class="el" href="CFGToSCF_8cpp_source.html#l01226">checkTransformationPreconditions()</a>, <a class="el" href="AsyncRegionRewriter_8cpp_source.html#l00046">hasSideEffects()</a>, <a class="el" href="ParallelLoopFusion_8cpp_source.html#l00061">haveNoReadsAfterWriteExceptSameIndex()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01161">hoistOpsBetween()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00336">mlir::affine::MemRefDependenceGraph::init()</a>, <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00320">isMemoryEffectFree()</a>, <a class="el" href="AffineLoopInvariantCodeMotion_8cpp_source.html#l00063">isOpLoopInvariant()</a>, <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00403">isPure()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00290">matchReduction()</a>, <a class="el" href="ParallelLoopFusion_8cpp_source.html#l00235">mlir::scf::naivelyFuseParallelOps()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00164">noAliasingUseInLoop()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00306">replaceOpWithPredicatedOp()</a>, <a class="el" href="LivenessAnalysis_8cpp_source.html#l00118">mlir::dataflow::LivenessAnalysis::visitBranchOperand()</a>, and <a class="el" href="LivenessAnalysis_8cpp_source.html#l00080">mlir::dataflow::LivenessAnalysis::visitOperation()</a>.</p>

</div>
</div>
<a id="a625259a35e521a9f6d7b7fe115423e87" name="a625259a35e521a9f6d7b7fe115423e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a625259a35e521a9f6d7b7fe115423e87">&#9670;&#160;</a></span>isNotBranchOpInterfaceOrReturnLikeOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::isNotBranchOpInterfaceOrReturnLikeOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if op is neither BranchOpInterface nor ReturnLike. </p>
<p>TODO Try to get rid of this function and invert the meaning of <span class="tt">isLegalForBranchOpInterfaceTypeConversionPattern</span> and <span class="tt">isLegalForReturnOpTypeConversionPattern</span>. </p>

<p class="definition">Definition at line <a class="el" href="FuncConversions_8cpp_source.html#l00184">184</a> of file <a class="el" href="FuncConversions_8cpp_source.html">FuncConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00152">mlir::Block::back()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00757">mlir::Operation::mightHaveTrait()</a>.</p>

</div>
</div>
<a id="af0f2798d2b9db90ac8a8f2b7a0958327" name="af0f2798d2b9db90ac8a8f2b7a0958327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f2798d2b9db90ac8a8f2b7a0958327">&#9670;&#160;</a></span>isOneInteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::isOneInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if <span class="tt">v</span> is an IntegerAttr with value <span class="tt">1</span>. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00022">22</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00155">isConstantIntValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00774">denormalizeInductionVariable()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00749">denormalizeInductionVariableForIndexType()</a>, <a class="el" href="ReshapePatterns_8cpp_source.html#l00462">mlir::tensor::getCollapsedExtractSliceInfo()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l03815">normalizeForallLoopOp()</a>, <a class="el" href="SwapExtractSliceWithProducerPatterns_8cpp_source.html#l00025">mlir::tensor::replaceExtractSliceWithTiledProducer()</a>, <a class="el" href="SwapExtractSliceWithProducerPatterns_8cpp_source.html#l00061">mlir::tensor::replaceInsertSlicesWithTiledConsumer()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l02188">tileAndFuseConsumerOfSlicesImpl()</a>.</p>

</div>
</div>
<a id="a4bd6b581b08699ce79d3e9f820c1ade9" name="a4bd6b581b08699ce79d3e9f820c1ade9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd6b581b08699ce79d3e9f820c1ade9">&#9670;&#160;</a></span>isOpaqueTypeWithName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::isOpaqueTypeWithName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>dialect</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>typeData</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the specified type is an opaque type with the specified dialect and typeData. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00047">47</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

</div>
</div>
<a id="a8583719d6a8f0699c36ac4c4b53057f2" name="a8583719d6a8f0699c36ac4c4b53057f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8583719d6a8f0699c36ac4c4b53057f2">&#9670;&#160;</a></span>isOpTriviallyDead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::isOpTriviallyDead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the given operation is unused, and has no side effects on memory that prevent erasing. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00035">35</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00852">mlir::Operation::use_empty()</a>, and <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00312">wouldOpBeTriviallyDead()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2ArmSME_2IR_2Utils_8cpp_source.html#l00133">mlir::arm_sme::eraseTriviallyDeadTileOps()</a>.</p>

</div>
</div>
<a id="a02cbcfb8713e367c7f1866a83625edcf" name="a02cbcfb8713e367c7f1866a83625edcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02cbcfb8713e367c7f1866a83625edcf">&#9670;&#160;</a></span>isPerfectlyNestedForLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::isPerfectlyNestedForLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; LoopLikeOpInterface &gt;</td>          <td class="paramname"><span class="paramname"><em>loops</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the provided loops are perfectly nested for-loops. </p>
<p>Perfect nesting means:</p><ol type="1">
<li>All loops are scf.for operations</li>
<li>Each outer loop's region iter args match the inner loop's init args</li>
<li>Each outer loop's yields match the inner loop's results</li>
<li>Each region iter arg and result has exactly one use </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01524">1524</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l02050">getUntiledConsumerFromSlice()</a>.</p>

</div>
</div>
<a id="aeb49fb26d8c1e3dc571db7ff9e34cb7f" name="aeb49fb26d8c1e3dc571db7ff9e34cb7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb49fb26d8c1e3dc571db7ff9e34cb7f">&#9670;&#160;</a></span>isPermutationVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::isPermutationVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>interchange</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to check if an interchange vector is a permutation. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00204">204</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgOps_8cpp_source.html#l05189">mlir::linalg::commonPermutationOfPackAndUnPackOp()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00076">mlir::tensor::computeTransposedType()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00748">mlir::linalg::packMatmulGreedily()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00657">mlir::linalg::packTranspose()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00340">mlir::detail::TileOffsetRangeImpl::TileOffsetRangeImpl()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l00077">verifyOptions()</a>.</p>

</div>
</div>
<a id="a550cdaef652bf5d59dfe33a15dc81af5" name="a550cdaef652bf5d59dfe33a15dc81af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a550cdaef652bf5d59dfe33a15dc81af5">&#9670;&#160;</a></span>isPure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::isPure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given operation is pure, i.e., is speculatable that does not touch memory. </p>
<p>The implementation of this function replicates the <span class="tt">def Pure : TraitList</span> in <span class="tt">SideEffectInterfaces.td</span> and has to be kept in sync manually.</p>
<p>This function is the C++ equivalent of the <span class="tt">Pure</span> trait. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00403">403</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00320">isMemoryEffectFree()</a>, and <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00377">isSpeculatable()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2ArmSME_2IR_2Utils_8cpp_source.html#l00153">mlir::arm_sme::isTriviallyCloneableTileOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00457">mlir::affine::isValidSymbol()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l01145">moveValueDefinitions()</a>.</p>

</div>
</div>
<a id="ae209f096d9240a818927afbab10f43b8" name="ae209f096d9240a818927afbab10f43b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae209f096d9240a818927afbab10f43b8">&#9670;&#160;</a></span>isRankReducedType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a11353e6611651b85531ad95629c57d75">SliceVerificationResult</a> mlir::isRankReducedType </td>
          <td>(</td>
          <td class="paramtype">ShapedType</td>          <td class="paramname"><span class="paramname"><em>originalType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ShapedType</td>          <td class="paramname"><span class="paramname"><em>candidateReducedType</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if <span class="tt">originalType</span> can be rank reduced to <span class="tt">candidateReducedType</span> type by dropping some dimensions with static size <span class="tt">1</span>. </p>
<p>Return <span class="tt"><a class="el" href="#a11353e6611651b85531ad95629c57d75a505a83f220c02df2f85c3810cd9ceb38">SliceVerificationResult::Success</a></span> on success or an appropriate error code. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00490">490</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00456">computeRankReductionMask()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00360">ElemTypeMismatch</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00358">RankTooLarge</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00359">SizeMismatch</a>, and <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00357">Success</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00217">mlir::linalg::lowerPack()</a>, and <a class="el" href="TensorOps_8cpp_source.html#l02842">verifyInsertSliceOp()</a>.</p>

</div>
</div>
<a id="a9e3d6f94b6a941066c3e7e5535817a9b" name="a9e3d6f94b6a941066c3e7e5535817a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e3d6f94b6a941066c3e7e5535817a9b">&#9670;&#160;</a></span>isReassociationValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::isReassociationValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>reassociation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>invalidIndex</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the reassociation specification is valid, false otherwise. </p>
<p>When false, the <span class="tt">invalidIndex</span> integer pointer is optionally filled with the index of the offending reassociation map. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00460">460</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l01773">getCollapsedVecType()</a>.</p>

</div>
</div>
<a id="aa28d7afae3a8e6d54489b5857b938d07" name="aa28d7afae3a8e6d54489b5857b938d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa28d7afae3a8e6d54489b5857b938d07">&#9670;&#160;</a></span>isRowMajorBatchMatmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::isRowMajorBatchMatmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a></td>          <td class="paramname"><span class="paramname"><em>indexingMaps</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether the given maps describe a row major batch matmul. </p>
<p>The test is permutation-invariant. Note that this only checks the affine maps from an operation, so does not perform any checks on the math being performed within the reduction. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00072">72</a> of file <a class="el" href="StructuredOpsUtils_8cpp_source.html">StructuredOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>.</p>

</div>
</div>
<a id="ae53f9bcf99efe125a11237ad6b64642c" name="ae53f9bcf99efe125a11237ad6b64642c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53f9bcf99efe125a11237ad6b64642c">&#9670;&#160;</a></span>isRowMajorMatmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::isRowMajorMatmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a></td>          <td class="paramname"><span class="paramname"><em>indexingMaps</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether the given maps describe a row major matmul. </p>
<p>The test is permutation-invariant. Note that this only checks the affine maps from an operation, so does not perform any checks on the math being performed within the reduction. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00020">20</a> of file <a class="el" href="StructuredOpsUtils_8cpp_source.html">StructuredOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>.</p>

</div>
</div>
<a id="a7a2c465ce654633415e61167b64b8a91" name="a7a2c465ce654633415e61167b64b8a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2c465ce654633415e61167b64b8a91">&#9670;&#160;</a></span>isSpeculatable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::isSpeculatable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given operation is speculatable, i.e. </p>
<p>has no undefined behavior or other side effects.</p>
<p>An operation can indicate that it is speculatable by implementing the getSpeculatability hook in the ConditionallySpeculatable op interface. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00377">377</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00677">mlir::Operation::getRegions()</a>, <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00377">isSpeculatable()</a>, <a class="el" href="SideEffectInterfaces_8h_source.html#l00300">mlir::Speculation::NotSpeculatable</a>, <a class="el" href="SideEffectInterfaces_8h_source.html#l00302">mlir::Speculation::RecursivelySpeculatable</a>, and <a class="el" href="SideEffectInterfaces_8h_source.html#l00301">mlir::Speculation::Speculatable</a>.</p>

<p class="reference">Referenced by <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00403">isPure()</a>, and <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00377">isSpeculatable()</a>.</p>

</div>
</div>
<a id="afe7f79e5d443d52d8bd488719b15dc63" name="afe7f79e5d443d52d8bd488719b15dc63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe7f79e5d443d52d8bd488719b15dc63">&#9670;&#160;</a></span>isStrictFileLineColLoc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::isStrictFileLineColLoc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff the given location is a <a class="el" href="classFileLineColRange.html">FileLineColRange</a> with exactly one line and column. </p>

<p class="definition">Definition at line <a class="el" href="Location_8cpp_source.html#l00177">177</a> of file <a class="el" href="Location_8cpp_source.html">Location.cpp</a>.</p>

</div>
</div>
<a id="a1077d0bb73f4b48dfdff162ee992e116" name="a1077d0bb73f4b48dfdff162ee992e116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1077d0bb73f4b48dfdff162ee992e116">&#9670;&#160;</a></span>isValidVectorTypeElementType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::isValidVectorTypeElementType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">::mlir::Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00003">3</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

</div>
</div>
<a id="ac5fb321c11f8758094dbc4ece855d206" name="ac5fb321c11f8758094dbc4ece855d206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5fb321c11f8758094dbc4ece855d206">&#9670;&#160;</a></span>isVecmat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::isVecmat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a></td>          <td class="paramname"><span class="paramname"><em>indexingMaps</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether the given maps describe a vector matrix multiplication. </p>
<p>The test is permutation-invariant. Note that this only checks the affine maps from an operation, so does not perform any checks on the math being performed within the reduction. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00099">99</a> of file <a class="el" href="StructuredOpsUtils_8cpp_source.html">StructuredOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>.</p>

</div>
</div>
<a id="a87f260b5183e13d54bcf371961d8051b" name="a87f260b5183e13d54bcf371961d8051b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f260b5183e13d54bcf371961d8051b">&#9670;&#160;</a></span>isZeroInteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::isZeroInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if <span class="tt">v</span> is an IntegerAttr with value <span class="tt">0</span>. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00020">20</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00155">isConstantIntValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00088">mlir::tensor::bubbleUpPadSlice()</a>, <a class="el" href="Tiling_8cpp_source.html#l00362">calculateTileOffsetsAndSizes()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l05091">mlir::linalg::commonVerifierPackAndUnPackOp()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l02008">mlir::linalg::computeTileOffsets()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l02022">mlir::linalg::computeTileSizes()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00774">denormalizeInductionVariable()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00749">denormalizeInductionVariableForIndexType()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00687">generateLoopNest()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00557">generateLoopNestUsingForallOp()</a>, <a class="el" href="ReshapePatterns_8cpp_source.html#l00462">mlir::tensor::getCollapsedExtractSliceInfo()</a>, <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00714">getCollapsedIndices()</a>, <a class="el" href="PadTilingInterface_8cpp_source.html#l00037">getFullRankPaddingSizes()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00306">getLoopBounds()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00277">getTileOffsetAndSizes()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00474">getTileOffsetAndSizesWithForAllOp()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00101">getUserTileSizesAndNumThreads()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l03815">normalizeForallLoopOp()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00429">mlir::linalg::rewriteInDestinationPassingStyle()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00588">mlir::linalg::tileReductionUsingForall()</a>.</p>

</div>
</div>
<a id="a4bfe9337070eb0f67cb7a3098ee136ee" name="a4bfe9337070eb0f67cb7a3098ee136ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bfe9337070eb0f67cb7a3098ee136ee">&#9670;&#160;</a></span>JitRunnerMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mlir::JitRunnerMain </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>argc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1JitRunnerConfig.html">JitRunnerConfig</a></td>          <td class="paramname"><span class="paramname"><em>config</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry point for all CPU runners. </p>
<p>Expects the common argc/argv arguments for standard C++ main functions. The supplied dialect registry is expected to contain any registers that appear in the input IR, they will be loaded on-demand by the parser.</p>
<p>Expects the common argc/argv arguments for standard C++ main functions. </p>

<p class="definition">Definition at line <a class="el" href="JitRunner_8cpp_source.html#l00308">308</a> of file <a class="el" href="JitRunner_8cpp_source.html">JitRunner.cpp</a>.</p>

<p class="reference">References <a class="el" href="JitRunner_8cpp_source.html#l00274">compileAndExecuteSingleReturnFunction()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00222">compileAndExecuteVoidFunction()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00284">config</a>, <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00044">Error</a>, <a class="el" href="JitRunner_8cpp_source.html#l00163">getCommandLineOptLevel()</a>, <a class="el" href="#a159f88d87b78c353731e1661c65a0b98">makeOptimizingTransformer()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00158">makeStringError()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, and <a class="el" href="JitRunner_8cpp_source.html#l00134">parseMLIRInput()</a>.</p>

</div>
</div>
<a id="ac84b6a6dfd9d9eb78ca02c17cabbebed" name="ac84b6a6dfd9d9eb78ca02c17cabbebed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84b6a6dfd9d9eb78ca02c17cabbebed">&#9670;&#160;</a></span>linearize() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint64__t.html">int64_t</a> mlir::linearize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>offsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the linearized index of 'offsets' w.r.t. </p>
<p>'basis'.</p>
<p><span class="tt">basis</span> elements are asserted to be non-negative. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00090">90</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00045">linearizeImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l03434">calculateInsertPosition()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02115">foldDenseElementsAttrSrcExtractOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01815">foldExtractFromShapeCast()</a>, <a class="el" href="VectorOps_8cpp_source.html#l04292">foldExtractStridedSliceNonSplatConstant()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00163">linearize()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l02484">ToElementsOfBroadcast::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a3e83fe20fc8231df5769e1eebe268bdd" name="a3e83fe20fc8231df5769e1eebe268bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e83fe20fc8231df5769e1eebe268bdd">&#9670;&#160;</a></span>linearize() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::linearize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>offsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the linearized index of 'offsets' w.r.t. </p>
<p>'basis'.</p>
<p>Assuming <span class="tt">offsets</span> is <span class="tt">[o0, .. on]</span> and <span class="tt">basis</span> is <span class="tt">[b0, .. bn]</span>, return the <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> <span class="tt">o0 * b0 + .. + on * bn</span>.</p>
<p>It is the caller's responsibility to pass proper <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> kind that result in valid <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> (i.e. cannot multiply 2 <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a> or divide by an <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a>).</p>
<p><span class="tt">basis</span> elements are expected to bind to non-negative values. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00157">157</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="#ab26cdced424aa629fde4150cc8674d50">getAffineConstantExpr()</a>, and <a class="el" href="IndexingUtils_8cpp_source.html#l00045">linearizeImpl()</a>.</p>

</div>
</div>
<a id="a1c0b8417b72fde91ffbc7d792fc97121" name="a1c0b8417b72fde91ffbc7d792fc97121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0b8417b72fde91ffbc7d792fc97121">&#9670;&#160;</a></span>linearize() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::linearize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>offsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00163">163</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="#ace395202c24e4dc75013296cf46ed692">getAffineConstantExprs()</a>, and <a class="el" href="IndexingUtils_8cpp_source.html#l00090">linearize()</a>.</p>

</div>
</div>
<a id="a69fd85a25b107960e7f482b7ae177dfd" name="a69fd85a25b107960e7f482b7ae177dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69fd85a25b107960e7f482b7ae177dfd">&#9670;&#160;</a></span>LLVM_DEPRECATED()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::LLVM_DEPRECATED </td>
          <td>(</td>
          <td class="paramtype">&quot;Use <a class="el" href="#a66e5c50eb8b1daecc9b2ac2f97681685">applyOpPatternsGreedily</a>() instead&quot;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;applyOpPatternsGreedily&quot;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <span class="tt">applyOpPatternsGreedily</span> with folding. </p>
<p>FIXME: Remove this once transition to above is complieted. </p>

</div>
</div>
<a id="af912da94236cff04e9076f6e052676b1" name="af912da94236cff04e9076f6e052676b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af912da94236cff04e9076f6e052676b1">&#9670;&#160;</a></span>LLVM_ENABLE_BITMASK_ENUMS_IN_NAMESPACE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::LLVM_ENABLE_BITMASK_ENUMS_IN_NAMESPACE </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable Bitmask enums for <a class="el" href="structmlir_1_1OperationEquivalence.html#a292ebf6a0885a07fd4c94f9750587dfe">OperationEquivalence::Flags</a>. </p>

</div>
</div>
<a id="a7d85acf663c85ff9286024bd8ca84f1b" name="a7d85acf663c85ff9286024bd8ca84f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d85acf663c85ff9286024bd8ca84f1b">&#9670;&#160;</a></span>loopUnrollByFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1UnrolledLoopInfo.html">UnrolledLoopInfo</a> &gt; mlir::loopUnrollByFactor </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unrollFactor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>annotateFn</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls this for operation by the specified unroll factor. </p>
<p>Unrolls 'forOp' by 'unrollFactor', returns the unrolled main loop and the epilogue loop, if the loop is unrolled.</p>
<p>Returns the unrolled main loop and the epilogue loop, if the loop is unrolled. Otherwise returns failure if the loop cannot be unrolled either due to restrictions or due to invalid unroll factors. Requires positive loop bounds and step. If specified, annotates the Ops in each unrolled iteration by applying <span class="tt">annotateFn</span>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00367">367</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00265">ceilDivPositive()</a>, <a class="el" href="Builders_8cpp_source.html#l00562">mlir::OpBuilder::clone()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8h_source.html#l00116">mlir::UnrolledLoopInfo::epilogueLoopOp</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00294">generateUnrolledLoop()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">getConstantIntValue()</a>, <a class="el" href="Builders_8cpp_source.html#l00228">mlir::Builder::getIntegerAttr()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8h_source.html#l00115">mlir::UnrolledLoopInfo::mainLoopOp</a>, <a class="el" href="Builders_8h_source.html#l00412">mlir::OpBuilder::setInsertionPointAfter()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02103">ValueRange</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00495">loopUnrollFull()</a>.</p>

</div>
</div>
<a id="a4fc247600aa65daf2fd099cb63a5bcee" name="a4fc247600aa65daf2fd099cb63a5bcee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc247600aa65daf2fd099cb63a5bcee">&#9670;&#160;</a></span>loopUnrollFull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::loopUnrollFull </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls this loop completely. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00495">495</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00367">loopUnrollByFactor()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a7f0b0e4e1d0aa48d157009f2f9530492" name="a7f0b0e4e1d0aa48d157009f2f9530492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f0b0e4e1d0aa48d157009f2f9530492">&#9670;&#160;</a></span>loopUnrollJamByFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::loopUnrollJamByFactor </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unrollFactor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls and jams this <span class="tt">scf.for</span> operation by the specified unroll factor. </p>
<p>Unrolls and jams this loop by the specified factor.</p>
<p>Returns failure if the loop cannot be unrolled either due to restrictions or due to invalid unroll factors. In case of unroll factor of 1, the function bails out without doing anything (returns success). Currently, only constant trip count that are divided by the unroll factor is supported. Currently, for operations with results are not supported. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00523">523</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00510">areInnerBoundsInvariant()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="Builders_8cpp_source.html#l00562">mlir::OpBuilder::clone()</a>, <a class="el" href="Builders_8h_source.html#l00526">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Builders_8h_source.html#l00398">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="LoopLikeInterface_8h_source.html#l00058">mlir::JamBlockGatherer&lt; OpTy &gt;::subBlocks</a>, <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, and <a class="el" href="LoopLikeInterface_8h_source.html#l00061">mlir::JamBlockGatherer&lt; OpTy &gt;::walk()</a>.</p>

</div>
</div>
<a id="af4cd463c8738400fd147e2f040e89948" name="af4cd463c8738400fd147e2f040e89948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4cd463c8738400fd147e2f040e89948">&#9670;&#160;</a></span>lowerAffineLowerBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::lowerAffineLowerBound </td>
          <td>(</td>
          <td class="paramtype">affine::AffineForOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit code that computes the lower bound of the given affine loop using standard arithmetic operations. </p>

<p class="reference">Referenced by <a class="el" href="SCFToGPU_8cpp_source.html#l00093">getOrEmitLowerBound()</a>.</p>

</div>
</div>
<a id="a59b670d3c5d9075cd52ef9d183168708" name="a59b670d3c5d9075cd52ef9d183168708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b670d3c5d9075cd52ef9d183168708">&#9670;&#160;</a></span>lowerAffineUpperBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::lowerAffineUpperBound </td>
          <td>(</td>
          <td class="paramtype">affine::AffineForOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit code that computes the upper bound of the given affine loop using standard arithmetic operations. </p>

<p class="reference">Referenced by <a class="el" href="SCFToGPU_8cpp_source.html#l00099">getOrEmitUpperBound()</a>.</p>

</div>
</div>
<a id="a8ea33aa665368d4f2108eb2d41c85111" name="a8ea33aa665368d4f2108eb2d41c85111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea33aa665368d4f2108eb2d41c85111">&#9670;&#160;</a></span>m_AnyZeroFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a> mlir::m_AnyZeroFloat </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat float (both positive and negative) zero. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00399">399</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="FoldAddIntoDest_8cpp_source.html#l00018">isDefinedAsZero()</a>, <a class="el" href="SparseTensorRewriting_8cpp_source.html#l00043">isZeroValue()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02155">ReduceRedundantZero::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a18d87ea3290be975b746704e58465017" name="a18d87ea3290be975b746704e58465017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d87ea3290be975b746704e58465017">&#9670;&#160;</a></span>m_Attr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1AttrOpMatcher.html">detail::AttrOpMatcher</a> mlir::m_Attr </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>attrName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a named attribute operation. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00374">374</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a51586639ab172c46df53c0c718cb6fbc" name="a51586639ab172c46df53c0c718cb6fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51586639ab172c46df53c0c718cb6fbc">&#9670;&#160;</a></span>m_Attr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AttrT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1AttrOpBinder.html">detail::AttrOpBinder</a>&lt; AttrT &gt; mlir::m_Attr </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>attrName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AttrT *</td>          <td class="paramname"><span class="paramname"><em>bindValue</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a named attribute operation and writes the value to bind_value. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00392">392</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="ad402a86ee4c9000c6fa1fceaddab560b" name="ad402a86ee4c9000c6fa1fceaddab560b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad402a86ee4c9000c6fa1fceaddab560b">&#9670;&#160;</a></span>m_Constant() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__op__matcher.html">detail::constant_op_matcher</a> mlir::m_Constant </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant foldable operation. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00369">369</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LocalAliasAnalysis_8cpp_source.html#l00342">mlir::LocalAliasAnalysis::aliasImpl()</a>, <a class="el" href="IndexOps_8cpp_source.html#l00125">canonicalizeAssociativeCommutativeBinaryOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01682">canonicalizeMapOrSetAndOperands()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00042">checkMatchingPadConstAndZp()</a>, <a class="el" href="Math_2Transforms_2ExpandOps_8cpp_source.html#l00255">convertFPowIOp()</a>, <a class="el" href="XeGPUTransformOps_8cpp_source.html#l00027">convertMixedValuesToInt()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00082">createLinalgBodyCalculationForElementwiseOp()</a>, <a class="el" href="InlinerInterfaceImpl_8cpp_source.html#l00271">createNewAliasScopesFromNoAliasParameter()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00657">mlir::Operation::fold()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00395">foldDynamicIndexList()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02558">foldLoopBounds()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00081">getAsOpFoldResult()</a>, <a class="el" href="MemRefMemorySlot_8cpp_source.html#l00181">getAttributeIndexFromIndexOperands()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l01004">getBroadcastableOperands()</a>, <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00049">mlir::shape::getShapeVec()</a>, <a class="el" href="ControlFlowSinkUtils_8cpp_source.html#l00140">getSinglyExecutedRegionsToSink()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00200">mlir::ValueShapeRange::getValueAsShape()</a>, <a class="el" href="TosaOps_8cpp_source.html#l02601">getZeroPoint()</a>, <a class="el" href="InlinerInterfaceImpl_8cpp_source.html#l00056">handleInlinedAllocas()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00113">mlir::OperationFolder::insertKnownConstant()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00506">isDefinedOutsideOrConstant()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00075">isLikelyAnIndexComputation()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00207">isSplatWriteConsistentWithMaskedRead()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00457">mlir::affine::isValidSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01469">mlir::affine::makeComposedFoldedAffineApply()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01540">makeComposedFoldedMinMax()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01510">mlir::linalg::makeComposedPadHighOp()</a>, <a class="el" href="ArithOps_8cpp_source.html#l02176">CmpFIntToFPConst::matchAndRewrite()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00636">ConcatSliceOptimization::matchAndRewrite()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00133">IAddCarryFold::matchAndRewrite()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00213">MulExtendedFold&lt; spirv::SMulExtendedOp, true &gt;::matchAndRewrite()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00704">PadSliceOptimization::matchAndRewrite()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00842">SliceDynamicSizeCanonicalization::matchAndRewrite()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00331">UModSimplification::matchAndRewrite()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l02002">mlir::LLVM::ModuleImport::matchFloatAttr()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01992">mlir::LLVM::ModuleImport::matchIntegerAttr()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00051">materializeConstant()</a>, <a class="el" href="LLVMMemorySlot_8cpp_source.html#l01050">memsetGetStored()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00093">movePaddingToFillOrGenericOp()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00176">mlir::OperationFolder::notifyRemoval()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00172">reifyMixedParamAndHandleResults()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00062">remainsLegalAfterInline()</a>, and <a class="el" href="LoopEmitter_8cpp_source.html#l00091">tryFoldTensors()</a>.</p>

</div>
</div>
<a id="a1eb2469cde2027cb17828303ca629518" name="a1eb2469cde2027cb17828303ca629518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb2469cde2027cb17828303ca629518">&#9670;&#160;</a></span>m_Constant() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AttrT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__op__binder.html">detail::constant_op_binder</a>&lt; AttrT &gt; mlir::m_Constant </td>
          <td>(</td>
          <td class="paramtype">AttrT *</td>          <td class="paramname"><span class="paramname"><em>bind_value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a value from a constant foldable operation and writes the value to bind_value. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00386">386</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="aefeea9b182f6e6e1a267b0bd157e7970" name="aefeea9b182f6e6e1a267b0bd157e7970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefeea9b182f6e6e1a267b0bd157e7970">&#9670;&#160;</a></span>m_ConstantFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__float__value__binder.html">detail::constant_float_value_binder</a> mlir::m_ConstantFloat </td>
          <td>(</td>
          <td class="paramtype">FloatAttr::ValueType *</td>          <td class="paramname"><span class="paramname"><em>bind_value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant holding a scalar/vector/tensor float (splat) and writes the float value to bind_value. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00520">520</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Math_2Transforms_2ExpandOps_8cpp_source.html#l00326">convertPowfOp()</a>.</p>

</div>
</div>
<a id="a091c0686ba6d6f3ad4af9db1aea8063f" name="a091c0686ba6d6f3ad4af9db1aea8063f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a091c0686ba6d6f3ad4af9db1aea8063f">&#9670;&#160;</a></span>m_ConstantInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__int__value__binder.html">detail::constant_int_value_binder</a> mlir::m_ConstantInt </td>
          <td>(</td>
          <td class="paramtype">IntegerAttr::ValueType *</td>          <td class="paramname"><span class="paramname"><em>bind_value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant holding a scalar/vector/tensor integer (splat) and writes the integer value to bind_value. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00527">527</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Promotion_8cpp_source.html#l00436">allocateSubviewGPUMemoryInAddressSpace()</a>, <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00115">mlir::scf::computeUbMinusLb()</a>, <a class="el" href="Math_2Transforms_2ExpandOps_8cpp_source.html#l00255">convertFPowIOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00660">destructureIndices()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00118">getConstantAPIntValue()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00064">getConstantIntValue()</a>, <a class="el" href="AMDGPUDialect_8cpp_source.html#l00248">getConstantUint32()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00141">getIntOrSplatIntValue()</a>, <a class="el" href="GPU_2IR_2InferIntRangeInterfaceImpls_8cpp_source.html#l00086">getKnownLaunchDim()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01613">isMaskTriviallyFoldable()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00157">maybeConstantDimsAttr()</a>, and <a class="el" href="ControlFlow_2IR_2ControlFlowOps_8cpp_source.html#l00747">simplifyConstSwitchValue()</a>.</p>

</div>
</div>
<a id="a4136ce33972b8eb3801f4c304f53acae" name="a4136ce33972b8eb3801f4c304f53acae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4136ce33972b8eb3801f4c304f53acae">&#9670;&#160;</a></span>m_IntRangeWithoutNegOneS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__int__range__predicate__matcher.html">detail::constant_int_range_predicate_matcher</a> mlir::m_IntRangeWithoutNegOneS </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat integer or a signed integer range that does not contain minus one. </p>
<p>Note that this matcher interprets the target value as a signed integer. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00471">471</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArithOps_8cpp_source.html#l00753">getDivSISpeculatability()</a>.</p>

</div>
</div>
<a id="ab744f07f6776a02e49c0851786db161a" name="ab744f07f6776a02e49c0851786db161a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab744f07f6776a02e49c0851786db161a">&#9670;&#160;</a></span>m_IntRangeWithoutZeroS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__int__range__predicate__matcher.html">detail::constant_int_range_predicate_matcher</a> mlir::m_IntRangeWithoutZeroS </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat integer or a signed integer range that does not contain zero. </p>
<p>Note that this matcher interprets the target value as a signed integer. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00462">462</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArithOps_8cpp_source.html#l00753">getDivSISpeculatability()</a>.</p>

</div>
</div>
<a id="afbe6d87f8ecb162173628bc66674ba72" name="afbe6d87f8ecb162173628bc66674ba72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe6d87f8ecb162173628bc66674ba72">&#9670;&#160;</a></span>m_IntRangeWithoutZeroU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__int__range__predicate__matcher.html">detail::constant_int_range_predicate_matcher</a> mlir::m_IntRangeWithoutZeroU </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat integer or a unsigned integer range that does not contain zero. </p>
<p>Note that this matcher interprets the target value as an unsigned integer. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00455">455</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArithOps_8cpp_source.html#l00711">getDivUISpeculatability()</a>.</p>

</div>
</div>
<a id="a17093f5e4f75a743e4cf9ac9af43a506" name="a17093f5e4f75a743e4cf9ac9af43a506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17093f5e4f75a743e4cf9ac9af43a506">&#9670;&#160;</a></span>m_NaNFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a> mlir::m_NaNFloat </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat float ones. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00421">421</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a9e89b015211525b010832d2d2c37650b" name="a9e89b015211525b010832d2d2c37650b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e89b015211525b010832d2d2c37650b">&#9670;&#160;</a></span>m_NegInfFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a> mlir::m_NegInfFloat </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat float negative infinity. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00435">435</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="aa9eba8d1292854c0da6c062988ecac9b" name="aa9eba8d1292854c0da6c062988ecac9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9eba8d1292854c0da6c062988ecac9b">&#9670;&#160;</a></span>m_NegZeroFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a> mlir::m_NegZeroFloat </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat float negative zero. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00409">409</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a94bb42600b9be680591776fdc14a53cd" name="a94bb42600b9be680591776fdc14a53cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94bb42600b9be680591776fdc14a53cd">&#9670;&#160;</a></span>m_NonZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html">detail::constant_int_predicate_matcher</a> mlir::m_NonZero </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat integer that is any non-zero value. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00448">448</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a907f415a4c803b15ef57db37cc732f39" name="a907f415a4c803b15ef57db37cc732f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a907f415a4c803b15ef57db37cc732f39">&#9670;&#160;</a></span>m_One()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html">detail::constant_int_predicate_matcher</a> mlir::m_One </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat integer one. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00478">478</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="GPUDialect_8cpp_source.html#l01182">FoldLaunchArguments::matchAndRewrite()</a>, <a class="el" href="ArithOps_8cpp_source.html#l02443">SelectToExtUI::matchAndRewrite()</a>, and <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00289">UMulExtendedOpXOne::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="af0495d84f34cf3238a7741fa6974a485" name="af0495d84f34cf3238a7741fa6974a485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0495d84f34cf3238a7741fa6974a485">&#9670;&#160;</a></span>m_OneFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a> mlir::m_OneFloat </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat float ones. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00414">414</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="acc77c58bbea63e3a122e37a2a608ae92" name="acc77c58bbea63e3a122e37a2a608ae92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc77c58bbea63e3a122e37a2a608ae92">&#9670;&#160;</a></span>m_Op() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpClass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1op__matcher.html">detail::op_matcher</a>&lt; OpClass &gt; mlir::m_Op </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches the given OpClass. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00484">484</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00093">mlir::linalg::RegionMatcher::matchAsScalarBinaryOp()</a>.</p>

</div>
</div>
<a id="a7ecde76b07cd295bae0d6ef10d1c45d8" name="a7ecde76b07cd295bae0d6ef10d1c45d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ecde76b07cd295bae0d6ef10d1c45d8">&#9670;&#160;</a></span>m_Op() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpType, typename... Matchers&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::m_Op </td>
          <td>(</td>
          <td class="paramtype">Matchers...</td>          <td class="paramname"><span class="paramname"><em>matchers</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00532">532</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a69b52f968271c9a4da1bc766ee083a9c" name="a69b52f968271c9a4da1bc766ee083a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b52f968271c9a4da1bc766ee083a9c">&#9670;&#160;</a></span>m_Op() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1NameOpMatcher.html">detail::NameOpMatcher</a> mlir::m_Op </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>opName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a named operation. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00379">379</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00093">mlir::linalg::RegionMatcher::matchAsScalarBinaryOp()</a>, and <a class="el" href="LoopEmitter_8cpp_source.html#l00091">tryFoldTensors()</a>.</p>

</div>
</div>
<a id="adc93dfeaa35bda23b16591c462c335f6" name="adc93dfeaa35bda23b16591c462c335f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc93dfeaa35bda23b16591c462c335f6">&#9670;&#160;</a></span>m_PosInfFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a> mlir::m_PosInfFloat </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat float positive infinity. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00427">427</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a774a1ae971f4ef00eb57389293dfe617" name="a774a1ae971f4ef00eb57389293dfe617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774a1ae971f4ef00eb57389293dfe617">&#9670;&#160;</a></span>m_PosZeroFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a> mlir::m_PosZeroFloat </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat float positive zero. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00404">404</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a7f5d8af15bd8994b1a7abeaaacfe1b06" name="a7f5d8af15bd8994b1a7abeaaacfe1b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5d8af15bd8994b1a7abeaaacfe1b06">&#9670;&#160;</a></span>m_Zero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html">detail::constant_int_predicate_matcher</a> mlir::m_Zero </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat integer zero. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00442">442</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="FoldAddIntoDest_8cpp_source.html#l00018">isDefinedAsZero()</a>, <a class="el" href="SparseTensorRewriting_8cpp_source.html#l00043">isZeroValue()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00133">IAddCarryFold::matchAndRewrite()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00213">MulExtendedFold&lt; spirv::SMulExtendedOp, true &gt;::matchAndRewrite()</a>, and <a class="el" href="ArithOps_8cpp_source.html#l02443">SelectToExtUI::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="ac603376cc0dac0b2bd27c2dcde3c2e14" name="ac603376cc0dac0b2bd27c2dcde3c2e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac603376cc0dac0b2bd27c2dcde3c2e14">&#9670;&#160;</a></span>makeCanonicalStridedLayoutExpr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::makeCanonicalStridedLayoutExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>exprs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given MemRef <span class="tt">sizes</span> that are either static or dynamic, returns the canonical "contiguous" strides <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a>. </p>
<p>Strides are multiplicative and once a dynamic dimension is encountered, all canonical strides become dynamic and need to be encoded with a different symbol. For canonical strides expressions, the offset is always 0 and the fastest varying stride is always <span class="tt">1</span>.</p>
<p>Examples:</p><ul>
<li><a class="el" href="namespacemlir_1_1memref.html">memref&lt;3x4x5xf32&gt;</a> has canonical stride expression <span class="tt">20*exprs[0] + 5*exprs[1] + exprs[2]</span>.</li>
<li>memref&lt;3x?x5xf32&gt; has canonical stride expression <span class="tt">s0*exprs[0] + 5*exprs[1] + exprs[2]</span>.</li>
<li>memref&lt;3x4x?xf32&gt; has canonical stride expression <span class="tt">s1*exprs[0] + s0*exprs[1] + exprs[2]</span>. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00855">855</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="#ab26cdced424aa629fde4150cc8674d50">getAffineConstantExpr()</a>, <a class="el" href="#aefb7ba5a55b4f16631528884d3617a47">getAffineSymbolExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00308">mlir::AffineMap::inferFromExprList()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01612">simplifyAffineExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BuiltinAttributeInterfaces_8cpp_source.html#l00161">getStridesAndOffset()</a>, and <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00887">makeCanonicalStridedLayoutExpr()</a>.</p>

</div>
</div>
<a id="ad25cd8672ecb721d7a4f0ecd22bac6e8" name="ad25cd8672ecb721d7a4f0ecd22bac6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad25cd8672ecb721d7a4f0ecd22bac6e8">&#9670;&#160;</a></span>makeCanonicalStridedLayoutExpr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::makeCanonicalStridedLayoutExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the result of makeCanonicalStrudedLayoutExpr for the common case where <span class="tt">exprs</span> is {d0, d1, .., d_(sizes.size()-1)}. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00887">887</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="#addfd4323ef72147332661606b030d04d">getAffineDimExpr()</a>, and <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00855">makeCanonicalStridedLayoutExpr()</a>.</p>

</div>
</div>
<a id="a159f88d87b78c353731e1661c65a0b98" name="a159f88d87b78c353731e1661c65a0b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a159f88d87b78c353731e1661c65a0b98">&#9670;&#160;</a></span>makeOptimizingTransformer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; llvm::Error(llvm::Module *)&gt; mlir::makeOptimizingTransformer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>optLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>sizeLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::TargetMachine *</td>          <td class="paramname"><span class="paramname"><em>targetMachine</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a module transformer function for MLIR <a class="el" href="classmlir_1_1ExecutionEngine.html" title="JIT-backed execution engine for MLIR.">ExecutionEngine</a> that runs <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR passes corresponding to the given speed and size optimization levels (e.g. </p>
<p>-O2 or -Os). If not null, <span class="tt">targetMachine</span> is used to initialize passes that provide target-specific information to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> optimizer. <span class="tt">targetMachine</span> must outlive the returned std::function. </p>

<p class="reference">Referenced by <a class="el" href="JitRunner_8cpp_source.html#l00308">JitRunnerMain()</a>, <a class="el" href="CAPI_2ExecutionEngine_2ExecutionEngine_8cpp_source.html#l00023">mlirExecutionEngineCreate()</a>, and <a class="el" href="ModuleToObject_8cpp_source.html#l00179">mlir::LLVM::ModuleToObject::optimizeModule()</a>.</p>

</div>
</div>
<a id="a7d806144c2d33e56f341109c75c3d277" name="a7d806144c2d33e56f341109c75c3d277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d806144c2d33e56f341109c75c3d277">&#9670;&#160;</a></span>makeRegionIsolatedFromAbove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::makeRegionIsolatedFromAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>region</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td>          <td class="paramname"><span class="paramname"><em>cloneOperationIntoRegion</em></span><span class="paramdefsep"> = </span><span class="paramdefval">[](<a class="el" href="classmlir_1_1Operation.html">Operation</a>&#160;*)&#160;{&#160;return&#160;<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>;&#160;}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a region isolated from above. </p>
<ul>
<li>Capture the values that are defined above the region and used within it.</li>
<li>Append to the entry block arguments that represent the captured values (one per captured value).</li>
<li>Replace all uses within the region of the captured values with the newly added arguments.</li>
<li><span class="tt">cloneOperationIntoRegion</span> is a callback that allows caller to specify if the operation defining an <span class="tt"><a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a></span> needs to be cloned into the region. Then the operands of this operation become part of the captured values set (unless the operations that define the operands themeselves are to be cloned). The cloned operations are added to the entry block of the region. Return the set of captured values for the operation. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00087">87</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="IR_2Region_8h_source.html#l00055">mlir::Region::begin()</a>, <a class="el" href="Builders_8cpp_source.html#l00562">mlir::OpBuilder::clone()</a>, <a class="el" href="TopologicalSortUtils_8cpp_source.html#l00107">computeTopologicalSorting()</a>, <a class="el" href="Builders_8cpp_source.html#l00430">mlir::OpBuilder::createBlock()</a>, <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="Block_8h_source.html#l00087">mlir::Block::getArguments()</a>, <a class="el" href="Block_8cpp_source.html#l00149">mlir::Block::getArgumentTypes()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="Block_8h_source.html#l00128">mlir::Block::getNumArguments()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00378">mlir::Operation::getOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00415">mlir::Operation::getResults()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00070">getUsedValuesDefinedAbove()</a>, <a class="el" href="IRMapping_8h_source.html#l00030">mlir::IRMapping::map()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00343">mlir::RewriterBase::mergeBlocks()</a>, <a class="el" href="PatternMatch_8h_source.html#l00687">mlir::RewriterBase::replaceOpUsesWithIf()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00261">mlir::RewriterBase::replaceUsesWithIf()</a>, and <a class="el" href="Builders_8h_source.html#l00431">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

</div>
</div>
<a id="a4df3b51e6123c8ab9fb3809ba255e00b" name="a4df3b51e6123c8ab9fb3809ba255e00b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df3b51e6123c8ab9fb3809ba255e00b">&#9670;&#160;</a></span>makeReproducer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mlir::makeReproducer </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>anchorName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1iterator__range.html">llvm::iterator_range</a>&lt; <a class="el" href="classmlir_1_1OpPassManager.html#a837570fd9379798502631e59734ae30e">OpPassManager::pass_iterator</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>passes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>outputFile</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>disableThreads</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>verifyPasses</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PassCrashRecovery_8cpp_source.html#l00451">451</a> of file <a class="el" href="PassCrashRecovery_8cpp_source.html">PassCrashRecovery.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassCrashRecovery_8cpp_source.html#l00107">appendReproducer()</a>, <a class="el" href="PassCrashRecovery_8cpp_source.html#l00431">makeReproducerStreamFactory()</a>, and <a class="el" href="Pass_2Pass_8cpp_source.html#l00422">printAsTextualPipeline()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00496">performActions()</a>.</p>

</div>
</div>
<a id="a923fafcbdcfdcb3b735fab2ab293a1ad" name="a923fafcbdcfdcb3b735fab2ab293a1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923fafcbdcfdcb3b735fab2ab293a1ad">&#9670;&#160;</a></span>makeStridedLinearLayoutMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::makeStridedLinearLayoutMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a list of strides (in which ShapedType::kDynamic represents a dynamic value), return the single result <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> which represents the linearized strided layout map. </p>
<p>Dimensions correspond to the offset followed by the strides in order. Symbols are inserted for each dynamic dimension in order. A stride is always positive.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md32"></a>
Examples:</h1>
<ol type="1">
<li>For offset: 0 strides: ?, ?, 1 return (i, j, k)[M, N]-&gt;(M * i + N * j + k)</li>
<li>For offset: 3 strides: 32, ?, 16 return (i, j, k)[M]-&gt;(3 + 32 * i + M * j + 16 * k)</li>
<li>For offset: ? strides: ?, ?, ? return (i, j, k)[off, M, N, P]-&gt;(off + M * i + N * j + P * k) </li>
</ol>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01808">1808</a> of file <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="#ab26cdced424aa629fde4150cc8674d50">getAffineConstantExpr()</a>, <a class="el" href="#addfd4323ef72147332661606b030d04d">getAffineDimExpr()</a>, and <a class="el" href="#aefb7ba5a55b4f16631528884d3617a47">getAffineSymbolExpr()</a>.</p>

</div>
</div>
<a id="ac7736bcb70dbd9f242cd5182dd443031" name="ac7736bcb70dbd9f242cd5182dd443031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7736bcb70dbd9f242cd5182dd443031">&#9670;&#160;</a></span>matchConstantIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1op__matcher.html">detail::op_matcher</a>&lt; <a class="el" href="classmlir_1_1arith_1_1ConstantIndexOp.html">arith::ConstantIndexOp</a> &gt; mlir::matchConstantIndex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a ConstantIndexOp. </p>
<p>TODO: This should probably just be a general matcher that uses matchConstant and checks the operation for an index type. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00086">86</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<a id="a77883d2221f5bdf428d745d778f90d49" name="a77883d2221f5bdf428d745d778f90d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77883d2221f5bdf428d745d778f90d49">&#9670;&#160;</a></span>matchPattern() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classmlir_1_1Pattern.html">Pattern</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::matchPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td>          <td class="paramname"><span class="paramname"><em>attr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Pattern.html">Pattern</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Entry point for matching a pattern over an <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>. </p>
<p>Returns <span class="tt">false</span> when <span class="tt">attr</span> is null. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00508">508</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a1b97d57dcd6c08b495fbd3ef22aeda6f" name="a1b97d57dcd6c08b495fbd3ef22aeda6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b97d57dcd6c08b495fbd3ef22aeda6f">&#9670;&#160;</a></span>matchPattern() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classmlir_1_1Pattern.html">Pattern</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::matchPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Pattern.html">Pattern</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Entry point for matching a pattern over an <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00500">500</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a0190228b09e7b51a4bc1e013c01d404c" name="a0190228b09e7b51a4bc1e013c01d404c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0190228b09e7b51a4bc1e013c01d404c">&#9670;&#160;</a></span>matchPattern() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classmlir_1_1Pattern.html">Pattern</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::matchPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Pattern.html">Pattern</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Entry point for matching a pattern over a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00490">490</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LocalAliasAnalysis_8cpp_source.html#l00342">mlir::LocalAliasAnalysis::aliasImpl()</a>, <a class="el" href="Promotion_8cpp_source.html#l00436">allocateSubviewGPUMemoryInAddressSpace()</a>, <a class="el" href="IndexOps_8cpp_source.html#l00125">canonicalizeAssociativeCommutativeBinaryOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01682">canonicalizeMapOrSetAndOperands()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00042">checkMatchingPadConstAndZp()</a>, <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00115">mlir::scf::computeUbMinusLb()</a>, <a class="el" href="Math_2Transforms_2ExpandOps_8cpp_source.html#l00255">convertFPowIOp()</a>, <a class="el" href="XeGPUTransformOps_8cpp_source.html#l00027">convertMixedValuesToInt()</a>, <a class="el" href="Math_2Transforms_2ExpandOps_8cpp_source.html#l00326">convertPowfOp()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00082">createLinalgBodyCalculationForElementwiseOp()</a>, <a class="el" href="InlinerInterfaceImpl_8cpp_source.html#l00271">createNewAliasScopesFromNoAliasParameter()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00660">destructureIndices()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00657">mlir::Operation::fold()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00395">foldDynamicIndexList()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02558">foldLoopBounds()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00081">getAsOpFoldResult()</a>, <a class="el" href="MemRefMemorySlot_8cpp_source.html#l00181">getAttributeIndexFromIndexOperands()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l01004">getBroadcastableOperands()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00118">getConstantAPIntValue()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00064">getConstantIntValue()</a>, <a class="el" href="AMDGPUDialect_8cpp_source.html#l00248">getConstantUint32()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00753">getDivSISpeculatability()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00711">getDivUISpeculatability()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00141">getIntOrSplatIntValue()</a>, <a class="el" href="GPU_2IR_2InferIntRangeInterfaceImpls_8cpp_source.html#l00086">getKnownLaunchDim()</a>, <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00049">mlir::shape::getShapeVec()</a>, <a class="el" href="ControlFlowSinkUtils_8cpp_source.html#l00140">getSinglyExecutedRegionsToSink()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00200">mlir::ValueShapeRange::getValueAsShape()</a>, <a class="el" href="TosaOps_8cpp_source.html#l02601">getZeroPoint()</a>, <a class="el" href="InlinerInterfaceImpl_8cpp_source.html#l00056">handleInlinedAllocas()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00113">mlir::OperationFolder::insertKnownConstant()</a>, <a class="el" href="FoldAddIntoDest_8cpp_source.html#l00018">isDefinedAsZero()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00506">isDefinedOutsideOrConstant()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00075">isLikelyAnIndexComputation()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01613">isMaskTriviallyFoldable()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00207">isSplatWriteConsistentWithMaskedRead()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00457">mlir::affine::isValidSymbol()</a>, <a class="el" href="SparseTensorRewriting_8cpp_source.html#l00043">isZeroValue()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01469">mlir::affine::makeComposedFoldedAffineApply()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01540">makeComposedFoldedMinMax()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01510">mlir::linalg::makeComposedPadHighOp()</a>, <a class="el" href="ArithOps_8cpp_source.html#l02176">CmpFIntToFPConst::matchAndRewrite()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00636">ConcatSliceOptimization::matchAndRewrite()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l01182">FoldLaunchArguments::matchAndRewrite()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00133">IAddCarryFold::matchAndRewrite()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00213">MulExtendedFold&lt; spirv::SMulExtendedOp, true &gt;::matchAndRewrite()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00704">PadSliceOptimization::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02155">ReduceRedundantZero::matchAndRewrite()</a>, <a class="el" href="ArithOps_8cpp_source.html#l02443">SelectToExtUI::matchAndRewrite()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00842">SliceDynamicSizeCanonicalization::matchAndRewrite()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00331">UModSimplification::matchAndRewrite()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00289">UMulExtendedOpXOne::matchAndRewrite()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l02002">mlir::LLVM::ModuleImport::matchFloatAttr()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01992">mlir::LLVM::ModuleImport::matchIntegerAttr()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00051">materializeConstant()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00157">maybeConstantDimsAttr()</a>, <a class="el" href="LLVMMemorySlot_8cpp_source.html#l01050">memsetGetStored()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00093">movePaddingToFillOrGenericOp()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00176">mlir::OperationFolder::notifyRemoval()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00172">reifyMixedParamAndHandleResults()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00062">remainsLegalAfterInline()</a>, <a class="el" href="ControlFlow_2IR_2ControlFlowOps_8cpp_source.html#l00747">simplifyConstSwitchValue()</a>, and <a class="el" href="LoopEmitter_8cpp_source.html#l00091">tryFoldTensors()</a>.</p>

</div>
</div>
<a id="a6bc751bc8f30d71ad4cb771c0fcc788b" name="a6bc751bc8f30d71ad4cb771c0fcc788b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc751bc8f30d71ad4cb771c0fcc788b">&#9670;&#160;</a></span>matchReduction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::matchReduction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>iterCarriedArgs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>redPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>combinerOps</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility to match a generic reduction given a list of iteration-carried arguments, <span class="tt">iterCarriedArgs</span> and the position of the potential reduction argument within the list, <span class="tt">redPos</span>. </p>
<p>If a reduction is matched, returns the reduced value and the topologically-sorted list of combiner operations involved in the reduction. Otherwise, returns a null value.</p>
<p>The matching algorithm relies on the following invariants, which are subject to change:</p><ol type="1">
<li>The first combiner operation must be a binary operation with the iteration-carried value and the reduced value as operands.</li>
<li>The iteration-carried value and combiner operations must be side effect-free, have single result and a single use.</li>
<li>Combiner operations must be immediately nested in the region op performing the reduction.</li>
<li>Reduction def-use chain must end in a terminator op that yields the next iteration/output values in the same order as the iteration-carried values in <span class="tt">iterCarriedArgs</span>.</li>
<li><span class="tt">iterCarriedArgs</span> must contain all the iteration-carried/output values of the region op performing the reduction.</li>
</ol>
<p>This utility is generic enough to detect reductions involving multiple combiner operations (disabled for now) across multiple dialects, including Linalg, Affine and SCF. For the sake of genericity, it does not return specific enum values for the combiner operations since its goal is also matching reductions without pre-defined semantics in core MLIR. It's up to each client to make sense out of the list of combiner operations. It's also up to each client to check for additional invariants on the expected reductions not covered by this generic matching. </p>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8cpp_source.html#l00290">290</a> of file <a class="el" href="SliceAnalysis_8cpp_source.html">SliceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="SliceAnalysis_8cpp_source.html#l00235">dependsOnCarriedVals()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00346">mlir::Operation::getNumOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00404">mlir::Operation::getNumResults()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00350">mlir::Operation::getOperand()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00873">mlir::Operation::getUsers()</a>, <a class="el" href="Value_8h_source.html#l00218">mlir::Value::getUsers()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00849">mlir::Operation::hasOneUse()</a>, <a class="el" href="Value_8h_source.html#l00197">mlir::Value::hasOneUse()</a>, <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00320">isMemoryEffectFree()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00757">mlir::Operation::mightHaveTrait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00126">mlir::linalg::createDestinationPassingStyleInitOperand()</a>, <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00076">mlir::linalg::getCombinerOp()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00040">getSupportedReduction()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00669">matchLinalgReduction()</a>, <a class="el" href="SCFToOpenMP_8cpp_source.html#l00041">matchSimpleReduction()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00030">mlir::linalg::splitReduction()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00241">mlir::linalg::splitReductionByScaling()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01486">vectorizeAffineYieldOp()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l01337">vectorizeOneOp()</a>.</p>

</div>
</div>
<a id="a5c318aa15564b0d662d9a699f74f8eea" name="a5c318aa15564b0d662d9a699f74f8eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c318aa15564b0d662d9a699f74f8eea">&#9670;&#160;</a></span>mayBeGraphRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::mayBeGraphRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>region</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return "true" if the given region may be a graph region without SSA dominance. </p>
<p>This function returns "true" in case the owner op is an unregistered op. It returns "false" if it is a registered op that does not implement the RegionKindInterface. </p>

<p class="definition">Definition at line <a class="el" href="RegionKindInterface_8cpp_source.html#l00027">27</a> of file <a class="el" href="RegionKindInterface_8cpp_source.html">RegionKindInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00200">mlir::Region::getParentOp()</a>, <a class="el" href="IR_2Region_8cpp_source.html#l00062">mlir::Region::getRegionNumber()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00129">mlir::Operation::isRegistered()</a>.</p>

</div>
</div>
<a id="a5ed40bd15766a7dff96f3d30577d8f87" name="a5ed40bd15766a7dff96f3d30577d8f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed40bd15766a7dff96f3d30577d8f87">&#9670;&#160;</a></span>mayHaveSSADominance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::mayHaveSSADominance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>region</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return "true" if the given region may have SSA dominance. </p>
<p>This function also returns "true" in case the owner op is an unregistered op or an op that does not implement the RegionKindInterface. </p>

<p class="definition">Definition at line <a class="el" href="RegionKindInterface_8cpp_source.html#l00020">20</a> of file <a class="el" href="RegionKindInterface_8cpp_source.html">RegionKindInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00200">mlir::Region::getParentOp()</a>, and <a class="el" href="IR_2Region_8cpp_source.html#l00062">mlir::Region::getRegionNumber()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Iterators_8h_source.html#l00053">mlir::ForwardDominanceIterator&lt; NoGraphRegions &gt;::makeIterable()</a>, and <a class="el" href="Iterators_8h_source.html#l00095">mlir::ReverseDominanceIterator&lt; NoGraphRegions &gt;::makeIterable()</a>.</p>

</div>
</div>
<a id="ae5dd2f85ac8fc28edb96c1bc73f3ad0e" name="ae5dd2f85ac8fc28edb96c1bc73f3ad0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5dd2f85ac8fc28edb96c1bc73f3ad0e">&#9670;&#160;</a></span>mightHaveEffect() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... EffectTys&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::mightHaveEffect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns "true" if <span class="tt">op</span> might have an effect of type <span class="tt">EffectTy</span>. </p>
<p>Returns "true" if the op has unknown effects. Recursive effects are not taken into account. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8h_source.html#l00431">431</a> of file <a class="el" href="SideEffectInterfaces_8h_source.html">SideEffectInterfaces.h</a>.</p>

<p class="reference">References <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00217">hasEffect()</a>, and <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00307">hasUnknownEffects()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OwnershipBasedBufferDeallocation_8cpp_source.html#l00053">hasNeitherAllocateNorFreeSideEffect()</a>.</p>

</div>
</div>
<a id="a82cc254e5dca6419b6cba5e19b3f8acc" name="a82cc254e5dca6419b6cba5e19b3f8acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82cc254e5dca6419b6cba5e19b3f8acc">&#9670;&#160;</a></span>mightHaveEffect() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... EffectTys&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::mightHaveEffect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns "true" if <span class="tt">op</span> might have an effect of type <span class="tt">EffectTy</span> on <span class="tt">value</span>. </p>
<p>Returns "true" if the op has unknown effects. Recursive effects are not taken into account. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8h_source.html#l00439">439</a> of file <a class="el" href="SideEffectInterfaces_8h_source.html">SideEffectInterfaces.h</a>.</p>

<p class="reference">References <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00217">hasEffect()</a>, and <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00307">hasUnknownEffects()</a>.</p>

</div>
</div>
<a id="ac3671b9478b3b43240ca578ec2ce89c3" name="ac3671b9478b3b43240ca578ec2ce89c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3671b9478b3b43240ca578ec2ce89c3">&#9670;&#160;</a></span>mightHaveEffect() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueTy, typename... EffectTys&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::mightHaveEffect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueTy</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns "true" if <span class="tt">op</span> might have an effect of type <span class="tt">EffectTy</span> on <span class="tt">value</span> of type <span class="tt">ValueTy</span>. </p>
<p>Returns "true" if the op has unknown effects. Recursive effects are not taken into account. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8h_source.html#l00447">447</a> of file <a class="el" href="SideEffectInterfaces_8h_source.html">SideEffectInterfaces.h</a>.</p>

<p class="reference">References <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00217">hasEffect()</a>, and <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00307">hasUnknownEffects()</a>.</p>

</div>
</div>
<a id="a5b6bd2ae129738dfe4f7ec2c98d0c603" name="a5b6bd2ae129738dfe4f7ec2c98d0c603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6bd2ae129738dfe4f7ec2c98d0c603">&#9670;&#160;</a></span>MlirLspServerMain() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::LogicalResult mlir::MlirLspServerMain </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>argc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation for tools like <span class="tt">mlir-lsp-server</span>. </p>
<ul>
<li>registry should contain all the dialects that can be parsed in source IR passed to the server. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="MlirLspServerMain_8cpp_source.html#l00082">82</a> of file <a class="el" href="MlirLspServerMain_8cpp_source.html">MlirLspServerMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="MlirLspServerMain_8cpp_source.html#l00082">MlirLspServerMain()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirLspServerMain_8cpp_source.html#l00082">MlirLspServerMain()</a>.</p>

</div>
</div>
<a id="a6074601f706b63b9fc40ae76198411fe" name="a6074601f706b63b9fc40ae76198411fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6074601f706b63b9fc40ae76198411fe">&#9670;&#160;</a></span>MlirLspServerMain() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::MlirLspServerMain </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>argc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1lsp.html#a60b07b16e81f544ded595be16ffc501c">lsp::DialectRegistryFn</a></td>          <td class="paramname"><span class="paramname"><em>registry_fn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation for tools like <span class="tt">mlir-lsp-server</span>. </p>
<ul>
<li>registry should contain all the dialects that can be parsed in source IR passed to the server and may register different dialects depending on the input URI. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="MlirLspServerMain_8cpp_source.html#l00024">24</a> of file <a class="el" href="MlirLspServerMain_8cpp_source.html">MlirLspServerMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir_1_1lsp.html#acbe5b4374658bf13acf545f407ae23a1">mlir::lsp::runMlirLSPServer()</a>.</p>

</div>
</div>
<a id="af142b3ef60201e867dd545860bf1f71d" name="af142b3ef60201e867dd545860bf1f71d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af142b3ef60201e867dd545860bf1f71d">&#9670;&#160;</a></span>MlirOptMain() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::MlirOptMain </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>argc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef</td>          <td class="paramname"><span class="paramname"><em>inputFilename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef</td>          <td class="paramname"><span class="paramname"><em>outputFilename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation for tools like <span class="tt">mlir-opt</span>. </p>
<p>This function can be used with registerAndParseCLIOptions so that CLI options can be accessed before running MlirOptMain.</p><ul>
<li>inputFilename is the name of the input mlir file.</li>
<li>outputFilename is the name of the output file.</li>
<li>registry should contain all the dialects that can be parsed in the source. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="MlirOptMain_8cpp_source.html#l00786">786</a> of file <a class="el" href="MlirOptMain_8cpp_source.html">MlirOptMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00284">config</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00348">mlir::MlirOptMainConfig::createFromCLOptions()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00735">MlirOptMain()</a>, <a class="el" href="#a5ca85238ce4c87b3f6c9c5dd1c0969f7">openInputFile()</a>, <a class="el" href="#a2385cabecee3f62afafa0e997df79f5f">openOutputFile()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00723">printRegisteredDialects()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00730">printRegisteredPassesAndReturn()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a1f6b96254b4e476bf34403287c27825a" name="a1f6b96254b4e476bf34403287c27825a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6b96254b4e476bf34403287c27825a">&#9670;&#160;</a></span>MlirOptMain() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::MlirOptMain </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>argc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef</td>          <td class="paramname"><span class="paramname"><em>toolName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation for tools like <span class="tt">mlir-opt</span>. </p>
<ul>
<li>toolName is used for the header displayed by <span class="tt">--help</span>.</li>
<li>registry should contain all the dialects that can be parsed in the source. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="MlirOptMain_8cpp_source.html#l00830">830</a> of file <a class="el" href="MlirOptMain_8cpp_source.html">MlirOptMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="MlirOptMain_8cpp_source.html#l00735">MlirOptMain()</a>, and <a class="el" href="MlirOptMain_8cpp_source.html#l00716">registerAndParseCLIOptions()</a>.</p>

</div>
</div>
<a id="a440508357b9fe36f36010043c99e2f22" name="a440508357b9fe36f36010043c99e2f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a440508357b9fe36f36010043c99e2f22">&#9670;&#160;</a></span>MlirOptMain() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::MlirOptMain </td>
          <td>(</td>
          <td class="paramtype">llvm::raw_ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>outputStream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; llvm::MemoryBuffer &gt;</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1MlirOptMainConfig.html">MlirOptMainConfig</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>config</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the core processing behind <span class="tt">mlir-opt</span>. </p>
<ul>
<li>outputStream is the stream where the resulting IR is printed.</li>
<li>buffer is the in-memory file to parser and process.</li>
<li>registry should contain all the dialects that can be parsed in the source.</li>
<li>config contains the configuration options for the tool. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="MlirOptMain_8cpp_source.html#l00735">735</a> of file <a class="el" href="MlirOptMain_8cpp_source.html">MlirOptMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00284">config</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00655">mlir::MLIRContext::getThreadPool()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00597">mlir::MLIRContext::isMultithreadingEnabled()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00723">printRegisteredDialects()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00730">printRegisteredPassesAndReturn()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00631">processBuffer()</a>, <a class="el" href="#a715b8c35aa2d5155832ef2f0c09db693">splitAndProcessBuffer()</a>, and <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00843">mlir::SourceMgrDiagnosticVerifierHandler::verify()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00786">MlirOptMain()</a>, and <a class="el" href="MlirOptMain_8cpp_source.html#l00830">MlirOptMain()</a>.</p>

</div>
</div>
<a id="afcf1fa346908020b9dbc2009bb3630ce" name="afcf1fa346908020b9dbc2009bb3630ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf1fa346908020b9dbc2009bb3630ce">&#9670;&#160;</a></span>MlirPdllLspServerMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::MlirPdllLspServerMain </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>argc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation for tools like <span class="tt">mlir-pdll-lsp-server</span>. </p>

<p class="definition">Definition at line <a class="el" href="MlirPdllLspServerMain_8cpp_source.html#l00023">23</a> of file <a class="el" href="MlirPdllLspServerMain_8cpp_source.html">MlirPdllLspServerMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, and <a class="el" href="namespacemlir_1_1lsp.html#afc8291e3c71ab3c0feb0e8352686ceb7">mlir::lsp::runPdllLSPServer()</a>.</p>

</div>
</div>
<a id="a7810268d0608849708e435fcb9791bb1" name="a7810268d0608849708e435fcb9791bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7810268d0608849708e435fcb9791bb1">&#9670;&#160;</a></span>mlirQueryMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::LogicalResult mlir::mlirQueryMain </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>argc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1query_1_1matcher_1_1Registry.html">mlir::query::matcher::Registry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>matcherRegistry</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MlirQueryMain_8cpp_source.html#l00032">32</a> of file <a class="el" href="MlirQueryMain_8cpp_source.html">MlirQueryMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00589">mlir::MLIRContext::allowUnregisteredDialects()</a>, <a class="el" href="Query_8cpp_source.html#l00026">mlir::query::complete()</a>, <a class="el" href="OwningOpRef_8h_source.html#l00051">mlir::OwningOpRef&lt; OpTy &gt;::get()</a>, <a class="el" href="#a5ca85238ce4c87b3f6c9c5dd1c0969f7">openInputFile()</a>, <a class="el" href="Query_8cpp_source.html#l00021">mlir::query::parse()</a>, <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l00038">parseSourceFile()</a>, and <a class="el" href="QuerySession_8h_source.html#l00034">mlir::query::QuerySession::terminate</a>.</p>

</div>
</div>
<a id="ab515fd3b6aebea7df681f094b42d9e71" name="ab515fd3b6aebea7df681f094b42d9e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab515fd3b6aebea7df681f094b42d9e71">&#9670;&#160;</a></span>mlirReduceMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::mlirReduceMain </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>argc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MlirReduceMain_8cpp_source.html#l00045">45</a> of file <a class="el" href="MlirReduceMain_8cpp_source.html">MlirReduceMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassRegistry_8cpp_source.html#l01005">mlir::PassPipelineCLParser::addToPipeline()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00589">mlir::MLIRContext::allowUnregisteredDialects()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00332">emitError()</a>, <a class="el" href="OwningOpRef_8h_source.html#l00051">mlir::OwningOpRef&lt; OpTy &gt;::get()</a>, <a class="el" href="MlirReduceMain_8cpp_source.html#l00029">loadModule()</a>, <a class="el" href="#a2385cabecee3f62afafa0e997df79f5f">openOutputFile()</a>, <a class="el" href="Reducer_2Passes_8h_source.html#l00265">registerReducerPasses()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l01035">mlir::PassManager::run()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="ad4175a8043cece857c2779663ef3ba91" name="ad4175a8043cece857c2779663ef3ba91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4175a8043cece857c2779663ef3ba91">&#9670;&#160;</a></span>MlirTblgenMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mlir::MlirTblgenMain </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>argc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main Program for tools like 'mlir-tblgen' with custom backends. </p>
<p>To add a new backend, simply create a new '<a class="el" href="structmlir_1_1GenRegistration.html" title="GenRegistration provides a global initializer that registers a generator function.">mlir::GenRegistration</a>' global variable. See its documentation for more info.</p>
<p>The 'argc' and 'argv' arguments are simply forwarded from a main function. The return value is the exit code from llvm::TableGenMain. </p>

<p class="definition">Definition at line <a class="el" href="MlirTblgenMain_8cpp_source.html#l00139">139</a> of file <a class="el" href="MlirTblgenMain_8cpp_source.html">MlirTblgenMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="MlirTblgenMain_8cpp_source.html#l00029">actionOnDeprecatedValue</a>, <a class="el" href="MlirTblgenMain_8cpp_source.html#l00027">Error</a>, <a class="el" href="MlirTblgenMain_8cpp_source.html#l00124">generator</a>, <a class="el" href="MlirTblgenMain_8cpp_source.html#l00128">mlirTableGenMain()</a>, <a class="el" href="MlirTblgenMain_8cpp_source.html#l00027">None</a>, and <a class="el" href="MlirTblgenMain_8cpp_source.html#l00027">Warn</a>.</p>

</div>
</div>
<a id="ab673e648679ec83d87417b04baf281dd" name="ab673e648679ec83d87417b04baf281dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab673e648679ec83d87417b04baf281dd">&#9670;&#160;</a></span>mlirTranslateMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::mlirTranslateMain </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>argc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>toolName</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate to/from an MLIR module from/to an external representation (e.g. </p>
<p><a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR, SPIRV binary, ...). This is the entry point for the implementation of tools like <span class="tt">mlir-translate</span>. The translation to perform is parsed from the command line. The <span class="tt">toolName</span> argument is used for the header displayed by <span class="tt">--help</span>. </p>

</div>
</div>
<a id="af79a420cd75e576fa80212258d3de025" name="af79a420cd75e576fa80212258d3de025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af79a420cd75e576fa80212258d3de025">&#9670;&#160;</a></span>moveLoopInvariantCode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mlir::moveLoopInvariantCode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>regions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;</td>          <td class="paramname"><span class="paramname"><em>isDefinedOutsideRegion</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;</td>          <td class="paramname"><span class="paramname"><em>shouldMoveOutOfRegion</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;</td>          <td class="paramname"><span class="paramname"><em>moveOutOfRegion</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a list of regions, perform loop-invariant code motion. </p>
<p>An operation is loop-invariant if it depends only of values defined outside of the loop. LICM moves these operations out of the loop body so that they are not computed more than once.</p>
<p>Example:</p>
<div class="fragment"><div class="line">affine.for %arg0 = 0 to 10 {</div>
<div class="line">  affine.for %arg1 = 0 to 10 {</div>
<div class="line">    %v0 = arith.addi %arg0, %arg0 : i32</div>
<div class="line">    %v1 = arith.addi %v0, %arg1 : i32</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>After LICM:</p>
<div class="fragment"><div class="line">affine.for %arg0 = 0 to 10 {</div>
<div class="line">  %v0 = arith.addi %arg0, %arg0 : i32</div>
<div class="line">  affine.for %arg1 = 0 to 10 {</div>
<div class="line">    %v1 = arith.addi %v0, %arg1 : i32</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Users must supply three callbacks.</p>
<ul>
<li><span class="tt">isDefinedOutsideRegion</span> returns true if the given value is invariant with respect to the given region. A common implementation might be: <span class="tt">value.getParentRegion()-&gt;isProperAncestor(region)</span>.</li>
<li><span class="tt">shouldMoveOutOfRegion</span> returns true if the provided operation can be moved of the given region, e.g. if it is side-effect free.</li>
<li><span class="tt">moveOutOfRegion</span> moves the operation out of the given region. A common implementation might be: <span class="tt">op-&gt;moveBefore(region-&gt;getParentOp())</span>.</li>
</ul>
<p>An operation is moved if all of its operands satisfy <span class="tt">isDefinedOutsideRegion</span> and it satisfies <span class="tt">shouldMoveOutOfRegion</span>.</p>
<p>Returns the number of operations moved. </p>

<p class="definition">Definition at line <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html#l00061">61</a> of file <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html">LoopInvariantCodeMotionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html#l00033">canBeHoisted()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00230">mlir::Operation::getParentRegion()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00873">mlir::Operation::getUsers()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Hoisting_8cpp_source.html#l00089">mlir::linalg::hoistRedundantVectorBroadcasts()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00198">mlir::linalg::hoistRedundantVectorTransfers()</a>, and <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html#l00111">moveLoopInvariantCode()</a>.</p>

</div>
</div>
<a id="a56b9f2d2e0330c53880b673633907ac6" name="a56b9f2d2e0330c53880b673633907ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b9f2d2e0330c53880b673633907ac6">&#9670;&#160;</a></span>moveLoopInvariantCode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mlir::moveLoopInvariantCode </td>
          <td>(</td>
          <td class="paramtype">LoopLikeOpInterface</td>          <td class="paramname"><span class="paramname"><em>loopLike</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move side-effect free loop invariant code out of a loop-like op using methods provided by the interface. </p>

<p class="definition">Definition at line <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html#l00111">111</a> of file <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html">LoopInvariantCodeMotionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html#l00061">moveLoopInvariantCode()</a>.</p>

</div>
</div>
<a id="a9dae870bd077007ddaae656fd4ddf14a" name="a9dae870bd077007ddaae656fd4ddf14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dae870bd077007ddaae656fd4ddf14a">&#9670;&#160;</a></span>moveOperationDependencies() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::moveOperationDependencies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>insertionPoint</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l01138">1138</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="RegionUtils_8cpp_source.html#l01089">moveOperationDependencies()</a>.</p>

</div>
</div>
<a id="a2fdbd0b74e2e10bef579e3e78fd9c5b1" name="a2fdbd0b74e2e10bef579e3e78fd9c5b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fdbd0b74e2e10bef579e3e78fd9c5b1">&#9670;&#160;</a></span>moveOperationDependencies() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::moveOperationDependencies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>insertionPoint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dominance</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move SSA values used within an operation before an insertion point, so that the operation itself (or its replacement) can be moved to the insertion point. </p>
<p>Current support is only for movement of dependencies of <span class="tt">op</span> before <span class="tt">insertionPoint</span> in the same basic block. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l01089">1089</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="SliceAnalysis_8cpp_source.html#l00179">getBackwardSlice()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00407">mlir::RewriterBase::moveOpBefore()</a>, <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="Dominance_8cpp_source.html#l00323">mlir::DominanceInfo::properlyDominates()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8cpp_source.html#l01138">moveOperationDependencies()</a>.</p>

</div>
</div>
<a id="a1506f6b75720ad7dfe864646585c4ba2" name="a1506f6b75720ad7dfe864646585c4ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1506f6b75720ad7dfe864646585c4ba2">&#9670;&#160;</a></span>moveValueDefinitions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::moveValueDefinitions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>insertionPoint</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l01214">1214</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="RegionUtils_8cpp_source.html#l01145">moveValueDefinitions()</a>.</p>

</div>
</div>
<a id="adfb87364046c64c85ee85e862ee4d19e" name="adfb87364046c64c85ee85e862ee4d19e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb87364046c64c85ee85e862ee4d19e">&#9670;&#160;</a></span>moveValueDefinitions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::moveValueDefinitions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>insertionPoint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dominance</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move definitions of <span class="tt">values</span> before an insertion point. </p>
<p>Current support is only for movement of definitions within the same basic block. Note that this is an all-or-nothing approach. Either definitions of all values are moved before insertion point, or none of them are. Any side-effecting operations in the producer chain pessimistically blocks movement. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l01145">1145</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="SliceAnalysis_8cpp_source.html#l00179">getBackwardSlice()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00403">isPure()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00407">mlir::RewriterBase::moveOpBefore()</a>, <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="Dominance_8cpp_source.html#l00323">mlir::DominanceInfo::properlyDominates()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, and <a class="el" href="TopologicalSortUtils_8cpp_source.html#l00275">topologicalSort()</a>.</p>

<p class="reference">Referenced by <a class="el" href="EmptyTensorElimination_8cpp_source.html#l00096">mlir::bufferization::buildSubsetExtraction()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00865">fuseWithReshapeByExpansion()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l01214">moveValueDefinitions()</a>.</p>

</div>
</div>
<a id="afff65ad1a751cdba6e58ef912d9ebaa8" name="afff65ad1a751cdba6e58ef912d9ebaa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff65ad1a751cdba6e58ef912d9ebaa8">&#9670;&#160;</a></span>normalizeForallOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; scf::ForallOp &gt; mlir::normalizeForallOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ForallOp</td>          <td class="paramname"><span class="paramname"><em>forallOp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize an <span class="tt">scf.forall</span> operation. </p>
<p>Returns <span class="tt">failure()</span>if normalization fails. newly created operation with all uses of the original operation replaced with results of the new operation. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01479">1479</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00774">denormalizeInductionVariable()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00703">emitNormalizedLoopBounds()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00232">mlir::RewriterBase::eraseBlock()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00395">foldDynamicIndexList()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">getValueOrCreateConstantIndexOp()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00376">mlir::RewriterBase::inlineRegionBefore()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="Builders_8h_source.html#l00398">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="Builders_8h_source.html#l00431">mlir::OpBuilder::setInsertionPointToStart()</a>, and <a class="el" href="StaticValueUtils_8h_source.html#l00037">mlir::Range::size</a>.</p>

</div>
</div>
<a id="a4ec63c3f9b9b50f77b7cc8b92f506204" name="a4ec63c3f9b9b50f77b7cc8b92f506204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec63c3f9b9b50f77b7cc8b92f506204">&#9670;&#160;</a></span>openInputFile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; llvm::MemoryBuffer &gt; mlir::openInputFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef</td>          <td class="paramname"><span class="paramname"><em>inputFilename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Align</td>          <td class="paramname"><span class="paramname"><em>alignment</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *</td>          <td class="paramname"><span class="paramname"><em>errorMessage</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open the file specified by its name for reading, with the given buffer alignment constraint. </p>
<p>Write the error message to <span class="tt">errorMessage</span> if errors occur and <span class="tt">errorMessage</span> is not nullptr. </p>

<p class="definition">Definition at line <a class="el" href="FileUtilities_8cpp_source.html#l00043">43</a> of file <a class="el" href="FileUtilities_8cpp_source.html">FileUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="FileUtilities_8cpp_source.html#l00023">openInputFileImpl()</a>.</p>

</div>
</div>
<a id="a5ca85238ce4c87b3f6c9c5dd1c0969f7" name="a5ca85238ce4c87b3f6c9c5dd1c0969f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca85238ce4c87b3f6c9c5dd1c0969f7">&#9670;&#160;</a></span>openInputFile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; llvm::MemoryBuffer &gt; mlir::openInputFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef</td>          <td class="paramname"><span class="paramname"><em>inputFilename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *</td>          <td class="paramname"><span class="paramname"><em>errorMessage</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open the file specified by its name for reading. </p>
<p>Write the error message to <span class="tt">errorMessage</span> if errors occur and <span class="tt">errorMessage</span> is not nullptr. </p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00385">loadIRDLDialects()</a>, <a class="el" href="MlirReduceMain_8cpp_source.html#l00029">loadModule()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00786">MlirOptMain()</a>, <a class="el" href="MlirQueryMain_8cpp_source.html#l00032">mlirQueryMain()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00134">parseMLIRInput()</a>, and <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00088">mlir::transform::detail::parseTransformModuleFromFile()</a>.</p>

</div>
</div>
<a id="a2385cabecee3f62afafa0e997df79f5f" name="a2385cabecee3f62afafa0e997df79f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2385cabecee3f62afafa0e997df79f5f">&#9670;&#160;</a></span>openOutputFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; llvm::ToolOutputFile &gt; mlir::openOutputFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef</td>          <td class="paramname"><span class="paramname"><em>outputFilename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *</td>          <td class="paramname"><span class="paramname"><em>errorMessage</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open the file specified by its name for writing. </p>
<p>Write the error message to <span class="tt">errorMessage</span> if errors occur and <span class="tt">errorMessage</span> is not nullptr. </p>

<p class="reference">Referenced by <a class="el" href="IRPrinting_8cpp_source.html#l00260">createTreePrinterOutputPath()</a>, <a class="el" href="ExecutionEngine_2ExecutionEngine_8cpp_source.html#l00083">mlir::SimpleObjectCache::dumpToObjectFile()</a>, <a class="el" href="LocationSnapshot_8cpp_source.html#l00072">generateLocationsFromIR()</a>, <a class="el" href="CLOptionsSetup_8cpp_source.html#l00085">mlir::tracing::InstallDebugHandler::Impl::Impl()</a>, <a class="el" href="PassCrashRecovery_8cpp_source.html#l00431">makeReproducerStreamFactory()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00786">MlirOptMain()</a>, and <a class="el" href="MlirReduceMain_8cpp_source.html#l00045">mlirReduceMain()</a>.</p>

</div>
</div>
<a id="aee326f96469cd288efb48265e173295e" name="aee326f96469cd288efb48265e173295e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee326f96469cd288efb48265e173295e">&#9670;&#160;</a></span>operator!=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpState.html">OpState</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpState.html">OpState</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00265">265</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>.</p>

</div>
</div>
<a id="a62534636110d65226b611986e9a316a1" name="a62534636110d65226b611986e9a316a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62534636110d65226b611986e9a316a1">&#9670;&#160;</a></span>operator!=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RegionBranchPoint.html">RegionBranchPoint</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RegionBranchPoint.html">RegionBranchPoint</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8h_source.html#l00270">270</a> of file <a class="el" href="ControlFlowInterfaces_8h_source.html">ControlFlowInterfaces.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>.</p>

</div>
</div>
<a id="a8db56ba5c170b04848e194937be59a56" name="a8db56ba5c170b04848e194937be59a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db56ba5c170b04848e194937be59a56">&#9670;&#160;</a></span>operator!=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype">StringAttr</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01060">1060</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>.</p>

</div>
</div>
<a id="a6bb385e3105982b905c5ef4db9f9f21b" name="a6bb385e3105982b905c5ef4db9f9f21b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb385e3105982b905c5ef4db9f9f21b">&#9670;&#160;</a></span>operator!=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype">StringAttr</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringAttr</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01066">1066</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>.</p>

</div>
</div>
<a id="a48146d74baebce1c83140c378053f3c2" name="a48146d74baebce1c83140c378053f3c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48146d74baebce1c83140c378053f3c2">&#9670;&#160;</a></span>operator!=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype">StringAttr</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01072">1072</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>.</p>

</div>
</div>
<a id="a4bfbb1c5941d2cc005eb3f483e881202" name="a4bfbb1c5941d2cc005eb3f483e881202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bfbb1c5941d2cc005eb3f483e881202">&#9670;&#160;</a></span>operator!=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringAttr</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01076">1076</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>.</p>

</div>
</div>
<a id="a4f5d450d84010aaf140c9cccddf00804" name="a4f5d450d84010aaf140c9cccddf00804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f5d450d84010aaf140c9cccddf00804">&#9670;&#160;</a></span>operator&amp;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> mlir::operator&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataFlowFramework_8h_source.html#l00048">48</a> of file <a class="el" href="DataFlowFramework_8h_source.html">DataFlowFramework.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, <a class="el" href="DataFlowFramework_8h_source.html#l00038">NoChange</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>.</p>

</div>
</div>
<a id="a9137193b56dc5134c3092273b13e3f47" name="a9137193b56dc5134c3092273b13e3f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9137193b56dc5134c3092273b13e3f47">&#9670;&#160;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00252">252</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

</div>
</div>
<a id="a8f6f52bcd2d859c9d9a6f393ad5481c1" name="a8f6f52bcd2d859c9d9a6f393ad5481c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f6f52bcd2d859c9d9a6f393ad5481c1">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00251">251</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

</div>
</div>
<a id="a72aa3fc8e169b33e5d4a63f593172d4e" name="a72aa3fc8e169b33e5d4a63f593172d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72aa3fc8e169b33e5d4a63f593172d4e">&#9670;&#160;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00253">253</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

</div>
</div>
<a id="ab8eec2af29b78e6f1f81872e63d4824a" name="ab8eec2af29b78e6f1f81872e63d4824a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8eec2af29b78e6f1f81872e63d4824a">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/44]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT, typename ElementT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; ElementT &gt;</td>          <td class="paramname"><span class="paramname"><em>types</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00110">110</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="aa8ebd23da6c03a288b5c18332b631820" name="aa8ebd23da6c03a288b5c18332b631820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ebd23da6c03a288b5c18332b631820">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/44]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td>          <td class="paramname"><span class="paramname"><em>attr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00110">110</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="a48a311b94dbcdd8d8a8f496782255017" name="a48a311b94dbcdd8d8a8f496782255017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a311b94dbcdd8d8a8f496782255017">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[3/44]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00110">110</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="aad6015509602df66ca1bd652646cb2f4" name="aad6015509602df66ca1bd652646cb2f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad6015509602df66ca1bd652646cb2f4">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[4/44]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const APFloat &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00110">110</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="aa8dacf7f3e3ed3310320966a4b83d744" name="aa8dacf7f3e3ed3310320966a4b83d744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8dacf7f3e3ed3310320966a4b83d744">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[5/44]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT, typename T, std::enable_if_t&lt;!std::is_convertible&lt; T &amp;, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp; &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, <a class="el" href="classmlir_1_1Type.html">Type</a> &amp; &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &amp; &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, APFloat &amp; &gt;::value &amp;&amp;!llvm::is_one_of&lt; T, <a class="el" href="classbool.html">bool</a>, float, double &gt;::value, T &gt; * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00110">110</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="a36d6ce3e12cd2c5c887b82abd275b25b" name="a36d6ce3e12cd2c5c887b82abd275b25b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36d6ce3e12cd2c5c887b82abd275b25b">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[6/44]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value &amp;&amp;std::is_convertible&lt; T &amp;, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> &gt;::value, AsmPrinterT &amp; &gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2dcbaa0d8dada489c3adb5b030487e55" name="a2dcbaa0d8dada489c3adb5b030487e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dcbaa0d8dada489c3adb5b030487e55">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[7/44]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>types</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00110">110</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="af58488c343a38262634f085412b61111" name="af58488c343a38262634f085412b61111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58488c343a38262634f085412b61111">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[8/44]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT, typename ValueRangeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueTypeRange.html">ValueTypeRange</a>&lt; ValueRangeT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>types</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00110">110</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="a5005efd19da059f389f19aba557cf694" name="a5005efd19da059f389f19aba557cf694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5005efd19da059f389f19aba557cf694">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[9/44]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00110">110</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="af822a020908515c46b867efc178eca9a" name="af822a020908515c46b867efc178eca9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af822a020908515c46b867efc178eca9a">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[10/44]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00110">110</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="abd77c78ac9e1328408b0b68a432bfeb7" name="abd77c78ac9e1328408b0b68a432bfeb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd77c78ac9e1328408b0b68a432bfeb7">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[11/44]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00110">110</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="a3bf207a294e93baf22d2bc33d903b721" name="a3bf207a294e93baf22d2bc33d903b721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf207a294e93baf22d2bc33d903b721">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[12/44]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::raw_ostream &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">llvm::raw_ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>region</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Region_8cpp_source.html#l00256">256</a> of file <a class="el" href="IR_2Region_8cpp_source.html">Region.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00045">mlir::Region::getBlocks()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00119">mlir::Operation::getName()</a>, <a class="el" href="IR_2Region_8h_source.html#l00200">mlir::Region::getParentOp()</a>, and <a class="el" href="IR_2Region_8cpp_source.html#l00062">mlir::Region::getRegionNumber()</a>.</p>

</div>
</div>
<a id="aa96fcd93e4a339c2cff5c75bf37447e8" name="aa96fcd93e4a339c2cff5c75bf37447e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa96fcd93e4a339c2cff5c75bf37447e8">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[13/44]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::raw_ostream &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">llvm::raw_ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RegionBranchPoint.html">RegionBranchPoint</a></td>          <td class="paramname"><span class="paramname"><em>point</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8h_source.html#l00274">274</a> of file <a class="el" href="ControlFlowInterfaces_8h_source.html">ControlFlowInterfaces.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00230">mlir::Operation::getParentRegion()</a>, <a class="el" href="IR_2Region_8cpp_source.html#l00062">mlir::Region::getRegionNumber()</a>, <a class="el" href="ControlFlowInterfaces_8h_source.html#l00254">mlir::RegionBranchPoint::getTerminatorPredecessorOrNull()</a>, and <a class="el" href="ControlFlowInterfaces_8h_source.html#l00250">mlir::RegionBranchPoint::isParent()</a>.</p>

</div>
</div>
<a id="ae4193648916732525e8b9ffff25b7140" name="ae4193648916732525e8b9ffff25b7140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4193648916732525e8b9ffff25b7140">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[14/44]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::raw_ostream &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">llvm::raw_ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RegionSuccessor.html">RegionSuccessor</a></td>          <td class="paramname"><span class="paramname"><em>successor</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8h_source.html#l00288">288</a> of file <a class="el" href="ControlFlowInterfaces_8h_source.html">ControlFlowInterfaces.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8cpp_source.html#l00062">mlir::Region::getRegionNumber()</a>, <a class="el" href="ControlFlowInterfaces_8h_source.html#l00209">mlir::RegionSuccessor::getSuccessor()</a>, <a class="el" href="ControlFlowInterfaces_8h_source.html#l00216">mlir::RegionSuccessor::getSuccessorInputs()</a>, and <a class="el" href="ControlFlowInterfaces_8h_source.html#l00212">mlir::RegionSuccessor::isParent()</a>.</p>

</div>
</div>
<a id="af58e1ab7641f5c0781af1f167b66d4ca" name="af58e1ab7641f5c0781af1f167b66d4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58e1ab7641f5c0781af1f167b66d4ca">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[15/44]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00565">565</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1OpAsmPrinter.html#a922b7c99e121802c2e58a80f964b8561">mlir::OpAsmPrinter::printSuccessor()</a>.</p>

</div>
</div>
<a id="a0454cf763cf2a4bab30345a05f174fe6" name="a0454cf763cf2a4bab30345a05f174fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0454cf763cf2a4bab30345a05f174fe6">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[16/44]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::enable_if_t&lt; std::is_convertible&lt; T &amp;, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp; &gt;::value, T &gt; * = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00560">560</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="OpImplementation_8h_source.html#l00476">mlir::OpAsmPrinter::printOperands()</a>.</p>

</div>
</div>
<a id="ae7e3ca24d197f44633191038fa9730d0" name="ae7e3ca24d197f44633191038fa9730d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e3ca24d197f44633191038fa9730d0">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[17/44]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00551">551</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1OpAsmPrinter.html#acddd5eb143c94fa8528920c75799e3ba">mlir::OpAsmPrinter::printOperand()</a>.</p>

</div>
</div>
<a id="a13e488dd4f0933d688cd10581b313afb" name="a13e488dd4f0933d688cd10581b313afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e488dd4f0933d688cd10581b313afb">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[18/44]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>block</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l04177">4177</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l04143">mlir::Block::print()</a>.</p>

</div>
</div>
<a id="ab96f3b26c90ea659c4be029b0e410cd3" name="ab96f3b26c90ea659c4be029b0e410cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab96f3b26c90ea659c4be029b0e410cd3">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[19/44]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1IntegerValueRange.html">IntegerValueRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InferIntRangeInterface_8cpp_source.html#l00144">144</a> of file <a class="el" href="InferIntRangeInterface_8cpp_source.html">InferIntRangeInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="InferIntRangeInterface_8h_source.html#l00150">mlir::IntegerValueRange::print()</a>.</p>

</div>
</div>
<a id="ae69078b1d3f3263a1769df2e0f1730df" name="ae69078b1d3f3263a1769df2e0f1730df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69078b1d3f3263a1769df2e0f1730df">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[20/44]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01080">1080</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l04013">mlir::AffineExpr::print()</a>.</p>

</div>
</div>
<a id="a425d39b5f3079c19e427e5ae82cb7838" name="a425d39b5f3079c19e427e5ae82cb7838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425d39b5f3079c19e427e5ae82cb7838">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[21/44]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00664">664</a> of file <a class="el" href="mlir_2IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l04027">mlir::AffineMap::print()</a>.</p>

</div>
</div>
<a id="a2b6866ece3e4c58dfc2a59a233c4ce7b" name="a2b6866ece3e4c58dfc2a59a233c4ce7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b6866ece3e4c58dfc2a59a233c4ce7b">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[22/44]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td>          <td class="paramname"><span class="paramname"><em>attr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Attributes_8h_source.html#l00150">150</a> of file <a class="el" href="Attributes_8h_source.html">Attributes.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l03933">mlir::Attribute::print()</a>.</p>

</div>
</div>
<a id="a28d8b08d9561c09e1c96244503e2de51" name="a28d8b08d9561c09e1c96244503e2de51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d8b08d9561c09e1c96244503e2de51">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[23/44]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1AliasResult.html">AliasResult</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AliasAnalysis_8h_source.html#l00078">78</a> of file <a class="el" href="AliasAnalysis_8h_source.html">AliasAnalysis.h</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

</div>
</div>
<a id="a942e7952bc6a382ba284b8dee6295f9c" name="a942e7952bc6a382ba284b8dee6295f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a942e7952bc6a382ba284b8dee6295f9c">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[24/44]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1AnalysisState.html">AnalysisState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataFlowFramework_8h_source.html#l00774">774</a> of file <a class="el" href="DataFlowFramework_8h_source.html">DataFlowFramework.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1AnalysisState.html#a6abd2440851a3aeb4417c0d7c09abdd9">mlir::AnalysisState::print()</a>.</p>

</div>
</div>
<a id="a9d68b8241f5fecc2c47b23acbb6910c8" name="a9d68b8241f5fecc2c47b23acbb6910c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d68b8241f5fecc2c47b23acbb6910c8">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[25/44]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ConstantIntRanges.html">ConstantIntRanges</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InferIntRangeInterface_8cpp_source.html#l00127">127</a> of file <a class="el" href="InferIntRangeInterface_8cpp_source.html">InferIntRangeInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="InferIntRangeInterface_8cpp_source.html#l00029">mlir::ConstantIntRanges::smax()</a>, <a class="el" href="InferIntRangeInterface_8cpp_source.html#l00027">mlir::ConstantIntRanges::smin()</a>, <a class="el" href="InferIntRangeInterface_8cpp_source.html#l00025">mlir::ConstantIntRanges::umax()</a>, and <a class="el" href="InferIntRangeInterface_8cpp_source.html#l00023">mlir::ConstantIntRanges::umin()</a>.</p>

</div>
</div>
<a id="a0bc71fe62040378c9ab46fff9d5d7fff" name="a0bc71fe62040378c9ab46fff9d5d7fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc71fe62040378c9ab46fff9d5d7fff">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[26/44]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Diagnostic.html">Diagnostic</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>diag</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00304">304</a> of file <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

<p class="reference">References <a class="el" href="ModuleImport_8cpp_source.html#l00057">diag()</a>.</p>

</div>
</div>
<a id="a4c2a679d84bee635872c71c673d32927" name="a4c2a679d84bee635872c71c673d32927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2a679d84bee635872c71c673d32927">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[27/44]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DiagnosticArgument.html">DiagnosticArgument</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00144">144</a> of file <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00058">mlir::DiagnosticArgument::print()</a>.</p>

</div>
</div>
<a id="a8f9664a2bf70922634eb43fbb1a21d6f" name="a8f9664a2bf70922634eb43fbb1a21d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9664a2bf70922634eb43fbb1a21d6f">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[28/44]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1IRUnit.html">IRUnit</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>unit</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8348a1e9094397a47c0fb1caa89c325" name="ad8348a1e9094397a47c0fb1caa89c325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8348a1e9094397a47c0fb1caa89c325">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[29/44]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1LatticeAnchor.html">LatticeAnchor</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>anchor</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataFlowFramework_8h_source.html#l00779">779</a> of file <a class="el" href="DataFlowFramework_8h_source.html">DataFlowFramework.h</a>.</p>

<p class="reference">References <a class="el" href="DataFlowFramework_8cpp_source.html#l00078">mlir::LatticeAnchor::print()</a>.</p>

</div>
</div>
<a id="ae846cd7dd23c30e524844ff15e90ee93" name="ae846cd7dd23c30e524844ff15e90ee93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae846cd7dd23c30e524844ff15e90ee93">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[30/44]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Location.html">Location</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>loc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Location_8h_source.html#l00116">116</a> of file <a class="el" href="Location_8h_source.html">Location.h</a>.</p>

<p class="reference">References <a class="el" href="Location_8h_source.html#l00097">mlir::Location::print()</a>.</p>

</div>
</div>
<a id="a61082d1d6689e96ddb09eff087188676" name="a61082d1d6689e96ddb09eff087188676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61082d1d6689e96ddb09eff087188676">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[31/44]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ModRefResult.html">ModRefResult</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AliasAnalysis_8h_source.html#l00165">165</a> of file <a class="el" href="AliasAnalysis_8h_source.html">AliasAnalysis.h</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

</div>
</div>
<a id="a562b0755b16f72f37cd4a237a1a4726e" name="a562b0755b16f72f37cd4a237a1a4726e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562b0755b16f72f37cd4a237a1a4726e">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[32/44]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Operation_8h_source.html#l01100">1100</a> of file <a class="el" href="IR_2Operation_8h_source.html">Operation.h</a>.</p>

<p class="reference">References <a class="el" href="SPIRVAttributes_8cpp_source.html#l00624">print()</a>.</p>

</div>
</div>
<a id="adff0953d991123738b20a3a06880bf4f" name="adff0953d991123738b20a3a06880bf4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adff0953d991123738b20a3a06880bf4f">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[33/44]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1OpWithState.html">OpWithState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opWithState</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Operation_8h_source.html#l01145">1145</a> of file <a class="el" href="IR_2Operation_8h_source.html">Operation.h</a>.</p>

</div>
</div>
<a id="ad29d63a43cfe388d03a96a02a5538186" name="ad29d63a43cfe388d03a96a02a5538186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29d63a43cfe388d03a96a02a5538186">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[34/44]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1ProgramPoint.html">ProgramPoint</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>point</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataFlowFramework_8h_source.html#l00150">150</a> of file <a class="el" href="DataFlowFramework_8h_source.html">DataFlowFramework.h</a>.</p>

<p class="reference">References <a class="el" href="DataFlowFramework_8cpp_source.html#l00060">mlir::ProgramPoint::print()</a>.</p>

</div>
</div>
<a id="ac7e879c874e4fdc6aaf9d4742abdb876" name="ac7e879c874e4fdc6aaf9d4742abdb876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e879c874e4fdc6aaf9d4742abdb876">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[35/44]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1Range.html">Range</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l03167">3167</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8h_source.html#l00036">mlir::Range::offset</a>, <a class="el" href="StaticValueUtils_8h_source.html#l00037">mlir::Range::size</a>, and <a class="el" href="StaticValueUtils_8h_source.html#l00038">mlir::Range::stride</a>.</p>

</div>
</div>
<a id="acad8f15b79c90ee0690435ef9f1377bf" name="acad8f15b79c90ee0690435ef9f1377bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad8f15b79c90ee0690435ef9f1377bf">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[36/44]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1StridedMetadataRange.html">StridedMetadataRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the strided metadata to <span class="tt">os</span>. </p>

<p class="definition">Definition at line <a class="el" href="InferStridedMetadataInterface_8h_source.html#l00132">132</a> of file <a class="el" href="InferStridedMetadataInterface_8h_source.html">InferStridedMetadataInterface.h</a>.</p>

<p class="reference">References <a class="el" href="InferStridedMetadataInterface_8cpp_source.html#l00018">mlir::StridedMetadataRange::print()</a>.</p>

</div>
</div>
<a id="a92c9dfdfaa5c9ea5bc0f92d5c5958ade" name="a92c9dfdfaa5c9ea5bc0f92d5c5958ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c9dfdfaa5c9ea5bc0f92d5c5958ade">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[37/44]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>types</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit a type range to the given output stream. </p>

<p class="definition">Definition at line <a class="el" href="TypeRange_8h_source.html#l00079">79</a> of file <a class="el" href="TypeRange_8h_source.html">TypeRange.h</a>.</p>

</div>
</div>
<a id="a8e27c9f52d26754f19dd7389f3fcba13" name="a8e27c9f52d26754f19dd7389f3fcba13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e27c9f52d26754f19dd7389f3fcba13">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[38/44]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperationName.html">OperationName</a></td>          <td class="paramname"><span class="paramname"><em>info</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OperationSupport_8h_source.html#l00507">507</a> of file <a class="el" href="OperationSupport_8h_source.html">OperationSupport.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l00060">mlir::OperationName::print()</a>.</p>

</div>
</div>
<a id="a8c357b30f2e56803678fe5f7b75e80a1" name="a8c357b30f2e56803678fe5f7b75e80a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c357b30f2e56803678fe5f7b75e80a1">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[39/44]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>ofr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow printing to a stream. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00307">307</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="a4b8f6ec965d2fe8aa8366a1a2a3a5625" name="a4b8f6ec965d2fe8aa8366a1a2a3a5625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b8f6ec965d2fe8aa8366a1a2a3a5625">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[40/44]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpState.html">OpState</a></td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow printing to a stream. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00315">315</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="OpDefinition_8h_source.html#l00118">mlir::OpState::print()</a>.</p>

</div>
</div>
<a id="abc6d43cb09978b626a10009d6717ac19" name="abc6d43cb09978b626a10009d6717ac19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6d43cb09978b626a10009d6717ac19">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[41/44]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpWithFlags.html">OpWithFlags</a></td>          <td class="paramname"><span class="paramname"><em>opWithFlags</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Operation_8h_source.html#l01125">1125</a> of file <a class="el" href="IR_2Operation_8h_source.html">Operation.h</a>.</p>

</div>
</div>
<a id="a78425f2c879f5b708f5c58af03931e9f" name="a78425f2c879f5b708f5c58af03931e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78425f2c879f5b708f5c58af03931e9f">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[42/44]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SymbolTable.html#a4f1a6f39b93a08abe4e80a5c15fe32b8">SymbolTable::Visibility</a></td>          <td class="paramname"><span class="paramname"><em>visibility</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SymbolTable_8cpp_source.html#l00465">465</a> of file <a class="el" href="SymbolTable_8cpp_source.html">SymbolTable.cpp</a>.</p>

<p class="reference">References <a class="el" href="SymbolTable_8h_source.html#l00103">mlir::SymbolTable::Nested</a>, <a class="el" href="SymbolTable_8h_source.html#l00097">mlir::SymbolTable::Private</a>, and <a class="el" href="SymbolTable_8h_source.html#l00093">mlir::SymbolTable::Public</a>.</p>

</div>
</div>
<a id="a6786609f81b82b6052450de22a9b1b26" name="a6786609f81b82b6052450de22a9b1b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6786609f81b82b6052450de22a9b1b26">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[43/44]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00237">237</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l03985">mlir::Type::print()</a>.</p>

</div>
</div>
<a id="a95e1190b2da04d950c05089d47cd09ff" name="a95e1190b2da04d950c05089d47cd09ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e1190b2da04d950c05089d47cd09ff">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[44/44]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Value_8h_source.html#l00246">246</a> of file <a class="el" href="Value_8h_source.html">Value.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l04041">mlir::Value::print()</a>.</p>

</div>
</div>
<a id="a8fc3d1f66f267d9111234fac1effdfce" name="a8fc3d1f66f267d9111234fac1effdfce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc3d1f66f267d9111234fac1effdfce">&#9670;&#160;</a></span>operator==() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueTypeRange.html">ValueTypeRange</a>&lt; RangeT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeRange_8h_source.html#l00167">167</a> of file <a class="el" href="TypeRange_8h_source.html">TypeRange.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>.</p>

</div>
</div>
<a id="abc4f129dda2c412845b5ec66a77325a3" name="abc4f129dda2c412845b5ec66a77325a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4f129dda2c412845b5ec66a77325a3">&#9670;&#160;</a></span>operator==() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpState.html">OpState</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpState.html">OpState</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00262">262</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>.</p>

</div>
</div>
<a id="a543c4328a4fa5ed530aa88a9d7d158a9" name="a543c4328a4fa5ed530aa88a9d7d158a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543c4328a4fa5ed530aa88a9d7d158a9">&#9670;&#160;</a></span>operator==() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::operator== </td>
          <td>(</td>
          <td class="paramtype">StringAttr</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define comparisons for StringAttr against nullptr and itself to avoid the StringRef overloads from being chosen when not desirable. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01059">1059</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l01035">mlir::ValueBoundsConstraintSet::BoundBuilder::operator==()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l01015">mlir::ValueBoundsConstraintSet::BoundBuilder::operator==()</a>.</p>

</div>
</div>
<a id="a40ce38cb70a016263f28574d4982475b" name="a40ce38cb70a016263f28574d4982475b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ce38cb70a016263f28574d4982475b">&#9670;&#160;</a></span>operator==() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::operator== </td>
          <td>(</td>
          <td class="paramtype">StringAttr</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringAttr</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01063">1063</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>.</p>

</div>
</div>
<a id="a075d7bf5dfe5d33c409763bc28330180" name="a075d7bf5dfe5d33c409763bc28330180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075d7bf5dfe5d33c409763bc28330180">&#9670;&#160;</a></span>operator==() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::operator== </td>
          <td>(</td>
          <td class="paramtype">StringAttr</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow direct comparison with StringRef. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01069">1069</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>.</p>

</div>
</div>
<a id="a50c46bfb0a0fbbe700ef6c07a611dbf8" name="a50c46bfb0a0fbbe700ef6c07a611dbf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c46bfb0a0fbbe700ef6c07a611dbf8">&#9670;&#160;</a></span>operator==() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::operator== </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringAttr</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01073">1073</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>.</p>

</div>
</div>
<a id="a609ab9ceb7a2ad554864c86fc7ece4fd" name="a609ab9ceb7a2ad554864c86fc7ece4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609ab9ceb7a2ad554864c86fc7ece4fd">&#9670;&#160;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> mlir::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataFlowFramework_8h_source.html#l00041">41</a> of file <a class="el" href="DataFlowFramework_8h_source.html">DataFlowFramework.h</a>.</p>

<p class="reference">References <a class="el" href="DataFlowFramework_8h_source.html#l00039">Change</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>.</p>

</div>
</div>
<a id="aff732a72842f5442e81cce4ac2679355" name="aff732a72842f5442e81cce4ac2679355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff732a72842f5442e81cce4ac2679355">&#9670;&#160;</a></span>operator|=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> &amp; mlir::operator|= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataFlowFramework_8h_source.html#l00044">44</a> of file <a class="el" href="DataFlowFramework_8h_source.html">DataFlowFramework.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>.</p>

</div>
</div>
<a id="a10aad3624e000c0585087c96357ea857" name="a10aad3624e000c0585087c96357ea857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10aad3624e000c0585087c96357ea857">&#9670;&#160;</a></span>outlineIfOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::outlineIfOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::IfOp</td>          <td class="paramname"><span class="paramname"><em>ifOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">func::FuncOp *</td>          <td class="paramname"><span class="paramname"><em>thenFn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>thenFnName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">func::FuncOp *</td>          <td class="paramname"><span class="paramname"><em>elseFn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>elseFnName</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outline the then and/or else regions of <span class="tt">ifOp</span> as follows: </p>
<ul>
<li>if <span class="tt">thenFn</span> is not null, <span class="tt">thenFnName</span> must be specified and the <span class="tt">then</span> region is inlined into a new FuncOp that is captured by the pointer.</li>
<li>if <span class="tt">elseFn</span> is not null, <span class="tt">elseFnName</span> must be specified and the <span class="tt">else</span> region is inlined into a new FuncOp that is captured by the pointer. Creates new FuncOps and thus cannot be used in a FuncOp pass. The client is responsible for providing a unique <span class="tt">thenFnName</span>/<span class="tt">elseFnName</span> that will not collide with another FuncOp name. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00217">217</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00114">outlineSingleBlockRegion()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="ae9152a09d079148a1a2f40d4946f7c17" name="ae9152a09d079148a1a2f40d4946f7c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9152a09d079148a1a2f40d4946f7c17">&#9670;&#160;</a></span>outlineKernelFunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gpu::GPUFuncOp mlir::outlineKernelFunc </td>
          <td>(</td>
          <td class="paramtype">gpu::LaunchOp</td>          <td class="paramname"><span class="paramname"><em>launchOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>kernelFnName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">llvm::SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a gpu.func created from outlining the region of a gpu.launch op with the given <span class="tt">kernelFnName</span>. </p>
<p>The region of the <span class="tt">launchOp</span> can use values from above. These need to be captured and passed as arguments to the generated gpu.func. The generated function has arguments</p><ul>
<li>corresponding to the values passed in as <span class="tt">operands</span>, in that order.</li>
<li>any additional values that might be used within the region of the <span class="tt">launchOp</span> and defined above it. These captured values are appended to the <span class="tt">operands</span> list. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="KernelOutlining_8cpp_source.html#l00264">264</a> of file <a class="el" href="KernelOutlining_8cpp_source.html">KernelOutlining.cpp</a>.</p>

<p class="reference">References <a class="el" href="KernelOutlining_8cpp_source.html#l00177">outlineKernelFuncImpl()</a>.</p>

</div>
</div>
<a id="abdec8fa23b93085ee2e142defd7c5599" name="abdec8fa23b93085ee2e142defd7c5599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdec8fa23b93085ee2e142defd7c5599">&#9670;&#160;</a></span>outlineSingleBlockRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; func::FuncOp &gt; mlir::outlineSingleBlockRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>region</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>funcName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">func::CallOp *</td>          <td class="paramname"><span class="paramname"><em>callOp</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outline a region with a single block into a new FuncOp. </p>
<p>Assumes the FuncOp result types is the type of the yielded operands of the single block. This constraint makes it easy to determine the result. This method also clones the <span class="tt"><a class="el" href="classmlir_1_1arith_1_1ConstantIndexOp.html" title="Specialization of arith.constant op that returns an integer of index type.">arith::ConstantIndexOp</a></span> at the start of <span class="tt">outlinedFuncBody</span> to alloc simple canonicalizations. Creates a new FuncOp and thus cannot be used in a FuncOp pass. The client is responsible for providing a unique <span class="tt">funcName</span> that will not collide with another FuncOp name. If <span class="tt">callOp</span> is provided, it will be set to point to the operation that calls the outlined function.</p>
<p>Assumes the FuncOp result types is the type of the yielded operands of the single block. This constraint makes it easy to determine the result. This method also clones the <span class="tt"><a class="el" href="classmlir_1_1arith_1_1ConstantIndexOp.html" title="Specialization of arith.constant op that returns an integer of index type.">arith::ConstantIndexOp</a></span> at the start of <span class="tt">outlinedFuncBody</span> to alloc simple canonicalizations. If <span class="tt">callOp</span> is provided, it will be set to point to the operation that calls the outlined function. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00114">114</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00055">mlir::Region::begin()</a>, <a class="el" href="Builders_8cpp_source.html#l00562">mlir::OpBuilder::clone()</a>, <a class="el" href="Builders_8cpp_source.html#l00430">mlir::OpBuilder::createBlock()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00155">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="Block_8h_source.html#l00087">mlir::Block::getArguments()</a>, <a class="el" href="IR_2Region_8h_source.html#l00081">mlir::Region::getArguments()</a>, <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="Block_8h_source.html#l00128">mlir::Block::getNumArguments()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00378">mlir::Operation::getOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00397">mlir::Operation::getOperandTypes()</a>, <a class="el" href="UseDefLists_8h_source.html#l00038">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="IR_2Region_8h_source.html#l00205">mlir::Region::getParentOfType()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00407">mlir::Operation::getResult()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00428">mlir::Operation::getResultTypes()</a>, <a class="el" href="Block_8cpp_source.html#l00244">mlir::Block::getTerminator()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00070">getUsedValuesDefinedAbove()</a>, <a class="el" href="IR_2Region_8h_source.html#l00068">mlir::Region::hasOneBlock()</a>, <a class="el" href="IRMapping_8h_source.html#l00030">mlir::IRMapping::map()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00343">mlir::RewriterBase::mergeBlocks()</a>, <a class="el" href="Value_8cpp_source.html#l00091">mlir::Value::replaceUsesWithIf()</a>, <a class="el" href="Builders_8h_source.html#l00398">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="Builders_8h_source.html#l00436">mlir::OpBuilder::setInsertionPointToEnd()</a>, and <a class="el" href="Builders_8h_source.html#l00431">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00217">outlineIfOp()</a>.</p>

</div>
</div>
<a id="ad02ff92115796118c612bc82db603b7e" name="ad02ff92115796118c612bc82db603b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02ff92115796118c612bc82db603b7e">&#9670;&#160;</a></span>parallelFor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FuncT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::parallelFor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncT &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the given function on the elements between [begin, end) asynchronously. </p>
<p>Diagnostics emitted during processing are ordered relative to the element's position within [begin, end). If the provided context does not have multi-threading enabled, this function always processes elements sequentially. </p>

<p class="definition">Definition at line <a class="el" href="Threading_8h_source.html#l00141">141</a> of file <a class="el" href="Threading_8h_source.html">Threading.h</a>.</p>

<p class="reference">References <a class="el" href="Threading_8h_source.html#l00117">parallelForEach()</a>.</p>

</div>
</div>
<a id="a7acf0c58d63da562112dd8f6a81b49e3" name="a7acf0c58d63da562112dd8f6a81b49e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7acf0c58d63da562112dd8f6a81b49e3">&#9670;&#160;</a></span>parallelForEach() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorT, typename FuncT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::parallelForEach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncT &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the given function on the elements between [begin, end) asynchronously. </p>
<p>Diagnostics emitted during processing are ordered relative to the element's position within [begin, end). If the provided context does not have multi-threading enabled, this function always processes elements sequentially. </p>

<p class="definition">Definition at line <a class="el" href="Threading_8h_source.html#l00117">117</a> of file <a class="el" href="Threading_8h_source.html">Threading.h</a>.</p>

<p class="reference">References <a class="el" href="Threading_8h_source.html#l00036">failableParallelForEach()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Threading_8h_source.html#l00141">parallelFor()</a>, and <a class="el" href="Threading_8h_source.html#l00130">parallelForEach()</a>.</p>

</div>
</div>
<a id="af1232c5821e793866aa3cf2234e1ba93" name="af1232c5821e793866aa3cf2234e1ba93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1232c5821e793866aa3cf2234e1ba93">&#9670;&#160;</a></span>parallelForEach() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT, typename FuncT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::parallelForEach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RangeT &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncT &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the given function on the elements in the provided range asynchronously. </p>
<p>Diagnostics emitted during processing are ordered relative to the element's position within the range. If the provided context does not have multi-threading enabled, this function always processes elements sequentially. </p>

<p class="definition">Definition at line <a class="el" href="Threading_8h_source.html#l00130">130</a> of file <a class="el" href="Threading_8h_source.html">Threading.h</a>.</p>

<p class="reference">References <a class="el" href="Threading_8h_source.html#l00117">parallelForEach()</a>.</p>

</div>
</div>
<a id="a926832e2ae31cbf66f87b6508bca56cd" name="a926832e2ae31cbf66f87b6508bca56cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a926832e2ae31cbf66f87b6508bca56cd">&#9670;&#160;</a></span>parallelLoopUnrollByFactors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; scf::ParallelOp &gt; mlir::parallelLoopUnrollByFactors </td>
          <td>(</td>
          <td class="paramtype">scf::ParallelOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>unrollFactors</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>annotateFn</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> *</td>          <td class="paramname"><span class="paramname"><em>clonedToSrcOpsMap</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unroll this scf::Parallel loop by the specified unroll factors. </p>
<p>Returns the unrolled loop if the unroll succeded; otherwise returns failure if the loop cannot be unrolled either due to restrictions or to invalid unroll factors. Requires positive loop bounds and step. If specified, annotates the Ops in each unrolled iteration by applying <span class="tt">annotateFn</span>. If provided, 'clonedToSrcOpsMap' is populated with the mappings from the cloned ops to the original op. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01580">1580</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00294">generateUnrolledLoop()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">getConstantIntValue()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01563">getConstLoopTripCounts()</a>, <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="Builders_8h_source.html#l00390">mlir::OpBuilder::restoreInsertionPoint()</a>, <a class="el" href="Builders_8h_source.html#l00385">mlir::OpBuilder::saveInsertionPoint()</a>, <a class="el" href="Builders_8h_source.html#l00398">mlir::OpBuilder::setInsertionPoint()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02103">ValueRange</a>.</p>

</div>
</div>
<a id="a351183b9c1036310349dea952c1f2d5a" name="a351183b9c1036310349dea952c1f2d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351183b9c1036310349dea952c1f2d5a">&#9670;&#160;</a></span>parseAffineMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::parseAffineMap </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses a single IntegerSet/AffineMap to an MLIR context if it was valid. </p>
<p>If not, an error message is emitted through a new <a class="el" href="classmlir_1_1SourceMgrDiagnosticHandler.html" title="This class is a utility diagnostic handler for use with llvm::SourceMgr.">SourceMgrDiagnosticHandler</a> constructed from a new SourceMgr with a single MemoryBuffer wrapping <span class="tt">str</span>. If the passed <span class="tt">str</span> has additional tokens that were not part of the IntegerSet/AffineMap, a failure is returned. </p>

</div>
</div>
<a id="a2ce4d766139754b57d04b314aefacea5" name="a2ce4d766139754b57d04b314aefacea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce4d766139754b57d04b314aefacea5">&#9670;&#160;</a></span>parseAsmSourceFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::parseAsmSourceFile </td>
          <td>(</td>
          <td class="paramtype">const llvm::SourceMgr &amp;</td>          <td class="paramname"><span class="paramname"><em>sourceMgr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>config</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmParserState.html">AsmParserState</a> *</td>          <td class="paramname"><span class="paramname"><em>asmState</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmParserCodeCompleteContext.html">AsmParserCodeCompleteContext</a> *</td>          <td class="paramname"><span class="paramname"><em>codeCompleteContext</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated SourceMgr and appends parsed operations to the given block. </p>
<p>If the block is non-empty, the operations are placed before the current terminator. If parsing is successful, success is returned. Otherwise, an error message is emitted through the error handler registered in the context, and failure is returned. If <span class="tt">sourceFileLoc</span> is non-null, it is populated with a file location representing the start of the source file that is being parsed. If <span class="tt">asmState</span> is non-null, it is populated with detailed information about the parsed IR (including exact locations for SSA uses and definitions). <span class="tt">asmState</span> should only be provided if this detailed information is desired. If <span class="tt">codeCompleteContext</span> is non-null, it is used to signal tracking of a code completion event (generally only ever useful for LSP or other high level language tooling). </p>

<p class="definition">Definition at line <a class="el" href="AsmParser_2Parser_8cpp_source.html#l02918">2918</a> of file <a class="el" href="AsmParser_2Parser_8cpp_source.html">Parser.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00284">config</a>, and <a class="el" href="Location_8cpp_source.html#l00157">mlir::FileLineColLoc::get()</a>.</p>

</div>
</div>
<a id="a6658f887276425945e0ebe6fcc194c23" name="a6658f887276425945e0ebe6fcc194c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6658f887276425945e0ebe6fcc194c23">&#9670;&#160;</a></span>parseAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::parseAttribute </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef</td>          <td class="paramname"><span class="paramname"><em>attrStr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>numRead</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>isKnownNullTerminated</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses a single MLIR attribute to an MLIR context if it was valid. </p>
<p>If not, an error diagnostic is emitted to the context and a null value is returned. If <span class="tt">numRead</span> is provided, it is set to the number of consumed characters on successful parse. Otherwise, parsing fails if the entire string is not consumed. Some internal copying can be skipped if the source string is known to be null terminated. </p>

<p class="reference">Referenced by <a class="el" href="KernelOutlining_8cpp_source.html#l00335">createGpuKernelOutliningPass()</a>, and <a class="el" href="IR_8cpp_source.html#l01276">mlirAttributeParseGet()</a>.</p>

</div>
</div>
<a id="a0671bbb5d03153a40cb4574afd081c92" name="a0671bbb5d03153a40cb4574afd081c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0671bbb5d03153a40cb4574afd081c92">&#9670;&#160;</a></span>parseCLIOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, std::string &gt; mlir::parseCLIOptions </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>argc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef</td>          <td class="paramname"><span class="paramname"><em>helpHeader</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse command line options. </p>
<ul>
<li>helpHeader is used for the header displayed by <span class="tt">--help</span>.</li>
<li>return std::pair&lt;std::string, std::string&gt; for inputFilename and outputFilename command line option values. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="MlirOptMain_8cpp_source.html#l00704">704</a> of file <a class="el" href="MlirOptMain_8cpp_source.html">MlirOptMain.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00716">registerAndParseCLIOptions()</a>.</p>

</div>
</div>
<a id="a12d828f0860b1c0863b1badf0fe06e30" name="a12d828f0860b1c0863b1badf0fe06e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d828f0860b1c0863b1badf0fe06e30">&#9670;&#160;</a></span>parseDimensionList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult mlir::parseDimensionList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a12cd3f8e7b8c9f2cac6f17ff1dd80cd8">DenseI64ArrayAttr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dimensions</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l04196">4196</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1AsmParser.html#a33803273c4fc1a660d73cb91aceac30b">mlir::AsmParser::emitError()</a>, <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html#a07a6e71658d0790d8e265c0bc364923e">mlir::detail::DenseArrayAttrImpl&lt; int64_t &gt;::get()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l00072">mlir::AsmParser::getContext()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a7850fe0a2961f835384adb372758d58b">mlir::AsmParser::getCurrentLocation()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a55d178f0d42011618d0c479b1d48cc0a">mlir::AsmParser::parseDimensionList()</a>, <a class="el" href="classmlir_1_1AsmParser.html#aed41da9f5ed12ea4b41136ef1b6239dd">mlir::AsmParser::parseOptionalLSquare()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a3a1446df423154a41d52374b062ee1ff">mlir::AsmParser::parseRSquare()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a29a5b016cd9b34a332636231a29f78d1" name="a29a5b016cd9b34a332636231a29f78d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a5b016cd9b34a332636231a29f78d1">&#9670;&#160;</a></span>parseDynamicIndexList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult mlir::parseDynamicIndexList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">OpAsmParser::UnresolvedOperand</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a12cd3f8e7b8c9f2cac6f17ff1dd80cd8">DenseI64ArrayAttr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>integers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#abac17268f4f35fc764ae9f810faad3df">DenseBoolArrayAttr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>scalableFlags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>valueTypes</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">AsmParser::Delimiter</a></td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">AsmParser::Delimiter::Square</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parser hooks for custom directive in assemblyFormat. </p>
<p>custom&lt;DynamicIndexList&gt;($values, $integers) custom&lt;DynamicIndexList&gt;($values, $integers, type($values))</p>
<p>where <span class="tt">values</span> is of ODS type <span class="tt">Variadic&lt;*&gt;</span> and <span class="tt">integers</span> is of ODS type <span class="tt">I64ArrayAttr</span>. Parse a mixed list where each element is either a static integer or an SSA value. Fill <span class="tt">integers</span> with the integer ArrayAttr, where <span class="tt">kDynamic</span> encodes the position of SSA values. Add the parsed SSA values to <span class="tt">values</span> in-order.</p>
<p>If <span class="tt">valueTypes</span> is provided, fill it with the types corresponding to each value in <span class="tt">values</span>. Otherwise, the caller must handle the types and parsing will fail if the type of the value is found (e.g., <span class="tt">[arg0 : index, 3, arg1
/ : index]</span>). </p><pre class="fragment">Integer indices can also be scalable in the context of scalable vectors,
denoted by square brackets (e.g., "[2, [4], 8]"). For each value in
`integers`, the corresponding `bool` in `scalableFlags` encodes whether it's
a scalable index.

Examples:

  * After parsing "[%arg0 : index, 7, 42, %arg42 : i32]":
      1. `result` is filled with `[kDynamic, 7, 42, kDynamic]`
      2. `values` is filled with "[%arg0, %arg1]".
      3. `scalableFlags` is filled with `[false, true, false]`.

  * After parsing `[2, [4], 8]`:
      1. `result` is filled with `[2, 4, 8]`
      2. `values` is empty.
      3. `scalableFlags` is filled with `[false, true, false]`.
</pre> 
<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00231">231</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1AsmParser.html#a33803273c4fc1a660d73cb91aceac30b">mlir::AsmParser::emitError()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a1d400e969b4479eec3faf8f272c99f44">mlir::AsmParser::getBuilder()</a>, <a class="el" href="Builders_8cpp_source.html#l00151">mlir::Builder::getDenseBoolArrayAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00167">mlir::Builder::getDenseI64ArrayAttr()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a8d00f93debeb1567ae8f7bbb76cdea37">mlir::AsmParser::getNameLoc()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a709cff503c00735e0a35ecd795364a2a">mlir::AsmParser::parseColonType()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2839f5b817f7fd118a6b0381da695436">mlir::AsmParser::parseCommaSeparatedList()</a>, <a class="el" href="OpImplementation_8h_source.html#l00752">mlir::AsmParser::parseInteger()</a>, <a class="el" href="classmlir_1_1AsmParser.html#aed41da9f5ed12ea4b41136ef1b6239dd">mlir::AsmParser::parseOptionalLSquare()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a8fd765b541880aa1f11ca238ce62ad9d">mlir::OpAsmParser::parseOptionalOperand()</a>, <a class="el" href="classmlir_1_1AsmParser.html#aacb77758ffb3701ad5ede6299de580f0">mlir::AsmParser::parseOptionalRSquare()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ViewLikeInterface_8h_source.html#l00216">parseDynamicIndexList()</a>, and <a class="el" href="Dialect_2Transform_2Utils_2Utils_8cpp_source.html#l00033">mlir::transform::parsePackedOrDynamicIndexList()</a>.</p>

</div>
</div>
<a id="a113026edf72f8e99369fc9128e2e0da2" name="a113026edf72f8e99369fc9128e2e0da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113026edf72f8e99369fc9128e2e0da2">&#9670;&#160;</a></span>parseDynamicIndexList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult mlir::parseDynamicIndexList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">OpAsmParser::UnresolvedOperand</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a12cd3f8e7b8c9f2cac6f17ff1dd80cd8">DenseI64ArrayAttr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>integers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>valueTypes</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">AsmParser::Delimiter</a></td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">AsmParser::Delimiter::Square</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8h_source.html#l00216">216</a> of file <a class="el" href="ViewLikeInterface_8h_source.html">ViewLikeInterface.h</a>.</p>

<p class="reference">References <a class="el" href="ViewLikeInterface_8cpp_source.html#l00231">parseDynamicIndexList()</a>, and <a class="el" href="OpImplementation_8h_source.html#l00818">mlir::AsmParser::Square</a>.</p>

</div>
</div>
<a id="acda383f3d69ddb866ea67abc7ba9e75e" name="acda383f3d69ddb866ea67abc7ba9e75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda383f3d69ddb866ea67abc7ba9e75e">&#9670;&#160;</a></span>parseIntegerSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> mlir::parseIntegerSet </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8d10077c7edf58c1152a1170257d739" name="ad8d10077c7edf58c1152a1170257d739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d10077c7edf58c1152a1170257d739">&#9670;&#160;</a></span>parsePassPipeline() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::parsePassPipeline </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>pipeline</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>errorStream</em></span><span class="paramdefsep"> = </span><span class="paramdefval">llvm::errs()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the textual representation of a pass pipeline, adding the result to 'pm' on success. </p>
<p>Returns failure if the given pipeline was invalid. 'errorStream' is the output stream used to emit errors found during parsing. </p>

<p class="definition">Definition at line <a class="el" href="PassRegistry_8cpp_source.html#l00768">768</a> of file <a class="el" href="PassRegistry_8cpp_source.html">PassRegistry.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PassRegistry_8cpp_source.html#l01005">mlir::PassPipelineCLParser::addToPipeline()</a>, <a class="el" href="PassCrashRecovery_8cpp_source.html#l00517">mlir::PassReproducerOptions::apply()</a>, <a class="el" href="CAPI_2IR_2Pass_8cpp_source.html#l00116">mlirOpPassManagerAddPipeline()</a>, <a class="el" href="CAPI_2IR_2Pass_8cpp_source.html#l00131">mlirParsePassPipeline()</a>, and <a class="el" href="PassRegistry_8cpp_source.html#l00782">parsePassPipeline()</a>.</p>

</div>
</div>
<a id="aef5abaea7950d9dc385a018dbbb40d0b" name="aef5abaea7950d9dc385a018dbbb40d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5abaea7950d9dc385a018dbbb40d0b">&#9670;&#160;</a></span>parsePassPipeline() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &gt; mlir::parsePassPipeline </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>pipeline</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>errorStream</em></span><span class="paramdefsep"> = </span><span class="paramdefval">llvm::errs()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the given textual representation of a pass pipeline, and return the parsed pipeline on success. </p>
<p>The given pipeline string should be wrapped with the desired type of operation to root the created operation, i.e. <span class="tt">builtin.module(cse)</span> over <span class="tt">cse</span>. Returns failure if the given pipeline was invalid. 'errorStream' is the output stream used to emit errors found during parsing. </p>

<p class="definition">Definition at line <a class="el" href="PassRegistry_8cpp_source.html#l00782">782</a> of file <a class="el" href="PassRegistry_8cpp_source.html">PassRegistry.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassRegistry_8cpp_source.html#l00768">parsePassPipeline()</a>.</p>

</div>
</div>
<a id="a3ee9c22e4e76e3de2f4c6da9783145a4" name="a3ee9c22e4e76e3de2f4c6da9783145a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee9c22e4e76e3de2f4c6da9783145a4">&#9670;&#160;</a></span>parseSemiFunctionType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult mlir::parseSemiFunctionType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>argumentType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>resultTypes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Syntax_8cpp_source.html#l00033">33</a> of file <a class="el" href="Syntax_8cpp_source.html">Syntax.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1AsmParser.html#aadaac62d4dff4fde5f3a8b9ee355d923">mlir::AsmParser::parseArrow()</a>, <a class="el" href="classmlir_1_1AsmParser.html#aca8bb7b19bcdc7638597791aff1bafed">mlir::AsmParser::parseOptionalLParen()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a33657a4e5f2cd8018b6d57d468b5f04a">mlir::AsmParser::parseRParen()</a>, <a class="el" href="classmlir_1_1AsmParser.html#ab85d23c93adf11e18d6507779bf95fad">mlir::AsmParser::parseType()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l00077">mlir::AsmParser::parseTypeList()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a774412201bb8ce6277dff9e9a73c8f68" name="a774412201bb8ce6277dff9e9a73c8f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774412201bb8ce6277dff9e9a73c8f68">&#9670;&#160;</a></span>parseSemiFunctionType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult mlir::parseSemiFunctionType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>argumentType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>resultType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>resultOptional</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a single non-function type or a function type with at least one argument. </p>
<p>This allows for the following syntax:</p>
<ul>
<li>type: just the argument type;</li>
<li><span class="tt">(</span> type <span class="tt">)</span> <span class="tt">-&gt;</span> type: one argument and one result type;</li>
<li><span class="tt">(</span> type <span class="tt">)</span> <span class="tt">-&gt;</span> <span class="tt">(</span> comma-separated-type-list <span class="tt">)</span>: one argument and multiple result types.</li>
</ul>
<p>Unlike FunctionType, this allows and requires one to omit the parens around the argument type in absence of result types, and does not accept the trailing <span class="tt">-&gt; ()</span> construct, which makes the syntax nicer for operations. </p>

<p class="definition">Definition at line <a class="el" href="Syntax_8cpp_source.html#l00015">15</a> of file <a class="el" href="Syntax_8cpp_source.html">Syntax.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1AsmParser.html#aadaac62d4dff4fde5f3a8b9ee355d923">mlir::AsmParser::parseArrow()</a>, <a class="el" href="classmlir_1_1AsmParser.html#ab4382d557de477b5b1b7bbfbbf7ba03f">mlir::AsmParser::parseLParen()</a>, <a class="el" href="classmlir_1_1AsmParser.html#aca8bb7b19bcdc7638597791aff1bafed">mlir::AsmParser::parseOptionalLParen()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a33657a4e5f2cd8018b6d57d468b5f04a">mlir::AsmParser::parseRParen()</a>, <a class="el" href="classmlir_1_1AsmParser.html#ab85d23c93adf11e18d6507779bf95fad">mlir::AsmParser::parseType()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="ab0f975095772c8ece0dbda8bf7f455eb" name="ab0f975095772c8ece0dbda8bf7f455eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f975095772c8ece0dbda8bf7f455eb">&#9670;&#160;</a></span>parseSourceFile() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">const llvm::SourceMgr &amp;</td>          <td class="paramname"><span class="paramname"><em>sourceMgr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>config</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *</td>          <td class="paramname"><span class="paramname"><em>sourceFileLoc</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated SourceMgr and appends parsed operations to the given block. </p>
<p>If the block is non-empty, the operations are placed before the current terminator. If parsing is successful, success is returned. Otherwise, an error message is emitted through the error handler registered in the context, and failure is returned. If <span class="tt">sourceFileLoc</span> is non-null, it is populated with a file location representing the start of the source file that is being parsed. </p>

<p class="definition">Definition at line <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l00038">38</a> of file <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html">Parser.cpp</a>.</p>

<p class="reference">References <a class="el" href="Tools_2PDLL_2AST_2Types_8cpp_source.html#l00112">mlir::pdll::ast::TypeRangeType::get()</a>, <a class="el" href="Tools_2PDLL_2AST_2Types_8cpp_source.html#l00166">mlir::pdll::ast::TypeType::get()</a>, <a class="el" href="Tools_2PDLL_2AST_2Types_8cpp_source.html#l00174">mlir::pdll::ast::ValueType::get()</a>, and <a class="el" href="AST_2Context_8h_source.html#l00042">mlir::pdll::ast::Context::getDiagEngine()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MLIRServer_8cpp_source.html#l01355">mlir::lsp::MLIRServer::convertFromBytecode()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00385">loadIRDLDialects()</a>, <a class="el" href="IR_8cpp_source.html#l00437">mlirModuleCreateParseFromFile()</a>, <a class="el" href="MlirQueryMain_8cpp_source.html#l00032">mlirQueryMain()</a>, <a class="el" href="ParseUtilities_8h_source.html#l00027">parseSourceFileForTool()</a>, and <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00088">mlir::transform::detail::parseTransformModuleFromFile()</a>.</p>

</div>
</div>
<a id="abd9f27d3cd1ed0e2476079e5b21bd280" name="abd9f27d3cd1ed0e2476079e5b21bd280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd9f27d3cd1ed0e2476079e5b21bd280">&#9670;&#160;</a></span>parseSourceFile() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT = Operation *&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt; mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">const llvm::SourceMgr &amp;</td>          <td class="paramname"><span class="paramname"><em>sourceMgr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>config</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated SourceMgr. </p>
<p>If the source IR contained a single instance of <span class="tt">ContainerOpT</span>, it is returned. Otherwise, a new instance of <span class="tt">ContainerOpT</span> is constructed containing all of the parsed operations. If parsing was not successful, null is returned and an error message is emitted through the error handler registered in the context, and failure is returned. <span class="tt">ContainerOpT</span> is required to have a single region containing a single block, and must implement the <span class="tt">SingleBlockImplicitTerminator</span> trait. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00176">176</a> of file <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00284">config</a>, and <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00154">mlir::detail::parseSourceFile()</a>.</p>

</div>
</div>
<a id="a537a80c31d8487a710f53cd9a38e390a" name="a537a80c31d8487a710f53cd9a38e390a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537a80c31d8487a710f53cd9a38e390a">&#9670;&#160;</a></span>parseSourceFile() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sourceMgr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>config</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *</td>          <td class="paramname"><span class="paramname"><em>sourceFileLoc</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An overload with a source manager that may have references taken during the parsing process, and whose lifetime can be freely extended (such that the source manager is not destroyed before the parsed IR). </p>
<p>This is useful, for example, to avoid copying some large resources into the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a> and instead referencing the data directly from the input buffers. </p>

<p class="definition">Definition at line <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l00052">52</a> of file <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html">Parser.cpp</a>.</p>

<p class="reference">References <a class="el" href="Tools_2PDLL_2AST_2Types_8cpp_source.html#l00056">mlir::pdll::ast::AttributeType::get()</a>, and <a class="el" href="Tools_2PDLL_2AST_2Types_8cpp_source.html#l00126">mlir::pdll::ast::ValueRangeType::get()</a>.</p>

</div>
</div>
<a id="a1cb2000f972c9b5bdd065f9df337daf6" name="a1cb2000f972c9b5bdd065f9df337daf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb2000f972c9b5bdd065f9df337daf6">&#9670;&#160;</a></span>parseSourceFile() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT = Operation *&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt; mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sourceMgr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>config</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An overload with a source manager that may have references taken during the parsing process, and whose lifetime can be freely extended (such that the source manager is not destroyed before the parsed IR). </p>
<p>This is useful, for example, to avoid copying some large resources into the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a> and instead referencing the data directly from the input buffers. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00186">186</a> of file <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00284">config</a>, and <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00154">mlir::detail::parseSourceFile()</a>.</p>

</div>
</div>
<a id="a006a32917056b7f14d65e9ea5cc08392" name="a006a32917056b7f14d65e9ea5cc08392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a006a32917056b7f14d65e9ea5cc08392">&#9670;&#160;</a></span>parseSourceFile() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>config</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *</td>          <td class="paramname"><span class="paramname"><em>sourceFileLoc</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated filename and appends parsed operations to the given block. </p>
<p>If the block is non-empty, the operations are placed before the current terminator. If parsing is successful, success is returned. Otherwise, an error message is emitted through the error handler registered in the context, and failure is returned. If <span class="tt">sourceFileLoc</span> is non-null, it is populated with a file location representing the start of the source file that is being parsed. </p>

<p class="definition">Definition at line <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l00067">67</a> of file <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html">Parser.cpp</a>.</p>

</div>
</div>
<a id="a54875232f3a58ed939964dc275d1e36f" name="a54875232f3a58ed939964dc275d1e36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54875232f3a58ed939964dc275d1e36f">&#9670;&#160;</a></span>parseSourceFile() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sourceMgr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>config</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *</td>          <td class="paramname"><span class="paramname"><em>sourceFileLoc</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An overload with a source manager that may have references taken during the parsing process, and whose lifetime can be freely extended (such that the source manager is not destroyed before the parsed IR). </p>
<p>This is useful, for example, to avoid copying some large resources into the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a> and instead referencing the data directly from the input buffers. </p>

<p class="definition">Definition at line <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l00100">100</a> of file <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html">Parser.cpp</a>.</p>

</div>
</div>
<a id="a03c54eff1ecb9aed89506db0c67637ef" name="a03c54eff1ecb9aed89506db0c67637ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c54eff1ecb9aed89506db0c67637ef">&#9670;&#160;</a></span>parseSourceFile() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT = Operation *&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt; mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sourceMgr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>config</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An overload with a source manager that may have references taken during the parsing process, and whose lifetime can be freely extended (such that the source manager is not destroyed before the parsed IR). </p>
<p>This is useful, for example, to avoid copying some large resources into the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a> and instead referencing the data directly from the input buffers. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00226">226</a> of file <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00284">config</a>, and <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00154">mlir::detail::parseSourceFile()</a>.</p>

</div>
</div>
<a id="a13ad011b0b3c1635c410fe60bfd557c2" name="a13ad011b0b3c1635c410fe60bfd557c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ad011b0b3c1635c410fe60bfd557c2">&#9670;&#160;</a></span>parseSourceFile() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::SourceMgr &amp;</td>          <td class="paramname"><span class="paramname"><em>sourceMgr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>config</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *</td>          <td class="paramname"><span class="paramname"><em>sourceFileLoc</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated filename using the provided SourceMgr and appends parsed operations to the given block. </p>
<p>If the block is non-empty, the operations are placed before the current terminator. If parsing is successful, success is returned. Otherwise, an error message is emitted through the error handler registered in the context, and failure is returned. If <span class="tt">sourceFileLoc</span> is non-null, it is populated with a file location representing the start of the source file that is being parsed. </p>

<p class="definition">Definition at line <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l00092">92</a> of file <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html">Parser.cpp</a>.</p>

</div>
</div>
<a id="a268594711173cad736a1f63c3cc87dd2" name="a268594711173cad736a1f63c3cc87dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a268594711173cad736a1f63c3cc87dd2">&#9670;&#160;</a></span>parseSourceFile() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT = Operation *&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt; mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::SourceMgr &amp;</td>          <td class="paramname"><span class="paramname"><em>sourceMgr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>config</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated filename using the provided SourceMgr. </p>
<p>If the source IR contained a single instance of <span class="tt">ContainerOpT</span>, it is returned. Otherwise, a new instance of <span class="tt">ContainerOpT</span> is constructed containing all of the parsed operations. If parsing was not successful, null is returned and an error message is emitted through the error handler registered in the context, and failure is returned. <span class="tt">ContainerOpT</span> is required to have a single region containing a single block, and must implement the <span class="tt">SingleBlockImplicitTerminator</span> trait. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00214">214</a> of file <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00284">config</a>, and <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00154">mlir::detail::parseSourceFile()</a>.</p>

</div>
</div>
<a id="ad8ee13d8990b60e1f9a11f3b4f86b1fa" name="ad8ee13d8990b60e1f9a11f3b4f86b1fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ee13d8990b60e1f9a11f3b4f86b1fa">&#9670;&#160;</a></span>parseSourceFile() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT = Operation *&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt; mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>config</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated filename. </p>
<p>If the source IR contained a single instance of <span class="tt">ContainerOpT</span>, it is returned. Otherwise, a new instance of <span class="tt">ContainerOpT</span> is constructed containing all of the parsed operations. If parsing was not successful, null is returned and an error message is emitted through the error handler registered in the context, and failure is returned. <span class="tt">ContainerOpT</span> is required to have a single region containing a single block, and must implement the <span class="tt">SingleBlockImplicitTerminator</span> trait. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00200">200</a> of file <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00284">config</a>, and <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00154">mlir::detail::parseSourceFile()</a>.</p>

</div>
</div>
<a id="ac869d2ba53c15c3d06e6b879a8f95d3d" name="ac869d2ba53c15c3d06e6b879a8f95d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac869d2ba53c15c3d06e6b879a8f95d3d">&#9670;&#160;</a></span>parseSourceFileForTool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::parseSourceFileForTool </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sourceMgr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>config</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>insertImplicitModule</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated SourceMgr. </p>
<p>If parsing was not successful, null is returned and an error message is emitted through the error handler registered in the context. If 'insertImplicitModule' is true a top-level 'builtin.module' op will be inserted that contains the parsed IR, unless one exists already. </p>

<p class="definition">Definition at line <a class="el" href="ParseUtilities_8h_source.html#l00027">27</a> of file <a class="el" href="ParseUtilities_8h_source.html">ParseUtilities.h</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00284">config</a>, and <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l00038">parseSourceFile()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirReduceMain_8cpp_source.html#l00029">loadModule()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00134">parseMLIRInput()</a>, and <a class="el" href="MlirOptMain_8cpp_source.html#l00496">performActions()</a>.</p>

</div>
</div>
<a id="a80178c9e23c4fd7db357124cbe19651a" name="a80178c9e23c4fd7db357124cbe19651a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80178c9e23c4fd7db357124cbe19651a">&#9670;&#160;</a></span>parseSourceString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::parseSourceString </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef</td>          <td class="paramname"><span class="paramname"><em>sourceStr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>config</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>sourceName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *</td>          <td class="paramname"><span class="paramname"><em>sourceFileLoc</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses the IR string and appends parsed operations to the given block. </p>
<p>If the block is non-empty, the operations are placed before the current terminator. If parsing is successful, success is returned. Otherwise, an error message is emitted through the error handler registered in the context, and failure is returned. <span class="tt">sourceName</span> is used as the file name of the source; any IR without locations will get a <span class="tt"><a class="el" href="classmlir_1_1FileLineColLoc.html" title="An instance of this location represents a tuple of file, line number, and column number.">FileLineColLoc</a></span> location with <span class="tt">sourceName</span> as the file name. If <span class="tt">sourceFileLoc</span> is non-null, it is populated with a file location representing the start of the source file that is being parsed. </p>

<p class="definition">Definition at line <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l00108">108</a> of file <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html">Parser.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleImport_8cpp_source.html#l00057">diag()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00416">doVerifyRoundTrip()</a>, <a class="el" href="IR_8cpp_source.html#l00429">mlirModuleCreateParse()</a>, <a class="el" href="IR_8cpp_source.html#l00626">mlirOperationCreateParse()</a>, and <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00244">parseSourceString()</a>.</p>

</div>
</div>
<a id="af093c42a93dadc189eb4502ffcc4395c" name="af093c42a93dadc189eb4502ffcc4395c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af093c42a93dadc189eb4502ffcc4395c">&#9670;&#160;</a></span>parseSourceString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT = Operation *&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt; mlir::parseSourceString </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef</td>          <td class="paramname"><span class="paramname"><em>sourceStr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>config</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>sourceName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This parses the provided string containing MLIR. </p>
<p>If the source IR contained a single instance of <span class="tt">ContainerOpT</span>, it is returned. Otherwise, a new instance of <span class="tt">ContainerOpT</span> is constructed containing all of the parsed operations. If parsing was not successful, null is returned and an error message is emitted through the error handler registered in the context, and failure is returned. <span class="tt">ContainerOpT</span> is required to have a single region containing a single block, and must implement the <span class="tt">SingleBlockImplicitTerminator</span> trait. <span class="tt">sourceName</span> is used as the file name of the source; any IR without locations will get a <span class="tt"><a class="el" href="classmlir_1_1FileLineColLoc.html" title="An instance of this location represents a tuple of file, line number, and column number.">FileLineColLoc</a></span> location with <span class="tt">sourceName</span> as the file name. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00244">244</a> of file <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00284">config</a>, <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00038">mlir::detail::constructContainerOpForParserIfNecessary()</a>, and <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l00108">parseSourceString()</a>.</p>

</div>
</div>
<a id="abab8375de28e1d1916659a658e7ad318" name="abab8375de28e1d1916659a658e7ad318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab8375de28e1d1916659a658e7ad318">&#9670;&#160;</a></span>parseType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::parseType </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef</td>          <td class="paramname"><span class="paramname"><em>typeStr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>numRead</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>isKnownNullTerminated</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses a single MLIR type to an MLIR context if it was valid. </p>
<p>If not, an error diagnostic is emitted to the context. If <span class="tt">numRead</span> is provided, it is set to the number of consumed characters on successful parse. Otherwise, parsing fails if the entire string is not consumed. Some internal copying can be skipped if the source string is known to be null terminated. </p>

<p class="reference">Referenced by <a class="el" href="IR_8cpp_source.html#l01245">mlirTypeParseGet()</a>, and <a class="el" href="LLVMTypes_8cpp_source.html#l00090">parseExtTypeParams()</a>.</p>

</div>
</div>
<a id="aee7856a3b7ff811204524bbc9959c8c9" name="aee7856a3b7ff811204524bbc9959c8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7856a3b7ff811204524bbc9959c8c9">&#9670;&#160;</a></span>populateAffineToStdConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateAffineToStdConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the Affine dialect to the Standard dialect, in particular convert structured affine control flow into CFG branch-based control flow. </p>

<p class="definition">Definition at line <a class="el" href="AffineToStandard_8cpp_source.html#l00527">527</a> of file <a class="el" href="AffineToStandard_8cpp_source.html">AffineToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="ad6a984b6da6b0bf690f727bd2e20dd31" name="ad6a984b6da6b0bf690f727bd2e20dd31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a984b6da6b0bf690f727bd2e20dd31">&#9670;&#160;</a></span>populateAffineToVectorConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateAffineToVectorConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert vector-related Affine ops to the <a class="el" href="structVector.html">Vector</a> dialect. </p>

<p class="definition">Definition at line <a class="el" href="AffineToStandard_8cpp_source.html#l00545">545</a> of file <a class="el" href="AffineToStandard_8cpp_source.html">AffineToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a9dca6cbddde02ebb60f3f7d61835e63a" name="a9dca6cbddde02ebb60f3f7d61835e63a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dca6cbddde02ebb60f3f7d61835e63a">&#9670;&#160;</a></span>populateAMDGPUToROCDLConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateAMDGPUToROCDLConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1amdgpu_1_1Chipset.html">amdgpu::Chipset</a></td>          <td class="paramname"><span class="paramname"><em>chipset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Note: This function will also add conversions for the AMDGPU-specific address spaces and types, but those can be added separately using <a class="el" href="#ad98c9bd5dd17f663af91020fad13f0c9" title="Remap AMDGPU memory spaces to LLVM address spaces by mapping amdgpu::AddressSpace::fat_raw_buffer to ...">populateAMDGPUTypeAndAttributeConversions()</a>. </p>

<p class="definition">Definition at line <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l03052">3052</a> of file <a class="el" href="AMDGPUToROCDL_8cpp_source.html">AMDGPUToROCDL.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>, and <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l03029">populateAMDGPUTypeAndAttributeConversions()</a>.</p>

</div>
</div>
<a id="ad98c9bd5dd17f663af91020fad13f0c9" name="ad98c9bd5dd17f663af91020fad13f0c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98c9bd5dd17f663af91020fad13f0c9">&#9670;&#160;</a></span>populateAMDGPUTypeAndAttributeConversions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateAMDGPUTypeAndAttributeConversions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remap AMDGPU memory spaces to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> address spaces by mapping amdgpu::AddressSpace::fat_raw_buffer to ptr addrspace(7), amdgpu::AddressSpace::buffer_rsrc to ptr addrspace(8), and amdgpu::AddressSpace::fat_strided_buffer to ptr addrspace(9). </p>

<p class="definition">Definition at line <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l03029">3029</a> of file <a class="el" href="AMDGPUToROCDL_8cpp_source.html">AMDGPUToROCDL.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8cpp_source.html#l00035">mlir::Type::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l03052">populateAMDGPUToROCDLConversionPatterns()</a>.</p>

</div>
</div>
<a id="a996cc8b761f1373132a5d77b16d2076a" name="a996cc8b761f1373132a5d77b16d2076a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a996cc8b761f1373132a5d77b16d2076a">&#9670;&#160;</a></span>populateAMXLegalizeForLLVMExportPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateAMXLegalizeForLLVMExportPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to lower AMX ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>

<p class="definition">Definition at line <a class="el" href="AMX_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00041">41</a> of file <a class="el" href="AMX_2Transforms_2LegalizeForLLVMExport_8cpp_source.html">LegalizeForLLVMExport.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8cpp_source.html#l00275">mlir::LLVMTypeConverter::getContext()</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="adc52e1e0b9c1d604f07abeb1c33cd6eb" name="adc52e1e0b9c1d604f07abeb1c33cd6eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc52e1e0b9c1d604f07abeb1c33cd6eb">&#9670;&#160;</a></span>populateArithToEmitCPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateArithToEmitCPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArithToEmitC_8cpp_source.html#l00806">806</a> of file <a class="el" href="ArithToEmitC_8cpp_source.html">ArithToEmitC.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>, and <a class="el" href="TypeConversions_8cpp_source.html#l00030">populateEmitCSizeTTypeConversions()</a>.</p>

</div>
</div>
<a id="afe2a83e0a6a467d1838b6dd39f65fb6d" name="afe2a83e0a6a467d1838b6dd39f65fb6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe2a83e0a6a467d1838b6dd39f65fb6d">&#9670;&#160;</a></span>populateArmSMEToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateArmSMEToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from the ArmSME dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8cpp_source.html#l00973">973</a> of file <a class="el" href="ArmSMEToLLVM_8cpp_source.html">ArmSMEToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2ArmSME_2IR_2Utils_8cpp_source.html#l00043">mlir::arm_sme::isValidSMETileVectorType()</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a726da53640cac549a26c8eb0396fb0e6" name="a726da53640cac549a26c8eb0396fb0e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726da53640cac549a26c8eb0396fb0e6">&#9670;&#160;</a></span>populateArmSMEToSCFConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateArmSMEToSCFConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the ArmSME dialect to SCF. </p>

<p class="definition">Definition at line <a class="el" href="ArmSMEToSCF_8cpp_source.html#l00403">403</a> of file <a class="el" href="ArmSMEToSCF_8cpp_source.html">ArmSMEToSCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="ab4e0bc56426ca98e9bddc31e4ec82d35" name="ab4e0bc56426ca98e9bddc31e4ec82d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e0bc56426ca98e9bddc31e4ec82d35">&#9670;&#160;</a></span>populateArmSVELegalizeForLLVMExportPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateArmSVELegalizeForLLVMExportPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to lower ArmSVE ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>
<p>Populate the given list with patterns that convert from ArmSVE to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="ArmSVE_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00187">187</a> of file <a class="el" href="ArmSVE_2Transforms_2LegalizeForLLVMExport_8cpp_source.html">LegalizeForLLVMExport.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="aa9ea90e10c603e639fe6b6cbc9f24265" name="aa9ea90e10c603e639fe6b6cbc9f24265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ea90e10c603e639fe6b6cbc9f24265">&#9670;&#160;</a></span>populateAsyncFuncToAsyncRuntimeConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateAsyncFuncToAsyncRuntimeConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConversionTarget.html">ConversionTarget</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00853">853</a> of file <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html">AsyncToAsyncRuntime.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02100">target</a>.</p>

</div>
</div>
<a id="a9659670212051d0795efd99cf38772ed" name="a9659670212051d0795efd99cf38772ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9659670212051d0795efd99cf38772ed">&#9670;&#160;</a></span>populateAsyncStructuralTypeConversionsAndLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateAsyncStructuralTypeConversionsAndLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConversionTarget.html">ConversionTarget</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates patterns for async structural type conversions. </p>
<p>A "structural" type conversion is one where the underlying ops are completely agnostic to the actual types involved and simply need to update their types. An example of this is async.execute &ndash; the async.execute op and the corresponding async.yield ops need to update their types accordingly to the <a class="el" href="classTypeConverter.html">TypeConverter</a>, but otherwise don't care what type conversions are happening. </p>

<p class="definition">Definition at line <a class="el" href="AsyncToLLVM_8cpp_source.html#l01151">1151</a> of file <a class="el" href="AsyncToLLVM_8cpp_source.html">AsyncToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02100">target</a>.</p>

</div>
</div>
<a id="a67ef267fd846574457641b3fc2ec2088" name="a67ef267fd846574457641b3fc2ec2088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ef267fd846574457641b3fc2ec2088">&#9670;&#160;</a></span>populateBranchOpInterfaceTypeConversionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateBranchOpInterfaceTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(BranchOpInterface branchOp, int idx)&gt;</td>          <td class="paramname"><span class="paramname"><em>shouldConvertBranchOperand</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a pattern to the given pattern list to rewrite branch operations to use operands that have been legalized by the conversion framework. </p>
<p>This can only be done if the branch operation implements the BranchOpInterface. Only needed for partial conversions.</p>
<p>If for some branch ops, we need to convert/legalize only a sub-set of the op's operands, such filtering behavior can be specified in shouldConvertBranchOperand. This callback should return true if branchOp's operand at index idx should be converted. </p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a87d229499a39cbc1a4e2bfd3acbe1a7e" name="a87d229499a39cbc1a4e2bfd3acbe1a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87d229499a39cbc1a4e2bfd3acbe1a7e">&#9670;&#160;</a></span>populateBubbleDownMemorySpaceCastPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateBubbleDownMemorySpaceCastPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to bubble-down memory-space cast operations. </p>

<p class="definition">Definition at line <a class="el" href="BubbleDownMemorySpaceCasts_8cpp_source.html#l00066">66</a> of file <a class="el" href="BubbleDownMemorySpaceCasts_8cpp_source.html">BubbleDownMemorySpaceCasts.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="BubbleDownMemorySpaceCasts_8cpp_source.html#l00057">mlir::impl::BubbleDownMemorySpaceCastsBase&lt; DerivedT &gt;::getArgumentName()</a>.</p>

</div>
</div>
<a id="a5c9ab382a920a458ce63cd4534dcb273" name="a5c9ab382a920a458ce63cd4534dcb273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9ab382a920a458ce63cd4534dcb273">&#9670;&#160;</a></span>populateBuiltinFuncToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateBuiltinFuncToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating the builtin <span class="tt">func</span> op to the SPIR-V dialect. </p>
<p>These patterns do not handle shader interface/ABI; they convert function parameters to be of SPIR-V allowed types. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVConversion_8cpp_source.html#l01717">1717</a> of file <a class="el" href="SPIRVConversion_8cpp_source.html">SPIRVConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a48b2f65418c4fb28b0988f59d86dd3d3" name="a48b2f65418c4fb28b0988f59d86dd3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b2f65418c4fb28b0988f59d86dd3d3">&#9670;&#160;</a></span>populateCallOpTypeConversionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateCallOpTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a pattern to the given pattern list to convert the operand and result types of a CallOp with the given type converter. </p>

<p class="definition">Definition at line <a class="el" href="FuncConversions_8cpp_source.html#l00067">67</a> of file <a class="el" href="FuncConversions_8cpp_source.html">FuncConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="Arith_2Transforms_2EmulateNarrowType_8cpp_source.html#l00050">mlir::arith::populateArithNarrowTypeEmulationPatterns()</a>.</p>

</div>
</div>
<a id="ad0a585f7a2f3592bdc05659e34adc79d" name="ad0a585f7a2f3592bdc05659e34adc79d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a585f7a2f3592bdc05659e34adc79d">&#9670;&#160;</a></span>populateCommonAMDGPUTypeAndAttributeConversions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateCommonAMDGPUTypeAndAttributeConversions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remap common GPU memory spaces (Workgroup, Private, etc) to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> address spaces. </p>

<p class="definition">Definition at line <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l03013">3013</a> of file <a class="el" href="AMDGPUToROCDL_8cpp_source.html">AMDGPUToROCDL.cpp</a>.</p>

<p class="reference">References <a class="el" href="GPUOpsLowering_8cpp_source.html#l00818">populateGpuMemorySpaceAttributeConversions()</a>.</p>

</div>
</div>
<a id="a6657dab425bc62dafe146c813979dc2b" name="a6657dab425bc62dafe146c813979dc2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6657dab425bc62dafe146c813979dc2b">&#9670;&#160;</a></span>populateCommutativityUtilsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateCommutativityUtilsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the commutativity utility patterns. </p>

<p class="definition">Definition at line <a class="el" href="CommutativityUtils_8cpp_source.html#l00311">311</a> of file <a class="el" href="CommutativityUtils_8cpp_source.html">CommutativityUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="af655a0b587c08462a963b23b6c656ca5" name="af655a0b587c08462a963b23b6c656ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af655a0b587c08462a963b23b6c656ca5">&#9670;&#160;</a></span>populateComplexToLibmConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateComplexToLibmConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from Complex to Libm calls. </p>

<p class="definition">Definition at line <a class="el" href="ComplexToLibm_8cpp_source.html#l00099">99</a> of file <a class="el" href="ComplexToLibm_8cpp_source.html">ComplexToLibm.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a2587dd2d601cb5613d673f9eae76b615" name="a2587dd2d601cb5613d673f9eae76b615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2587dd2d601cb5613d673f9eae76b615">&#9670;&#160;</a></span>populateComplexToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateComplexToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::complex::ComplexRangeFlags</td>          <td class="paramname"><span class="paramname"><em>complexRange</em></span><span class="paramdefsep"> = </span><span class="paramdefval">mlir::complex::ComplexRangeFlags::basic</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from Complex to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a1103f8e89a3e08ffd4fbd3d1bab0ee90" name="a1103f8e89a3e08ffd4fbd3d1bab0ee90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1103f8e89a3e08ffd4fbd3d1bab0ee90">&#9670;&#160;</a></span>populateComplexToROCDLLibraryCallsConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateComplexToROCDLLibraryCallsConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from Complex to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> calls. </p>

<p class="definition">Definition at line <a class="el" href="ComplexToROCDLLibraryCalls_8cpp_source.html#l00109">109</a> of file <a class="el" href="ComplexToROCDLLibraryCalls_8cpp_source.html">ComplexToROCDLLibraryCalls.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="ac59f15aca5e1be49c639ee5b12e611f2" name="ac59f15aca5e1be49c639ee5b12e611f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac59f15aca5e1be49c639ee5b12e611f2">&#9670;&#160;</a></span>populateComplexToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateComplexToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating Complex ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="ComplexToSPIRV_8cpp_source.html#l00103">103</a> of file <a class="el" href="ComplexToSPIRV_8cpp_source.html">ComplexToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a7561db931b79277cde554d85e85f2bc6" name="a7561db931b79277cde554d85e85f2bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7561db931b79277cde554d85e85f2bc6">&#9670;&#160;</a></span>populateComplexToStandardConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateComplexToStandardConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::complex::ComplexRangeFlags</td>          <td class="paramname"><span class="paramname"><em>complexRange</em></span><span class="paramdefsep"> = </span><span class="paramdefval">mlir::complex::ComplexRangeFlags::improved</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from Complex to Standard. </p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a1bd3c63a12bd65ca2208a6353dbc9186" name="a1bd3c63a12bd65ca2208a6353dbc9186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd3c63a12bd65ca2208a6353dbc9186">&#9670;&#160;</a></span>populateConversionTargetFromOperation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateConversionTargetFromOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConversionTarget.html">ConversionTarget</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively walk the IR and collect all dialects implementing the interface, and populate the conversion patterns. </p>

<p class="definition">Definition at line <a class="el" href="ToLLVMInterface_8cpp_source.html#l00015">15</a> of file <a class="el" href="ToLLVMInterface_8cpp_source.html">ToLLVMInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00220">mlir::Operation::getDialect()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02100">target</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00797">mlir::Operation::walk()</a>.</p>

</div>
</div>
<a id="a93264171f98ba147ce9b57df5866b96a" name="a93264171f98ba147ce9b57df5866b96a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93264171f98ba147ce9b57df5866b96a">&#9670;&#160;</a></span>populateConversionTargetFromOperation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateConversionTargetFromOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConversionTarget.html">ConversionTarget</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively walk the IR and collect all dialects implementing the interface, and populate the conversion patterns. </p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02100">target</a>.</p>

</div>
</div>
<a id="a45f6113274b77800e7c3b22dd83771e0" name="a45f6113274b77800e7c3b22dd83771e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f6113274b77800e7c3b22dd83771e0">&#9670;&#160;</a></span>populateConvertArmNeon2dToIntrPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateConvertArmNeon2dToIntrPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates patterns for the lowering of Arm NEON 2D ops to intrinsics. </p>
<p>See createConvertArmNeon2dToIntrPass. </p>

<p class="definition">Definition at line <a class="el" href="ArmNeon2dToIntr_8cpp_source.html#l00068">68</a> of file <a class="el" href="ArmNeon2dToIntr_8cpp_source.html">ArmNeon2dToIntr.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a7848cf7b0f5c06cc25a460eaeaa07aec" name="a7848cf7b0f5c06cc25a460eaeaa07aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7848cf7b0f5c06cc25a460eaeaa07aec">&#9670;&#160;</a></span>populateConvertMathToEmitCPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateConvertMathToEmitCPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1emitc.html#a0ad3720c07467edc248a23dbc84d6cf4">emitc::LanguageTarget</a></td>          <td class="paramname"><span class="paramname"><em>languageTarget</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MathToEmitC_8cpp_source.html#l00060">60</a> of file <a class="el" href="MathToEmitC_8cpp_source.html">MathToEmitC.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="ae6e66615eb7e50976ed8c89b2bb05adc" name="ae6e66615eb7e50976ed8c89b2bb05adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e66615eb7e50976ed8c89b2bb05adc">&#9670;&#160;</a></span>populateConvertShapeConstraintsConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateConvertShapeConstraintsConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertShapeConstraints_8cpp_source.html#l00042">42</a> of file <a class="el" href="ConvertShapeConstraints_8cpp_source.html">ConvertShapeConstraints.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a5f173d8afb5bfa9aca23651433c1c3a1" name="a5f173d8afb5bfa9aca23651433c1c3a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f173d8afb5bfa9aca23651433c1c3a1">&#9670;&#160;</a></span>populateEmitCSizeTTypeConversions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateEmitCSizeTTypeConversions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeConversions_8cpp_source.html#l00030">30</a> of file <a class="el" href="TypeConversions_8cpp_source.html">TypeConversions.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArithToEmitC_8cpp_source.html#l00806">populateArithToEmitCPatterns()</a>.</p>

</div>
</div>
<a id="a7706b8ce246435dbbe7e1191938d2f1c" name="a7706b8ce246435dbbe7e1191938d2f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7706b8ce246435dbbe7e1191938d2f1c">&#9670;&#160;</a></span>populateFinalizeMemRefToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateFinalizeMemRefToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SymbolTableCollection.html">SymbolTableCollection</a> *</td>          <td class="paramname"><span class="paramname"><em>symbolTables</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert memory-related operations from the MemRef dialect to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect. </p>

<p class="definition">Definition at line <a class="el" href="MemRefToLLVM_8cpp_source.html#l02038">2038</a> of file <a class="el" href="MemRefToLLVM_8cpp_source.html">MemRefToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoweringOptions_8h_source.html#l00042">mlir::LowerToLLVMOptions::AlignedAlloc</a>, <a class="el" href="LoweringOptions_8h_source.html#l00049">mlir::LowerToLLVMOptions::allocLowering</a>, <a class="el" href="TypeConverter_8h_source.html#l00107">mlir::LLVMTypeConverter::getOptions()</a>, <a class="el" href="LoweringOptions_8h_source.html#l00039">mlir::LowerToLLVMOptions::Malloc</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a00c79fe894fb6efe41ad37b5219a7b8a" name="a00c79fe894fb6efe41ad37b5219a7b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c79fe894fb6efe41ad37b5219a7b8a">&#9670;&#160;</a></span>populateFuncOpVectorRewritePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateFuncOpVectorRewritePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRVConversion_8cpp_source.html#l01722">1722</a> of file <a class="el" href="SPIRVConversion_8cpp_source.html">SPIRVConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVConversion_8cpp_source.html#l01478">mlir::spirv::unrollVectorsInSignatures()</a>.</p>

</div>
</div>
<a id="aefad2b8a321c6af909b8c1096784d004" name="aefad2b8a321c6af909b8c1096784d004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefad2b8a321c6af909b8c1096784d004">&#9670;&#160;</a></span>populateFuncToEmitCPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateFuncToEmitCPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FuncToEmitC_8cpp_source.html#l00164">164</a> of file <a class="el" href="FuncToEmitC_8cpp_source.html">FuncToEmitC.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a51d060144ae5b7843e2eb3142c685f47" name="a51d060144ae5b7843e2eb3142c685f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d060144ae5b7843e2eb3142c685f47">&#9670;&#160;</a></span>populateFuncToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateFuncToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SymbolTableCollection.html">SymbolTableCollection</a> *</td>          <td class="paramname"><span class="paramname"><em>symbolTables</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect the patterns to convert from the Func dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>
<p>The conversion patterns capture the <a class="el" href="classmlir_1_1LLVMTypeConverter.html" title="Conversion from types to the LLVM IR dialect.">LLVMTypeConverter</a> and the <a class="el" href="classmlir_1_1LowerToLLVMOptions.html" title="Options to control the LLVM lowering.">LowerToLLVMOptions</a> by reference meaning the references have to remain alive during the entire pattern lifetime.</p>
<p>The <span class="tt">symbolTable</span> parameter can be used to speed up function lookups in the module. It's good to provide it, but only if we know that the patterns will be applied to a single module and the symbols referenced by the symbol table will not be removed and new symbols will not be added during the usage of the patterns. If provided, the lookups will have O(calls) cumulative runtime, otherwise O(calls * functions). The symbol table is currently not needed if <span class="tt">converter.getOptions().useBarePtrCallConv</span> is <span class="tt">true</span>, but it's not an error to provide it anyway. </p>

<p class="definition">Definition at line <a class="el" href="FuncToLLVM_8cpp_source.html#l00791">791</a> of file <a class="el" href="FuncToLLVM_8cpp_source.html">FuncToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>, and <a class="el" href="FuncToLLVM_8cpp_source.html#l00785">populateFuncToLLVMFuncOpConversionPattern()</a>.</p>

</div>
</div>
<a id="a5c1bfb234358ffd9f600fe167863be2b" name="a5c1bfb234358ffd9f600fe167863be2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c1bfb234358ffd9f600fe167863be2b">&#9670;&#160;</a></span>populateFuncToLLVMFuncOpConversionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateFuncToLLVMFuncOpConversionPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SymbolTableCollection.html">SymbolTableCollection</a> *</td>          <td class="paramname"><span class="paramname"><em>symbolTables</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect the default pattern to convert a FuncOp to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect. </p>
<p>If <span class="tt">emitCWrappers</span> is set, the pattern will also produce functions that pass memref descriptors by pointer-to-structure in addition to the default unpacked form. </p>

<p class="definition">Definition at line <a class="el" href="FuncToLLVM_8cpp_source.html#l00785">785</a> of file <a class="el" href="FuncToLLVM_8cpp_source.html">FuncToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="FuncToLLVM_8cpp_source.html#l00791">populateFuncToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="a62bf9368c68fc8006128f4ff2f1c5001" name="a62bf9368c68fc8006128f4ff2f1c5001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62bf9368c68fc8006128f4ff2f1c5001">&#9670;&#160;</a></span>populateFuncToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateFuncToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating Func ops to SPIR-V ops. </p>
<p>Also adds the patterns to legalize ops not directly translated to SPIR-V dialect. </p>

<p class="definition">Definition at line <a class="el" href="FuncToSPIRV_8cpp_source.html#l00087">87</a> of file <a class="el" href="FuncToSPIRV_8cpp_source.html">FuncToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a9701a7692a76e65edd69bd6f22156776" name="a9701a7692a76e65edd69bd6f22156776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9701a7692a76e65edd69bd6f22156776">&#9670;&#160;</a></span>populateGpuAllReducePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuAllReducePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to rewrite all-reduce ops within the GPU dialect. </p>

<p class="definition">Definition at line <a class="el" href="AllReduceLowering_8cpp_source.html#l00377">377</a> of file <a class="el" href="AllReduceLowering_8cpp_source.html">AllReduceLowering.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l00091">populateGpuRewritePatterns()</a>.</p>

</div>
</div>
<a id="ab57dcf9ca48416677b4f10118916da61" name="ab57dcf9ca48416677b4f10118916da61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab57dcf9ca48416677b4f10118916da61">&#9670;&#160;</a></span>populateGpuBreakDownSubgroupReducePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuBreakDownSubgroupReducePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>maxShuffleBitwidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">32</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to break down subgroup_reduce ops into smaller ones supported by the target of <span class="tt">size &lt;= maxShuffleBitwidth</span>, where <span class="tt">size</span> is the subgroup_reduce value bitwidth. </p>

<p class="definition">Definition at line <a class="el" href="SubgroupReduceLowering_8cpp_source.html#l00563">563</a> of file <a class="el" href="SubgroupReduceLowering_8cpp_source.html">SubgroupReduceLowering.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="ac0ea23f9a62b16d2214c2e70f282c5c1" name="ac0ea23f9a62b16d2214c2e70f282c5c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ea23f9a62b16d2214c2e70f282c5c1">&#9670;&#160;</a></span>populateGpuDecomposeMemrefsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuDecomposeMemrefsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to decompose memrefs ops. </p>

<p class="definition">Definition at line <a class="el" href="DecomposeMemRefs_8cpp_source.html#l00236">236</a> of file <a class="el" href="DecomposeMemRefs_8cpp_source.html">DecomposeMemRefs.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="af5eff4e5da432d2edf4f655585785460" name="af5eff4e5da432d2edf4f655585785460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5eff4e5da432d2edf4f655585785460">&#9670;&#160;</a></span>populateGpuEliminateBarriersPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuEliminateBarriersPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase barriers that do not enforce conflicting memory side effects. </p>

<p class="definition">Definition at line <a class="el" href="EliminateBarriers_8cpp_source.html#l00617">617</a> of file <a class="el" href="EliminateBarriers_8cpp_source.html">EliminateBarriers.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a352a5fec8fc09705220c6ed268d15709" name="a352a5fec8fc09705220c6ed268d15709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a352a5fec8fc09705220c6ed268d15709">&#9670;&#160;</a></span>populateGpuGlobalIdPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuGlobalIdPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to rewrite GlobalIdOp op within the GPU dialect. </p>

<p class="definition">Definition at line <a class="el" href="GlobalIdRewriter_8cpp_source.html#l00043">43</a> of file <a class="el" href="GlobalIdRewriter_8cpp_source.html">GlobalIdRewriter.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l00091">populateGpuRewritePatterns()</a>.</p>

</div>
</div>
<a id="afe98d13c529561423b0a00d4cbe7cdb1" name="afe98d13c529561423b0a00d4cbe7cdb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe98d13c529561423b0a00d4cbe7cdb1">&#9670;&#160;</a></span>populateGpuLowerClusteredSubgroupReduceToDPPPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuLowerClusteredSubgroupReduceToDPPPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>subgroupSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1amdgpu_1_1Chipset.html">amdgpu::Chipset</a></td>          <td class="paramname"><span class="paramname"><em>chipset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disjoint counterpart of <span class="tt">populateGpuLowerSubgroupReduceToDPPPatterns</span> that only matches <span class="tt">gpu.subgroup_reduce</span> ops with a <span class="tt">cluster_size</span>. </p>

<p class="definition">Definition at line <a class="el" href="SubgroupReduceLowering_8cpp_source.html#l00579">579</a> of file <a class="el" href="SubgroupReduceLowering_8cpp_source.html">SubgroupReduceLowering.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a7feacef2681f1cb159920f8a6ed188ad" name="a7feacef2681f1cb159920f8a6ed188ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7feacef2681f1cb159920f8a6ed188ad">&#9670;&#160;</a></span>populateGpuLowerClusteredSubgroupReduceToShufflePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuLowerClusteredSubgroupReduceToShufflePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>subgroupSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>shuffleBitwidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">32</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disjoint counterpart of <span class="tt">populateGpuLowerSubgroupReduceToShufflePatterns</span> that only matches <span class="tt">gpu.subgroup_reduce</span> ops with a <span class="tt">cluster_size</span>. </p>

<p class="definition">Definition at line <a class="el" href="SubgroupReduceLowering_8cpp_source.html#l00595">595</a> of file <a class="el" href="SubgroupReduceLowering_8cpp_source.html">SubgroupReduceLowering.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="acfaf756739b50fa93f64e888ebd9af60" name="acfaf756739b50fa93f64e888ebd9af60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfaf756739b50fa93f64e888ebd9af60">&#9670;&#160;</a></span>populateGpuLowerSubgroupReduceToDPPPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuLowerSubgroupReduceToDPPPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>subgroupSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1amdgpu_1_1Chipset.html">amdgpu::Chipset</a></td>          <td class="paramname"><span class="paramname"><em>chipset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to lower <span class="tt">gpu.subgroup_reduce</span> into <span class="tt">amdgpu.dpp</span> ops over scalar types. </p>
<p>Assumes that the subgroup has <span class="tt">subgroupSize</span> lanes. Applicable only to AMD GPUs. </p>

<p class="definition">Definition at line <a class="el" href="SubgroupReduceLowering_8cpp_source.html#l00571">571</a> of file <a class="el" href="SubgroupReduceLowering_8cpp_source.html">SubgroupReduceLowering.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a6c34168191ab5b4336dd5a832eab08e0" name="a6c34168191ab5b4336dd5a832eab08e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c34168191ab5b4336dd5a832eab08e0">&#9670;&#160;</a></span>populateGpuLowerSubgroupReduceToShufflePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuLowerSubgroupReduceToShufflePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>subgroupSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>shuffleBitwidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">32</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to lower <span class="tt">gpu.subgroup_reduce</span> into <span class="tt">gpu.shuffle</span> ops over <span class="tt">shuffleBitwidth</span> scalar types. </p>
<p>Assumes that the subgroup has <span class="tt">subgroupSize</span> lanes. Uses the butterfly shuffle algorithm.</p>
<p>The patterns populated by this function will ignore ops with the <span class="tt">cluster_size</span> attribute. <span class="tt">populateGpuLowerClusteredSubgroupReduceToShufflePatterns</span> is the opposite. </p>

<p class="definition">Definition at line <a class="el" href="SubgroupReduceLowering_8cpp_source.html#l00587">587</a> of file <a class="el" href="SubgroupReduceLowering_8cpp_source.html">SubgroupReduceLowering.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a07982150babf881946ef966e4d7842e0" name="a07982150babf881946ef966e4d7842e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07982150babf881946ef966e4d7842e0">&#9670;&#160;</a></span>populateGpuMemorySpaceAttributeConversions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuMemorySpaceAttributeConversions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates memory space attribute conversion rules for lowering gpu.address_space to integer values. </p>

<p class="definition">Definition at line <a class="el" href="GPUToLLVMSPV_8cpp_source.html#l00534">534</a> of file <a class="el" href="GPUToLLVMSPV_8cpp_source.html">GPUToLLVMSPV.cpp</a>.</p>

<p class="reference">References <a class="el" href="GPUOpsLowering_8cpp_source.html#l00818">populateGpuMemorySpaceAttributeConversions()</a>.</p>

</div>
</div>
<a id="a9a64af4be39c0a24e5cf7dd18d7f619f" name="a9a64af4be39c0a24e5cf7dd18d7f619f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a64af4be39c0a24e5cf7dd18d7f619f">&#9670;&#160;</a></span>populateGpuMemorySpaceAttributeConversions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuMemorySpaceAttributeConversions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a7a0b25e7052411f56f063eca0b73e8a2">MemorySpaceMapping</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mapping</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates memory space attribute conversion rules for lowering gpu.address_space to integer values. </p>

<p class="definition">Definition at line <a class="el" href="GPUOpsLowering_8cpp_source.html#l00818">818</a> of file <a class="el" href="GPUOpsLowering_8cpp_source.html">GPUOpsLowering.cpp</a>.</p>

<p class="reference">References <a class="el" href="GPUOpsLowering_8cpp_source.html#l00664">wrapNumericMemorySpace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00448">configureGpuToNVVMTypeConverter()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l03013">populateCommonAMDGPUTypeAndAttributeConversions()</a>, and <a class="el" href="GPUToLLVMSPV_8cpp_source.html#l00534">populateGpuMemorySpaceAttributeConversions()</a>.</p>

</div>
</div>
<a id="ab7e92953bee29d6688ad7e9dd8747285" name="ab7e92953bee29d6688ad7e9dd8747285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e92953bee29d6688ad7e9dd8747285">&#9670;&#160;</a></span>populateGpuPromoteShuffleToAMDGPUPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuPromoteShuffleToAMDGPUPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="structmlir_1_1amdgpu_1_1Chipset.html">amdgpu::Chipset</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>maybeChipset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to promote <span class="tt">gpu.shuffle</span>s to specialized AMDGPU intrinsics. </p>

<p class="definition">Definition at line <a class="el" href="PromoteShuffleToAMDGPU_8cpp_source.html#l00101">101</a> of file <a class="el" href="PromoteShuffleToAMDGPU_8cpp_source.html">PromoteShuffleToAMDGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00047">kGfx950</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a4ae1d309360c9e54edaa39ddb48d3ea1" name="a4ae1d309360c9e54edaa39ddb48d3ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ae1d309360c9e54edaa39ddb48d3ea1">&#9670;&#160;</a></span>populateGpuRewritePatterns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuRewritePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collect all patterns to rewrite ops within the GPU dialect. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l00091">91</a> of file <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>, <a class="el" href="AllReduceLowering_8cpp_source.html#l00377">populateGpuAllReducePatterns()</a>, <a class="el" href="GlobalIdRewriter_8cpp_source.html#l00043">populateGpuGlobalIdPatterns()</a>, and <a class="el" href="ShuffleRewriter_8cpp_source.html#l00095">populateGpuShufflePatterns()</a>.</p>

</div>
</div>
<a id="a1cdef2da7628821e92464510d6556332" name="a1cdef2da7628821e92464510d6556332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cdef2da7628821e92464510d6556332">&#9670;&#160;</a></span>populateGpuShufflePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuShufflePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to rewrite shuffle ops within the GPU dialect. </p>

<p class="definition">Definition at line <a class="el" href="ShuffleRewriter_8cpp_source.html#l00095">95</a> of file <a class="el" href="ShuffleRewriter_8cpp_source.html">ShuffleRewriter.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l00091">populateGpuRewritePatterns()</a>.</p>

</div>
</div>
<a id="adb3fb4d0bde3373634983b148f0b0c03" name="adb3fb4d0bde3373634983b148f0b0c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb3fb4d0bde3373634983b148f0b0c03">&#9670;&#160;</a></span>populateGpuSubgroupIdPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuSubgroupIdPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to rewrite SubgroupIdOp op within the GPU dialect. </p>

<p class="definition">Definition at line <a class="el" href="SubgroupIdRewriter_8cpp_source.html#l00083">83</a> of file <a class="el" href="SubgroupIdRewriter_8cpp_source.html">SubgroupIdRewriter.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a8df7e4388da5d61f0a3831f7e84559e2" name="a8df7e4388da5d61f0a3831f7e84559e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df7e4388da5d61f0a3831f7e84559e2">&#9670;&#160;</a></span>populateGpuSubgroupReduceOpLoweringPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuSubgroupReduceOpLoweringPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate GpuSubgroupReduce pattern to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>. </p>
<p>It generates a specific nvvm op that is not available on every GPU. </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00598">598</a> of file <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html">LowerGpuOpsToNVVMOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a8613a6ab11e19c2d24255fff3a3b2c87" name="a8613a6ab11e19c2d24255fff3a3b2c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8613a6ab11e19c2d24255fff3a3b2c87">&#9670;&#160;</a></span>populateGpuToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>kernelBarePtrCallConv</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>kernelIntersperseSizeCallConv</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> and populate converter for gpu types. </p>

<p class="definition">Definition at line <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l01790">1790</a> of file <a class="el" href="GPUToLLVMConversion_8cpp_source.html">GPUToLLVMConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l01549">addOpaquePointerConversion()</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a15d3286013eff75a1bf8168b7f569308" name="a15d3286013eff75a1bf8168b7f569308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d3286013eff75a1bf8168b7f569308">&#9670;&#160;</a></span>populateGpuToLLVMSPVConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuToLLVMSPVConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GPUToLLVMSPV_8cpp_source.html#l00505">505</a> of file <a class="el" href="GPUToLLVMSPV_8cpp_source.html">GPUToLLVMSPV.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8cpp_source.html#l00275">mlir::LLVMTypeConverter::getContext()</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a994285c8f7cd14dbbb4d8776179a48ea" name="a994285c8f7cd14dbbb4d8776179a48ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994285c8f7cd14dbbb4d8776179a48ea">&#9670;&#160;</a></span>populateGpuToNVVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuToNVVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00695">695</a> of file <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html">LowerGpuOpsToNVVMOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8cpp_source.html#l00275">mlir::LLVMTypeConverter::getContext()</a>, <a class="el" href="NVVMDialect_8h_source.html#l00049">mlir::NVVM::kSharedMemoryAlignmentBit</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>, and <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00604">populateLibDeviceConversionPatterns()</a>.</p>

</div>
</div>
<a id="a0ae71be7fe03174473e044b1e6db32e7" name="a0ae71be7fe03174473e044b1e6db32e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ae71be7fe03174473e044b1e6db32e7">&#9670;&#160;</a></span>populateGpuToROCDLConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuToROCDLConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1gpu_1_1amd.html#a8637afbd01b984be30dbd1cdb78ae45f">gpu::amd::Runtime</a></td>          <td class="paramname"><span class="paramname"><em>runtime</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1amdgpu_1_1Chipset.html">amdgpu::Chipset</a></td>          <td class="paramname"><span class="paramname"><em>chipset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a>. </p>
<p>If <span class="tt">runtime</span> is Unknown, gpu.printf will not be lowered The resulting pattern set should be run over a gpu.module op </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html#l00431">431</a> of file <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html">LowerGpuOpsToROCDLOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8cpp_source.html#l00275">mlir::LLVMTypeConverter::getContext()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00454">mlir::MLIRContext::getLoadedDialect()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>, and <a class="el" href="MathToROCDL_8cpp_source.html#l00085">populateMathToROCDLConversionPatterns()</a>.</p>

</div>
</div>
<a id="aa38792a214e31cdbf60cb4b3f859767d" name="aa38792a214e31cdbf60cb4b3f859767d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38792a214e31cdbf60cb4b3f859767d">&#9670;&#160;</a></span>populateGPUToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGPUToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating GPU Ops to SPIR-V ops. </p>
<p>For a gpu.func to be converted, it should have a spirv.entry_point_abi attribute. </p>

<p class="definition">Definition at line <a class="el" href="GPUToSPIRV_8cpp_source.html#l00830">830</a> of file <a class="el" href="GPUToSPIRV_8cpp_source.html">GPUToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="aff8142e6ea13c807b37d7352283aeda9" name="aff8142e6ea13c807b37d7352283aeda9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8142e6ea13c807b37d7352283aeda9">&#9670;&#160;</a></span>populateGpuWMMAToNVVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuWMMAToNVVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert WMMA ops from GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="WmmaOpsToNvvm_8cpp_source.html#l00423">423</a> of file <a class="el" href="WmmaOpsToNvvm_8cpp_source.html">WmmaOpsToNvvm.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a875bfbc01fd879b9697d28ef7856b4f7" name="a875bfbc01fd879b9697d28ef7856b4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a875bfbc01fd879b9697d28ef7856b4f7">&#9670;&#160;</a></span>populateGpuWMMAToSPIRVCoopMatrixKHRConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuWMMAToSPIRVCoopMatrixKHRConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert WMMA ops from GPU dialect to SPIRV, using the KHR Cooperative Matrix extension. </p>

<p class="definition">Definition at line <a class="el" href="WmmaOpsToSPIRV_8cpp_source.html#l00355">355</a> of file <a class="el" href="WmmaOpsToSPIRV_8cpp_source.html">WmmaOpsToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="af8bcc32e84f5710bd6e288f171d4178b" name="af8bcc32e84f5710bd6e288f171d4178b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8bcc32e84f5710bd6e288f171d4178b">&#9670;&#160;</a></span>populateLibDeviceConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateLibDeviceConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns that lower certain arith and math dialect ops to libdevice calls. </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00604">604</a> of file <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html">LowerGpuOpsToNVVMOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>, <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00589">populateFloatIntOpPatterns()</a>, <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00580">populateIntOpPatterns()</a>, and <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00568">populateOpPatterns()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00695">populateGpuToNVVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="a95f30ee88fb58c23838e930cd42216c7" name="a95f30ee88fb58c23838e930cd42216c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f30ee88fb58c23838e930cd42216c7">&#9670;&#160;</a></span>populateLowerContractionToSVEBFMMLAPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateLowerContractionToSVEBFMMLAPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LowerContractToSVEPatterns_8cpp_source.html#l00590">590</a> of file <a class="el" href="LowerContractToSVEPatterns_8cpp_source.html">LowerContractToSVEPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="aa975dde69503e4fee3f3a75dca5c9fac" name="aa975dde69503e4fee3f3a75dca5c9fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa975dde69503e4fee3f3a75dca5c9fac">&#9670;&#160;</a></span>populateLowerContractionToSVEI8MMPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateLowerContractionToSVEI8MMPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LowerContractToSVEPatterns_8cpp_source.html#l00584">584</a> of file <a class="el" href="LowerContractToSVEPatterns_8cpp_source.html">LowerContractToSVEPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="aeac82ef141dff9c99336d99169954925" name="aeac82ef141dff9c99336d99169954925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac82ef141dff9c99336d99169954925">&#9670;&#160;</a></span>populateLowerForeachToSCFPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateLowerForeachToSCFPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseTensorRewriting_8cpp_source.html#l01595">1595</a> of file <a class="el" href="SparseTensorRewriting_8cpp_source.html">SparseTensorRewriting.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a8f175c99ce23bb21e02b216876b31171" name="a8f175c99ce23bb21e02b216876b31171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f175c99ce23bb21e02b216876b31171">&#9670;&#160;</a></span>populateLowerSparseIterationToSCFPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateLowerSparseIterationToSCFPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseIterationToScf_8cpp_source.html#l00452">452</a> of file <a class="el" href="SparseIterationToScf_8cpp_source.html">SparseIterationToScf.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a9848c16612b09d5d062b7e49564e8659" name="a9848c16612b09d5d062b7e49564e8659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9848c16612b09d5d062b7e49564e8659">&#9670;&#160;</a></span>populateLowerSparseOpsToForeachPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateLowerSparseOpsToForeachPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>enableRT</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>enableConvert</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseTensorRewriting_8cpp_source.html#l01579">1579</a> of file <a class="el" href="SparseTensorRewriting_8cpp_source.html">SparseTensorRewriting.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a747b91bacc09bde115c3e891deb5ebe5" name="a747b91bacc09bde115c3e891deb5ebe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747b91bacc09bde115c3e891deb5ebe5">&#9670;&#160;</a></span>populateMathAlgebraicSimplificationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateMathAlgebraicSimplificationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AlgebraicSimplification_8cpp_source.html#l00246">246</a> of file <a class="el" href="AlgebraicSimplification_8cpp_source.html">AlgebraicSimplification.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a2d9cd55affd07926cd68087af95206ba" name="a2d9cd55affd07926cd68087af95206ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9cd55affd07926cd68087af95206ba">&#9670;&#160;</a></span>populateMathF32ExpansionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateMathF32ExpansionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(StringRef)&gt;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PolynomialApproximation_8cpp_source.html#l01793">1793</a> of file <a class="el" href="PolynomialApproximation_8cpp_source.html">PolynomialApproximation.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>, and <a class="el" href="PolynomialApproximation_8cpp_source.html#l01785">populateMathF32ExpansionPattern()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PolynomialApproximation_8cpp_source.html#l01875">populateMathPolynomialApproximationPatterns()</a>.</p>

</div>
</div>
<a id="ada84ecb306c38b4e2a547962acc98dfd" name="ada84ecb306c38b4e2a547962acc98dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada84ecb306c38b4e2a547962acc98dfd">&#9670;&#160;</a></span>populateMathPolynomialApproximationPatterns() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateMathPolynomialApproximationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1MathPolynomialApproximationOptions.html">MathPolynomialApproximationOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PolynomialApproximation_8cpp_source.html#l01875">1875</a> of file <a class="el" href="PolynomialApproximation_8cpp_source.html">PolynomialApproximation.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l01793">populateMathF32ExpansionPatterns()</a>, and <a class="el" href="PolynomialApproximation_8cpp_source.html#l01833">populateMathPolynomialApproximationPatterns()</a>.</p>

</div>
</div>
<a id="afda27c3980d49d43e0256cc87d3d3b69" name="afda27c3980d49d43e0256cc87d3d3b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda27c3980d49d43e0256cc87d3d3b69">&#9670;&#160;</a></span>populateMathPolynomialApproximationPatterns() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateMathPolynomialApproximationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(StringRef)&gt;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PolynomialApproximation_8cpp_source.html#l01833">1833</a> of file <a class="el" href="PolynomialApproximation_8cpp_source.html">PolynomialApproximation.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>, and <a class="el" href="PolynomialApproximation_8cpp_source.html#l01825">populateMathPolynomialApproximationPattern()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PolynomialApproximation_8cpp_source.html#l01875">populateMathPolynomialApproximationPatterns()</a>.</p>

</div>
</div>
<a id="a040f9de8ca0ac669f74c26f01f8c139d" name="a040f9de8ca0ac669f74c26f01f8c139d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a040f9de8ca0ac669f74c26f01f8c139d">&#9670;&#160;</a></span>populateMathToLibmConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateMathToLibmConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from Math to Libm calls. </p>
<p>If log1pBenefit is present, use it instead of benefit for the Log1p op. </p>

<p class="definition">Definition at line <a class="el" href="MathToLibm_8cpp_source.html#l00163">163</a> of file <a class="el" href="MathToLibm_8cpp_source.html">MathToLibm.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a498c981e702899dd3494491f2f001a9d" name="a498c981e702899dd3494491f2f001a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498c981e702899dd3494491f2f001a9d">&#9670;&#160;</a></span>populateMathToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateMathToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>approximateLog1p</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MathToLLVM_8cpp_source.html#l00419">419</a> of file <a class="el" href="MathToLLVM_8cpp_source.html">MathToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a122c10e64cb8e8527ba75c5db4235740" name="a122c10e64cb8e8527ba75c5db4235740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a122c10e64cb8e8527ba75c5db4235740">&#9670;&#160;</a></span>populateMathToROCDLConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateMathToROCDLConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="structmlir_1_1amdgpu_1_1Chipset.html">amdgpu::Chipset</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>chipset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from Math to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> calls. </p>

<p class="definition">Definition at line <a class="el" href="MathToROCDL_8cpp_source.html#l00085">85</a> of file <a class="el" href="MathToROCDL_8cpp_source.html">MathToROCDL.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>, and <a class="el" href="MathToROCDL_8cpp_source.html#l00039">populateOpPatterns()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html#l00431">populateGpuToROCDLConversionPatterns()</a>, and <a class="el" href="MathToROCDL_8cpp_source.html#l00178">ConvertMathToROCDLPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="a6c5cdff8faeb322f48015571f5f4aae2" name="a6c5cdff8faeb322f48015571f5f4aae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c5cdff8faeb322f48015571f5f4aae2">&#9670;&#160;</a></span>populateMathToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateMathToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating Math ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="MathToSPIRV_8cpp_source.html#l00488">488</a> of file <a class="el" href="MathToSPIRV_8cpp_source.html">MathToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a110b276b38744134d9934f9f9ec6acd1" name="a110b276b38744134d9934f9f9ec6acd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110b276b38744134d9934f9f9ec6acd1">&#9670;&#160;</a></span>populateMathToXeVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateMathToXeVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>convertArith</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from Math to XeVM calls. </p>

<p class="definition">Definition at line <a class="el" href="MathToXeVM_8cpp_source.html#l00122">122</a> of file <a class="el" href="MathToXeVM_8cpp_source.html">MathToXeVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a99266ebe2b3be9d39e425ef361013656" name="a99266ebe2b3be9d39e425ef361013656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99266ebe2b3be9d39e425ef361013656">&#9670;&#160;</a></span>populateMemRefToEmitCConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateMemRefToEmitCConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefToEmitC_8cpp_source.html#l00407">407</a> of file <a class="el" href="MemRefToEmitC_8cpp_source.html">MemRefToEmitC.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a58637750147b089cca80eec8603b220f" name="a58637750147b089cca80eec8603b220f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58637750147b089cca80eec8603b220f">&#9670;&#160;</a></span>populateMemRefToEmitCTypeConversion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateMemRefToEmitCTypeConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefToEmitC_8cpp_source.html#l00379">379</a> of file <a class="el" href="MemRefToEmitC_8cpp_source.html">MemRefToEmitC.cpp</a>.</p>

<p class="reference">References <a class="el" href="MemRefToEmitC_8cpp_source.html#l00031">isMemRefTypeLegalForEmitC()</a>.</p>

</div>
</div>
<a id="ad19383f60ade82f3ca68e0cabda60d42" name="ad19383f60ade82f3ca68e0cabda60d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad19383f60ade82f3ca68e0cabda60d42">&#9670;&#160;</a></span>populateMemRefToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateMemRefToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating MemRef ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="MemRefToSPIRV_8cpp_source.html#l01105">1105</a> of file <a class="el" href="MemRefToSPIRV_8cpp_source.html">MemRefToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="ab2ca5cbf58aa081676683b5b8111cc50" name="ab2ca5cbf58aa081676683b5b8111cc50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ca5cbf58aa081676683b5b8111cc50">&#9670;&#160;</a></span>populateMMAToSPIRVCoopMatrixTypeConversion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateMMAToSPIRVCoopMatrixTypeConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">mlir::SPIRVTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds <span class="tt">MMAMatrixType</span> conversions to SPIR-V cooperative matrix KHR type conversion to the type converter. </p>

<p class="definition">Definition at line <a class="el" href="WmmaOpsToSPIRV_8cpp_source.html#l00368">368</a> of file <a class="el" href="WmmaOpsToSPIRV_8cpp_source.html">WmmaOpsToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVTypes_8cpp_source.html#l00269">mlir::spirv::CooperativeMatrixType::get()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00206">mlir::gpu::MMAMatrixType::getElementType()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00208">mlir::gpu::MMAMatrixType::getOperand()</a>, and <a class="el" href="GPUDialect_8cpp_source.html#l00202">mlir::gpu::MMAMatrixType::getShape()</a>.</p>

</div>
</div>
<a id="a77bc264eaa4a13001177aa530bcd2313" name="a77bc264eaa4a13001177aa530bcd2313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77bc264eaa4a13001177aa530bcd2313">&#9670;&#160;</a></span>populateNVGPUToNVVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateNVGPUToNVVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NVGPUToNVVM_8cpp_source.html#l01722">1722</a> of file <a class="el" href="NVGPUToNVVM_8cpp_source.html">NVGPUToNVVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a35eb3329af0ae57e8a63db9abeaf88e5" name="a35eb3329af0ae57e8a63db9abeaf88e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35eb3329af0ae57e8a63db9abeaf88e5">&#9670;&#160;</a></span>populateNVVMToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateNVVMToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NVVMToLLVM_8cpp_source.html#l00112">112</a> of file <a class="el" href="NVVMToLLVM_8cpp_source.html">NVVMToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="ac47aae037a21122571a70f95533c0152" name="ac47aae037a21122571a70f95533c0152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac47aae037a21122571a70f95533c0152">&#9670;&#160;</a></span>populateOpConvertToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateOpConvertToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConversionTarget.html">ConversionTarget</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function for populating <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> conversion patterns. </p>
<p>If <span class="tt">op</span> implements the <span class="tt">ConvertToLLVMOpInterface</span> interface, then the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> conversion pattern attributes provided by the interface will be used to configure the conversion target, type converter, and the pattern set. </p>

<p class="definition">Definition at line <a class="el" href="ToLLVMInterface_8cpp_source.html#l00033">33</a> of file <a class="el" href="ToLLVMInterface_8cpp_source.html">ToLLVMInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00238">mlir::Operation::getParentOfType()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02100">target</a>.</p>

</div>
</div>
<a id="a725b3caed685f9615fba2027124f359f" name="a725b3caed685f9615fba2027124f359f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725b3caed685f9615fba2027124f359f">&#9670;&#160;</a></span>populateOpenACCToSCFConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateOpenACCToSCFConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect the patterns to convert from the OpenACC dialect to OpenACC with SCF dialect. </p>

<p class="definition">Definition at line <a class="el" href="OpenACCToSCF_8cpp_source.html#l00059">59</a> of file <a class="el" href="OpenACCToSCF_8cpp_source.html">OpenACCToSCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a1111bfc29c10d7cd2ebba33996e38509" name="a1111bfc29c10d7cd2ebba33996e38509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1111bfc29c10d7cd2ebba33996e38509">&#9670;&#160;</a></span>populateOpenMPToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateOpenMPToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from OpenMP to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="OpenMPToLLVM_8cpp_source.html#l00150">150</a> of file <a class="el" href="OpenMPToLLVM_8cpp_source.html">OpenMPToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="OpenMPToLLVM_8cpp_source.html#l00145">addOpenMPOpConversions()</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a1727b1783cbf671c6ee60cc2a5c2f132" name="a1727b1783cbf671c6ee60cc2a5c2f132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1727b1783cbf671c6ee60cc2a5c2f132">&#9670;&#160;</a></span>populateParallelLoopToGPUPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateParallelLoopToGPUPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the conversion pattern from <span class="tt">scf.parallel</span> to <span class="tt">gpu.launch</span> to the provided pattern list. </p>

<p class="definition">Definition at line <a class="el" href="SCFToGPU_8cpp_source.html#l00770">770</a> of file <a class="el" href="SCFToGPU_8cpp_source.html">SCFToGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a0f51bdb2fcf79501ba4d3d7840fcd756" name="a0f51bdb2fcf79501ba4d3d7840fcd756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f51bdb2fcf79501ba4d3d7840fcd756">&#9670;&#160;</a></span>populatePolynomialApproximateErfcPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populatePolynomialApproximateErfcPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PolynomialApproximation_8cpp_source.html#l01778">1778</a> of file <a class="el" href="PolynomialApproximation_8cpp_source.html">PolynomialApproximation.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a3114521ec355e66601d128ab0cb9426f" name="a3114521ec355e66601d128ab0cb9426f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3114521ec355e66601d128ab0cb9426f">&#9670;&#160;</a></span>populatePolynomialApproximateErfPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populatePolynomialApproximateErfPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PolynomialApproximation_8cpp_source.html#l01773">1773</a> of file <a class="el" href="PolynomialApproximation_8cpp_source.html">PolynomialApproximation.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a350315b238bcca2eb1b91364e55deaf4" name="a350315b238bcca2eb1b91364e55deaf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a350315b238bcca2eb1b91364e55deaf4">&#9670;&#160;</a></span>populatePolynomialApproximateTanhPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populatePolynomialApproximateTanhPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PolynomialApproximation_8cpp_source.html#l01768">1768</a> of file <a class="el" href="PolynomialApproximation_8cpp_source.html">PolynomialApproximation.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a10daa5ecf515d29ea9079368f9b9b08d" name="a10daa5ecf515d29ea9079368f9b9b08d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10daa5ecf515d29ea9079368f9b9b08d">&#9670;&#160;</a></span>populatePrepareVectorToMMAPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populatePrepareVectorToMMAPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>useNvGpu</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to transform vector ops into a canonical form to convert to MMA matrix operations. </p>
<p>If <span class="tt">useNvGpu</span> is true, then the patterns will populated will prepare for conversion to <span class="tt">nvgpu</span> mma operations rather than the <span class="tt">gpu</span> dialect WMMA operations. </p>

<p class="definition">Definition at line <a class="el" href="VectorToGPU_8cpp_source.html#l01229">1229</a> of file <a class="el" href="VectorToGPU_8cpp_source.html">VectorToGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02357">mlir::vector::populateVectorContractCanonicalizeMatmulToMMT()</a>.</p>

</div>
</div>
<a id="a667f68e2860101c8caec8f46732e316e" name="a667f68e2860101c8caec8f46732e316e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a667f68e2860101c8caec8f46732e316e">&#9670;&#160;</a></span>populatePreSparsificationRewriting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populatePreSparsificationRewriting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseTensorRewriting_8cpp_source.html#l01572">1572</a> of file <a class="el" href="SparseTensorRewriting_8cpp_source.html">SparseTensorRewriting.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="ac260b877914dd5ce7bf80eb50ff87a4b" name="ac260b877914dd5ce7bf80eb50ff87a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac260b877914dd5ce7bf80eb50ff87a4b">&#9670;&#160;</a></span>populateRemoveShapeConstraintsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateRemoveShapeConstraintsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RemoveShapeConstraints_8cpp_source.html#l00064">64</a> of file <a class="el" href="RemoveShapeConstraints_8cpp_source.html">RemoveShapeConstraints.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a220ac6ca7c2aa2d95bfef6be6e813fc4" name="a220ac6ca7c2aa2d95bfef6be6e813fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220ac6ca7c2aa2d95bfef6be6e813fc4">&#9670;&#160;</a></span>populateReturnOpTypeConversionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateReturnOpTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a pattern to the given pattern list to rewrite <span class="tt">return</span> ops to use operands that have been legalized by the conversion framework. </p>

<p class="definition">Definition at line <a class="el" href="FuncConversions_8cpp_source.html#l00164">164</a> of file <a class="el" href="FuncConversions_8cpp_source.html">FuncConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="Arith_2Transforms_2EmulateNarrowType_8cpp_source.html#l00050">mlir::arith::populateArithNarrowTypeEmulationPatterns()</a>.</p>

</div>
</div>
<a id="a2162d2bc9640db32d4ae88c12ef3bd23" name="a2162d2bc9640db32d4ae88c12ef3bd23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2162d2bc9640db32d4ae88c12ef3bd23">&#9670;&#160;</a></span>populateReturnOpVectorRewritePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateReturnOpVectorRewritePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRVConversion_8cpp_source.html#l01726">1726</a> of file <a class="el" href="SPIRVConversion_8cpp_source.html">SPIRVConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVConversion_8cpp_source.html#l01478">mlir::spirv::unrollVectorsInSignatures()</a>.</p>

</div>
</div>
<a id="a9fc663ae01ea2b6384c3f6ce299be3b0" name="a9fc663ae01ea2b6384c3f6ce299be3b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc663ae01ea2b6384c3f6ce299be3b0">&#9670;&#160;</a></span>populateSCFToControlFlowConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateSCFToControlFlowConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert SCF operations to CFG branch-based operations within the ControlFlow dialect. </p>

<p class="definition">Definition at line <a class="el" href="SCFToControlFlow_8cpp_source.html#l00723">723</a> of file <a class="el" href="SCFToControlFlow_8cpp_source.html">SCFToControlFlow.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a601f437fd236d61c80f964d231b881cb" name="a601f437fd236d61c80f964d231b881cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601f437fd236d61c80f964d231b881cb">&#9670;&#160;</a></span>populateSCFToEmitCConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateSCFToEmitCConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert SCF operations to the EmitC dialect. </p>

<p class="definition">Definition at line <a class="el" href="SCFToEmitC_8cpp_source.html#l00504">504</a> of file <a class="el" href="SCFToEmitC_8cpp_source.html">SCFToEmitC.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a8ca1349510877edff1b6a3fe7249226c" name="a8ca1349510877edff1b6a3fe7249226c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca1349510877edff1b6a3fe7249226c">&#9670;&#160;</a></span>populateSCFToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateSCFToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ScfToSPIRVContext.html">ScfToSPIRVContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>scfToSPIRVContext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects a set of patterns to lower from scf.for, scf.if, and loop.terminator to CFG operations within the SPIR-V dialect. </p>

<p class="definition">Definition at line <a class="el" href="SCFToSPIRV_8cpp_source.html#l00448">448</a> of file <a class="el" href="SCFToSPIRV_8cpp_source.html">SCFToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="SCFToSPIRV_8h_source.html#l00029">mlir::ScfToSPIRVContext::getImpl()</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a068b739b7424900d4d98c15c81e4609e" name="a068b739b7424900d4d98c15c81e4609e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068b739b7424900d4d98c15c81e4609e">&#9670;&#160;</a></span>populateShapeRewritePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateShapeRewritePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects a set of patterns to rewrite ops within the Shape dialect. </p>

<p class="definition">Definition at line <a class="el" href="ShapeToShapeLowering_8cpp_source.html#l00080">80</a> of file <a class="el" href="ShapeToShapeLowering_8cpp_source.html">ShapeToShapeLowering.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a9d32c331310df6a35924ac128fa789f3" name="a9d32c331310df6a35924ac128fa789f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d32c331310df6a35924ac128fa789f3">&#9670;&#160;</a></span>populateShapeToStandardConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateShapeToStandardConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ShapeToStandard_8cpp_source.html#l00708">708</a> of file <a class="el" href="ShapeToStandard_8cpp_source.html">ShapeToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="aacaa4c3b727375b5ba2dc196a70a42bb" name="aacaa4c3b727375b5ba2dc196a70a42bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacaa4c3b727375b5ba2dc196a70a42bb">&#9670;&#160;</a></span>populateSparseAssembler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateSparseAssembler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>directOut</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseAssembler_8cpp_source.html#l00249">249</a> of file <a class="el" href="SparseAssembler_8cpp_source.html">SparseAssembler.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a6168f425252f728e066433be9ee022b2" name="a6168f425252f728e066433be9ee022b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6168f425252f728e066433be9ee022b2">&#9670;&#160;</a></span>populateSparseBufferRewriting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateSparseBufferRewriting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>enableBufferInitialization</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseBufferRewriting_8cpp_source.html#l01430">1430</a> of file <a class="el" href="SparseBufferRewriting_8cpp_source.html">SparseBufferRewriting.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="ad48873e0e6f944a5579b28be3cc1c944" name="ad48873e0e6f944a5579b28be3cc1c944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad48873e0e6f944a5579b28be3cc1c944">&#9670;&#160;</a></span>populateSparseGPUCodegenPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateSparseGPUCodegenPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numThreads</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseGPUCodegen_8cpp_source.html#l01334">1334</a> of file <a class="el" href="SparseGPUCodegen_8cpp_source.html">SparseGPUCodegen.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a41ac451ba0b1c3393df013233d3c93c2" name="a41ac451ba0b1c3393df013233d3c93c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ac451ba0b1c3393df013233d3c93c2">&#9670;&#160;</a></span>populateSparseGPULibgenPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateSparseGPULibgenPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>enableRT</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseGPUCodegen_8cpp_source.html#l01339">1339</a> of file <a class="el" href="SparseGPUCodegen_8cpp_source.html">SparseGPUCodegen.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="ae43552eafb8cb1d923a84783b520748d" name="ae43552eafb8cb1d923a84783b520748d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43552eafb8cb1d923a84783b520748d">&#9670;&#160;</a></span>populateSparseReinterpretMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateSparseReinterpretMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a855a7d93430958efaaf3a6f69e3dac1c">ReinterpretMapScope</a></td>          <td class="paramname"><span class="paramname"><em>scope</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a831cb9fe0506a02a0ad7a9babfba8eb7">sparse_tensor::LoopOrderingStrategy</a></td>          <td class="paramname"><span class="paramname"><em>strategy</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a831cb9fe0506a02a0ad7a9babfba8eb7a6867faeaa475fda467e48267db2bb8a8">sparse_tensor::LoopOrderingStrategy::kDefault</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseReinterpretMap_8cpp_source.html#l00796">796</a> of file <a class="el" href="SparseReinterpretMap_8cpp_source.html">SparseReinterpretMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l00046">kAll</a>, <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l00048">kExceptGeneric</a>, <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l00047">kGenericOnly</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a271ea308903cf0d605df0c3ba5f13b6c" name="a271ea308903cf0d605df0c3ba5f13b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a271ea308903cf0d605df0c3ba5f13b6c">&#9670;&#160;</a></span>populateSparseTensorCodegenPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateSparseTensorCodegenPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>createSparseDeallocs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>enableBufferInitialization</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up sparse tensor codegen rules. </p>
<p>Populates the given patterns list with conversion rules required for the sparsification of linear algebra operations. </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorCodegen_8cpp_source.html#l01615">1615</a> of file <a class="el" href="SparseTensorCodegen_8cpp_source.html">SparseTensorCodegen.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a5a109a00c2dac890cb8db767e9a9982d" name="a5a109a00c2dac890cb8db767e9a9982d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a109a00c2dac890cb8db767e9a9982d">&#9670;&#160;</a></span>populateSparseTensorConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateSparseTensorConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up sparse tensor conversion rules. </p>
<p>Populates the given patterns list with conversion rules required for the sparsification of linear algebra operations. </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorConversion_8cpp_source.html#l00914">914</a> of file <a class="el" href="SparseTensorConversion_8cpp_source.html">SparseTensorConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a76dc06de29760922469c1e4bd10a62c9" name="a76dc06de29760922469c1e4bd10a62c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76dc06de29760922469c1e4bd10a62c9">&#9670;&#160;</a></span>populateSparseVectorizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateSparseVectorizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>vectorLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>enableVLAVectorization</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>enableSIMDIndex32</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the given patterns list with vectorization rules. </p>

<p class="definition">Definition at line <a class="el" href="SparseVectorization_8cpp_source.html#l00682">682</a> of file <a class="el" href="SparseVectorization_8cpp_source.html">SparseVectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>, and <a class="el" href="LowerVectorStep_8cpp_source.html#l00046">mlir::vector::populateVectorStepLoweringPatterns()</a>.</p>

</div>
</div>
<a id="a86f7f8933f0baf6ebeddfdc698327c31" name="a86f7f8933f0baf6ebeddfdc698327c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f7f8933f0baf6ebeddfdc698327c31">&#9670;&#160;</a></span>populateSparsificationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateSparsificationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up sparsification rewriting rules with the given options. </p>
<p>Populates the given patterns list with rewriting rules required for the sparsification of linear algebra operations. </p>

<p class="definition">Definition at line <a class="el" href="Sparsification_8cpp_source.html#l01482">1482</a> of file <a class="el" href="Sparsification_8cpp_source.html">Sparsification.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="aa47a30210dfc5deae1daa2e2c8840d8f" name="aa47a30210dfc5deae1daa2e2c8840d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47a30210dfc5deae1daa2e2c8840d8f">&#9670;&#160;</a></span>populateSPIRVToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateSPIRVToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spirv::ClientAPI</td>          <td class="paramname"><span class="paramname"><em>clientAPIForAddressSpaceMapping</em></span><span class="paramdefsep"> = </span><span class="paramdefval">spirv::ClientAPI::Unknown</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the given list with patterns that convert from SPIR-V to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVToLLVM_8cpp_source.html#l01790">1790</a> of file <a class="el" href="SPIRVToLLVM_8cpp_source.html">SPIRVToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a6ee4e0b9121971b2ca8fcc16640d457f" name="a6ee4e0b9121971b2ca8fcc16640d457f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee4e0b9121971b2ca8fcc16640d457f">&#9670;&#160;</a></span>populateSPIRVToLLVMFunctionConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateSPIRVToLLVMFunctionConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the given list with patterns for function conversion from SPIR-V to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVToLLVM_8cpp_source.html#l01956">1956</a> of file <a class="el" href="SPIRVToLLVM_8cpp_source.html">SPIRVToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="abe47840c56acca273d219c5fc82b179d" name="abe47840c56acca273d219c5fc82b179d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe47840c56acca273d219c5fc82b179d">&#9670;&#160;</a></span>populateSPIRVToLLVMModuleConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateSPIRVToLLVMModuleConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the given patterns for module conversion from SPIR-V to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVToLLVM_8cpp_source.html#l01961">1961</a> of file <a class="el" href="SPIRVToLLVM_8cpp_source.html">SPIRVToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a35333950f5d30c0990ebca7da9dd882c" name="a35333950f5d30c0990ebca7da9dd882c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35333950f5d30c0990ebca7da9dd882c">&#9670;&#160;</a></span>populateSPIRVToLLVMTypeConversion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateSPIRVToLLVMTypeConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spirv::ClientAPI</td>          <td class="paramname"><span class="paramname"><em>clientAPIForAddressSpaceMapping</em></span><span class="paramdefsep"> = </span><span class="paramdefval">spirv::ClientAPI::Unknown</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates type conversions with additional SPIR-V types. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVToLLVM_8cpp_source.html#l01774">1774</a> of file <a class="el" href="SPIRVToLLVM_8cpp_source.html">SPIRVToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00255">convertArrayType()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00270">convertPointerType()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00281">convertRuntimeArrayType()</a>, and <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00291">convertStructType()</a>.</p>

</div>
</div>
<a id="ab05749dd321afd1862ad40e29349e733" name="ab05749dd321afd1862ad40e29349e733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05749dd321afd1862ad40e29349e733">&#9670;&#160;</a></span>populateStageSparseOperationsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateStageSparseOperationsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up StageSparseOperation rewriting rules. </p>

<p class="definition">Definition at line <a class="el" href="StageSparseOperations_8cpp_source.html#l00070">70</a> of file <a class="el" href="StageSparseOperations_8cpp_source.html">StageSparseOperations.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a07d707e1aa02507e261dec9e171b37d1" name="a07d707e1aa02507e261dec9e171b37d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d707e1aa02507e261dec9e171b37d1">&#9670;&#160;</a></span>populateStorageSpecifierToLLVMPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateStorageSpecifierToLLVMPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseStorageSpecifierToLLVM_8cpp_source.html#l00353">353</a> of file <a class="el" href="SparseStorageSpecifierToLLVM_8cpp_source.html">SparseStorageSpecifierToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a5b8ecf548ab4c5b21eddf5ee62e618e8" name="a5b8ecf548ab4c5b21eddf5ee62e618e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8ecf548ab4c5b21eddf5ee62e618e8">&#9670;&#160;</a></span>populateTensorToLinalgPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateTensorToLinalgPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating tensor ops to Linalg ops. </p>

<p class="definition">Definition at line <a class="el" href="TensorToLinalg_8cpp_source.html#l00024">24</a> of file <a class="el" href="TensorToLinalg_8cpp_source.html">TensorToLinalg.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a0ba8a125094bd28e1f1db4858eb5ff52" name="a0ba8a125094bd28e1f1db4858eb5ff52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba8a125094bd28e1f1db4858eb5ff52">&#9670;&#160;</a></span>populateTensorToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateTensorToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>byteCountThreshold</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating tensor ops to SPIR-V ops. </p>
<p>Note: Normally tensors will be stored in buffers before converting to SPIR-V, given that is how a large amount of data is sent to the GPU. However, SPIR-V supports converting from tensors directly too. This is for the cases where the tensor just contains a small amount of elements and it makes sense to directly inline them as a small data array in the shader. To handle this, internally the conversion might create new local variables. SPIR-V consumers in GPU drivers may or may not optimize that away. So this has implications over register pressure. Therefore, a threshold is used to control when the patterns should kick in. </p>

<p class="definition">Definition at line <a class="el" href="TensorToSPIRV_8cpp_source.html#l00103">103</a> of file <a class="el" href="TensorToSPIRV_8cpp_source.html">TensorToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a54519be832df231094e4e22a067bde19" name="a54519be832df231094e4e22a067bde19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54519be832df231094e4e22a067bde19">&#9670;&#160;</a></span>populateUpliftToFMAPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateUpliftToFMAPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="UpliftToFMA_8cpp_source.html#l00076">76</a> of file <a class="el" href="UpliftToFMA_8cpp_source.html">UpliftToFMA.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a7fdbf57d9d955aea59286a07c5c3c03a" name="a7fdbf57d9d955aea59286a07c5c3c03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fdbf57d9d955aea59286a07c5c3c03a">&#9670;&#160;</a></span>populateVectorReductionToSPIRVDotProductPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateVectorReductionToSPIRVDotProductPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns to convert vector reduction of the form: </p>
<div class="fragment"><div class="line"><a class="code hl_namespace" href="namespacemlir_1_1vector.html">vector</a>.reduction &lt;<a class="code hl_define" href="XeGPUDialect_8cpp.html#a1a14019f88db2a0b038688cd9830ea7e">add</a>&gt;, (muli (ext %<a class="code hl_variable" href="IR_2AffineExpr_8cpp.html#a204f446339af7929852f44df41484be5">lhs</a>), (ext %<a class="code hl_variable" href="VectorTransforms_8cpp.html#a611c177776150f2e11f15c1cec5764c1">rhs</a>)), [%<a class="code hl_namespace" href="namespacemlir_1_1acc.html">acc</a>]</div>
<div class="ttc" id="aIR_2AffineExpr_8cpp_html_a204f446339af7929852f44df41484be5"><div class="ttname"><a href="IR_2AffineExpr_8cpp.html#a204f446339af7929852f44df41484be5">lhs</a></div><div class="ttdeci">lhs</div><div class="ttdef"><b>Definition</b> <a href="IR_2AffineExpr_8cpp_source.html#l00832">AffineExpr.cpp:832</a></div></div>
<div class="ttc" id="aVectorTransforms_8cpp_html_a611c177776150f2e11f15c1cec5764c1"><div class="ttname"><a href="VectorTransforms_8cpp.html#a611c177776150f2e11f15c1cec5764c1">rhs</a></div><div class="ttdeci">*B rhs</div><div class="ttdef"><b>Definition</b> <a href="VectorTransforms_8cpp_source.html#l02249">VectorTransforms.cpp:2249</a></div></div>
<div class="ttc" id="aXeGPUDialect_8cpp_html_a1a14019f88db2a0b038688cd9830ea7e"><div class="ttname"><a href="XeGPUDialect_8cpp.html#a1a14019f88db2a0b038688cd9830ea7e">add</a></div><div class="ttdeci">#define add(a, b)</div><div class="ttdef"><b>Definition</b> <a href="XeGPUDialect_8cpp_source.html#l00976">XeGPUDialect.cpp:976</a></div></div>
<div class="ttc" id="anamespacemlir_1_1acc_html"><div class="ttname"><a href="namespacemlir_1_1acc.html">mlir::acc</a></div><div class="ttdef"><b>Definition</b> <a href="OpenACCSupport_8h_source.html#l00061">OpenACCSupport.h:61</a></div></div>
<div class="ttc" id="anamespacemlir_1_1vector_html"><div class="ttname"><a href="namespacemlir_1_1vector.html">mlir::vector</a></div><div class="ttdef"><b>Definition</b> <a href="ConvertVectorToLLVM_8h_source.html#l00022">ConvertVectorToLLVM.h:22</a></div></div>
</div><!-- fragment --><p>to SPIR-V integer dot product ops. </p>

<p class="definition">Definition at line <a class="el" href="VectorToSPIRV_8cpp_source.html#l01092">1092</a> of file <a class="el" href="VectorToSPIRV_8cpp_source.html">VectorToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a2cbeef3e897ac11eb895c16b9cdb9a2c" name="a2cbeef3e897ac11eb895c16b9cdb9a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cbeef3e897ac11eb895c16b9cdb9a2c">&#9670;&#160;</a></span>populateVectorToAMXConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateVectorToAMXConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the vector to AMX ops. </p>

<p class="definition">Definition at line <a class="el" href="VectorToAMX_8cpp_source.html#l00426">426</a> of file <a class="el" href="VectorToAMX_8cpp_source.html">VectorToAMX.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="ae512bcd2d0e2cc4f8ddb82e2922ccc8b" name="ae512bcd2d0e2cc4f8ddb82e2922ccc8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae512bcd2d0e2cc4f8ddb82e2922ccc8b">&#9670;&#160;</a></span>populateVectorToArmSMEPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateVectorToArmSMEPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to lower <a class="el" href="structVector.html">Vector</a> ops to ArmSME ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>

<p class="definition">Definition at line <a class="el" href="VectorToArmSME_8cpp_source.html#l00736">736</a> of file <a class="el" href="VectorToArmSME_8cpp_source.html">VectorToArmSME.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a9e2a9c17c36e972e2c9b81bee3a58a7d" name="a9e2a9c17c36e972e2c9b81bee3a58a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e2a9c17c36e972e2c9b81bee3a58a7d">&#9670;&#160;</a></span>populateVectorToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateVectorToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>reassociateFPReductions</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>force32BitVectorIndices</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>useVectorAlignment</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the <a class="el" href="structVector.html">Vector</a> dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>
<p>Populate the given list with patterns that convert from <a class="el" href="structVector.html">Vector</a> to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l02199">2199</a> of file <a class="el" href="ConvertVectorToLLVM_8cpp_source.html">ConvertVectorToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8h_source.html#l00105">mlir::LLVMTypeConverter::getDialect()</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a96c6c9c53e199da9b2def6f5e62eec02" name="a96c6c9c53e199da9b2def6f5e62eec02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c6c9c53e199da9b2def6f5e62eec02">&#9670;&#160;</a></span>populateVectorToSCFConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateVectorToSCFConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the <a class="el" href="structVector.html">Vector</a> dialect to SCF + func. </p>

<p class="definition">Definition at line <a class="el" href="VectorToSCF_8cpp_source.html#l01697">1697</a> of file <a class="el" href="VectorToSCF_8cpp_source.html">VectorToSCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="aff2bafba6c8ae1b85a1abadc386f22a3" name="aff2bafba6c8ae1b85a1abadc386f22a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2bafba6c8ae1b85a1abadc386f22a3">&#9670;&#160;</a></span>populateVectorToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateVectorToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating <a class="el" href="structVector.html">Vector</a> Ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="VectorToSPIRV_8cpp_source.html#l01069">1069</a> of file <a class="el" href="VectorToSPIRV_8cpp_source.html">VectorToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a94a6fd23ac57182bebb5185f7013e2fa" name="a94a6fd23ac57182bebb5185f7013e2fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a6fd23ac57182bebb5185f7013e2fa">&#9670;&#160;</a></span>populateVectorToXeGPUConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateVectorToXeGPUConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the vector to XeGPU ops. </p>

<p class="definition">Definition at line <a class="el" href="VectorToXeGPU_8cpp_source.html#l00826">826</a> of file <a class="el" href="VectorToXeGPU_8cpp_source.html">VectorToXeGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a05930f6194dee5366651710de8da45c9" name="a05930f6194dee5366651710de8da45c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05930f6194dee5366651710de8da45c9">&#9670;&#160;</a></span>populateX86VectorLegalizeForLLVMExportPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateX86VectorLegalizeForLLVMExportPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to lower X86Vector ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>
<p>Populate the given list with patterns that convert from X86Vector to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="X86Vector_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00041">41</a> of file <a class="el" href="X86Vector_2Transforms_2LegalizeForLLVMExport_8cpp_source.html">LegalizeForLLVMExport.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a9516463b940e7c464ca9398d327558cc" name="a9516463b940e7c464ca9398d327558cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9516463b940e7c464ca9398d327558cc">&#9670;&#160;</a></span>populateXeGPUToXeVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateXeGPUToXeVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUToXeVM_8cpp_source.html#l01267">1267</a> of file <a class="el" href="XeGPUToXeVM_8cpp_source.html">XeGPUToXeVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>.</p>

</div>
</div>
<a id="a5fab7f1dcbf00d2ed28e6800debf00cc" name="a5fab7f1dcbf00d2ed28e6800debf00cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fab7f1dcbf00d2ed28e6800debf00cc">&#9670;&#160;</a></span>populateXeVMToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void::mlir::populateXeVMToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classConversionTarget.html">ConversionTarget</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeVMToLLVM_8cpp_source.html#l00910">910</a> of file <a class="el" href="XeVMToLLVM_8cpp_source.html">XeVMToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02100">target</a>.</p>

</div>
</div>
<a id="a34ab168056505b09c113dda01ee42d5e" name="a34ab168056505b09c113dda01ee42d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34ab168056505b09c113dda01ee42d5e">&#9670;&#160;</a></span>printDimensionList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::printDimensionList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>printer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>dimensions</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l04187">4187</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l03020">mlir::AsmPrinter::printDimensionList()</a>.</p>

</div>
</div>
<a id="a34ab168056505b09c113dda01ee42d5e" name="a34ab168056505b09c113dda01ee42d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34ab168056505b09c113dda01ee42d5e">&#9670;&#160;</a></span>printDimensionList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::printDimensionList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>printer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>dimensions</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l04187">4187</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l03020">mlir::AsmPrinter::printDimensionList()</a>.</p>

</div>
</div>
<a id="af0ddf52b0e7e83bc5b1add0aef99f487" name="af0ddf52b0e7e83bc5b1add0aef99f487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ddf52b0e7e83bc5b1add0aef99f487">&#9670;&#160;</a></span>printDynamicIndexList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::printDynamicIndexList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>printer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperandRange.html">OperandRange</a></td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>integers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classbool.html">bool</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>scalableFlags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a></td>          <td class="paramname"><span class="paramname"><em>valueTypes</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">AsmParser::Delimiter</a></td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">AsmParser::Delimiter::Square</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Printer hooks for custom directive in assemblyFormat. </p>
<p>custom&lt;DynamicIndexList&gt;($values, $integers) custom&lt;DynamicIndexList&gt;($values, $integers, type($values))</p>
<p>where <span class="tt">values</span> is of ODS type <span class="tt">Variadic&lt;*&gt;</span> and <span class="tt">integers</span> is of ODS type <span class="tt">I64ArrayAttr</span>. Print a list where each element is either:</p><ol type="1">
<li>the static integer value in <span class="tt">integers</span>, if it's not <span class="tt">kDynamic</span> or,</li>
<li>the next value in <span class="tt">values</span>, otherwise.</li>
</ol>
<p>If <span class="tt">valueTypes</span> is provided, the corresponding type of each dynamic value is printed. Otherwise, the type is not printed. Each type must match the type of the corresponding value in <span class="tt">values</span>. <span class="tt">valueTypes</span> is redundant for printing as we can retrieve the types from the actual <span class="tt">values</span>. However, <span class="tt">valueTypes</span> is needed for parsing and we must keep the API symmetric for parsing and printing. The type for integer elements is <span class="tt">i64</span> by default and never printed.</p>
<p>Integer indices can also be scalable in the context of scalable vectors, denoted by square brackets (e.g., "[2, [4], 8]"). For each value in <span class="tt">integers</span>, the corresponding <span class="tt">bool</span> in <span class="tt">scalableFlags</span> encodes whether it's a scalable index. If <span class="tt">scalableFlags</span> is empty then assume that all indices are non-scalable.</p>
<p>Examples:</p>
<ul>
<li>Input: <span class="tt">integers = [kDynamic, 7, 42, kDynamic]</span>, <span class="tt">values = [arg0, arg42]</span> and <span class="tt">valueTypes = [index, index]</span> prints: <span class="tt">[arg0 : index, 7, 42, arg42 : i32]</span></li>
<li>Input: <span class="tt">integers = [kDynamic, 7, 42, kDynamic]</span>, <span class="tt">values = [arg0, arg42]</span> and <span class="tt">valueTypes = []</span> prints: <span class="tt">[arg0, 7, 42, arg42]</span></li>
<li>Input: <span class="tt">integers = [2, 4, 8]</span>, <span class="tt">values = []</span> and <span class="tt">scalableFlags = [false, true, false]</span> prints: <span class="tt">[2, [4], 8]</span> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00195">195</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ViewLikeInterface_8cpp_source.html#l00165">getLeftDelimiter()</a>, and <a class="el" href="ViewLikeInterface_8cpp_source.html#l00180">getRightDelimiter()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ViewLikeInterface_8h_source.html#l00169">printDynamicIndexList()</a>, <a class="el" href="XeGPUOps_8cpp_source.html#l00450">printOptionalDynamicIndexList()</a>, and <a class="el" href="Dialect_2Transform_2Utils_2Utils_8cpp_source.html#l00017">mlir::transform::printPackedOrDynamicIndexList()</a>.</p>

</div>
</div>
<a id="aac3d9353398664321147f5b579f1d767" name="aac3d9353398664321147f5b579f1d767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac3d9353398664321147f5b579f1d767">&#9670;&#160;</a></span>printDynamicIndexList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::printDynamicIndexList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>printer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperandRange.html">OperandRange</a></td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>integers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a></td>          <td class="paramname"><span class="paramname"><em>valueTypes</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">AsmParser::Delimiter</a></td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">AsmParser::Delimiter::Square</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8h_source.html#l00169">169</a> of file <a class="el" href="ViewLikeInterface_8h_source.html">ViewLikeInterface.h</a>.</p>

<p class="reference">References <a class="el" href="ViewLikeInterface_8cpp_source.html#l00195">printDynamicIndexList()</a>, and <a class="el" href="OpImplementation_8h_source.html#l00818">mlir::AsmParser::Square</a>.</p>

</div>
</div>
<a id="a41d5e525ca50e6257e78416957f7778c" name="a41d5e525ca50e6257e78416957f7778c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41d5e525ca50e6257e78416957f7778c">&#9670;&#160;</a></span>printRegisteredPasses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::printRegisteredPasses </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the passes that were previously registered and stored in passRegistry. </p>

<p class="definition">Definition at line <a class="el" href="PassRegistry_8cpp_source.html#l00072">72</a> of file <a class="el" href="PassRegistry_8cpp_source.html">PassRegistry.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00027">passRegistry</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00730">printRegisteredPassesAndReturn()</a>.</p>

</div>
</div>
<a id="a89e64306db27cef578b1ba608d3d8565" name="a89e64306db27cef578b1ba608d3d8565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89e64306db27cef578b1ba608d3d8565">&#9670;&#160;</a></span>printSemiFunctionType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::printSemiFunctionType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>printer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>argumentType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>resultType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>resultOptional</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Syntax_8cpp_source.html#l00076">76</a> of file <a class="el" href="Syntax_8cpp_source.html">Syntax.cpp</a>.</p>

<p class="reference">References <a class="el" href="Syntax_8cpp_source.html#l00060">printSemiFunctionType()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02099">TypeRange</a>.</p>

</div>
</div>
<a id="a979423818fdead0e008345256a1e2d10" name="a979423818fdead0e008345256a1e2d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979423818fdead0e008345256a1e2d10">&#9670;&#160;</a></span>printSemiFunctionType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::printSemiFunctionType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>printer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>argumentType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a></td>          <td class="paramname"><span class="paramname"><em>resultType</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints argument and result types in a syntax similar to that of FunctionType but allowing and requiring one to omit the parens around the argument type in absence of result types, and without the trailing <span class="tt">-&gt; ()</span>. </p>

<p class="definition">Definition at line <a class="el" href="Syntax_8cpp_source.html#l00060">60</a> of file <a class="el" href="Syntax_8cpp_source.html">Syntax.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Syntax_8cpp_source.html#l00076">printSemiFunctionType()</a>.</p>

</div>
</div>
<a id="ae1261e0343cefe25ab1724c67005b7d2" name="ae1261e0343cefe25ab1724c67005b7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1261e0343cefe25ab1724c67005b7d2">&#9670;&#160;</a></span>projectDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::projectDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;</td>          <td class="paramname"><span class="paramname"><em>projectedDimensions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>compressDimsFlag</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the map that results from projecting out the dimensions specified in <span class="tt">projectedDimensions</span>. </p>
<p>The projected dimensions are set to 0.</p>
<p>Example: 1) map : affine_map&lt;(d0, d1, d2) -&gt; (d0, d1)&gt; projected_dimensions : {2} result : affine_map&lt;(d0, d1) -&gt; (d0, d1)&gt;</p>
<p>2) map : affine_map&lt;(d0, d1) -&gt; (d0 + d1)&gt; projected_dimensions : {1} result : affine_map&lt;(d0) -&gt; (d0)&gt;</p>
<p>3) map : affine_map&lt;(d0, d1, d2) -&gt; (d0, d1)&gt; projected_dimensions : {1} result : affine_map&lt;(d0, d1) -&gt; (d0, 0)&gt;</p>
<p>This function also compresses the dims when the boolean flag is true. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00899">899</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00853">projectCommonImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00710">compressDims()</a>, <a class="el" href="PadTilingInterface_8cpp_source.html#l00099">mlir::linalg::computePaddedShape()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00913">getProjectedMap()</a>.</p>

</div>
</div>
<a id="ae5ec6082bc5758f83f4b0938b00b160d" name="ae5ec6082bc5758f83f4b0938b00b160d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ec6082bc5758f83f4b0938b00b160d">&#9670;&#160;</a></span>projectSymbols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::projectSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;</td>          <td class="paramname"><span class="paramname"><em>projectedSymbols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>compressSymbolsFlag</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Symbol counterpart of <span class="tt">projectDims</span>. </p>
<p>This function also compresses the symbols when the boolean flag is true. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00906">906</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00853">projectCommonImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00724">compressSymbols()</a>.</p>

</div>
</div>
<a id="a7173c36d6b113dcdb0599eb672526b43" name="a7173c36d6b113dcdb0599eb672526b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7173c36d6b113dcdb0599eb672526b43">&#9670;&#160;</a></span>promoteToWorkgroupMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::promoteToWorkgroupMemory </td>
          <td>(</td>
          <td class="paramtype">gpu::GPUFuncOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promotes a function argument to workgroup memory in the given function. </p>
<p>The copies will be inserted in the beginning and in the end of the function. </p>

</div>
</div>
<a id="af98f1102c5f82e37f4e4cf21be1736f8" name="af98f1102c5f82e37f4e4cf21be1736f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af98f1102c5f82e37f4e4cf21be1736f8">&#9670;&#160;</a></span>readBytecodeFile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::readBytecodeFile </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sourceMgr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>config</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An overload with a source manager whose main file buffer is used for parsing. </p>
<p>The lifetime of the source manager may be freely extended during parsing such that the source manager is not destroyed before the parsed IR. </p>

<p class="definition">Definition at line <a class="el" href="BytecodeReader_8cpp_source.html#l02836">2836</a> of file <a class="el" href="BytecodeReader_8cpp_source.html">BytecodeReader.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00284">config</a>, and <a class="el" href="BytecodeReader_8cpp_source.html#l02815">readBytecodeFileImpl()</a>.</p>

</div>
</div>
<a id="ad3b71d67f0d7fe035e455a121e826f08" name="ad3b71d67f0d7fe035e455a121e826f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b71d67f0d7fe035e455a121e826f08">&#9670;&#160;</a></span>readBytecodeFile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::readBytecodeFile </td>
          <td>(</td>
          <td class="paramtype">llvm::MemoryBufferRef</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>config</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the operations defined within the given memory buffer, containing MLIR bytecode, into the provided block. </p>

<p class="definition">Definition at line <a class="el" href="BytecodeReader_8cpp_source.html#l02831">2831</a> of file <a class="el" href="BytecodeReader_8cpp_source.html">BytecodeReader.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00284">config</a>, and <a class="el" href="BytecodeReader_8cpp_source.html#l02815">readBytecodeFileImpl()</a>.</p>

</div>
</div>
<a id="a2ef4c7804d8356c0813ce04f87b2b1ff" name="a2ef4c7804d8356c0813ce04f87b2b1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ef4c7804d8356c0813ce04f87b2b1ff">&#9670;&#160;</a></span>readResourceHandle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::readResourceHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectBytecodeReader.html">DialectBytecodeReader</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>reader</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FailureOr&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>params</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for resource handle reading that returns LogicalResult. </p>

<p class="definition">Definition at line <a class="el" href="BytecodeImplementation_8h_source.html#l00494">494</a> of file <a class="el" href="BytecodeImplementation_8h_source.html">BytecodeImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00152">mlir::DialectBytecodeReader::readResourceHandle()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a579b330f2795cc0443c3a508a9585772" name="a579b330f2795cc0443c3a508a9585772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579b330f2795cc0443c3a508a9585772">&#9670;&#160;</a></span>reconcileUnrealizedCasts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::reconcileUnrealizedCasts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#abde461319ad5039ddbf5b4e70f47618b">DenseMap</a>&lt; UnrealizedConversionCastOp, UnresolvedMaterializationInfo &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>castOps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; UnrealizedConversionCastOp &gt; *</td>          <td class="paramname"><span class="paramname"><em>remainingCastOps</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03261">3261</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l03140">reconcileUnrealizedCastsImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8cpp_source.html#l03401">mlir::OperationConverter::convertOperations()</a>.</p>

</div>
</div>
<a id="afe55df95d48191f0fa2c5ab8f4e81e34" name="afe55df95d48191f0fa2c5ab8f4e81e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe55df95d48191f0fa2c5ab8f4e81e34">&#9670;&#160;</a></span>registerAllDialects() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAllDialects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add all the MLIR dialects to the provided registry. </p>

<p class="definition">Definition at line <a class="el" href="RegisterAllDialects_8cpp_source.html#l00109">109</a> of file <a class="el" href="RegisterAllDialects_8cpp_source.html">RegisterAllDialects.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00152">mlir::DialectRegistry::insert()</a>, <a class="el" href="AllInterfaces_8cpp_source.html#l00017">mlir::linalg::registerAllDialectInterfaceImplementations()</a>, <a class="el" href="AllocationOpInterfaceImpl_8cpp_source.html#l00062">mlir::memref::registerAllocationOpInterfaceExternalModels()</a>, <a class="el" href="Arith_2Transforms_2BufferDeallocationOpInterfaceImpl_8cpp_source.html#l00080">mlir::arith::registerBufferDeallocationOpInterfaceExternalModels()</a>, <a class="el" href="ControlFlow_2Transforms_2BufferDeallocationOpInterfaceImpl_8cpp_source.html#l00159">mlir::cf::registerBufferDeallocationOpInterfaceExternalModels()</a>, <a class="el" href="GPU_2Transforms_2BufferDeallocationOpInterfaceImpl_8cpp_source.html#l00031">mlir::gpu::registerBufferDeallocationOpInterfaceExternalModels()</a>, <a class="el" href="SCF_2Transforms_2BufferDeallocationOpInterfaceImpl_8cpp_source.html#l00075">mlir::scf::registerBufferDeallocationOpInterfaceExternalModels()</a>, <a class="el" href="Arith_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00215">mlir::arith::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00541">mlir::bufferization::func_ext::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="ControlFlow_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00061">mlir::cf::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="MLProgram_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00160">mlir::ml_program::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="SCF_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l01367">mlir::scf::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="Shape_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00139">mlir::shape::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="SparseTensor_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00326">mlir::sparse_tensor::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="Tensor_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l01191">mlir::tensor::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="Vector_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00379">mlir::vector::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="Arith_2Transforms_2BufferViewFlowOpInterfaceImpl_8cpp_source.html#l00039">mlir::arith::registerBufferViewFlowOpInterfaceExternalModels()</a>, <a class="el" href="MemRef_2Transforms_2BufferViewFlowOpInterfaceImpl_8cpp_source.html#l00043">mlir::memref::registerBufferViewFlowOpInterfaceExternalModels()</a>, <a class="el" href="CastInterfaces_8cpp_source.html#l00080">mlir::builtin::registerCastOpInterfaceExternalModels()</a>, <a class="el" href="TensorTransformOps_8cpp_source.html#l00071">mlir::tensor::registerFindPayloadReplacementOpInterfaceExternalModels()</a>, <a class="el" href="TensorInferTypeOpInterfaceImpl_8cpp_source.html#l00131">mlir::tensor::registerInferTypeOpInterfaceExternalModels()</a>, <a class="el" href="InlinerInterfaceImpl_8cpp_source.html#l00829">mlir::LLVM::registerInlinerInterface()</a>, <a class="el" href="InlinerInterfaceImpl_8cpp_source.html#l00835">mlir::NVVM::registerInlinerInterface()</a>, <a class="el" href="MemRefMemorySlot_8cpp_source.html#l00332">mlir::memref::registerMemorySlotExternalModels()</a>, <a class="el" href="LLVM_2NVVM_2Target_8cpp_source.html#l00073">mlir::NVVM::registerNVVMTargetInterfaceExternalModels()</a>, <a class="el" href="LLVM_2ROCDL_2Target_8cpp_source.html#l00069">mlir::ROCDL::registerROCDLTargetInterfaceExternalModels()</a>, <a class="el" href="Linalg_2Transforms_2RuntimeOpVerification_8cpp_source.html#l00153">mlir::linalg::registerRuntimeVerifiableOpInterfaceExternalModels()</a>, <a class="el" href="MemRef_2Transforms_2RuntimeOpVerification_8cpp_source.html#l00403">mlir::memref::registerRuntimeVerifiableOpInterfaceExternalModels()</a>, <a class="el" href="Tensor_2Transforms_2RuntimeOpVerification_8cpp_source.html#l00244">mlir::tensor::registerRuntimeVerifiableOpInterfaceExternalModels()</a>, <a class="el" href="Arith_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00098">mlir::arith::registerShardingInterfaceExternalModels()</a>, <a class="el" href="Tosa_2IR_2ShardingInterfaceImpl_8cpp_source.html#l00116">mlir::tosa::registerShardingInterfaceExternalModels()</a>, <a class="el" href="SPIRV_2Target_8cpp_source.html#l00044">mlir::spirv::registerSPIRVTargetInterfaceExternalModels()</a>, <a class="el" href="Tensor_2Transforms_2SubsetInsertionOpInterfaceImpl_8cpp_source.html#l00087">mlir::tensor::registerSubsetOpInterfaceExternalModels()</a>, <a class="el" href="SubsetOpInterfaceImpl_8cpp_source.html#l00070">mlir::vector::registerSubsetOpInterfaceExternalModels()</a>, <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00311">mlir::tensor::registerTilingInterfaceExternalModels()</a>, <a class="el" href="Affine_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00155">mlir::affine::registerValueBoundsOpInterfaceExternalModels()</a>, <a class="el" href="Arith_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00167">mlir::arith::registerValueBoundsOpInterfaceExternalModels()</a>, <a class="el" href="GPU_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00093">mlir::gpu::registerValueBoundsOpInterfaceExternalModels()</a>, <a class="el" href="MemRef_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00149">mlir::memref::registerValueBoundsOpInterfaceExternalModels()</a>, <a class="el" href="SCF_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00237">mlir::scf::registerValueBoundsOpInterfaceExternalModels()</a>, <a class="el" href="Tensor_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00116">mlir::tensor::registerValueBoundsOpInterfaceExternalModels()</a>, <a class="el" href="Vector_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00045">mlir::vector::registerValueBoundsOpInterfaceExternalModels()</a>, and <a class="el" href="LLVM_2XeVM_2Target_8cpp_source.html#l00064">mlir::xevm::registerXeVMTargetInterfaceExternalModels()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CAPI_2RegisterEverything_2RegisterEverything_8cpp_source.html#l00020">mlirRegisterAllDialects()</a>, and <a class="el" href="RegisterAllDialects_8cpp_source.html#l00207">registerAllDialects()</a>.</p>

</div>
</div>
<a id="a5fcd07e2ad26a58627d961ce8e544f1b" name="a5fcd07e2ad26a58627d961ce8e544f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fcd07e2ad26a58627d961ce8e544f1b">&#9670;&#160;</a></span>registerAllDialects() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAllDialects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append all the MLIR dialects to the registry contained in the given context. </p>

<p class="definition">Definition at line <a class="el" href="RegisterAllDialects_8cpp_source.html#l00207">207</a> of file <a class="el" href="RegisterAllDialects_8cpp_source.html">RegisterAllDialects.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00416">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="RegisterAllDialects_8cpp_source.html#l00109">registerAllDialects()</a>.</p>

</div>
</div>
<a id="af478d18d439a803300e8e086d32bbb6e" name="af478d18d439a803300e8e086d32bbb6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af478d18d439a803300e8e086d32bbb6e">&#9670;&#160;</a></span>registerAllExtensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAllExtensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function may be called to register all MLIR dialect extensions with the provided registry. </p>
<p>If you're building a compiler, you generally shouldn't use this: you would individually register the specific extensions that are useful for the pipelines and transformations you are using. </p>

<p class="definition">Definition at line <a class="el" href="RegisterAllExtensions_8cpp_source.html#l00072">72</a> of file <a class="el" href="RegisterAllExtensions_8cpp_source.html">RegisterAllExtensions.cpp</a>.</p>

<p class="reference">References <a class="el" href="Func_2Extensions_2AllExtensions_8cpp_source.html#l00015">mlir::func::registerAllExtensions()</a>, <a class="el" href="Tensor_2Extensions_2AllExtensions_8cpp_source.html#l00014">mlir::tensor::registerAllExtensions()</a>, <a class="el" href="AMX_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00066">registerConvertAMXToLLVMInterface()</a>, <a class="el" href="ArithToEmitC_8cpp_source.html#l00041">registerConvertArithToEmitCInterface()</a>, <a class="el" href="ArithToLLVM_8cpp_source.html#l00596">mlir::arith::registerConvertArithToLLVMInterface()</a>, <a class="el" href="ComplexToLLVM_8cpp_source.html#l00393">registerConvertComplexToLLVMInterface()</a>, <a class="el" href="ControlFlowToLLVM_8cpp_source.html#l00317">mlir::cf::registerConvertControlFlowToLLVMInterface()</a>, <a class="el" href="FuncToEmitC_8cpp_source.html#l00039">registerConvertFuncToEmitCInterface()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00887">registerConvertFuncToLLVMInterface()</a>, <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l01858">mlir::gpu::registerConvertGpuToLLVMInterface()</a>, <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00785">mlir::NVVM::registerConvertGpuToNVVMInterface()</a>, <a class="el" href="IndexToLLVM_8cpp_source.html#l00393">mlir::index::registerConvertIndexToLLVMInterface()</a>, <a class="el" href="MathToLLVM_8cpp_source.html#l00487">registerConvertMathToLLVMInterface()</a>, <a class="el" href="MemRefToEmitC_8cpp_source.html#l00053">registerConvertMemRefToEmitCInterface()</a>, <a class="el" href="MemRefToLLVM_8cpp_source.html#l02129">registerConvertMemRefToLLVMInterface()</a>, <a class="el" href="MPIToLLVM_8cpp_source.html#l00809">mlir::mpi::registerConvertMPIToLLVMInterface()</a>, <a class="el" href="NVVMToLLVM_8cpp_source.html#l00116">registerConvertNVVMToLLVMInterface()</a>, <a class="el" href="OpenMPToLLVM_8cpp_source.html#l00217">registerConvertOpenMPToLLVMInterface()</a>, <a class="el" href="PtrToLLVM_8cpp_source.html#l00437">mlir::ptr::registerConvertPtrToLLVMInterface()</a>, <a class="el" href="SCFToEmitC_8cpp_source.html#l00051">registerConvertSCFToEmitCInterface()</a>, <a class="el" href="UBToLLVM_8cpp_source.html#l00142">mlir::ub::registerConvertUBToLLVMInterface()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l02244">mlir::vector::registerConvertVectorToLLVMInterface()</a>, <a class="el" href="XeVMToLLVM_8cpp_source.html#l00941">registerConvertXeVMToLLVMInterface()</a>, <a class="el" href="DebugExtension_8cpp_source.html#l00034">mlir::transform::registerDebugExtension()</a>, <a class="el" href="IRDLExtension_8cpp_source.html#l00034">mlir::transform::registerIRDLExtension()</a>, <a class="el" href="LoopExtension_8cpp_source.html#l00034">mlir::transform::registerLoopExtension()</a>, <a class="el" href="PDLExtension_8cpp_source.html#l00069">mlir::transform::registerPDLExtension()</a>, <a class="el" href="SMTExtension_8cpp_source.html#l00033">mlir::transform::registerSMTExtension()</a>, <a class="el" href="AffineTransformOps_8cpp_source.html#l00215">mlir::affine::registerTransformDialectExtension()</a>, <a class="el" href="ArmNeonVectorTransformOps_8cpp_source.html#l00056">mlir::arm_neon::registerTransformDialectExtension()</a>, <a class="el" href="ArmSVEVectorTransformOps_8cpp_source.html#l00056">mlir::arm_sve::registerTransformDialectExtension()</a>, <a class="el" href="BufferizationTransformOps_8cpp_source.html#l00180">mlir::bufferization::registerTransformDialectExtension()</a>, <a class="el" href="DLTITransformOps_8cpp_source.html#l00082">mlir::dlti::registerTransformDialectExtension()</a>, <a class="el" href="FuncTransformOps_8cpp_source.html#l00412">mlir::func::registerTransformDialectExtension()</a>, <a class="el" href="GPUTransformOps_8cpp_source.html#l00983">mlir::gpu::registerTransformDialectExtension()</a>, <a class="el" href="DialectExtension_8cpp_source.html#l00058">mlir::linalg::registerTransformDialectExtension()</a>, <a class="el" href="MemRefTransformOps_8cpp_source.html#l00334">mlir::memref::registerTransformDialectExtension()</a>, <a class="el" href="namespacemlir_1_1nvgpu.html#ae64270d2058ef5fd99281df6e7de4464">mlir::nvgpu::registerTransformDialectExtension()</a>, <a class="el" href="namespacemlir_1_1scf.html#a131df27a14db6c8a12e643fa2a0a5603">mlir::scf::registerTransformDialectExtension()</a>, <a class="el" href="SparseTensorTransformOps_8cpp_source.html#l00057">mlir::sparse_tensor::registerTransformDialectExtension()</a>, <a class="el" href="TensorTransformOps_8cpp_source.html#l00258">mlir::tensor::registerTransformDialectExtension()</a>, <a class="el" href="VectorTransformOps_8cpp_source.html#l00257">mlir::vector::registerTransformDialectExtension()</a>, <a class="el" href="X86VectorTransformOps_8cpp_source.html#l00066">mlir::x86vector::registerTransformDialectExtension()</a>, <a class="el" href="XeGPUTransformOps_8cpp_source.html#l00693">mlir::xegpu::registerTransformDialectExtension()</a>, and <a class="el" href="TuneExtension_8cpp_source.html#l00030">mlir::transform::registerTuneExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CAPI_2RegisterEverything_2RegisterEverything_8cpp_source.html#l00020">mlirRegisterAllDialects()</a>.</p>

</div>
</div>
<a id="a5b51fcb4b20988958223a34812c119a3" name="a5b51fcb4b20988958223a34812c119a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b51fcb4b20988958223a34812c119a3">&#9670;&#160;</a></span>registerAllFromLLVMIRTranslations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAllFromLLVMIRTranslations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers all dialects that can be translated from <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR and the corresponding translation interfaces. </p>

<p class="definition">Definition at line <a class="el" href="All_8h_source.html#l00079">79</a> of file <a class="el" href="All_8h_source.html">All.h</a>.</p>

<p class="reference">References <a class="el" href="LLVMIRToLLVMTranslation_8cpp_source.html#l00516">registerLLVMDialectImport()</a>, and <a class="el" href="LLVMIRToNVVMTranslation_8cpp_source.html#l00087">registerNVVMDialectImport()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00027">registerFromLLVMIRTranslation()</a>.</p>

</div>
</div>
<a id="a6f90059c48bfaae011de1a44d1d80683" name="a6f90059c48bfaae011de1a44d1d80683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f90059c48bfaae011de1a44d1d80683">&#9670;&#160;</a></span>registerAllGPUToLLVMIRTranslations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAllGPUToLLVMIRTranslations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers all the translations to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR required by GPU passes. </p>
<p>TODO: Remove this function when a safe dialect interface registration mechanism is implemented, see D157703. </p>

<p class="definition">Definition at line <a class="el" href="All_8h_source.html#l00063">63</a> of file <a class="el" href="All_8h_source.html">All.h</a>.</p>

<p class="reference">References <a class="el" href="BuiltinToLLVMIRTranslation_8cpp_source.html#l00036">registerBuiltinDialectTranslation()</a>, <a class="el" href="GPUToLLVMIRTranslation_8cpp_source.html#l00066">registerGPUDialectTranslation()</a>, <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00795">registerLLVMDialectTranslation()</a>, <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html#l00542">registerNVVMDialectTranslation()</a>, <a class="el" href="SelectObjectAttr_8cpp_source.html#l00467">mlir::gpu::registerOffloadingLLVMTranslationInterfaceExternalModels()</a>, <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html#l00243">registerROCDLDialectTranslation()</a>, <a class="el" href="SPIRVToLLVMIRTranslation_8cpp_source.html#l00021">registerSPIRVDialectTranslation()</a>, and <a class="el" href="#aaa1eb668cf1f44410ce301800e747661">registerXeVMDialectTranslation()</a>.</p>

</div>
</div>
<a id="afb552a159c6c887b98b3583dfd5cbe5d" name="afb552a159c6c887b98b3583dfd5cbe5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb552a159c6c887b98b3583dfd5cbe5d">&#9670;&#160;</a></span>registerAllPasses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAllPasses </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RegisterAllPasses_8cpp_source.html#l00059">59</a> of file <a class="el" href="RegisterAllPasses_8cpp_source.html">RegisterAllPasses.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01644">mlir::affine::registerAffinePasses()</a>, <a class="el" href="Dialect_2AMDGPU_2Transforms_2Passes_8h_source.html#l00433">mlir::amdgpu::registerAMDGPUPasses()</a>, <a class="el" href="Dialect_2Arith_2Transforms_2Passes_8h_source.html#l00694">mlir::arith::registerArithPasses()</a>, <a class="el" href="Dialect_2ArmSME_2Transforms_2Passes_8h_source.html#l00454">mlir::arm_sme::registerArmSMEPasses()</a>, <a class="el" href="Dialect_2ArmSVE_2Transforms_2Passes_8h_source.html#l00105">mlir::arm_sve::registerArmSVEPasses()</a>, <a class="el" href="Dialect_2Async_2Passes_8h_source.html#l00637">registerAsyncPasses()</a>, <a class="el" href="Dialect_2Bufferization_2Transforms_2Passes_8h_source.html#l01355">mlir::bufferization::registerBufferizationPasses()</a>, <a class="el" href="BufferizationPipelines_8cpp_source.html#l00045">mlir::bufferization::registerBufferizationPipelines()</a>, <a class="el" href="ArmSMEToLLVM_8h_source.html#l08947">registerConversionPasses()</a>, <a class="el" href="Dialect_2EmitC_2Transforms_2Passes_8h_source.html#l00213">mlir::emitc::registerEmitCPasses()</a>, <a class="el" href="Dialect_2Func_2Transforms_2Passes_8h_source.html#l00115">mlir::func::registerFuncPasses()</a>, <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l01348">registerGPUPasses()</a>, <a class="el" href="GPUToNVVMPipeline_8cpp_source.html#l00115">mlir::gpu::registerGPUToNVVMPipeline()</a>, <a class="el" href="GPUToXeVMPipeline_8cpp_source.html#l00141">mlir::gpu::registerGPUToXeVMPipeline()</a>, <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html#l01513">registerLinalgPasses()</a>, <a class="el" href="Dialect_2LLVMIR_2Transforms_2Passes_8h_source.html#l00653">mlir::LLVM::registerLLVMPasses()</a>, <a class="el" href="Dialect_2Math_2Transforms_2Passes_8h_source.html#l00453">mlir::math::registerMathPasses()</a>, <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html#l01089">mlir::memref::registerMemRefPasses()</a>, <a class="el" href="Dialect_2MLProgram_2Transforms_2Passes_8h_source.html#l00115">mlir::ml_program::registerMLProgramPasses()</a>, <a class="el" href="Dialect_2NVGPU_2Transforms_2Passes_8h_source.html#l00103">registerNVGPUPasses()</a>, <a class="el" href="Dialect_2OpenACC_2Transforms_2Passes_8h_source.html#l00698">mlir::acc::registerOpenACCPasses()</a>, <a class="el" href="Dialect_2OpenMP_2Transforms_2Passes_8h_source.html#l00115">mlir::omp::registerOpenMPPasses()</a>, <a class="el" href="Dialect_2Quant_2Transforms_2Passes_8h_source.html#l00317">mlir::quant::registerQuantPasses()</a>, <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html#l01072">registerSCFPasses()</a>, <a class="el" href="Dialect_2Shape_2Transforms_2Passes_8h_source.html#l00311">registerShapePasses()</a>, <a class="el" href="Dialect_2Shard_2Transforms_2Passes_8h_source.html#l00242">mlir::shard::registerShardPasses()</a>, <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01593">registerSparseTensorPasses()</a>, <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00106">mlir::sparse_tensor::registerSparseTensorPipelines()</a>, <a class="el" href="Dialect_2SPIRV_2Transforms_2Passes_8h_source.html#l00788">mlir::spirv::registerSPIRVPasses()</a>, <a class="el" href="Target_2LLVMIR_2Transforms_2Passes_8h_source.html#l00253">mlir::LLVM::registerTargetLLVMIRTransformsPasses()</a>, <a class="el" href="Dialect_2Tensor_2Transforms_2Passes_8h_source.html#l00117">mlir::tensor::registerTensorPasses()</a>, <a class="el" href="Dialect_2Tosa_2Transforms_2Passes_8h_source.html#l01106">mlir::tosa::registerTosaOptPasses()</a>, <a class="el" href="TosaToLinalgPass_8cpp_source.html#l00108">mlir::tosa::registerTosaToLinalgPipelines()</a>, <a class="el" href="Dialect_2Transform_2Transforms_2Passes_8h_source.html#l00462">mlir::transform::registerTransformPasses()</a>, <a class="el" href="Transforms_2Passes_8h_source.html#l02052">registerTransformsPasses()</a>, <a class="el" href="Dialect_2Vector_2Transforms_2Passes_8h_source.html#l00299">mlir::vector::registerVectorPasses()</a>, and <a class="el" href="Dialect_2XeGPU_2Transforms_2Passes_8h_source.html#l00746">mlir::xegpu::registerXeGPUPasses()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CAPI_2RegisterEverything_2RegisterEverything_8cpp_source.html#l00032">mlirRegisterAllPasses()</a>.</p>

</div>
</div>
<a id="ad1e68be8ebf61b3be9572769e19bc467" name="ad1e68be8ebf61b3be9572769e19bc467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e68be8ebf61b3be9572769e19bc467">&#9670;&#160;</a></span>registerAllToLLVMIRTranslations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAllToLLVMIRTranslations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers all dialects that can be translated to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR and the corresponding translation interfaces. </p>

<p class="definition">Definition at line <a class="el" href="All_8h_source.html#l00039">39</a> of file <a class="el" href="All_8h_source.html">All.h</a>.</p>

<p class="reference">References <a class="el" href="ArmNeonToLLVMIRTranslation_8cpp_source.html#l00046">registerArmNeonDialectTranslation()</a>, <a class="el" href="ArmSMEToLLVMIRTranslation_8cpp_source.html#l00046">registerArmSMEDialectTranslation()</a>, <a class="el" href="ArmSVEToLLVMIRTranslation_8cpp_source.html#l00045">registerArmSVEDialectTranslation()</a>, <a class="el" href="BuiltinToLLVMIRTranslation_8cpp_source.html#l00036">registerBuiltinDialectTranslation()</a>, <a class="el" href="GPUToLLVMIRTranslation_8cpp_source.html#l00066">registerGPUDialectTranslation()</a>, <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00795">registerLLVMDialectTranslation()</a>, <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html#l00542">registerNVVMDialectTranslation()</a>, <a class="el" href="SelectObjectAttr_8cpp_source.html#l00467">mlir::gpu::registerOffloadingLLVMTranslationInterfaceExternalModels()</a>, <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00530">registerOpenACCDialectTranslation()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l06885">registerOpenMPDialectTranslation()</a>, <a class="el" href="PtrToLLVMIRTranslation_8cpp_source.html#l00454">registerPtrDialectTranslation()</a>, <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html#l00243">registerROCDLDialectTranslation()</a>, <a class="el" href="SPIRVToLLVMIRTranslation_8cpp_source.html#l00021">registerSPIRVDialectTranslation()</a>, <a class="el" href="VCIXToLLVMIRTranslation_8cpp_source.html#l00076">registerVCIXDialectTranslation()</a>, and <a class="el" href="#aaa1eb668cf1f44410ce301800e747661">registerXeVMDialectTranslation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CAPI_2RegisterEverything_2RegisterEverything_8cpp_source.html#l00025">mlirRegisterAllLLVMTranslations()</a>, and <a class="el" href="ConvertToLLVMIR_8cpp_source.html#l00025">registerToLLVMIRTranslation()</a>.</p>

</div>
</div>
<a id="a8d16808b31b66905b067720d428adf61" name="a8d16808b31b66905b067720d428adf61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d16808b31b66905b067720d428adf61">&#9670;&#160;</a></span>registerAllTranslations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAllTranslations </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InitAllTranslations_8h_source.html#l00035">35</a> of file <a class="el" href="InitAllTranslations_8h_source.html">InitAllTranslations.h</a>.</p>

<p class="reference">References <a class="el" href="Target_2SMTLIB_2ExportSMTLIB_8cpp_source.html#l00705">mlir::smt::registerExportSMTLIBTranslation()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00027">registerFromLLVMIRTranslation()</a>, <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00058">registerFromSPIRVTranslation()</a>, <a class="el" href="Wasm_2TranslateRegistration_8cpp_source.html#l00017">registerFromWasmTranslation()</a>, <a class="el" href="TranslationRegistration_8cpp_source.html#l00025">registerIRDLToCppTranslation()</a>, <a class="el" href="Cpp_2TranslateRegistration_8cpp_source.html#l00024">registerToCppTranslation()</a>, <a class="el" href="ConvertToLLVMIR_8cpp_source.html#l00025">registerToLLVMIRTranslation()</a>, and <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00124">registerToSPIRVTranslation()</a>.</p>

</div>
</div>
<a id="ad495fac45c73eb07003f55e4c3c82ca2" name="ad495fac45c73eb07003f55e4c3c82ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad495fac45c73eb07003f55e4c3c82ca2">&#9670;&#160;</a></span>registerAndParseCLIOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, std::string &gt; mlir::registerAndParseCLIOptions </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>argc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef</td>          <td class="paramname"><span class="paramname"><em>toolName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register and parse command line options. </p>
<ul>
<li>toolName is used for the header displayed by <span class="tt">--help</span>.</li>
<li>registry should contain all the dialects that can be parsed in the source.</li>
<li>return std::pair&lt;std::string, std::string&gt; for inputFilename and outputFilename command line option values. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="MlirOptMain_8cpp_source.html#l00716">716</a> of file <a class="el" href="MlirOptMain_8cpp_source.html">MlirOptMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="MlirOptMain_8cpp_source.html#l00704">parseCLIOptions()</a>, and <a class="el" href="MlirOptMain_8cpp_source.html#l00684">registerCLIOptions()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00830">MlirOptMain()</a>.</p>

</div>
</div>
<a id="a3bc08d7b0eaa1c93ac0e4fcedea40cc3" name="a3bc08d7b0eaa1c93ac0e4fcedea40cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc08d7b0eaa1c93ac0e4fcedea40cc3">&#9670;&#160;</a></span>registerArithToAMDGPUConversionPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerArithToAMDGPUConversionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07225">7225</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="ad34f9f83677ca5c21f29cc3c0a89e5db" name="ad34f9f83677ca5c21f29cc3c0a89e5db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad34f9f83677ca5c21f29cc3c0a89e5db">&#9670;&#160;</a></span>registerArithToAMDGPUConversionPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerArithToAMDGPUConversionPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07232">7232</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a056aaeb346564df161bb90cb462b4685" name="a056aaeb346564df161bb90cb462b4685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056aaeb346564df161bb90cb462b4685">&#9670;&#160;</a></span>registerArithToAPFloatConversionPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerArithToAPFloatConversionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07246">7246</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="abfaf41ca3dd406c4332f3fc714636bee" name="abfaf41ca3dd406c4332f3fc714636bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfaf41ca3dd406c4332f3fc714636bee">&#9670;&#160;</a></span>registerArithToAPFloatConversionPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerArithToAPFloatConversionPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07253">7253</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="aaf3998463d154760d77efff830547a66" name="aaf3998463d154760d77efff830547a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf3998463d154760d77efff830547a66">&#9670;&#160;</a></span>registerArithToArmSMEConversionPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerArithToArmSMEConversionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07267">7267</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="ab1adf1404cc5a0c0ad17b327b10b6d4d" name="ab1adf1404cc5a0c0ad17b327b10b6d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1adf1404cc5a0c0ad17b327b10b6d4d">&#9670;&#160;</a></span>registerArithToArmSMEConversionPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerArithToArmSMEConversionPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07274">7274</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="ac7080efcc2ac4c70b3c9bea83ed82cc8" name="ac7080efcc2ac4c70b3c9bea83ed82cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7080efcc2ac4c70b3c9bea83ed82cc8">&#9670;&#160;</a></span>registerArithToLLVMConversionPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerArithToLLVMConversionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07288">7288</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="aa6f0bf41be503dfcf553db915615a30e" name="aa6f0bf41be503dfcf553db915615a30e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f0bf41be503dfcf553db915615a30e">&#9670;&#160;</a></span>registerArithToLLVMConversionPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerArithToLLVMConversionPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07295">7295</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="ac8cfe4c9ed6ee3105af1b2d4d4b7c2ad" name="ac8cfe4c9ed6ee3105af1b2d4d4b7c2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8cfe4c9ed6ee3105af1b2d4d4b7c2ad">&#9670;&#160;</a></span>registerArmNeonDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerArmNeonDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the ArmNeon dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="ArmNeonToLLVMIRTranslation_8cpp_source.html#l00046">46</a> of file <a class="el" href="ArmNeonToLLVMIRTranslation_8cpp_source.html">ArmNeonToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00152">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00039">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="ArmNeonToLLVMIRTranslation_8cpp_source.html#l00054">registerArmNeonDialectTranslation()</a>.</p>

</div>
</div>
<a id="a559f20bb41c97729f2d089e6f7a72e4e" name="a559f20bb41c97729f2d089e6f7a72e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559f20bb41c97729f2d089e6f7a72e4e">&#9670;&#160;</a></span>registerArmNeonDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerArmNeonDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the ArmNeon dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="ArmNeonToLLVMIRTranslation_8cpp_source.html#l00054">54</a> of file <a class="el" href="ArmNeonToLLVMIRTranslation_8cpp_source.html">ArmNeonToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00416">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="ArmNeonToLLVMIRTranslation_8cpp_source.html#l00046">registerArmNeonDialectTranslation()</a>.</p>

</div>
</div>
<a id="a44e3d0ed9dee8abc1c1da567b31f3520" name="a44e3d0ed9dee8abc1c1da567b31f3520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44e3d0ed9dee8abc1c1da567b31f3520">&#9670;&#160;</a></span>registerArmSMEDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerArmSMEDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the ArmSME dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVMIRTranslation_8cpp_source.html#l00046">46</a> of file <a class="el" href="ArmSMEToLLVMIRTranslation_8cpp_source.html">ArmSMEToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00152">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00039">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="ArmSMEToLLVMIRTranslation_8cpp_source.html#l00053">registerArmSMEDialectTranslation()</a>.</p>

</div>
</div>
<a id="a7e8ba95f7e3fc0b3d4885f3ae1b2926e" name="a7e8ba95f7e3fc0b3d4885f3ae1b2926e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e8ba95f7e3fc0b3d4885f3ae1b2926e">&#9670;&#160;</a></span>registerArmSMEDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerArmSMEDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the ArmSME dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVMIRTranslation_8cpp_source.html#l00053">53</a> of file <a class="el" href="ArmSMEToLLVMIRTranslation_8cpp_source.html">ArmSMEToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00416">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="ArmSMEToLLVMIRTranslation_8cpp_source.html#l00046">registerArmSMEDialectTranslation()</a>.</p>

</div>
</div>
<a id="a53be2d34e1d4e96ea100bbf93af35a2c" name="a53be2d34e1d4e96ea100bbf93af35a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53be2d34e1d4e96ea100bbf93af35a2c">&#9670;&#160;</a></span>registerArmSVEDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerArmSVEDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the ArmSVE dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="ArmSVEToLLVMIRTranslation_8cpp_source.html#l00045">45</a> of file <a class="el" href="ArmSVEToLLVMIRTranslation_8cpp_source.html">ArmSVEToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00152">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00039">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="ArmSVEToLLVMIRTranslation_8cpp_source.html#l00052">registerArmSVEDialectTranslation()</a>.</p>

</div>
</div>
<a id="afc9c160fac7074517c6f013864acee68" name="afc9c160fac7074517c6f013864acee68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9c160fac7074517c6f013864acee68">&#9670;&#160;</a></span>registerArmSVEDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerArmSVEDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the ArmSVE dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="ArmSVEToLLVMIRTranslation_8cpp_source.html#l00052">52</a> of file <a class="el" href="ArmSVEToLLVMIRTranslation_8cpp_source.html">ArmSVEToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00416">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="ArmSVEToLLVMIRTranslation_8cpp_source.html#l00045">registerArmSVEDialectTranslation()</a>.</p>

</div>
</div>
<a id="a894a08aa6ed051f55e57bc35859a379f" name="a894a08aa6ed051f55e57bc35859a379f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a894a08aa6ed051f55e57bc35859a379f">&#9670;&#160;</a></span>registerAsmPrinterCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAsmPrinterCLOptions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a set of useful command-line options that can be used to configure various flags within the <a class="el" href="classmlir_1_1AsmPrinter.html" title="This base class exposes generic asm printer hooks, usable across the various derived printers.">AsmPrinter</a>. </p>

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l00211">211</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

<p class="reference">References <a class="el" href="DebugCounter_8cpp_source.html#l00040">clOptions</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00684">registerCLIOptions()</a>.</p>

</div>
</div>
<a id="a9b1d5689e67822e988ebe93a71a50477" name="a9b1d5689e67822e988ebe93a71a50477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1d5689e67822e988ebe93a71a50477">&#9670;&#160;</a></span>registerAsyncFuncToAsyncRuntimePass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAsyncFuncToAsyncRuntimePass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Async_2Passes_8h_source.html#l00511">511</a> of file <a class="el" href="Dialect_2Async_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a5b13504225fee209724382bef7f11fdd" name="a5b13504225fee209724382bef7f11fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b13504225fee209724382bef7f11fdd">&#9670;&#160;</a></span>registerAsyncFuncToAsyncRuntimePassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAsyncFuncToAsyncRuntimePassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Async_2Passes_8h_source.html#l00518">518</a> of file <a class="el" href="Dialect_2Async_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a02ab19a0df07b7c1e51c2d1c335d9f7c" name="a02ab19a0df07b7c1e51c2d1c335d9f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02ab19a0df07b7c1e51c2d1c335d9f7c">&#9670;&#160;</a></span>registerAsyncParallelForPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAsyncParallelForPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Async_2Passes_8h_source.html#l00532">532</a> of file <a class="el" href="Dialect_2Async_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="af1d3ddf63ee3618c9a5aaab1a6936cc0" name="af1d3ddf63ee3618c9a5aaab1a6936cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d3ddf63ee3618c9a5aaab1a6936cc0">&#9670;&#160;</a></span>registerAsyncParallelForPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAsyncParallelForPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Async_2Passes_8h_source.html#l00539">539</a> of file <a class="el" href="Dialect_2Async_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a0666d844412191163d8cc46d4bc03ed8" name="a0666d844412191163d8cc46d4bc03ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0666d844412191163d8cc46d4bc03ed8">&#9670;&#160;</a></span>registerAsyncPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAsyncPasses </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Async_2Passes_8h_source.html#l00637">637</a> of file <a class="el" href="Dialect_2Async_2Passes_8h_source.html">Passes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllPasses_8cpp_source.html#l00059">registerAllPasses()</a>.</p>

</div>
</div>
<a id="a2b376130b053ae00adc79a5f52ca02d8" name="a2b376130b053ae00adc79a5f52ca02d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b376130b053ae00adc79a5f52ca02d8">&#9670;&#160;</a></span>registerAsyncRuntimePolicyBasedRefCountingPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAsyncRuntimePolicyBasedRefCountingPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Async_2Passes_8h_source.html#l00553">553</a> of file <a class="el" href="Dialect_2Async_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ac6d3a8e5ccd3f0e27b3ba387c29611fd" name="ac6d3a8e5ccd3f0e27b3ba387c29611fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d3a8e5ccd3f0e27b3ba387c29611fd">&#9670;&#160;</a></span>registerAsyncRuntimePolicyBasedRefCountingPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAsyncRuntimePolicyBasedRefCountingPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Async_2Passes_8h_source.html#l00560">560</a> of file <a class="el" href="Dialect_2Async_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="adb233121127b80ee0ff5161e66109534" name="adb233121127b80ee0ff5161e66109534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb233121127b80ee0ff5161e66109534">&#9670;&#160;</a></span>registerAsyncRuntimeRefCountingOptPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAsyncRuntimeRefCountingOptPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Async_2Passes_8h_source.html#l00574">574</a> of file <a class="el" href="Dialect_2Async_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a0e07030aeb20108e9f32ccaec9412b72" name="a0e07030aeb20108e9f32ccaec9412b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e07030aeb20108e9f32ccaec9412b72">&#9670;&#160;</a></span>registerAsyncRuntimeRefCountingOptPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAsyncRuntimeRefCountingOptPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Async_2Passes_8h_source.html#l00581">581</a> of file <a class="el" href="Dialect_2Async_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a7c379f5f8bfe81a3d424d21fc7df4f9a" name="a7c379f5f8bfe81a3d424d21fc7df4f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c379f5f8bfe81a3d424d21fc7df4f9a">&#9670;&#160;</a></span>registerAsyncRuntimeRefCountingPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAsyncRuntimeRefCountingPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Async_2Passes_8h_source.html#l00595">595</a> of file <a class="el" href="Dialect_2Async_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a556006007575eec098059c49e034868e" name="a556006007575eec098059c49e034868e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a556006007575eec098059c49e034868e">&#9670;&#160;</a></span>registerAsyncRuntimeRefCountingPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAsyncRuntimeRefCountingPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Async_2Passes_8h_source.html#l00602">602</a> of file <a class="el" href="Dialect_2Async_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a678e44574697efc8b44cfab3e652fa9f" name="a678e44574697efc8b44cfab3e652fa9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678e44574697efc8b44cfab3e652fa9f">&#9670;&#160;</a></span>registerAsyncToAsyncRuntimePass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAsyncToAsyncRuntimePass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Async_2Passes_8h_source.html#l00616">616</a> of file <a class="el" href="Dialect_2Async_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="aad63c49be4f113258f12361844c561a4" name="aad63c49be4f113258f12361844c561a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad63c49be4f113258f12361844c561a4">&#9670;&#160;</a></span>registerAsyncToAsyncRuntimePassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAsyncToAsyncRuntimePassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Async_2Passes_8h_source.html#l00623">623</a> of file <a class="el" href="Dialect_2Async_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a85fb5899228dbfc0fc1b1967a227a80b" name="a85fb5899228dbfc0fc1b1967a227a80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85fb5899228dbfc0fc1b1967a227a80b">&#9670;&#160;</a></span>registerBubbleDownMemorySpaceCasts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerBubbleDownMemorySpaceCasts </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01611">1611</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="adcf4a04f7d13ef88360053ccae573766" name="adcf4a04f7d13ef88360053ccae573766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcf4a04f7d13ef88360053ccae573766">&#9670;&#160;</a></span>registerBubbleDownMemorySpaceCastsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerBubbleDownMemorySpaceCastsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01618">1618</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a857314125d33fcc46a38cd3aca4d1d12" name="a857314125d33fcc46a38cd3aca4d1d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a857314125d33fcc46a38cd3aca4d1d12">&#9670;&#160;</a></span>registerBuiltinDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerBuiltinDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the translation from the builtin dialect to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry. </p>

<p class="definition">Definition at line <a class="el" href="BuiltinToLLVMIRTranslation_8cpp_source.html#l00036">36</a> of file <a class="el" href="BuiltinToLLVMIRTranslation_8cpp_source.html">BuiltinToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CAPI_2ExecutionEngine_2ExecutionEngine_8cpp_source.html#l00023">mlirExecutionEngineCreate()</a>, <a class="el" href="All_8h_source.html#l00063">registerAllGPUToLLVMIRTranslations()</a>, <a class="el" href="All_8h_source.html#l00039">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="BuiltinToLLVMIRTranslation_8cpp_source.html#l00042">registerBuiltinDialectTranslation()</a>.</p>

</div>
</div>
<a id="a1af1c7f18bef740745581f7130c8c46e" name="a1af1c7f18bef740745581f7130c8c46e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af1c7f18bef740745581f7130c8c46e">&#9670;&#160;</a></span>registerBuiltinDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerBuiltinDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the translation from the builtin dialect in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="BuiltinToLLVMIRTranslation_8cpp_source.html#l00042">42</a> of file <a class="el" href="BuiltinToLLVMIRTranslation_8cpp_source.html">BuiltinToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00416">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="BuiltinToLLVMIRTranslation_8cpp_source.html#l00036">registerBuiltinDialectTranslation()</a>.</p>

</div>
</div>
<a id="a616aaf5190a9b52c9ff1de894809be21" name="a616aaf5190a9b52c9ff1de894809be21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616aaf5190a9b52c9ff1de894809be21">&#9670;&#160;</a></span>registerCanonicalizer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerCanonicalizer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01653">1653</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a8bf366f61b59925618c1dc5a16fd7755" name="a8bf366f61b59925618c1dc5a16fd7755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf366f61b59925618c1dc5a16fd7755">&#9670;&#160;</a></span>registerCanonicalizerPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerCanonicalizerPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01660">1660</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a3dbb88af0759fb039752b61c0822afc5" name="a3dbb88af0759fb039752b61c0822afc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dbb88af0759fb039752b61c0822afc5">&#9670;&#160;</a></span>registerCLIOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mlir::registerCLIOptions </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef</td>          <td class="paramname"><span class="paramname"><em>toolName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register basic command line options. </p>
<ul>
<li>toolName is used for the header displayed by <span class="tt">--help</span>.</li>
<li>registry should contain all the dialects that can be parsed in the source.</li>
<li>return std::string for help header. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="MlirOptMain_8cpp_source.html#l00684">684</a> of file <a class="el" href="MlirOptMain_8cpp_source.html">MlirOptMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00200">mlir::DialectRegistry::getDialectNames()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l00211">registerAsmPrinterCLOptions()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00343">mlir::MlirOptMainConfig::registerCLOptions()</a>, <a class="el" href="DebugCounter_8cpp_source.html#l00112">mlir::tracing::DebugCounter::registerCLOptions()</a>, <a class="el" href="Timing_8cpp_source.html#l00612">registerDefaultTimingManagerCLOptions()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00088">registerMLIRContextCLOptions()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00140">registerPassManagerCLOptions()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00716">registerAndParseCLIOptions()</a>.</p>

</div>
</div>
<a id="a803727c613f23c396fcd3b379a778a94" name="a803727c613f23c396fcd3b379a778a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803727c613f23c396fcd3b379a778a94">&#9670;&#160;</a></span>registerCompositeFixedPointPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerCompositeFixedPointPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01674">1674</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a772d94a15b48bc8b335bcd8d70601541" name="a772d94a15b48bc8b335bcd8d70601541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772d94a15b48bc8b335bcd8d70601541">&#9670;&#160;</a></span>registerCompositeFixedPointPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerCompositeFixedPointPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01681">1681</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ae68c338c367f123cc04551f1753ac9b4" name="ae68c338c367f123cc04551f1753ac9b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae68c338c367f123cc04551f1753ac9b4">&#9670;&#160;</a></span>registerControlFlowSink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerControlFlowSink </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01695">1695</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a264461455c004817114cd73873dd2dea" name="a264461455c004817114cd73873dd2dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a264461455c004817114cd73873dd2dea">&#9670;&#160;</a></span>registerControlFlowSinkPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerControlFlowSinkPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01702">1702</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a506139ca4a3a8a66d0fe6a9e2531a5c9" name="a506139ca4a3a8a66d0fe6a9e2531a5c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a506139ca4a3a8a66d0fe6a9e2531a5c9">&#9670;&#160;</a></span>registerConversionPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConversionPasses </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08947">8947</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllPasses_8cpp_source.html#l00059">registerAllPasses()</a>.</p>

</div>
</div>
<a id="afbb7c0b603fc418cb9707ec45405c6f4" name="afbb7c0b603fc418cb9707ec45405c6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb7c0b603fc418cb9707ec45405c6f4">&#9670;&#160;</a></span>registerConvertAffineForToGPUPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertAffineForToGPUPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07330">7330</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a447cf32c2a42d229a1821787e59702ab" name="a447cf32c2a42d229a1821787e59702ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447cf32c2a42d229a1821787e59702ab">&#9670;&#160;</a></span>registerConvertAffineForToGPUPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertAffineForToGPUPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07337">7337</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="ac6a235ea76890419e01a2851b0e59df7" name="ac6a235ea76890419e01a2851b0e59df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a235ea76890419e01a2851b0e59df7">&#9670;&#160;</a></span>registerConvertAMDGPUToROCDLPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertAMDGPUToROCDLPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07309">7309</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="ae1a2f81e3ffecca8a4968441f4b0acec" name="ae1a2f81e3ffecca8a4968441f4b0acec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a2f81e3ffecca8a4968441f4b0acec">&#9670;&#160;</a></span>registerConvertAMDGPUToROCDLPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertAMDGPUToROCDLPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07316">7316</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="aefb5027d679a969e98b2cd7b83b31079" name="aefb5027d679a969e98b2cd7b83b31079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb5027d679a969e98b2cd7b83b31079">&#9670;&#160;</a></span>registerConvertAMXToLLVMInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertAMXToLLVMInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> conversion interface for AMX dialect. </p>

<p class="definition">Definition at line <a class="el" href="AMX_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00066">66</a> of file <a class="el" href="AMX_2Transforms_2LegalizeForLLVMExport_8cpp_source.html">LegalizeForLLVMExport.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllExtensions_8cpp_source.html#l00072">registerAllExtensions()</a>.</p>

</div>
</div>
<a id="ae273168b90db2508abf673b9ce3b5e55" name="ae273168b90db2508abf673b9ce3b5e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae273168b90db2508abf673b9ce3b5e55">&#9670;&#160;</a></span>registerConvertArithToEmitC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertArithToEmitC </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07351">7351</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a2a5c53b69971e5f369ff40d87dad5ae6" name="a2a5c53b69971e5f369ff40d87dad5ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5c53b69971e5f369ff40d87dad5ae6">&#9670;&#160;</a></span>registerConvertArithToEmitCInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertArithToEmitCInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArithToEmitC_8cpp_source.html#l00041">41</a> of file <a class="el" href="ArithToEmitC_8cpp_source.html">ArithToEmitC.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllExtensions_8cpp_source.html#l00072">registerAllExtensions()</a>.</p>

</div>
</div>
<a id="af1131cca58445b83bb3c753349c3df0c" name="af1131cca58445b83bb3c753349c3df0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1131cca58445b83bb3c753349c3df0c">&#9670;&#160;</a></span>registerConvertArithToEmitCPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertArithToEmitCPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07358">7358</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="abc1f775553f1cae09516c4ae935ade21" name="abc1f775553f1cae09516c4ae935ade21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1f775553f1cae09516c4ae935ade21">&#9670;&#160;</a></span>registerConvertArithToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertArithToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07372">7372</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a7bd392715db6eeda94e3fa57acc18c7c" name="a7bd392715db6eeda94e3fa57acc18c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd392715db6eeda94e3fa57acc18c7c">&#9670;&#160;</a></span>registerConvertArithToSPIRVPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertArithToSPIRVPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07379">7379</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a096c35c0bb5c57129ec240bf897b8869" name="a096c35c0bb5c57129ec240bf897b8869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096c35c0bb5c57129ec240bf897b8869">&#9670;&#160;</a></span>registerConvertArmNeon2dToIntrPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertArmNeon2dToIntrPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07393">7393</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a4ea564237cf4f63a31e847b2919ff221" name="a4ea564237cf4f63a31e847b2919ff221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea564237cf4f63a31e847b2919ff221">&#9670;&#160;</a></span>registerConvertArmNeon2dToIntrPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertArmNeon2dToIntrPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07400">7400</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="acdf0da5aa36162bf1a7815e5d1bbfab9" name="acdf0da5aa36162bf1a7815e5d1bbfab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf0da5aa36162bf1a7815e5d1bbfab9">&#9670;&#160;</a></span>registerConvertArmSMEToLLVM()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertArmSMEToLLVM </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07414">7414</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="af606ec9b83dca6c0b0a6f5a461258608" name="af606ec9b83dca6c0b0a6f5a461258608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af606ec9b83dca6c0b0a6f5a461258608">&#9670;&#160;</a></span>registerConvertArmSMEToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertArmSMEToLLVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07421">7421</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="abb7b6f0e17e5a3a248b6e4240f2df839" name="abb7b6f0e17e5a3a248b6e4240f2df839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7b6f0e17e5a3a248b6e4240f2df839">&#9670;&#160;</a></span>registerConvertArmSMEToSCFPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertArmSMEToSCFPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07435">7435</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a14efda6bd02c823b92f5d5cd7c7df71b" name="a14efda6bd02c823b92f5d5cd7c7df71b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14efda6bd02c823b92f5d5cd7c7df71b">&#9670;&#160;</a></span>registerConvertArmSMEToSCFPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertArmSMEToSCFPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07442">7442</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="ac96f3cd4d54d71f87d88cf1631ee9ee9" name="ac96f3cd4d54d71f87d88cf1631ee9ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac96f3cd4d54d71f87d88cf1631ee9ee9">&#9670;&#160;</a></span>registerConvertAsyncToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertAsyncToLLVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07456">7456</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="aec88cd051b19b819706cce6c4dfc32f7" name="aec88cd051b19b819706cce6c4dfc32f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec88cd051b19b819706cce6c4dfc32f7">&#9670;&#160;</a></span>registerConvertAsyncToLLVMPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertAsyncToLLVMPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07463">7463</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a13f5ad2dec8c53a92d9c90348b7fcf41" name="a13f5ad2dec8c53a92d9c90348b7fcf41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f5ad2dec8c53a92d9c90348b7fcf41">&#9670;&#160;</a></span>registerConvertBufferizationToMemRefPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertBufferizationToMemRefPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07477">7477</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="ae517e0cf89db75d522c3615bc42fac3b" name="ae517e0cf89db75d522c3615bc42fac3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae517e0cf89db75d522c3615bc42fac3b">&#9670;&#160;</a></span>registerConvertBufferizationToMemRefPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertBufferizationToMemRefPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07484">7484</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="af41e471bf4af49a441d1e5fd42d85643" name="af41e471bf4af49a441d1e5fd42d85643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af41e471bf4af49a441d1e5fd42d85643">&#9670;&#160;</a></span>registerConvertComplexToLibm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertComplexToLibm </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07519">7519</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a1afa5471b029cd428b00ac8ae9286ee3" name="a1afa5471b029cd428b00ac8ae9286ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1afa5471b029cd428b00ac8ae9286ee3">&#9670;&#160;</a></span>registerConvertComplexToLibmPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertComplexToLibmPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07526">7526</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a92e3131ae05feac332799cb2de81be2f" name="a92e3131ae05feac332799cb2de81be2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e3131ae05feac332799cb2de81be2f">&#9670;&#160;</a></span>registerConvertComplexToLLVMInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertComplexToLLVMInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ComplexToLLVM_8cpp_source.html#l00393">393</a> of file <a class="el" href="ComplexToLLVM_8cpp_source.html">ComplexToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllExtensions_8cpp_source.html#l00072">registerAllExtensions()</a>.</p>

</div>
</div>
<a id="a08b3972ec8b405b85435fb59a734771b" name="a08b3972ec8b405b85435fb59a734771b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b3972ec8b405b85435fb59a734771b">&#9670;&#160;</a></span>registerConvertComplexToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertComplexToLLVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07498">7498</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a1f887fb2c432aca14c8c8d04d52dadd3" name="a1f887fb2c432aca14c8c8d04d52dadd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f887fb2c432aca14c8c8d04d52dadd3">&#9670;&#160;</a></span>registerConvertComplexToLLVMPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertComplexToLLVMPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07505">7505</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="acad00d6f9627aa3ae61e21e0575fde82" name="acad00d6f9627aa3ae61e21e0575fde82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad00d6f9627aa3ae61e21e0575fde82">&#9670;&#160;</a></span>registerConvertComplexToROCDLLibraryCalls()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertComplexToROCDLLibraryCalls </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07540">7540</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a239ff38899672de9d46c4aed87b79f09" name="a239ff38899672de9d46c4aed87b79f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239ff38899672de9d46c4aed87b79f09">&#9670;&#160;</a></span>registerConvertComplexToROCDLLibraryCallsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertComplexToROCDLLibraryCallsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07547">7547</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a70fcc1bf94340796720cc5d49514c692" name="a70fcc1bf94340796720cc5d49514c692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70fcc1bf94340796720cc5d49514c692">&#9670;&#160;</a></span>registerConvertComplexToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertComplexToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07561">7561</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a5fbfba94a43afe1a073a4395e08f4ce4" name="a5fbfba94a43afe1a073a4395e08f4ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fbfba94a43afe1a073a4395e08f4ce4">&#9670;&#160;</a></span>registerConvertComplexToSPIRVPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertComplexToSPIRVPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07568">7568</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a83fdadd1f296a62f0b8fc3e88c4fc654" name="a83fdadd1f296a62f0b8fc3e88c4fc654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83fdadd1f296a62f0b8fc3e88c4fc654">&#9670;&#160;</a></span>registerConvertComplexToStandardPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertComplexToStandardPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07582">7582</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a42e0b4c5dba0ecc9593d9416113b1988" name="a42e0b4c5dba0ecc9593d9416113b1988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e0b4c5dba0ecc9593d9416113b1988">&#9670;&#160;</a></span>registerConvertComplexToStandardPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertComplexToStandardPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07589">7589</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a3a34f1d50818a63109bf766f5059f05c" name="a3a34f1d50818a63109bf766f5059f05c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a34f1d50818a63109bf766f5059f05c">&#9670;&#160;</a></span>registerConvertControlFlowToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertControlFlowToLLVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07603">7603</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a26c1e663a347bc3df793ebc52925aecd" name="a26c1e663a347bc3df793ebc52925aecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26c1e663a347bc3df793ebc52925aecd">&#9670;&#160;</a></span>registerConvertControlFlowToLLVMPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertControlFlowToLLVMPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07610">7610</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a1df50c4590e8fc48e97d1392e1ef2111" name="a1df50c4590e8fc48e97d1392e1ef2111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df50c4590e8fc48e97d1392e1ef2111">&#9670;&#160;</a></span>registerConvertControlFlowToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertControlFlowToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07624">7624</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a97f7e225951d979e1b87d433c66b2eb4" name="a97f7e225951d979e1b87d433c66b2eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f7e225951d979e1b87d433c66b2eb4">&#9670;&#160;</a></span>registerConvertControlFlowToSPIRVPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertControlFlowToSPIRVPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07631">7631</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a97ecdf9aebf503bb814a4c402d257ea6" name="a97ecdf9aebf503bb814a4c402d257ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ecdf9aebf503bb814a4c402d257ea6">&#9670;&#160;</a></span>registerConvertElementwiseToLinalgPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertElementwiseToLinalgPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html#l01219">1219</a> of file <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a23d118708262be53a1bec2e9ccda12b0" name="a23d118708262be53a1bec2e9ccda12b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23d118708262be53a1bec2e9ccda12b0">&#9670;&#160;</a></span>registerConvertElementwiseToLinalgPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertElementwiseToLinalgPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html#l01226">1226</a> of file <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a9b8d2b48540530c69aa46dc3e7fb4722" name="a9b8d2b48540530c69aa46dc3e7fb4722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8d2b48540530c69aa46dc3e7fb4722">&#9670;&#160;</a></span>registerConvertFuncToEmitC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertFuncToEmitC </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07645">7645</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a25d03114d3fbc5d75805750ddac07d71" name="a25d03114d3fbc5d75805750ddac07d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d03114d3fbc5d75805750ddac07d71">&#9670;&#160;</a></span>registerConvertFuncToEmitCInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertFuncToEmitCInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FuncToEmitC_8cpp_source.html#l00039">39</a> of file <a class="el" href="FuncToEmitC_8cpp_source.html">FuncToEmitC.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllExtensions_8cpp_source.html#l00072">registerAllExtensions()</a>.</p>

</div>
</div>
<a id="a2d3378a9e1423dc524c700a3e16cbd4d" name="a2d3378a9e1423dc524c700a3e16cbd4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3378a9e1423dc524c700a3e16cbd4d">&#9670;&#160;</a></span>registerConvertFuncToEmitCPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertFuncToEmitCPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07652">7652</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a4cd7b1431f65dc7d952407a7e062e63f" name="a4cd7b1431f65dc7d952407a7e062e63f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd7b1431f65dc7d952407a7e062e63f">&#9670;&#160;</a></span>registerConvertFuncToLLVMInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertFuncToLLVMInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FuncToLLVM_8cpp_source.html#l00887">887</a> of file <a class="el" href="FuncToLLVM_8cpp_source.html">FuncToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllExtensions_8cpp_source.html#l00072">registerAllExtensions()</a>.</p>

</div>
</div>
<a id="aaa56c74ad73df4db14579a9db513ea84" name="aaa56c74ad73df4db14579a9db513ea84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa56c74ad73df4db14579a9db513ea84">&#9670;&#160;</a></span>registerConvertFuncToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertFuncToLLVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07666">7666</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a6426aff071af118e2b0761b52b59008f" name="a6426aff071af118e2b0761b52b59008f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6426aff071af118e2b0761b52b59008f">&#9670;&#160;</a></span>registerConvertFuncToLLVMPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertFuncToLLVMPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07673">7673</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a4fe00d6aa4a619a172579db999588d55" name="a4fe00d6aa4a619a172579db999588d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe00d6aa4a619a172579db999588d55">&#9670;&#160;</a></span>registerConvertFuncToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertFuncToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07687">7687</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a0429d4efb3cb6879e1221903a4051ba5" name="a0429d4efb3cb6879e1221903a4051ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0429d4efb3cb6879e1221903a4051ba5">&#9670;&#160;</a></span>registerConvertFuncToSPIRVPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertFuncToSPIRVPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07694">7694</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="aa533454713753a1869bdee8487b9cea1" name="aa533454713753a1869bdee8487b9cea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa533454713753a1869bdee8487b9cea1">&#9670;&#160;</a></span>registerConvertGpuOpsToLLVMSPVOps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertGpuOpsToLLVMSPVOps </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07729">7729</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="ab65a7ef5b143f5b71f4982d84b8b491c" name="ab65a7ef5b143f5b71f4982d84b8b491c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65a7ef5b143f5b71f4982d84b8b491c">&#9670;&#160;</a></span>registerConvertGpuOpsToLLVMSPVOpsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertGpuOpsToLLVMSPVOpsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07736">7736</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a5fe97a463dee4a7f271148603e71eb03" name="a5fe97a463dee4a7f271148603e71eb03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fe97a463dee4a7f271148603e71eb03">&#9670;&#160;</a></span>registerConvertGpuOpsToNVVMOps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertGpuOpsToNVVMOps </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07750">7750</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="ab1ff1f03eea98a83f4806fbcfaa288c3" name="ab1ff1f03eea98a83f4806fbcfaa288c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ff1f03eea98a83f4806fbcfaa288c3">&#9670;&#160;</a></span>registerConvertGpuOpsToNVVMOpsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertGpuOpsToNVVMOpsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07757">7757</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="ac3c83ba1ea1b6aad3c929cfc10b6a9d3" name="ac3c83ba1ea1b6aad3c929cfc10b6a9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c83ba1ea1b6aad3c929cfc10b6a9d3">&#9670;&#160;</a></span>registerConvertGpuOpsToROCDLOps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertGpuOpsToROCDLOps </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07771">7771</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a67f6a28bbf36114e571565d0eb14f67a" name="a67f6a28bbf36114e571565d0eb14f67a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f6a28bbf36114e571565d0eb14f67a">&#9670;&#160;</a></span>registerConvertGpuOpsToROCDLOpsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertGpuOpsToROCDLOpsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07778">7778</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a98d8447a460fe33514ad2a682c4c260b" name="a98d8447a460fe33514ad2a682c4c260b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d8447a460fe33514ad2a682c4c260b">&#9670;&#160;</a></span>registerConvertGPUToSPIRV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertGPUToSPIRV </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07708">7708</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="ae2dec8e1013fa8cd1b069ab9fd453b6b" name="ae2dec8e1013fa8cd1b069ab9fd453b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2dec8e1013fa8cd1b069ab9fd453b6b">&#9670;&#160;</a></span>registerConvertGPUToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertGPUToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07715">7715</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a77b741faf49eadf990dedaeddf645bcc" name="a77b741faf49eadf990dedaeddf645bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b741faf49eadf990dedaeddf645bcc">&#9670;&#160;</a></span>registerConvertIndexToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertIndexToLLVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07792">7792</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a41ac6b01d7ddef0b8c79e0beff125690" name="a41ac6b01d7ddef0b8c79e0beff125690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ac6b01d7ddef0b8c79e0beff125690">&#9670;&#160;</a></span>registerConvertIndexToLLVMPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertIndexToLLVMPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07799">7799</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a01e88214a5b39e49e9b8a7ef281fdf91" name="a01e88214a5b39e49e9b8a7ef281fdf91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e88214a5b39e49e9b8a7ef281fdf91">&#9670;&#160;</a></span>registerConvertIndexToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertIndexToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07813">7813</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a403edeed2c1f7e7220320101f48c0cb8" name="a403edeed2c1f7e7220320101f48c0cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a403edeed2c1f7e7220320101f48c0cb8">&#9670;&#160;</a></span>registerConvertIndexToSPIRVPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertIndexToSPIRVPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07820">7820</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a0ec8c63c654693a9daafe4a341ce548b" name="a0ec8c63c654693a9daafe4a341ce548b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec8c63c654693a9daafe4a341ce548b">&#9670;&#160;</a></span>registerConvertLinalgToAffineLoopsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertLinalgToAffineLoopsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html#l01240">1240</a> of file <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a9f03c52c2be59f6f5fcf26c539069b81" name="a9f03c52c2be59f6f5fcf26c539069b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f03c52c2be59f6f5fcf26c539069b81">&#9670;&#160;</a></span>registerConvertLinalgToAffineLoopsPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertLinalgToAffineLoopsPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html#l01247">1247</a> of file <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a91d33006e35cfa953c7e7123793b72be" name="a91d33006e35cfa953c7e7123793b72be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d33006e35cfa953c7e7123793b72be">&#9670;&#160;</a></span>registerConvertLinalgToLoopsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertLinalgToLoopsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html#l01261">1261</a> of file <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a73cb428ff8c212129980c83896330a76" name="a73cb428ff8c212129980c83896330a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73cb428ff8c212129980c83896330a76">&#9670;&#160;</a></span>registerConvertLinalgToLoopsPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertLinalgToLoopsPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html#l01268">1268</a> of file <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a51a508b14163f40cf7650f0a54343c27" name="a51a508b14163f40cf7650f0a54343c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a508b14163f40cf7650f0a54343c27">&#9670;&#160;</a></span>registerConvertLinalgToParallelLoopsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertLinalgToParallelLoopsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html#l01282">1282</a> of file <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a1b97ac8485f9fedb81cb3ce69021bc6d" name="a1b97ac8485f9fedb81cb3ce69021bc6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b97ac8485f9fedb81cb3ce69021bc6d">&#9670;&#160;</a></span>registerConvertLinalgToParallelLoopsPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertLinalgToParallelLoopsPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html#l01289">1289</a> of file <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="adac78b8ab184ea2d53f6ed67c21a79e9" name="adac78b8ab184ea2d53f6ed67c21a79e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac78b8ab184ea2d53f6ed67c21a79e9">&#9670;&#160;</a></span>registerConvertLinalgToStandardPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertLinalgToStandardPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07834">7834</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="ada22f2f1588019fe9bc27b0e2c5c1b41" name="ada22f2f1588019fe9bc27b0e2c5c1b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada22f2f1588019fe9bc27b0e2c5c1b41">&#9670;&#160;</a></span>registerConvertLinalgToStandardPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertLinalgToStandardPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07841">7841</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a74a8d45f5b63e8c9f4c5a2d68cfa1648" name="a74a8d45f5b63e8c9f4c5a2d68cfa1648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a8d45f5b63e8c9f4c5a2d68cfa1648">&#9670;&#160;</a></span>registerConvertMathToEmitC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertMathToEmitC </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07855">7855</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a2d80facd0960d765dcb0965f81819552" name="a2d80facd0960d765dcb0965f81819552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d80facd0960d765dcb0965f81819552">&#9670;&#160;</a></span>registerConvertMathToEmitCPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertMathToEmitCPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07862">7862</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a955d7db1808a814477b698a4f54f4672" name="a955d7db1808a814477b698a4f54f4672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a955d7db1808a814477b698a4f54f4672">&#9670;&#160;</a></span>registerConvertMathToFuncs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertMathToFuncs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07876">7876</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a0daa4e194f223bd7d5e54da8c93101e6" name="a0daa4e194f223bd7d5e54da8c93101e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0daa4e194f223bd7d5e54da8c93101e6">&#9670;&#160;</a></span>registerConvertMathToFuncsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertMathToFuncsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07883">7883</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a05ad997ce786384fa6de9d231cede8f4" name="a05ad997ce786384fa6de9d231cede8f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ad997ce786384fa6de9d231cede8f4">&#9670;&#160;</a></span>registerConvertMathToLibmPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertMathToLibmPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07918">7918</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="acdcae51bb6c39818c80dedf983e03a0a" name="acdcae51bb6c39818c80dedf983e03a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdcae51bb6c39818c80dedf983e03a0a">&#9670;&#160;</a></span>registerConvertMathToLibmPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertMathToLibmPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07925">7925</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="af524bd5bb2e7831529a737536dee9e63" name="af524bd5bb2e7831529a737536dee9e63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af524bd5bb2e7831529a737536dee9e63">&#9670;&#160;</a></span>registerConvertMathToLLVMInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertMathToLLVMInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MathToLLVM_8cpp_source.html#l00487">487</a> of file <a class="el" href="MathToLLVM_8cpp_source.html">MathToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllExtensions_8cpp_source.html#l00072">registerAllExtensions()</a>.</p>

</div>
</div>
<a id="a2b5a3362c22d62221aafa898df03ed3a" name="a2b5a3362c22d62221aafa898df03ed3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b5a3362c22d62221aafa898df03ed3a">&#9670;&#160;</a></span>registerConvertMathToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertMathToLLVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07897">7897</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a3bedfaa457b9b21f4f4b9ac4753c08a0" name="a3bedfaa457b9b21f4f4b9ac4753c08a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bedfaa457b9b21f4f4b9ac4753c08a0">&#9670;&#160;</a></span>registerConvertMathToLLVMPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertMathToLLVMPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07904">7904</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="ac22e493d74b2890eab2c9e454a555640" name="ac22e493d74b2890eab2c9e454a555640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac22e493d74b2890eab2c9e454a555640">&#9670;&#160;</a></span>registerConvertMathToROCDL()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertMathToROCDL </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07939">7939</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a8685ca4e2f4ac3647ce5c8b8ccb654f3" name="a8685ca4e2f4ac3647ce5c8b8ccb654f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8685ca4e2f4ac3647ce5c8b8ccb654f3">&#9670;&#160;</a></span>registerConvertMathToROCDLPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertMathToROCDLPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07946">7946</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="ae755de1424ff83fb901a3b971d768eee" name="ae755de1424ff83fb901a3b971d768eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae755de1424ff83fb901a3b971d768eee">&#9670;&#160;</a></span>registerConvertMathToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertMathToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07960">7960</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a714e5f7d4f059693d2188eac88ee8866" name="a714e5f7d4f059693d2188eac88ee8866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714e5f7d4f059693d2188eac88ee8866">&#9670;&#160;</a></span>registerConvertMathToSPIRVPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertMathToSPIRVPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07967">7967</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a58bd4dcc53d4ebb6154d48f888c5efa0" name="a58bd4dcc53d4ebb6154d48f888c5efa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58bd4dcc53d4ebb6154d48f888c5efa0">&#9670;&#160;</a></span>registerConvertMathToXeVM()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertMathToXeVM </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07981">7981</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="ac71fff89df678ad07954e37abb9ebaa9" name="ac71fff89df678ad07954e37abb9ebaa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71fff89df678ad07954e37abb9ebaa9">&#9670;&#160;</a></span>registerConvertMathToXeVMPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertMathToXeVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l07988">7988</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a28235ac41da20e947abbf1dd68cfb51d" name="a28235ac41da20e947abbf1dd68cfb51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28235ac41da20e947abbf1dd68cfb51d">&#9670;&#160;</a></span>registerConvertMemRefToEmitC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertMemRefToEmitC </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08002">8002</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="ae8f146555b8c6c254ef00a1807de953d" name="ae8f146555b8c6c254ef00a1807de953d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f146555b8c6c254ef00a1807de953d">&#9670;&#160;</a></span>registerConvertMemRefToEmitCInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertMemRefToEmitCInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefToEmitC_8cpp_source.html#l00053">53</a> of file <a class="el" href="MemRefToEmitC_8cpp_source.html">MemRefToEmitC.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllExtensions_8cpp_source.html#l00072">registerAllExtensions()</a>.</p>

</div>
</div>
<a id="afb9003909e29980a18e71163798eee2f" name="afb9003909e29980a18e71163798eee2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb9003909e29980a18e71163798eee2f">&#9670;&#160;</a></span>registerConvertMemRefToEmitCPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertMemRefToEmitCPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08009">8009</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a064361570e348faf435496fbf4d5db7d" name="a064361570e348faf435496fbf4d5db7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064361570e348faf435496fbf4d5db7d">&#9670;&#160;</a></span>registerConvertMemRefToLLVMInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertMemRefToLLVMInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefToLLVM_8cpp_source.html#l02129">2129</a> of file <a class="el" href="MemRefToLLVM_8cpp_source.html">MemRefToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllExtensions_8cpp_source.html#l00072">registerAllExtensions()</a>.</p>

</div>
</div>
<a id="adfd3e376d7363c56fcd1c38fbb525975" name="adfd3e376d7363c56fcd1c38fbb525975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd3e376d7363c56fcd1c38fbb525975">&#9670;&#160;</a></span>registerConvertMemRefToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertMemRefToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08023">8023</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a82b85ec8db2d59274700dff89ef24b57" name="a82b85ec8db2d59274700dff89ef24b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b85ec8db2d59274700dff89ef24b57">&#9670;&#160;</a></span>registerConvertMemRefToSPIRVPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertMemRefToSPIRVPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08030">8030</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="af828fcfc7ee34b625d6e567eff925137" name="af828fcfc7ee34b625d6e567eff925137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af828fcfc7ee34b625d6e567eff925137">&#9670;&#160;</a></span>registerConvertNVGPUToNVVMPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertNVGPUToNVVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08044">8044</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a4fe1e5909f8de3e5efd29841ffa39a10" name="a4fe1e5909f8de3e5efd29841ffa39a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe1e5909f8de3e5efd29841ffa39a10">&#9670;&#160;</a></span>registerConvertNVGPUToNVVMPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertNVGPUToNVVMPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08051">8051</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="af5ef9c68e63c5458b7258ecb9b48b8bf" name="af5ef9c68e63c5458b7258ecb9b48b8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ef9c68e63c5458b7258ecb9b48b8bf">&#9670;&#160;</a></span>registerConvertNVVMToLLVMInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertNVVMToLLVMInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NVVMToLLVM_8cpp_source.html#l00116">116</a> of file <a class="el" href="NVVMToLLVM_8cpp_source.html">NVVMToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllExtensions_8cpp_source.html#l00072">registerAllExtensions()</a>.</p>

</div>
</div>
<a id="a0a5f4a512e94f6e26be843062d08b2a0" name="a0a5f4a512e94f6e26be843062d08b2a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5f4a512e94f6e26be843062d08b2a0">&#9670;&#160;</a></span>registerConvertNVVMToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertNVVMToLLVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08065">8065</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a3b7b560cdea4650e6f03095d7d9ec250" name="a3b7b560cdea4650e6f03095d7d9ec250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7b560cdea4650e6f03095d7d9ec250">&#9670;&#160;</a></span>registerConvertNVVMToLLVMPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertNVVMToLLVMPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08072">8072</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a1c8228d0f0062162b8f212d5144ec732" name="a1c8228d0f0062162b8f212d5144ec732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c8228d0f0062162b8f212d5144ec732">&#9670;&#160;</a></span>registerConvertOpenACCToSCFPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertOpenACCToSCFPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08086">8086</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a092d35a544220080021640b92b0ecaf3" name="a092d35a544220080021640b92b0ecaf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a092d35a544220080021640b92b0ecaf3">&#9670;&#160;</a></span>registerConvertOpenACCToSCFPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertOpenACCToSCFPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08093">8093</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a9410008d1bd500f1e43c258e655caf51" name="a9410008d1bd500f1e43c258e655caf51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9410008d1bd500f1e43c258e655caf51">&#9670;&#160;</a></span>registerConvertOpenMPToLLVMInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertOpenMPToLLVMInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers the <span class="tt"><a class="el" href="classmlir_1_1ConvertToLLVMPatternInterface.html" title="Base class for dialect interfaces providing translation to LLVM IR.">ConvertToLLVMPatternInterface</a></span> interface in the <span class="tt">OpenMP</span> dialect. </p>

<p class="definition">Definition at line <a class="el" href="OpenMPToLLVM_8cpp_source.html#l00217">217</a> of file <a class="el" href="OpenMPToLLVM_8cpp_source.html">OpenMPToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllExtensions_8cpp_source.html#l00072">registerAllExtensions()</a>.</p>

</div>
</div>
<a id="aa93576417f08fc54a7f749ed00fb259f" name="aa93576417f08fc54a7f749ed00fb259f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93576417f08fc54a7f749ed00fb259f">&#9670;&#160;</a></span>registerConvertOpenMPToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertOpenMPToLLVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08107">8107</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="aa67a8bd5615e06b3392ad8969b98784a" name="aa67a8bd5615e06b3392ad8969b98784a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa67a8bd5615e06b3392ad8969b98784a">&#9670;&#160;</a></span>registerConvertOpenMPToLLVMPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertOpenMPToLLVMPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08114">8114</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a6a45c6f078c2cdbad9653d35890d0759" name="a6a45c6f078c2cdbad9653d35890d0759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a45c6f078c2cdbad9653d35890d0759">&#9670;&#160;</a></span>registerConvertParallelLoopToGpuPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertParallelLoopToGpuPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08149">8149</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a4268cf392670a65eaeeae3312655d0e0" name="a4268cf392670a65eaeeae3312655d0e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4268cf392670a65eaeeae3312655d0e0">&#9670;&#160;</a></span>registerConvertParallelLoopToGpuPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertParallelLoopToGpuPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08156">8156</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a23d6284ece03f6e1ae72d12319c400a9" name="a23d6284ece03f6e1ae72d12319c400a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23d6284ece03f6e1ae72d12319c400a9">&#9670;&#160;</a></span>registerConvertPDLToPDLInterpPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertPDLToPDLInterpPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08128">8128</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a18bce95ff8e1a0a62306f63bda735860" name="a18bce95ff8e1a0a62306f63bda735860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18bce95ff8e1a0a62306f63bda735860">&#9670;&#160;</a></span>registerConvertPDLToPDLInterpPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertPDLToPDLInterpPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08135">8135</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="afbb6023aa80095813fe9d2a05b501603" name="afbb6023aa80095813fe9d2a05b501603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb6023aa80095813fe9d2a05b501603">&#9670;&#160;</a></span>registerConvertSCFToEmitCInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertSCFToEmitCInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SCFToEmitC_8cpp_source.html#l00051">51</a> of file <a class="el" href="SCFToEmitC_8cpp_source.html">SCFToEmitC.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllExtensions_8cpp_source.html#l00072">registerAllExtensions()</a>.</p>

</div>
</div>
<a id="ace96ba003051f7ae2e860099fff8eb54" name="ace96ba003051f7ae2e860099fff8eb54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace96ba003051f7ae2e860099fff8eb54">&#9670;&#160;</a></span>registerConvertSCFToOpenMPPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertSCFToOpenMPPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08170">8170</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a498e68e79bd3a59a8cabb5fb07cacfc6" name="a498e68e79bd3a59a8cabb5fb07cacfc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498e68e79bd3a59a8cabb5fb07cacfc6">&#9670;&#160;</a></span>registerConvertSCFToOpenMPPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertSCFToOpenMPPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08177">8177</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a2e122955bd1cb3fc15caca18e578824d" name="a2e122955bd1cb3fc15caca18e578824d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e122955bd1cb3fc15caca18e578824d">&#9670;&#160;</a></span>registerConvertShapeConstraintsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertShapeConstraintsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08212">8212</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="ab797f6ccf53b0a78e3e2091c35a93326" name="ab797f6ccf53b0a78e3e2091c35a93326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab797f6ccf53b0a78e3e2091c35a93326">&#9670;&#160;</a></span>registerConvertShapeConstraintsPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertShapeConstraintsPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08219">8219</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a018bbbb3bf2e2240e0ced0591293e270" name="a018bbbb3bf2e2240e0ced0591293e270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018bbbb3bf2e2240e0ced0591293e270">&#9670;&#160;</a></span>registerConvertShapeToStandardPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertShapeToStandardPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08233">8233</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="ac71a6b227ff2c7cce202ec727eb4db2d" name="ac71a6b227ff2c7cce202ec727eb4db2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71a6b227ff2c7cce202ec727eb4db2d">&#9670;&#160;</a></span>registerConvertShapeToStandardPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertShapeToStandardPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08240">8240</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="affed47fe766b7a67b16b374cf142f7a6" name="affed47fe766b7a67b16b374cf142f7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affed47fe766b7a67b16b374cf142f7a6">&#9670;&#160;</a></span>registerConvertShardToMPIPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertShardToMPIPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08254">8254</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="ab4f6f592e30fe755bcd8c2b139c0c80d" name="ab4f6f592e30fe755bcd8c2b139c0c80d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f6f592e30fe755bcd8c2b139c0c80d">&#9670;&#160;</a></span>registerConvertShardToMPIPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertShardToMPIPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08261">8261</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="ae25172e615beb064bb98f9360544b8ba" name="ae25172e615beb064bb98f9360544b8ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae25172e615beb064bb98f9360544b8ba">&#9670;&#160;</a></span>registerConvertSPIRVToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertSPIRVToLLVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08191">8191</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a06df0397211ca1c4d17742cdbab32359" name="a06df0397211ca1c4d17742cdbab32359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06df0397211ca1c4d17742cdbab32359">&#9670;&#160;</a></span>registerConvertSPIRVToLLVMPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertSPIRVToLLVMPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08198">8198</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a24ef9c83cb2a7fa5663e8424d2dce59f" name="a24ef9c83cb2a7fa5663e8424d2dce59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ef9c83cb2a7fa5663e8424d2dce59f">&#9670;&#160;</a></span>registerConvertTensorToLinalgPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertTensorToLinalgPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08275">8275</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a3687115274750178610d98170f65b433" name="a3687115274750178610d98170f65b433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3687115274750178610d98170f65b433">&#9670;&#160;</a></span>registerConvertTensorToLinalgPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertTensorToLinalgPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08282">8282</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="adc97378058439c5c33f40c9d035cafcc" name="adc97378058439c5c33f40c9d035cafcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc97378058439c5c33f40c9d035cafcc">&#9670;&#160;</a></span>registerConvertTensorToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertTensorToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08296">8296</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="ae22928ff9f5899f9449f40d4916a36e9" name="ae22928ff9f5899f9449f40d4916a36e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae22928ff9f5899f9449f40d4916a36e9">&#9670;&#160;</a></span>registerConvertTensorToSPIRVPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertTensorToSPIRVPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08303">8303</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a496aecce1f6215e7ecdbeb01a4838205" name="a496aecce1f6215e7ecdbeb01a4838205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a496aecce1f6215e7ecdbeb01a4838205">&#9670;&#160;</a></span>registerConvertToEmitC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertToEmitC </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08317">8317</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="aecbdc91e0bc4654fc64d94e6e905371c" name="aecbdc91e0bc4654fc64d94e6e905371c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecbdc91e0bc4654fc64d94e6e905371c">&#9670;&#160;</a></span>registerConvertToEmitCPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertToEmitCPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08324">8324</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a8a1cfd257150164208f96531454b4d59" name="a8a1cfd257150164208f96531454b4d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1cfd257150164208f96531454b4d59">&#9670;&#160;</a></span>registerConvertToLLVMDependentDialectLoading()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertToLLVMDependentDialectLoading </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the extension that will load dependent dialects for <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> conversion. </p>
<p>This is useful to implement a pass similar to "convert-to-llvm". </p>

<p class="definition">Definition at line <a class="el" href="ConvertToLLVMPass_8cpp_source.html#l00292">292</a> of file <a class="el" href="ConvertToLLVMPass_8cpp_source.html">ConvertToLLVMPass.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00222">mlir::DialectRegistry::addExtensions()</a>.</p>

</div>
</div>
<a id="aaf798b81989fc7a91ab9cb45ddea9d92" name="aaf798b81989fc7a91ab9cb45ddea9d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf798b81989fc7a91ab9cb45ddea9d92">&#9670;&#160;</a></span>registerConvertToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertToLLVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08338">8338</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a12f2c035753f98113ca6eb28723b3468" name="a12f2c035753f98113ca6eb28723b3468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f2c035753f98113ca6eb28723b3468">&#9670;&#160;</a></span>registerConvertToLLVMPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertToLLVMPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08345">8345</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a940f6293d3c34b746f269bdb00bbed8b" name="a940f6293d3c34b746f269bdb00bbed8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940f6293d3c34b746f269bdb00bbed8b">&#9670;&#160;</a></span>registerConvertVectorToAMX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertVectorToAMX </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08359">8359</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a450bdfd2a67f89c6ffb5b8379de695d5" name="a450bdfd2a67f89c6ffb5b8379de695d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a450bdfd2a67f89c6ffb5b8379de695d5">&#9670;&#160;</a></span>registerConvertVectorToAMXPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertVectorToAMXPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08366">8366</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a63630b09ed01fdbd642f0b5f0b873788" name="a63630b09ed01fdbd642f0b5f0b873788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63630b09ed01fdbd642f0b5f0b873788">&#9670;&#160;</a></span>registerConvertVectorToArmSMEPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertVectorToArmSMEPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08380">8380</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a2904dd1841ecb5b156a5ddd148733b87" name="a2904dd1841ecb5b156a5ddd148733b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2904dd1841ecb5b156a5ddd148733b87">&#9670;&#160;</a></span>registerConvertVectorToArmSMEPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertVectorToArmSMEPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08387">8387</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a82139faad591d2e9c0833e784c16a6cb" name="a82139faad591d2e9c0833e784c16a6cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82139faad591d2e9c0833e784c16a6cb">&#9670;&#160;</a></span>registerConvertVectorToGPU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertVectorToGPU </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08401">8401</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="aafebcaff3cb7aa01852f42d834957f59" name="aafebcaff3cb7aa01852f42d834957f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafebcaff3cb7aa01852f42d834957f59">&#9670;&#160;</a></span>registerConvertVectorToGPUPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertVectorToGPUPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08408">8408</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a7ca10302ef110f08a9e86e80a35aec6d" name="a7ca10302ef110f08a9e86e80a35aec6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca10302ef110f08a9e86e80a35aec6d">&#9670;&#160;</a></span>registerConvertVectorToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertVectorToLLVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08422">8422</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a06b8dbf318f98d66fc4f5cc77c4c5e04" name="a06b8dbf318f98d66fc4f5cc77c4c5e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b8dbf318f98d66fc4f5cc77c4c5e04">&#9670;&#160;</a></span>registerConvertVectorToLLVMPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertVectorToLLVMPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08429">8429</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a3200d7de5f20d50156567878a0d47d68" name="a3200d7de5f20d50156567878a0d47d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3200d7de5f20d50156567878a0d47d68">&#9670;&#160;</a></span>registerConvertVectorToSCF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertVectorToSCF </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08443">8443</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a6f940fb0c1ebaf03baedc31693730b93" name="a6f940fb0c1ebaf03baedc31693730b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f940fb0c1ebaf03baedc31693730b93">&#9670;&#160;</a></span>registerConvertVectorToSCFPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertVectorToSCFPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08450">8450</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="aa81ef468496bbfa2e5992df33a9863cc" name="aa81ef468496bbfa2e5992df33a9863cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81ef468496bbfa2e5992df33a9863cc">&#9670;&#160;</a></span>registerConvertVectorToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertVectorToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08464">8464</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="ac65fdd900df5950cd9d108160da0bb3f" name="ac65fdd900df5950cd9d108160da0bb3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac65fdd900df5950cd9d108160da0bb3f">&#9670;&#160;</a></span>registerConvertVectorToSPIRVPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertVectorToSPIRVPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08471">8471</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a64587fd9b69341014852e6fd3b240d62" name="a64587fd9b69341014852e6fd3b240d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64587fd9b69341014852e6fd3b240d62">&#9670;&#160;</a></span>registerConvertVectorToXeGPU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertVectorToXeGPU </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08485">8485</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a9abc9a63245a446e2482485f9c9c8073" name="a9abc9a63245a446e2482485f9c9c8073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9abc9a63245a446e2482485f9c9c8073">&#9670;&#160;</a></span>registerConvertVectorToXeGPUPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertVectorToXeGPUPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08492">8492</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a4e4f840142b66345b8c042d741b8fd2d" name="a4e4f840142b66345b8c042d741b8fd2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4f840142b66345b8c042d741b8fd2d">&#9670;&#160;</a></span>registerConvertXeGPUToXeVMPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertXeGPUToXeVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08506">8506</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="af3de8f4d0eda4229e2d32c11bafbf1d9" name="af3de8f4d0eda4229e2d32c11bafbf1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3de8f4d0eda4229e2d32c11bafbf1d9">&#9670;&#160;</a></span>registerConvertXeGPUToXeVMPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertXeGPUToXeVMPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08513">8513</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="afb1dd0bcae45a7ab0015246b4c8104b8" name="afb1dd0bcae45a7ab0015246b4c8104b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb1dd0bcae45a7ab0015246b4c8104b8">&#9670;&#160;</a></span>registerConvertXeVMToLLVMInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void::mlir::registerConvertXeVMToLLVMInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeVMToLLVM_8cpp_source.html#l00941">941</a> of file <a class="el" href="XeVMToLLVM_8cpp_source.html">XeVMToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllExtensions_8cpp_source.html#l00072">registerAllExtensions()</a>.</p>

</div>
</div>
<a id="a4e9d168096f37dd1020f4f8d7fb75978" name="a4e9d168096f37dd1020f4f8d7fb75978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e9d168096f37dd1020f4f8d7fb75978">&#9670;&#160;</a></span>registerConvertXeVMToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertXeVMToLLVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08527">8527</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a677ef761a7ebdd80cd44a4ce2d5be126" name="a677ef761a7ebdd80cd44a4ce2d5be126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677ef761a7ebdd80cd44a4ce2d5be126">&#9670;&#160;</a></span>registerConvertXeVMToLLVMPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerConvertXeVMToLLVMPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08534">8534</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="ae4abc5643d0337f579425d2f48f14249" name="ae4abc5643d0337f579425d2f48f14249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4abc5643d0337f579425d2f48f14249">&#9670;&#160;</a></span>registerCSE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerCSE </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01632">1632</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="aae45938de6e167022f8deb1ca2aa6ceb" name="aae45938de6e167022f8deb1ca2aa6ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae45938de6e167022f8deb1ca2aa6ceb">&#9670;&#160;</a></span>registerCSEPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerCSEPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01639">1639</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a1da5a75b8bc3193908b0e222a6da1d85" name="a1da5a75b8bc3193908b0e222a6da1d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da5a75b8bc3193908b0e222a6da1d85">&#9670;&#160;</a></span>registerDefaultTimingManagerCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerDefaultTimingManagerCLOptions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a set of useful command-line options that can be used to configure a <span class="tt"><a class="el" href="classmlir_1_1DefaultTimingManager.html" title="Facilities for time measurement and report printing to an output stream.">DefaultTimingManager</a></span>. </p>
<p>The values of these options can be applied via the <span class="tt">applyDefaultTimingManagerCLOptions</span> method. </p>

<p class="definition">Definition at line <a class="el" href="Timing_8cpp_source.html#l00612">612</a> of file <a class="el" href="Timing_8cpp_source.html">Timing.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00684">registerCLIOptions()</a>.</p>

</div>
</div>
<a id="a1392b2f88011768f84d961981ba9930f" name="a1392b2f88011768f84d961981ba9930f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1392b2f88011768f84d961981ba9930f">&#9670;&#160;</a></span>registerFinalizeMemRefToLLVMConversionPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerFinalizeMemRefToLLVMConversionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08548">8548</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a3b4b1062768de0de574f533f2a908ccf" name="a3b4b1062768de0de574f533f2a908ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b4b1062768de0de574f533f2a908ccf">&#9670;&#160;</a></span>registerFinalizeMemRefToLLVMConversionPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerFinalizeMemRefToLLVMConversionPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08555">8555</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a7a267e7e7ec38e0a09285a20831414d3" name="a7a267e7e7ec38e0a09285a20831414d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a267e7e7ec38e0a09285a20831414d3">&#9670;&#160;</a></span>registerFromLLVMIRTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerFromLLVMIRTranslation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00027">27</a> of file <a class="el" href="ConvertFromLLVMIR_8cpp_source.html">ConvertFromLLVMIR.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00332">emitError()</a>, <a class="el" href="All_8h_source.html#l00079">registerAllFromLLVMIRTranslations()</a>, and <a class="el" href="ModuleImport_8cpp_source.html#l03359">translateLLVMIRToModule()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllTranslations_8h_source.html#l00035">registerAllTranslations()</a>.</p>

</div>
</div>
<a id="a51ef91a9901d4d87a042990ccb79f2be" name="a51ef91a9901d4d87a042990ccb79f2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ef91a9901d4d87a042990ccb79f2be">&#9670;&#160;</a></span>registerFromSPIRVTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerFromSPIRVTranslation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00058">58</a> of file <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html">TranslateRegistration.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00039">deserializeModule()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllTranslations_8h_source.html#l00035">registerAllTranslations()</a>.</p>

</div>
</div>
<a id="a3985663c2b0a51493efab15e2f9f06bc" name="a3985663c2b0a51493efab15e2f9f06bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3985663c2b0a51493efab15e2f9f06bc">&#9670;&#160;</a></span>registerFromWasmTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerFromWasmTranslation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Wasm_2TranslateRegistration_8cpp_source.html#l00017">17</a> of file <a class="el" href="Wasm_2TranslateRegistration_8cpp_source.html">TranslateRegistration.cpp</a>.</p>

<p class="reference">References <a class="el" href="TranslateFromWasm_8cpp_source.html#l01954">mlir::wasm::importWebAssemblyToModule()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllTranslations_8h_source.html#l00035">registerAllTranslations()</a>.</p>

</div>
</div>
<a id="aecda2e833016d0a1cb419e39b4f00fc8" name="aecda2e833016d0a1cb419e39b4f00fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecda2e833016d0a1cb419e39b4f00fc8">&#9670;&#160;</a></span>registerGenerateRuntimeVerification()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerGenerateRuntimeVerification </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01716">1716</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="abb38875de50b6346efa2a01191578a96" name="abb38875de50b6346efa2a01191578a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb38875de50b6346efa2a01191578a96">&#9670;&#160;</a></span>registerGenerateRuntimeVerificationPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerGenerateRuntimeVerificationPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01723">1723</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a482927531fc314e46ea82a0995e591d9" name="a482927531fc314e46ea82a0995e591d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482927531fc314e46ea82a0995e591d9">&#9670;&#160;</a></span>registerGpuAsyncRegionPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerGpuAsyncRegionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l01117">1117</a> of file <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ac99755f363de6354507292d522f05df2" name="ac99755f363de6354507292d522f05df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99755f363de6354507292d522f05df2">&#9670;&#160;</a></span>registerGpuAsyncRegionPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerGpuAsyncRegionPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l01124">1124</a> of file <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a16f33fdfc11d308ce88089af2bd93e9c" name="a16f33fdfc11d308ce88089af2bd93e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f33fdfc11d308ce88089af2bd93e9c">&#9670;&#160;</a></span>registerGpuDecomposeMemrefsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerGpuDecomposeMemrefsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l01138">1138</a> of file <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ad03c9fed42a4f5fcba64f13341f1ae89" name="ad03c9fed42a4f5fcba64f13341f1ae89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03c9fed42a4f5fcba64f13341f1ae89">&#9670;&#160;</a></span>registerGpuDecomposeMemrefsPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerGpuDecomposeMemrefsPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l01145">1145</a> of file <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="aa9427230420827cff7cd15f78924cdb4" name="aa9427230420827cff7cd15f78924cdb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9427230420827cff7cd15f78924cdb4">&#9670;&#160;</a></span>registerGPUDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerGPUDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the GPU dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="GPUToLLVMIRTranslation_8cpp_source.html#l00066">66</a> of file <a class="el" href="GPUToLLVMIRTranslation_8cpp_source.html">GPUToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00152">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00063">registerAllGPUToLLVMIRTranslations()</a>, <a class="el" href="All_8h_source.html#l00039">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="GPUToLLVMIRTranslation_8cpp_source.html#l00073">registerGPUDialectTranslation()</a>.</p>

</div>
</div>
<a id="afe90c6efbbc0e7e7469f14619fd7445b" name="afe90c6efbbc0e7e7469f14619fd7445b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe90c6efbbc0e7e7469f14619fd7445b">&#9670;&#160;</a></span>registerGPUDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerGPUDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the GPU dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="GPUToLLVMIRTranslation_8cpp_source.html#l00073">73</a> of file <a class="el" href="GPUToLLVMIRTranslation_8cpp_source.html">GPUToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00416">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="GPUToLLVMIRTranslation_8cpp_source.html#l00066">registerGPUDialectTranslation()</a>.</p>

</div>
</div>
<a id="a2c285e555d33e8843aae7400a0747b9b" name="a2c285e555d33e8843aae7400a0747b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c285e555d33e8843aae7400a0747b9b">&#9670;&#160;</a></span>registerGpuEliminateBarriers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerGpuEliminateBarriers </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l01159">1159</a> of file <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a8915467bc4639915023534a752c34cb7" name="a8915467bc4639915023534a752c34cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8915467bc4639915023534a752c34cb7">&#9670;&#160;</a></span>registerGpuEliminateBarriersPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerGpuEliminateBarriersPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l01166">1166</a> of file <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a304d86139344d8dedf0c16cfdf5dcc18" name="a304d86139344d8dedf0c16cfdf5dcc18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a304d86139344d8dedf0c16cfdf5dcc18">&#9670;&#160;</a></span>registerGpuKernelOutliningPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerGpuKernelOutliningPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l01180">1180</a> of file <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a7729d63449e862160d350a8d3ab12716" name="a7729d63449e862160d350a8d3ab12716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7729d63449e862160d350a8d3ab12716">&#9670;&#160;</a></span>registerGpuKernelOutliningPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerGpuKernelOutliningPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l01187">1187</a> of file <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="aed772ebc7afaa2193f2336067fee0415" name="aed772ebc7afaa2193f2336067fee0415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed772ebc7afaa2193f2336067fee0415">&#9670;&#160;</a></span>registerGpuLaunchSinkIndexComputationsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerGpuLaunchSinkIndexComputationsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l01201">1201</a> of file <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="aa4e95e8bb42d67237fae5acc09d388ac" name="aa4e95e8bb42d67237fae5acc09d388ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e95e8bb42d67237fae5acc09d388ac">&#9670;&#160;</a></span>registerGpuLaunchSinkIndexComputationsPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerGpuLaunchSinkIndexComputationsPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l01208">1208</a> of file <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a8a5ec1968667f1574cd8a2fa7d86b79b" name="a8a5ec1968667f1574cd8a2fa7d86b79b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a5ec1968667f1574cd8a2fa7d86b79b">&#9670;&#160;</a></span>registerGpuMapParallelLoopsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerGpuMapParallelLoopsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l01222">1222</a> of file <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a04f863369b96423c61ec7f41586f668a" name="a04f863369b96423c61ec7f41586f668a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f863369b96423c61ec7f41586f668a">&#9670;&#160;</a></span>registerGpuMapParallelLoopsPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerGpuMapParallelLoopsPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l01229">1229</a> of file <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a0b19ceddc988456a302369257ba57c3d" name="a0b19ceddc988456a302369257ba57c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b19ceddc988456a302369257ba57c3d">&#9670;&#160;</a></span>registerGpuModuleToBinaryPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerGpuModuleToBinaryPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l01243">1243</a> of file <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a4544cabd9b2f8547127605809ebb9823" name="a4544cabd9b2f8547127605809ebb9823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4544cabd9b2f8547127605809ebb9823">&#9670;&#160;</a></span>registerGpuModuleToBinaryPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerGpuModuleToBinaryPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l01250">1250</a> of file <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a5987c6bcba9d38f84fce0f19e887a8c5" name="a5987c6bcba9d38f84fce0f19e887a8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5987c6bcba9d38f84fce0f19e887a8c5">&#9670;&#160;</a></span>registerGpuNVVMAttachTarget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerGpuNVVMAttachTarget </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l01264">1264</a> of file <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a823a18a1f0d69fb1ad5cdaf5864112a6" name="a823a18a1f0d69fb1ad5cdaf5864112a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a823a18a1f0d69fb1ad5cdaf5864112a6">&#9670;&#160;</a></span>registerGpuNVVMAttachTargetPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerGpuNVVMAttachTargetPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l01271">1271</a> of file <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="abdd28096ad54d3c4c633162adf520ad8" name="abdd28096ad54d3c4c633162adf520ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd28096ad54d3c4c633162adf520ad8">&#9670;&#160;</a></span>registerGPUPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerGPUPasses </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l01348">1348</a> of file <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllPasses_8cpp_source.html#l00059">registerAllPasses()</a>.</p>

</div>
</div>
<a id="aad75af260d41e616f135340c2d031ed3" name="aad75af260d41e616f135340c2d031ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad75af260d41e616f135340c2d031ed3">&#9670;&#160;</a></span>registerGpuROCDLAttachTarget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerGpuROCDLAttachTarget </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l01285">1285</a> of file <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a82b8b81fdf610ab5205b6e6bb3daf985" name="a82b8b81fdf610ab5205b6e6bb3daf985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b8b81fdf610ab5205b6e6bb3daf985">&#9670;&#160;</a></span>registerGpuROCDLAttachTargetPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerGpuROCDLAttachTargetPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l01292">1292</a> of file <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ac88b5bda540cbc2446a1fa4d66f8b6ba" name="ac88b5bda540cbc2446a1fa4d66f8b6ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88b5bda540cbc2446a1fa4d66f8b6ba">&#9670;&#160;</a></span>registerGpuSPIRVAttachTarget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerGpuSPIRVAttachTarget </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l01306">1306</a> of file <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="af61ecc4bec0daa2c13fea2995f0c8b23" name="af61ecc4bec0daa2c13fea2995f0c8b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61ecc4bec0daa2c13fea2995f0c8b23">&#9670;&#160;</a></span>registerGpuSPIRVAttachTargetPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerGpuSPIRVAttachTargetPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l01313">1313</a> of file <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ad27d757550250daa79dbd4308346dcd1" name="ad27d757550250daa79dbd4308346dcd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27d757550250daa79dbd4308346dcd1">&#9670;&#160;</a></span>registerGpuToLLVMConversionPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerGpuToLLVMConversionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08569">8569</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="aed92f27e122e47df5f504c4127295bc2" name="aed92f27e122e47df5f504c4127295bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed92f27e122e47df5f504c4127295bc2">&#9670;&#160;</a></span>registerGpuToLLVMConversionPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerGpuToLLVMConversionPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08576">8576</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a193c8e12180e01ad4e347345eb68b6e4" name="a193c8e12180e01ad4e347345eb68b6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193c8e12180e01ad4e347345eb68b6e4">&#9670;&#160;</a></span>registerGpuXeVMAttachTarget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerGpuXeVMAttachTarget </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l01327">1327</a> of file <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="abc28af19978d5cd9c2940fa3708086c2" name="abc28af19978d5cd9c2940fa3708086c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc28af19978d5cd9c2940fa3708086c2">&#9670;&#160;</a></span>registerGpuXeVMAttachTargetPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerGpuXeVMAttachTargetPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l01334">1334</a> of file <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a66780d20fcbef624019d5734c4853d39" name="a66780d20fcbef624019d5734c4853d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66780d20fcbef624019d5734c4853d39">&#9670;&#160;</a></span>registerInliner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerInliner </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01737">1737</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="abeb616f0d7b4bb70a8444b4f516b9e74" name="abeb616f0d7b4bb70a8444b4f516b9e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb616f0d7b4bb70a8444b4f516b9e74">&#9670;&#160;</a></span>registerInlinerPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerInlinerPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01744">1744</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a4b6247969f741fbafa5b04b6d65da860" name="a4b6247969f741fbafa5b04b6d65da860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6247969f741fbafa5b04b6d65da860">&#9670;&#160;</a></span>registerIRDLToCppTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerIRDLToCppTranslation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TranslationRegistration_8cpp_source.html#l00025">25</a> of file <a class="el" href="TranslationRegistration_8cpp_source.html">TranslationRegistration.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00268">mlir::Operation::emitError()</a>, <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, and <a class="el" href="IRDLToCpp_8cpp_source.html#l00637">mlir::irdl::translateIRDLDialectToCpp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllTranslations_8h_source.html#l00035">registerAllTranslations()</a>.</p>

</div>
</div>
<a id="a9a05d23e835ca674cc81003a6648fe9a" name="a9a05d23e835ca674cc81003a6648fe9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a05d23e835ca674cc81003a6648fe9a">&#9670;&#160;</a></span>registerLiftControlFlowToSCFPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLiftControlFlowToSCFPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08590">8590</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a65d236b5f016cce5a04aa091696c69f4" name="a65d236b5f016cce5a04aa091696c69f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d236b5f016cce5a04aa091696c69f4">&#9670;&#160;</a></span>registerLiftControlFlowToSCFPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLiftControlFlowToSCFPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08597">8597</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="ab2a6d985c6e6121d569de20c3f7f89fc" name="ab2a6d985c6e6121d569de20c3f7f89fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2a6d985c6e6121d569de20c3f7f89fc">&#9670;&#160;</a></span>registerLinalgBlockPackMatmul()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLinalgBlockPackMatmul </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html#l01303">1303</a> of file <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a80caeaacf364ddb81175f9b41c734a52" name="a80caeaacf364ddb81175f9b41c734a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80caeaacf364ddb81175f9b41c734a52">&#9670;&#160;</a></span>registerLinalgBlockPackMatmulPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLinalgBlockPackMatmulPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html#l01310">1310</a> of file <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ace41cb97a366d7f4de2c0c6dceb008d9" name="ace41cb97a366d7f4de2c0c6dceb008d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace41cb97a366d7f4de2c0c6dceb008d9">&#9670;&#160;</a></span>registerLinalgDetensorizePass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLinalgDetensorizePass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html#l01324">1324</a> of file <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a3227af85b7538bdc32b1f189516329aa" name="a3227af85b7538bdc32b1f189516329aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3227af85b7538bdc32b1f189516329aa">&#9670;&#160;</a></span>registerLinalgDetensorizePassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLinalgDetensorizePassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html#l01331">1331</a> of file <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a22d5f4384436d0ed58c2616c8644f80c" name="a22d5f4384436d0ed58c2616c8644f80c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d5f4384436d0ed58c2616c8644f80c">&#9670;&#160;</a></span>registerLinalgElementwiseOpFusionPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLinalgElementwiseOpFusionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html#l01345">1345</a> of file <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a2ac81842f2d678dd5f2d8dc1cb0f2335" name="a2ac81842f2d678dd5f2d8dc1cb0f2335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac81842f2d678dd5f2d8dc1cb0f2335">&#9670;&#160;</a></span>registerLinalgElementwiseOpFusionPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLinalgElementwiseOpFusionPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html#l01352">1352</a> of file <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="aec7445c96c74f7cd2a9b0fe0eb2ea613" name="aec7445c96c74f7cd2a9b0fe0eb2ea613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7445c96c74f7cd2a9b0fe0eb2ea613">&#9670;&#160;</a></span>registerLinalgFoldIntoElementwisePass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLinalgFoldIntoElementwisePass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html#l01366">1366</a> of file <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="afd70d5d6fd3823339e25c998c946db19" name="afd70d5d6fd3823339e25c998c946db19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd70d5d6fd3823339e25c998c946db19">&#9670;&#160;</a></span>registerLinalgFoldIntoElementwisePassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLinalgFoldIntoElementwisePassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html#l01373">1373</a> of file <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="afb6ca7f9b45dac2ffe55c3e633ac6f23" name="afb6ca7f9b45dac2ffe55c3e633ac6f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb6ca7f9b45dac2ffe55c3e633ac6f23">&#9670;&#160;</a></span>registerLinalgFoldUnitExtentDimsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLinalgFoldUnitExtentDimsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html#l01387">1387</a> of file <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="aaaf4d991808c11a4b36a35d22c6864e9" name="aaaf4d991808c11a4b36a35d22c6864e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf4d991808c11a4b36a35d22c6864e9">&#9670;&#160;</a></span>registerLinalgFoldUnitExtentDimsPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLinalgFoldUnitExtentDimsPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html#l01394">1394</a> of file <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a6d684b2bc847459cc887fd45418e9670" name="a6d684b2bc847459cc887fd45418e9670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d684b2bc847459cc887fd45418e9670">&#9670;&#160;</a></span>registerLinalgGeneralizeNamedOpsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLinalgGeneralizeNamedOpsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html#l01408">1408</a> of file <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a8526ed0dd37d3b6bec1a1d1f554204c8" name="a8526ed0dd37d3b6bec1a1d1f554204c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8526ed0dd37d3b6bec1a1d1f554204c8">&#9670;&#160;</a></span>registerLinalgGeneralizeNamedOpsPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLinalgGeneralizeNamedOpsPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html#l01415">1415</a> of file <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ae6b9637d5622bd12afabebe269c6bd6c" name="ae6b9637d5622bd12afabebe269c6bd6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b9637d5622bd12afabebe269c6bd6c">&#9670;&#160;</a></span>registerLinalgInlineScalarOperandsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLinalgInlineScalarOperandsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html#l01429">1429</a> of file <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a044e0005438657e2a0a4bba23095e562" name="a044e0005438657e2a0a4bba23095e562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044e0005438657e2a0a4bba23095e562">&#9670;&#160;</a></span>registerLinalgInlineScalarOperandsPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLinalgInlineScalarOperandsPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html#l01436">1436</a> of file <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="af5543a4a7fd631d5b0c34b0e48590dd3" name="af5543a4a7fd631d5b0c34b0e48590dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5543a4a7fd631d5b0c34b0e48590dd3">&#9670;&#160;</a></span>registerLinalgMorphOpsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLinalgMorphOpsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html#l01450">1450</a> of file <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a97ce6ecdd3b66ce9cee9b535a05a3eaa" name="a97ce6ecdd3b66ce9cee9b535a05a3eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ce6ecdd3b66ce9cee9b535a05a3eaa">&#9670;&#160;</a></span>registerLinalgMorphOpsPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLinalgMorphOpsPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html#l01457">1457</a> of file <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a5be854529eae74333823d129362ee47c" name="a5be854529eae74333823d129362ee47c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be854529eae74333823d129362ee47c">&#9670;&#160;</a></span>registerLinalgPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLinalgPasses </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html#l01513">1513</a> of file <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">Passes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllPasses_8cpp_source.html#l00059">registerAllPasses()</a>.</p>

</div>
</div>
<a id="a7dcdce489d744f45d02d14a11d6dab99" name="a7dcdce489d744f45d02d14a11d6dab99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dcdce489d744f45d02d14a11d6dab99">&#9670;&#160;</a></span>registerLinalgSpecializeGenericOpsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLinalgSpecializeGenericOpsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html#l01471">1471</a> of file <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a2a6f7835f99ed42c76b61b3302c0aad9" name="a2a6f7835f99ed42c76b61b3302c0aad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6f7835f99ed42c76b61b3302c0aad9">&#9670;&#160;</a></span>registerLinalgSpecializeGenericOpsPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLinalgSpecializeGenericOpsPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html#l01478">1478</a> of file <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ab01617995d72a114db65ee711b2422d5" name="ab01617995d72a114db65ee711b2422d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01617995d72a114db65ee711b2422d5">&#9670;&#160;</a></span>registerLLVMDialectImport() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLLVMDialectImport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and its import from <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry. </p>

<p class="definition">Definition at line <a class="el" href="LLVMIRToLLVMTranslation_8cpp_source.html#l00516">516</a> of file <a class="el" href="LLVMIRToLLVMTranslation_8cpp_source.html">LLVMIRToLLVMTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00152">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00079">registerAllFromLLVMIRTranslations()</a>, and <a class="el" href="LLVMIRToLLVMTranslation_8cpp_source.html#l00523">registerLLVMDialectImport()</a>.</p>

</div>
</div>
<a id="a4a0110d23914c27f0140d63a8bb934d4" name="a4a0110d23914c27f0140d63a8bb934d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0110d23914c27f0140d63a8bb934d4">&#9670;&#160;</a></span>registerLLVMDialectImport() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLLVMDialectImport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and its import from <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR with the given context. </p>

<p class="definition">Definition at line <a class="el" href="LLVMIRToLLVMTranslation_8cpp_source.html#l00523">523</a> of file <a class="el" href="LLVMIRToLLVMTranslation_8cpp_source.html">LLVMIRToLLVMTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00416">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="LLVMIRToLLVMTranslation_8cpp_source.html#l00516">registerLLVMDialectImport()</a>.</p>

</div>
</div>
<a id="a8b9759ca57d83ec47b341d58d966b9e8" name="a8b9759ca57d83ec47b341d58d966b9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9759ca57d83ec47b341d58d966b9e8">&#9670;&#160;</a></span>registerLLVMDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLLVMDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00795">795</a> of file <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html">LLVMToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00152">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CAPI_2ExecutionEngine_2ExecutionEngine_8cpp_source.html#l00023">mlirExecutionEngineCreate()</a>, <a class="el" href="All_8h_source.html#l00063">registerAllGPUToLLVMIRTranslations()</a>, <a class="el" href="All_8h_source.html#l00039">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00802">registerLLVMDialectTranslation()</a>.</p>

</div>
</div>
<a id="a74024a3b8ec9af8d50db598772774a96" name="a74024a3b8ec9af8d50db598772774a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74024a3b8ec9af8d50db598772774a96">&#9670;&#160;</a></span>registerLLVMDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLLVMDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00802">802</a> of file <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html">LLVMToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00416">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00795">registerLLVMDialectTranslation()</a>.</p>

</div>
</div>
<a id="aa5484eb02e0c7711fefd5682e3232ff8" name="aa5484eb02e0c7711fefd5682e3232ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5484eb02e0c7711fefd5682e3232ff8">&#9670;&#160;</a></span>registerLocationSnapshot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLocationSnapshot </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01758">1758</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ad72cb69ce7683e91104cea66dc51414b" name="ad72cb69ce7683e91104cea66dc51414b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad72cb69ce7683e91104cea66dc51414b">&#9670;&#160;</a></span>registerLocationSnapshotPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLocationSnapshotPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01765">1765</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a1184a39f4795553b783a2a75e22cd793" name="a1184a39f4795553b783a2a75e22cd793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1184a39f4795553b783a2a75e22cd793">&#9670;&#160;</a></span>registerLoopInvariantCodeMotion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLoopInvariantCodeMotion </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01779">1779</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a35701f9efec5e981cbaf69333ccf8621" name="a35701f9efec5e981cbaf69333ccf8621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35701f9efec5e981cbaf69333ccf8621">&#9670;&#160;</a></span>registerLoopInvariantCodeMotionPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLoopInvariantCodeMotionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01786">1786</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ab6acd4737757d4aaad024fd4bb599de6" name="ab6acd4737757d4aaad024fd4bb599de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6acd4737757d4aaad024fd4bb599de6">&#9670;&#160;</a></span>registerLoopInvariantSubsetHoisting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLoopInvariantSubsetHoisting </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01800">1800</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a07926685868dde44533a673f3d0aea70" name="a07926685868dde44533a673f3d0aea70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07926685868dde44533a673f3d0aea70">&#9670;&#160;</a></span>registerLoopInvariantSubsetHoistingPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLoopInvariantSubsetHoistingPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01807">1807</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ae61157414c88115eadab54125624e489" name="ae61157414c88115eadab54125624e489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61157414c88115eadab54125624e489">&#9670;&#160;</a></span>registerLowerAffinePass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLowerAffinePass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08611">8611</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a983602355d61e58201f7a5285591023f" name="a983602355d61e58201f7a5285591023f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a983602355d61e58201f7a5285591023f">&#9670;&#160;</a></span>registerLowerAffinePassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLowerAffinePassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08618">8618</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a49b63d76c793afa7b98fdb476dbcdd4f" name="a49b63d76c793afa7b98fdb476dbcdd4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b63d76c793afa7b98fdb476dbcdd4f">&#9670;&#160;</a></span>registerLowerForeachToSCF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLowerForeachToSCF </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01257">1257</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a210ead914f04a46c7e6a86074f1ca5d8" name="a210ead914f04a46c7e6a86074f1ca5d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210ead914f04a46c7e6a86074f1ca5d8">&#9670;&#160;</a></span>registerLowerForeachToSCFPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLowerForeachToSCFPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01264">1264</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a6eb139f97446e699b0d348b936414c7d" name="a6eb139f97446e699b0d348b936414c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb139f97446e699b0d348b936414c7d">&#9670;&#160;</a></span>registerLowerHostCodeToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLowerHostCodeToLLVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08632">8632</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a3a7ad7fb79e045b2b624696b1c2af1f6" name="a3a7ad7fb79e045b2b624696b1c2af1f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a7ad7fb79e045b2b624696b1c2af1f6">&#9670;&#160;</a></span>registerLowerHostCodeToLLVMPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLowerHostCodeToLLVMPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08639">8639</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="acb4ebdfa6c244c84da2d8f75bb7e2be2" name="acb4ebdfa6c244c84da2d8f75bb7e2be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb4ebdfa6c244c84da2d8f75bb7e2be2">&#9670;&#160;</a></span>registerLowerSparseIterationToSCF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLowerSparseIterationToSCF </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01278">1278</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a209751dcd4d78134d054f383f861d323" name="a209751dcd4d78134d054f383f861d323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a209751dcd4d78134d054f383f861d323">&#9670;&#160;</a></span>registerLowerSparseIterationToSCFPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLowerSparseIterationToSCFPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01285">1285</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ae4b51f56ea70dae66a8cc1ece74f90a6" name="ae4b51f56ea70dae66a8cc1ece74f90a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b51f56ea70dae66a8cc1ece74f90a6">&#9670;&#160;</a></span>registerLowerSparseOpsToForeach()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLowerSparseOpsToForeach </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01299">1299</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="adf27a0b1b44bbe0369b3a37db64efb67" name="adf27a0b1b44bbe0369b3a37db64efb67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf27a0b1b44bbe0369b3a37db64efb67">&#9670;&#160;</a></span>registerLowerSparseOpsToForeachPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLowerSparseOpsToForeachPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01306">1306</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a69cd02c9adb6f20ea81d2eb2040a303d" name="a69cd02c9adb6f20ea81d2eb2040a303d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69cd02c9adb6f20ea81d2eb2040a303d">&#9670;&#160;</a></span>registerMapMemRefStorageClass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerMapMemRefStorageClass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08653">8653</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a9351f27a62f3b696c923d394281a2d73" name="a9351f27a62f3b696c923d394281a2d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9351f27a62f3b696c923d394281a2d73">&#9670;&#160;</a></span>registerMapMemRefStorageClassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerMapMemRefStorageClassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08660">8660</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="ab0e9d2be26bac7f415719ce5aa38ae65" name="ab0e9d2be26bac7f415719ce5aa38ae65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e9d2be26bac7f415719ce5aa38ae65">&#9670;&#160;</a></span>registerMem2Reg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerMem2Reg </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01821">1821</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a736b18a1b20e48ece102cab1f77899a5" name="a736b18a1b20e48ece102cab1f77899a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736b18a1b20e48ece102cab1f77899a5">&#9670;&#160;</a></span>registerMem2RegPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerMem2RegPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01828">1828</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a5254079fbbd31a78a3430bff18df2d7c" name="a5254079fbbd31a78a3430bff18df2d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5254079fbbd31a78a3430bff18df2d7c">&#9670;&#160;</a></span>registerMLIRContextCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerMLIRContextCLOptions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a set of useful command-line options that can be used to configure various flags within the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a>. </p>
<p>These flags are used when constructing an MLIR context for initialization. </p>

<p class="definition">Definition at line <a class="el" href="MLIRContext_8cpp_source.html#l00088">88</a> of file <a class="el" href="MLIRContext_8cpp_source.html">MLIRContext.cpp</a>.</p>

<p class="reference">References <a class="el" href="DebugCounter_8cpp_source.html#l00040">clOptions</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00684">registerCLIOptions()</a>.</p>

</div>
</div>
<a id="af1579c7894e37d07a13ecee146c11684" name="af1579c7894e37d07a13ecee146c11684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1579c7894e37d07a13ecee146c11684">&#9670;&#160;</a></span>registerNVGPUPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerNVGPUPasses </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2NVGPU_2Transforms_2Passes_8h_source.html#l00103">103</a> of file <a class="el" href="Dialect_2NVGPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllPasses_8cpp_source.html#l00059">registerAllPasses()</a>.</p>

</div>
</div>
<a id="a59faf81890b27fbd773f3ae78f47a07b" name="a59faf81890b27fbd773f3ae78f47a07b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59faf81890b27fbd773f3ae78f47a07b">&#9670;&#160;</a></span>registerNVVMDialectImport() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerNVVMDialectImport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers the <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> dialect and its import from <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry. </p>

<p class="definition">Definition at line <a class="el" href="LLVMIRToNVVMTranslation_8cpp_source.html#l00087">87</a> of file <a class="el" href="LLVMIRToNVVMTranslation_8cpp_source.html">LLVMIRToNVVMTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00152">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00079">registerAllFromLLVMIRTranslations()</a>, and <a class="el" href="LLVMIRToNVVMTranslation_8cpp_source.html#l00094">registerNVVMDialectImport()</a>.</p>

</div>
</div>
<a id="add91ee93d64f27e24f1d6e1856893c5b" name="add91ee93d64f27e24f1d6e1856893c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add91ee93d64f27e24f1d6e1856893c5b">&#9670;&#160;</a></span>registerNVVMDialectImport() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerNVVMDialectImport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers the <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> dialect and its import from <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR with the given context. </p>

<p class="definition">Definition at line <a class="el" href="LLVMIRToNVVMTranslation_8cpp_source.html#l00094">94</a> of file <a class="el" href="LLVMIRToNVVMTranslation_8cpp_source.html">LLVMIRToNVVMTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00416">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="LLVMIRToNVVMTranslation_8cpp_source.html#l00087">registerNVVMDialectImport()</a>.</p>

</div>
</div>
<a id="a2989267e0da323d644b3316b85b3942f" name="a2989267e0da323d644b3316b85b3942f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2989267e0da323d644b3316b85b3942f">&#9670;&#160;</a></span>registerNVVMDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerNVVMDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html#l00542">542</a> of file <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html">NVVMToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00152">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00063">registerAllGPUToLLVMIRTranslations()</a>, <a class="el" href="All_8h_source.html#l00039">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html#l00549">registerNVVMDialectTranslation()</a>.</p>

</div>
</div>
<a id="a00d03cc4e706acdb35969f4d4e78142a" name="a00d03cc4e706acdb35969f4d4e78142a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d03cc4e706acdb35969f4d4e78142a">&#9670;&#160;</a></span>registerNVVMDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerNVVMDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html#l00549">549</a> of file <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html">NVVMToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00416">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html#l00542">registerNVVMDialectTranslation()</a>.</p>

</div>
</div>
<a id="ae9bc345c5d25bda3847f7ddf6cebe9bc" name="ae9bc345c5d25bda3847f7ddf6cebe9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9bc345c5d25bda3847f7ddf6cebe9bc">&#9670;&#160;</a></span>registerOpenACCDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerOpenACCDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the OpenACC dialect and the translation to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00530">530</a> of file <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html">OpenACCToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00152">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00039">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00537">registerOpenACCDialectTranslation()</a>.</p>

</div>
</div>
<a id="a889d8518a5c67b981e76d27c9a256d86" name="a889d8518a5c67b981e76d27c9a256d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889d8518a5c67b981e76d27c9a256d86">&#9670;&#160;</a></span>registerOpenACCDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerOpenACCDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the OpenACC dialect and the translation in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00537">537</a> of file <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html">OpenACCToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00416">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00530">registerOpenACCDialectTranslation()</a>.</p>

</div>
</div>
<a id="a6ea20d97a32efd36c02468e54db4b2e7" name="a6ea20d97a32efd36c02468e54db4b2e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea20d97a32efd36c02468e54db4b2e7">&#9670;&#160;</a></span>registerOpenMPDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerOpenMPDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the OpenMP dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l06885">6885</a> of file <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html">OpenMPToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00152">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CAPI_2ExecutionEngine_2ExecutionEngine_8cpp_source.html#l00023">mlirExecutionEngineCreate()</a>, <a class="el" href="All_8h_source.html#l00039">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l06892">registerOpenMPDialectTranslation()</a>.</p>

</div>
</div>
<a id="aaa35b353841b70d090e1ead360536308" name="aaa35b353841b70d090e1ead360536308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa35b353841b70d090e1ead360536308">&#9670;&#160;</a></span>registerOpenMPDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerOpenMPDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the OpenMP dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l06892">6892</a> of file <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html">OpenMPToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00416">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l06885">registerOpenMPDialectTranslation()</a>.</p>

</div>
</div>
<a id="abd6614781b90ba9975948b3f328c4e69" name="abd6614781b90ba9975948b3f328c4e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd6614781b90ba9975948b3f328c4e69">&#9670;&#160;</a></span>registerOptimizeSharedMemory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerOptimizeSharedMemory </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2NVGPU_2Transforms_2Passes_8h_source.html#l00082">82</a> of file <a class="el" href="Dialect_2NVGPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="abc4ef7056aeaff3add219604c60fbaff" name="abc4ef7056aeaff3add219604c60fbaff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4ef7056aeaff3add219604c60fbaff">&#9670;&#160;</a></span>registerOptimizeSharedMemoryPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerOptimizeSharedMemoryPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2NVGPU_2Transforms_2Passes_8h_source.html#l00089">89</a> of file <a class="el" href="Dialect_2NVGPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ae18ecc9eaa414b5de74e7c8eb2eecea8" name="ae18ecc9eaa414b5de74e7c8eb2eecea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18ecc9eaa414b5de74e7c8eb2eecea8">&#9670;&#160;</a></span>registerOptReductionPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerOptReductionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Reducer_2Passes_8h_source.html#l00223">223</a> of file <a class="el" href="Reducer_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="acb4b3950c4cb51f6f4089625f2e5c76e" name="acb4b3950c4cb51f6f4089625f2e5c76e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb4b3950c4cb51f6f4089625f2e5c76e">&#9670;&#160;</a></span>registerOptReductionPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerOptReductionPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Reducer_2Passes_8h_source.html#l00230">230</a> of file <a class="el" href="Reducer_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a922b21fc4f546577a0c2ee3281095143" name="a922b21fc4f546577a0c2ee3281095143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a922b21fc4f546577a0c2ee3281095143">&#9670;&#160;</a></span>registerOutlineShapeComputationPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerOutlineShapeComputationPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Shape_2Transforms_2Passes_8h_source.html#l00248">248</a> of file <a class="el" href="Dialect_2Shape_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="aaf2646c4b6cf320953491cd8c72d1a15" name="aaf2646c4b6cf320953491cd8c72d1a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2646c4b6cf320953491cd8c72d1a15">&#9670;&#160;</a></span>registerOutlineShapeComputationPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerOutlineShapeComputationPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Shape_2Transforms_2Passes_8h_source.html#l00255">255</a> of file <a class="el" href="Dialect_2Shape_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a5a4626059212aef6f3aa5fa7088ce667" name="a5a4626059212aef6f3aa5fa7088ce667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a4626059212aef6f3aa5fa7088ce667">&#9670;&#160;</a></span>registerPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a13509926eab92d24bb5729fef49bdf37">PassAllocatorFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>function</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a specific dialect pass allocator function with the system, typically used through the <a class="el" href="structmlir_1_1PassRegistration.html" title="PassRegistration provides a global initializer that registers a Pass allocation routine for a concret...">PassRegistration</a> template. </p>

<p class="definition">Definition at line <a class="el" href="PassRegistry_8cpp_source.html#l00149">149</a> of file <a class="el" href="PassRegistry_8cpp_source.html">PassRegistry.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassRegistry_8cpp_source.html#l00027">passRegistry</a>, and <a class="el" href="PassRegistry_8cpp_source.html#l00031">passRegistryTypeIDs</a>.</p>

<p class="reference">Referenced by <a class="el" href="PassRegistry_8h_source.html#l00156">mlir::PassRegistration&lt; ConcretePass &gt;::PassRegistration()</a>.</p>

</div>
</div>
<a id="aa5c4edce10b597637635af55bb162477" name="aa5c4edce10b597637635af55bb162477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5c4edce10b597637635af55bb162477">&#9670;&#160;</a></span>registerPassManagerCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerPassManagerCLOptions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a set of useful command-line options that can be used to configure a pass manager. </p>
<p>The values of these options can be applied via the 'applyPassManagerCLOptions' method below. </p>

<p class="definition">Definition at line <a class="el" href="PassManagerOptions_8cpp_source.html#l00140">140</a> of file <a class="el" href="PassManagerOptions_8cpp_source.html">PassManagerOptions.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00684">registerCLIOptions()</a>.</p>

</div>
</div>
<a id="a83965c855ad737422194336251348893" name="a83965c855ad737422194336251348893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83965c855ad737422194336251348893">&#9670;&#160;</a></span>registerPassPipeline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerPassPipeline </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>description</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a1eb8eb86939076c1bf86f544e23aef0e">PassRegistryFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>function</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(const <a class="el" href="classmlir_1_1detail_1_1PassOptions.html">detail::PassOptions</a> &amp;)&gt;)&gt;</td>          <td class="paramname"><span class="paramname"><em>optHandler</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a specific dialect pipeline registry function with the system, typically used through the <a class="el" href="structmlir_1_1PassPipelineRegistration.html" title="PassPipelineRegistration provides a global initializer that registers a Pass pipeline builder routine...">PassPipelineRegistration</a> template. </p>

<p class="reference">Referenced by <a class="el" href="PassRegistry_8h_source.html#l00178">mlir::PassPipelineRegistration&lt; Options &gt;::PassPipelineRegistration()</a>, and <a class="el" href="PassRegistry_8h_source.html#l00201">mlir::PassPipelineRegistration&lt; EmptyPipelineOptions &gt;::PassPipelineRegistration()</a>.</p>

</div>
</div>
<a id="a934661b51fd450e3ad6bb883dd709789" name="a934661b51fd450e3ad6bb883dd709789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a934661b51fd450e3ad6bb883dd709789">&#9670;&#160;</a></span>registerPreSparsificationRewrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerPreSparsificationRewrite </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01320">1320</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a7548e3512a8da14739ee2c8d113e992a" name="a7548e3512a8da14739ee2c8d113e992a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7548e3512a8da14739ee2c8d113e992a">&#9670;&#160;</a></span>registerPreSparsificationRewritePass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerPreSparsificationRewritePass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01327">1327</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="afb2317027118b46ca06fcb6b08158b0f" name="afb2317027118b46ca06fcb6b08158b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb2317027118b46ca06fcb6b08158b0f">&#9670;&#160;</a></span>registerPrintIRPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerPrintIRPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01842">1842</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="aa1b19a9a0a3d9cd01589ac1dc43fde36" name="aa1b19a9a0a3d9cd01589ac1dc43fde36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b19a9a0a3d9cd01589ac1dc43fde36">&#9670;&#160;</a></span>registerPrintIRPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerPrintIRPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01849">1849</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a6301f8a4ec9e21048723738a66702473" name="a6301f8a4ec9e21048723738a66702473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6301f8a4ec9e21048723738a66702473">&#9670;&#160;</a></span>registerPrintOpStats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerPrintOpStats </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01863">1863</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a341326afd173f52f0673fe2a6b6a0dba" name="a341326afd173f52f0673fe2a6b6a0dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341326afd173f52f0673fe2a6b6a0dba">&#9670;&#160;</a></span>registerPrintOpStatsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerPrintOpStatsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01870">1870</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a254a9153445a5c111b6eeb35feed7050" name="a254a9153445a5c111b6eeb35feed7050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254a9153445a5c111b6eeb35feed7050">&#9670;&#160;</a></span>registerPtrDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerPtrDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the <span class="tt">ptr</span> dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="PtrToLLVMIRTranslation_8cpp_source.html#l00454">454</a> of file <a class="el" href="PtrToLLVMIRTranslation_8cpp_source.html">PtrToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00152">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00039">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="PtrToLLVMIRTranslation_8cpp_source.html#l00461">registerPtrDialectTranslation()</a>.</p>

</div>
</div>
<a id="a453be5718dbda2042925e4e7076c9d91" name="a453be5718dbda2042925e4e7076c9d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453be5718dbda2042925e4e7076c9d91">&#9670;&#160;</a></span>registerPtrDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerPtrDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the <span class="tt">ptr</span> dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="PtrToLLVMIRTranslation_8cpp_source.html#l00461">461</a> of file <a class="el" href="PtrToLLVMIRTranslation_8cpp_source.html">PtrToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00416">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="PtrToLLVMIRTranslation_8cpp_source.html#l00454">registerPtrDialectTranslation()</a>.</p>

</div>
</div>
<a id="a51b56078ab20126d7494d9cb3253bf99" name="a51b56078ab20126d7494d9cb3253bf99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51b56078ab20126d7494d9cb3253bf99">&#9670;&#160;</a></span>registerReconcileUnrealizedCastsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerReconcileUnrealizedCastsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08674">8674</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="aee2d165dc396c1fbf281924660297755" name="aee2d165dc396c1fbf281924660297755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee2d165dc396c1fbf281924660297755">&#9670;&#160;</a></span>registerReconcileUnrealizedCastsPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerReconcileUnrealizedCastsPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08681">8681</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="af871dbe2d47c7f6da2d9e40ad12065e2" name="af871dbe2d47c7f6da2d9e40ad12065e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af871dbe2d47c7f6da2d9e40ad12065e2">&#9670;&#160;</a></span>registerReducerPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerReducerPasses </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Reducer_2Passes_8h_source.html#l00265">265</a> of file <a class="el" href="Reducer_2Passes_8h_source.html">Passes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirReduceMain_8cpp_source.html#l00045">mlirReduceMain()</a>.</p>

</div>
</div>
<a id="ad6f16e0db4eded0cefae0e63db471b32" name="ad6f16e0db4eded0cefae0e63db471b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f16e0db4eded0cefae0e63db471b32">&#9670;&#160;</a></span>registerReductionTreePass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerReductionTreePass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Reducer_2Passes_8h_source.html#l00244">244</a> of file <a class="el" href="Reducer_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a892a8e3becb55d2f56f877d4df851435" name="a892a8e3becb55d2f56f877d4df851435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892a8e3becb55d2f56f877d4df851435">&#9670;&#160;</a></span>registerReductionTreePassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerReductionTreePassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Reducer_2Passes_8h_source.html#l00251">251</a> of file <a class="el" href="Reducer_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ab5572eb7b4b9b8c4a269d29446f492fe" name="ab5572eb7b4b9b8c4a269d29446f492fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5572eb7b4b9b8c4a269d29446f492fe">&#9670;&#160;</a></span>registerRemoveDeadValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerRemoveDeadValues </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01884">1884</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a2b0c904754b8ce6c0c38b7a688a306a9" name="a2b0c904754b8ce6c0c38b7a688a306a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0c904754b8ce6c0c38b7a688a306a9">&#9670;&#160;</a></span>registerRemoveDeadValuesPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerRemoveDeadValuesPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01891">1891</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a7d2c5affc0233b165876f802918807df" name="a7d2c5affc0233b165876f802918807df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d2c5affc0233b165876f802918807df">&#9670;&#160;</a></span>registerRemoveShapeConstraintsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerRemoveShapeConstraintsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Shape_2Transforms_2Passes_8h_source.html#l00269">269</a> of file <a class="el" href="Dialect_2Shape_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a4627ca3894a6af8f55b220c3197dd4cc" name="a4627ca3894a6af8f55b220c3197dd4cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4627ca3894a6af8f55b220c3197dd4cc">&#9670;&#160;</a></span>registerRemoveShapeConstraintsPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerRemoveShapeConstraintsPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Shape_2Transforms_2Passes_8h_source.html#l00276">276</a> of file <a class="el" href="Dialect_2Shape_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ab895c88d57833ccee805eb3233c04ca6" name="ab895c88d57833ccee805eb3233c04ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab895c88d57833ccee805eb3233c04ca6">&#9670;&#160;</a></span>registerROCDLDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerROCDLDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html#l00243">243</a> of file <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html">ROCDLToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00152">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00063">registerAllGPUToLLVMIRTranslations()</a>, <a class="el" href="All_8h_source.html#l00039">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html#l00250">registerROCDLDialectTranslation()</a>.</p>

</div>
</div>
<a id="a4e522221c6652cb1450a6a3803125534" name="a4e522221c6652cb1450a6a3803125534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e522221c6652cb1450a6a3803125534">&#9670;&#160;</a></span>registerROCDLDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerROCDLDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html#l00250">250</a> of file <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html">ROCDLToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00416">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html#l00243">registerROCDLDialectTranslation()</a>.</p>

</div>
</div>
<a id="ae1aada75389e4d473a32b3e4175465eb" name="ae1aada75389e4d473a32b3e4175465eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1aada75389e4d473a32b3e4175465eb">&#9670;&#160;</a></span>registerSCCP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSCCP </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01905">1905</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a128bb4a336733aa44c305996e74b0b90" name="a128bb4a336733aa44c305996e74b0b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128bb4a336733aa44c305996e74b0b90">&#9670;&#160;</a></span>registerSCCPPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSCCPPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01912">1912</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ae8a31b1d85694dcc98a2370343ff5fa9" name="ae8a31b1d85694dcc98a2370343ff5fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a31b1d85694dcc98a2370343ff5fa9">&#9670;&#160;</a></span>registerSCFForallToForLoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSCFForallToForLoop </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html#l00925">925</a> of file <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="aa5e7e0cb99e9a2740dd6b1c7c56809ca" name="aa5e7e0cb99e9a2740dd6b1c7c56809ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e7e0cb99e9a2740dd6b1c7c56809ca">&#9670;&#160;</a></span>registerSCFForallToForLoopPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSCFForallToForLoopPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html#l00932">932</a> of file <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a073f93d96bed67d0e4890a0077cf5793" name="a073f93d96bed67d0e4890a0077cf5793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a073f93d96bed67d0e4890a0077cf5793">&#9670;&#160;</a></span>registerSCFForallToParallelLoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSCFForallToParallelLoop </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html#l00946">946</a> of file <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ae4d8310fbd00eff214b17b9eb7e72939" name="ae4d8310fbd00eff214b17b9eb7e72939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4d8310fbd00eff214b17b9eb7e72939">&#9670;&#160;</a></span>registerSCFForallToParallelLoopPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSCFForallToParallelLoopPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html#l00953">953</a> of file <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a0d9d102b1cf61a0c8373bac876739e10" name="a0d9d102b1cf61a0c8373bac876739e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9d102b1cf61a0c8373bac876739e10">&#9670;&#160;</a></span>registerSCFForLoopCanonicalization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSCFForLoopCanonicalization </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html#l00820">820</a> of file <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a8fa20d05891b8adc460c6f3160578785" name="a8fa20d05891b8adc460c6f3160578785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa20d05891b8adc460c6f3160578785">&#9670;&#160;</a></span>registerSCFForLoopCanonicalizationPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSCFForLoopCanonicalizationPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html#l00827">827</a> of file <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ae60d323af2bfd4d8dc4ceace5350e9d4" name="ae60d323af2bfd4d8dc4ceace5350e9d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae60d323af2bfd4d8dc4ceace5350e9d4">&#9670;&#160;</a></span>registerSCFForLoopPeeling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSCFForLoopPeeling </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html#l00841">841</a> of file <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ae05f737ea5c496f87b892e56101819b4" name="ae05f737ea5c496f87b892e56101819b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae05f737ea5c496f87b892e56101819b4">&#9670;&#160;</a></span>registerSCFForLoopPeelingPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSCFForLoopPeelingPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html#l00848">848</a> of file <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ae48b20fbd65e6c82e51eab983deabfd4" name="ae48b20fbd65e6c82e51eab983deabfd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48b20fbd65e6c82e51eab983deabfd4">&#9670;&#160;</a></span>registerSCFForLoopRangeFolding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSCFForLoopRangeFolding </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html#l00862">862</a> of file <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a781dea335ee3dddc1b0a0d1010b2954b" name="a781dea335ee3dddc1b0a0d1010b2954b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781dea335ee3dddc1b0a0d1010b2954b">&#9670;&#160;</a></span>registerSCFForLoopRangeFoldingPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSCFForLoopRangeFoldingPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html#l00869">869</a> of file <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a175bdd2cba15cbe9b5ae4f1511f95005" name="a175bdd2cba15cbe9b5ae4f1511f95005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a175bdd2cba15cbe9b5ae4f1511f95005">&#9670;&#160;</a></span>registerSCFForLoopSpecialization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSCFForLoopSpecialization </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html#l00883">883</a> of file <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="af01f309dc55105cc7cb89c04a99ec517" name="af01f309dc55105cc7cb89c04a99ec517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01f309dc55105cc7cb89c04a99ec517">&#9670;&#160;</a></span>registerSCFForLoopSpecializationPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSCFForLoopSpecializationPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html#l00890">890</a> of file <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a7632bd6ba19210acd438a29abc3a8b80" name="a7632bd6ba19210acd438a29abc3a8b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7632bd6ba19210acd438a29abc3a8b80">&#9670;&#160;</a></span>registerSCFForToWhileLoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSCFForToWhileLoop </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html#l00904">904</a> of file <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a210bc59e2fb78571dc549020d25f8c58" name="a210bc59e2fb78571dc549020d25f8c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210bc59e2fb78571dc549020d25f8c58">&#9670;&#160;</a></span>registerSCFForToWhileLoopPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSCFForToWhileLoopPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html#l00911">911</a> of file <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ae5bdcd72d469ee14ae52a624c1e9a4ae" name="ae5bdcd72d469ee14ae52a624c1e9a4ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5bdcd72d469ee14ae52a624c1e9a4ae">&#9670;&#160;</a></span>registerSCFParallelForToNestedFors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSCFParallelForToNestedFors </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html#l00967">967</a> of file <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a8dd8a6c3de4888fe2aebf82713092ffc" name="a8dd8a6c3de4888fe2aebf82713092ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd8a6c3de4888fe2aebf82713092ffc">&#9670;&#160;</a></span>registerSCFParallelForToNestedForsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSCFParallelForToNestedForsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html#l00974">974</a> of file <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a3f8089e9e69cbb2bcccf582c01fbb043" name="a3f8089e9e69cbb2bcccf582c01fbb043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f8089e9e69cbb2bcccf582c01fbb043">&#9670;&#160;</a></span>registerSCFParallelLoopFusion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSCFParallelLoopFusion </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html#l00988">988</a> of file <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a0afa0da149b2bfffc5247ecdc12173b6" name="a0afa0da149b2bfffc5247ecdc12173b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0afa0da149b2bfffc5247ecdc12173b6">&#9670;&#160;</a></span>registerSCFParallelLoopFusionPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSCFParallelLoopFusionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html#l00995">995</a> of file <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="af3323eec9f185bca0f00410dd380ad8c" name="af3323eec9f185bca0f00410dd380ad8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3323eec9f185bca0f00410dd380ad8c">&#9670;&#160;</a></span>registerSCFParallelLoopSpecialization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSCFParallelLoopSpecialization </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html#l01009">1009</a> of file <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a38e7bcbd42c865c8c9df909e02d943b8" name="a38e7bcbd42c865c8c9df909e02d943b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e7bcbd42c865c8c9df909e02d943b8">&#9670;&#160;</a></span>registerSCFParallelLoopSpecializationPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSCFParallelLoopSpecializationPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html#l01016">1016</a> of file <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ad8c9e163a0ff724a6edf0bf8a4fd5d5c" name="ad8c9e163a0ff724a6edf0bf8a4fd5d5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c9e163a0ff724a6edf0bf8a4fd5d5c">&#9670;&#160;</a></span>registerSCFParallelLoopTiling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSCFParallelLoopTiling </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html#l01030">1030</a> of file <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ad01077d65b3faa30d54b09c8f8ddea87" name="ad01077d65b3faa30d54b09c8f8ddea87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01077d65b3faa30d54b09c8f8ddea87">&#9670;&#160;</a></span>registerSCFParallelLoopTilingPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSCFParallelLoopTilingPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html#l01037">1037</a> of file <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a3ae34ac202bc7c305171a425b1be26de" name="a3ae34ac202bc7c305171a425b1be26de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae34ac202bc7c305171a425b1be26de">&#9670;&#160;</a></span>registerSCFPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSCFPasses </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html#l01072">1072</a> of file <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllPasses_8cpp_source.html#l00059">registerAllPasses()</a>.</p>

</div>
</div>
<a id="ae945c21b80b9190f9f3f850f41f5f14e" name="ae945c21b80b9190f9f3f850f41f5f14e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae945c21b80b9190f9f3f850f41f5f14e">&#9670;&#160;</a></span>registerSCFToControlFlowPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSCFToControlFlowPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08695">8695</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a944419934975e4300d1695f67c73c047" name="a944419934975e4300d1695f67c73c047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944419934975e4300d1695f67c73c047">&#9670;&#160;</a></span>registerSCFToControlFlowPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSCFToControlFlowPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08702">8702</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a34938d52c0c48307739e60d76aa7b614" name="a34938d52c0c48307739e60d76aa7b614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34938d52c0c48307739e60d76aa7b614">&#9670;&#160;</a></span>registerSCFToEmitC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSCFToEmitC </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08716">8716</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="ad6df13af469a80f6506a82f581b07001" name="ad6df13af469a80f6506a82f581b07001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6df13af469a80f6506a82f581b07001">&#9670;&#160;</a></span>registerSCFToEmitCPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSCFToEmitCPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08723">8723</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a3b0c54a3034fdf9257f7c63d8e2ddc07" name="a3b0c54a3034fdf9257f7c63d8e2ddc07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0c54a3034fdf9257f7c63d8e2ddc07">&#9670;&#160;</a></span>registerSCFToSPIRV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSCFToSPIRV </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08737">8737</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a9fe51fa1f6536e02502fb6aa6c777598" name="a9fe51fa1f6536e02502fb6aa6c777598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe51fa1f6536e02502fb6aa6c777598">&#9670;&#160;</a></span>registerSCFToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSCFToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08744">8744</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a3922ea8af887e683fe8537c3b41ae929" name="a3922ea8af887e683fe8537c3b41ae929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3922ea8af887e683fe8537c3b41ae929">&#9670;&#160;</a></span>registerSetLLVMModuleDataLayoutPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSetLLVMModuleDataLayoutPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08758">8758</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a29f6610cbedfe3730853c8105ba6151c" name="a29f6610cbedfe3730853c8105ba6151c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f6610cbedfe3730853c8105ba6151c">&#9670;&#160;</a></span>registerSetLLVMModuleDataLayoutPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSetLLVMModuleDataLayoutPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08765">8765</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="ae6cb2b4fddca0abf12bdbb4c774f349b" name="ae6cb2b4fddca0abf12bdbb4c774f349b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6cb2b4fddca0abf12bdbb4c774f349b">&#9670;&#160;</a></span>registerShapePasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerShapePasses </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Shape_2Transforms_2Passes_8h_source.html#l00311">311</a> of file <a class="el" href="Dialect_2Shape_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllPasses_8cpp_source.html#l00059">registerAllPasses()</a>.</p>

</div>
</div>
<a id="a4b32eb2464cc8a75d1db1e43b07db4aa" name="a4b32eb2464cc8a75d1db1e43b07db4aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b32eb2464cc8a75d1db1e43b07db4aa">&#9670;&#160;</a></span>registerShapeToShapeLoweringPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerShapeToShapeLoweringPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Shape_2Transforms_2Passes_8h_source.html#l00290">290</a> of file <a class="el" href="Dialect_2Shape_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="aa934e0ae0a2fc73da99e0cf3d871f1df" name="aa934e0ae0a2fc73da99e0cf3d871f1df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa934e0ae0a2fc73da99e0cf3d871f1df">&#9670;&#160;</a></span>registerShapeToShapeLoweringPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerShapeToShapeLoweringPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Shape_2Transforms_2Passes_8h_source.html#l00297">297</a> of file <a class="el" href="Dialect_2Shape_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a2fe7d936e0bd6b4954e0222c7dcc5f38" name="a2fe7d936e0bd6b4954e0222c7dcc5f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe7d936e0bd6b4954e0222c7dcc5f38">&#9670;&#160;</a></span>registerSimplifyDepthwiseConvPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSimplifyDepthwiseConvPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html#l01492">1492</a> of file <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a0e98d77e4a33c454d1c4c75857efa3a5" name="a0e98d77e4a33c454d1c4c75857efa3a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e98d77e4a33c454d1c4c75857efa3a5">&#9670;&#160;</a></span>registerSimplifyDepthwiseConvPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSimplifyDepthwiseConvPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html#l01499">1499</a> of file <a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a6183051415ba8e8aba515e37d885d8ba" name="a6183051415ba8e8aba515e37d885d8ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6183051415ba8e8aba515e37d885d8ba">&#9670;&#160;</a></span>registerSparseAssembler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSparseAssembler </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01341">1341</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ad1ec42768e9620fbc3faf3d78971fc6b" name="ad1ec42768e9620fbc3faf3d78971fc6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ec42768e9620fbc3faf3d78971fc6b">&#9670;&#160;</a></span>registerSparseAssemblerPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSparseAssemblerPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01348">1348</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a6f15b8670b123dce36fb07f80e0f05a7" name="a6f15b8670b123dce36fb07f80e0f05a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f15b8670b123dce36fb07f80e0f05a7">&#9670;&#160;</a></span>registerSparseBufferRewrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSparseBufferRewrite </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01362">1362</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a9b3ca94a2b794e37ccec8c493163345c" name="a9b3ca94a2b794e37ccec8c493163345c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b3ca94a2b794e37ccec8c493163345c">&#9670;&#160;</a></span>registerSparseBufferRewritePass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSparseBufferRewritePass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01369">1369</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a69d15be700aa8382b29b58dd0c5c86ca" name="a69d15be700aa8382b29b58dd0c5c86ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d15be700aa8382b29b58dd0c5c86ca">&#9670;&#160;</a></span>registerSparseGPUCodegen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSparseGPUCodegen </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01383">1383</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a1158082f4a56bba72317752a1869bba4" name="a1158082f4a56bba72317752a1869bba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1158082f4a56bba72317752a1869bba4">&#9670;&#160;</a></span>registerSparseGPUCodegenPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSparseGPUCodegenPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01390">1390</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a5c014df7aff145788ec7255c3a014fd5" name="a5c014df7aff145788ec7255c3a014fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c014df7aff145788ec7255c3a014fd5">&#9670;&#160;</a></span>registerSparseReinterpretMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSparseReinterpretMap </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01404">1404</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a40b83f3b7db1bc8c563133ea40e1e271" name="a40b83f3b7db1bc8c563133ea40e1e271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b83f3b7db1bc8c563133ea40e1e271">&#9670;&#160;</a></span>registerSparseReinterpretMapPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSparseReinterpretMapPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01411">1411</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a5d41535cdc30434df761304d60543028" name="a5d41535cdc30434df761304d60543028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d41535cdc30434df761304d60543028">&#9670;&#160;</a></span>registerSparseSpaceCollapse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSparseSpaceCollapse </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01425">1425</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a45ee41d6e54aea82f314c435144cc13d" name="a45ee41d6e54aea82f314c435144cc13d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ee41d6e54aea82f314c435144cc13d">&#9670;&#160;</a></span>registerSparseSpaceCollapsePass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSparseSpaceCollapsePass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01432">1432</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a7ef8aea2f01115612037875d2f283647" name="a7ef8aea2f01115612037875d2f283647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef8aea2f01115612037875d2f283647">&#9670;&#160;</a></span>registerSparseTensorCodegen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSparseTensorCodegen </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01446">1446</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a973d0cb845cabe7b1db4ff8166041196" name="a973d0cb845cabe7b1db4ff8166041196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a973d0cb845cabe7b1db4ff8166041196">&#9670;&#160;</a></span>registerSparseTensorCodegenPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSparseTensorCodegenPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01453">1453</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="afbb860e1972525881da72170adf4398a" name="afbb860e1972525881da72170adf4398a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb860e1972525881da72170adf4398a">&#9670;&#160;</a></span>registerSparseTensorConversionPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSparseTensorConversionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01467">1467</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a57f3586e55dbbdb9608b84f92d2efb27" name="a57f3586e55dbbdb9608b84f92d2efb27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f3586e55dbbdb9608b84f92d2efb27">&#9670;&#160;</a></span>registerSparseTensorConversionPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSparseTensorConversionPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01474">1474</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a0019f87f0182bf0d7455f7b47ce5f1bc" name="a0019f87f0182bf0d7455f7b47ce5f1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0019f87f0182bf0d7455f7b47ce5f1bc">&#9670;&#160;</a></span>registerSparseTensorPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSparseTensorPasses </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01593">1593</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllPasses_8cpp_source.html#l00059">registerAllPasses()</a>.</p>

</div>
</div>
<a id="a224c635adefbfd082b51339b59dae7c0" name="a224c635adefbfd082b51339b59dae7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224c635adefbfd082b51339b59dae7c0">&#9670;&#160;</a></span>registerSparseVectorization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSparseVectorization </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01488">1488</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="aa373f3a1f0c8313868741af7ea32a5c5" name="aa373f3a1f0c8313868741af7ea32a5c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa373f3a1f0c8313868741af7ea32a5c5">&#9670;&#160;</a></span>registerSparseVectorizationPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSparseVectorizationPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01495">1495</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a506d52d361e0a1275a7761eb403bbd85" name="a506d52d361e0a1275a7761eb403bbd85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a506d52d361e0a1275a7761eb403bbd85">&#9670;&#160;</a></span>registerSparsificationAndBufferization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSparsificationAndBufferization </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01509">1509</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a4a812d6e57454d1d0caef811d3c46c6e" name="a4a812d6e57454d1d0caef811d3c46c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a812d6e57454d1d0caef811d3c46c6e">&#9670;&#160;</a></span>registerSparsificationAndBufferizationPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSparsificationAndBufferizationPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01516">1516</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ae3b3b3c1aba6d4dfa4da45a1bb7bf398" name="ae3b3b3c1aba6d4dfa4da45a1bb7bf398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3b3b3c1aba6d4dfa4da45a1bb7bf398">&#9670;&#160;</a></span>registerSparsificationPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSparsificationPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01530">1530</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ac1ff078a407f63aaf674e1909afb5741" name="ac1ff078a407f63aaf674e1909afb5741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ff078a407f63aaf674e1909afb5741">&#9670;&#160;</a></span>registerSparsificationPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSparsificationPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01537">1537</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ad6971e37634f3b392e868dc60aefab9a" name="ad6971e37634f3b392e868dc60aefab9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6971e37634f3b392e868dc60aefab9a">&#9670;&#160;</a></span>registerSPIRVDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSPIRVDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the SPIR-V dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVToLLVMIRTranslation_8cpp_source.html#l00021">21</a> of file <a class="el" href="SPIRVToLLVMIRTranslation_8cpp_source.html">SPIRVToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00152">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00063">registerAllGPUToLLVMIRTranslations()</a>, <a class="el" href="All_8h_source.html#l00039">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="SPIRVToLLVMIRTranslation_8cpp_source.html#l00025">registerSPIRVDialectTranslation()</a>.</p>

</div>
</div>
<a id="a74395e0d79520f9e47d1467c7d4dcb25" name="a74395e0d79520f9e47d1467c7d4dcb25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74395e0d79520f9e47d1467c7d4dcb25">&#9670;&#160;</a></span>registerSPIRVDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSPIRVDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the SPIR-V dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVToLLVMIRTranslation_8cpp_source.html#l00025">25</a> of file <a class="el" href="SPIRVToLLVMIRTranslation_8cpp_source.html">SPIRVToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00416">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="SPIRVToLLVMIRTranslation_8cpp_source.html#l00021">registerSPIRVDialectTranslation()</a>.</p>

</div>
</div>
<a id="a62c66c897aff4ca94aba5db2244a2f54" name="a62c66c897aff4ca94aba5db2244a2f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62c66c897aff4ca94aba5db2244a2f54">&#9670;&#160;</a></span>registerSROA()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSROA </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01926">1926</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="af469192db553aad94693e1a61f57ec3c" name="af469192db553aad94693e1a61f57ec3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af469192db553aad94693e1a61f57ec3c">&#9670;&#160;</a></span>registerSROAPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSROAPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01933">1933</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ad460042feb741008a5a4578a56bd5702" name="ad460042feb741008a5a4578a56bd5702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad460042feb741008a5a4578a56bd5702">&#9670;&#160;</a></span>registerStageSparseOperations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerStageSparseOperations </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01551">1551</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a67b15607425b4cead1760537e5d40402" name="a67b15607425b4cead1760537e5d40402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67b15607425b4cead1760537e5d40402">&#9670;&#160;</a></span>registerStageSparseOperationsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerStageSparseOperationsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01558">1558</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a7ce9edd7c2427054d9e28ec7ddd480a6" name="a7ce9edd7c2427054d9e28ec7ddd480a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ce9edd7c2427054d9e28ec7ddd480a6">&#9670;&#160;</a></span>registerStorageSpecifierToLLVM()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerStorageSpecifierToLLVM </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01572">1572</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a3bd20fe234baec1d1ed83c3f4eda4829" name="a3bd20fe234baec1d1ed83c3f4eda4829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bd20fe234baec1d1ed83c3f4eda4829">&#9670;&#160;</a></span>registerStorageSpecifierToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerStorageSpecifierToLLVMPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l01579">1579</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ae1141fa3cd9876e6ae1c7d67ded257af" name="ae1141fa3cd9876e6ae1c7d67ded257af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1141fa3cd9876e6ae1c7d67ded257af">&#9670;&#160;</a></span>registerStripDebugInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerStripDebugInfo </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01947">1947</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a768914db327de87f19a87905f293cf80" name="a768914db327de87f19a87905f293cf80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a768914db327de87f19a87905f293cf80">&#9670;&#160;</a></span>registerStripDebugInfoPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerStripDebugInfoPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01954">1954</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a5d32ff1beeedc06a000e7cac2370aa7a" name="a5d32ff1beeedc06a000e7cac2370aa7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d32ff1beeedc06a000e7cac2370aa7a">&#9670;&#160;</a></span>registerSymbolDCE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSymbolDCE </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01968">1968</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a0e46bdac75c47d0c236e2731c40ba227" name="a0e46bdac75c47d0c236e2731c40ba227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e46bdac75c47d0c236e2731c40ba227">&#9670;&#160;</a></span>registerSymbolDCEPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSymbolDCEPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01975">1975</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a24d9ebd0dd67c407135fcaff3f125c86" name="a24d9ebd0dd67c407135fcaff3f125c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d9ebd0dd67c407135fcaff3f125c86">&#9670;&#160;</a></span>registerSymbolPrivatize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSymbolPrivatize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01989">1989</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a1052b12c0656e19b1fed04b73bb17113" name="a1052b12c0656e19b1fed04b73bb17113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1052b12c0656e19b1fed04b73bb17113">&#9670;&#160;</a></span>registerSymbolPrivatizePass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerSymbolPrivatizePass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l01996">1996</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a9ed913befc935e3b4b3e622838655b30" name="a9ed913befc935e3b4b3e622838655b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed913befc935e3b4b3e622838655b30">&#9670;&#160;</a></span>registerTestRoundtripDebugSPIRV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerTestRoundtripDebugSPIRV </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00188">188</a> of file <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html">TranslateRegistration.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00153">roundTripModule()</a>.</p>

</div>
</div>
<a id="a2b336390b16983a364b2d95bd2a64a2f" name="a2b336390b16983a364b2d95bd2a64a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b336390b16983a364b2d95bd2a64a2f">&#9670;&#160;</a></span>registerTestRoundtripSPIRV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerTestRoundtripSPIRV </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00177">177</a> of file <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html">TranslateRegistration.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00153">roundTripModule()</a>.</p>

</div>
</div>
<a id="a637857dee65c32d3b3a6244bd7613856" name="a637857dee65c32d3b3a6244bd7613856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a637857dee65c32d3b3a6244bd7613856">&#9670;&#160;</a></span>registerTestSCFParallelLoopCollapsing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerTestSCFParallelLoopCollapsing </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html#l01051">1051</a> of file <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a786bcf3d1d600e1578e33313dcb6058c" name="a786bcf3d1d600e1578e33313dcb6058c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a786bcf3d1d600e1578e33313dcb6058c">&#9670;&#160;</a></span>registerTestSCFParallelLoopCollapsingPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerTestSCFParallelLoopCollapsingPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html#l01058">1058</a> of file <a class="el" href="Dialect_2SCF_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a520bc0aa5f34c15a39f2202fdf521382" name="a520bc0aa5f34c15a39f2202fdf521382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a520bc0aa5f34c15a39f2202fdf521382">&#9670;&#160;</a></span>registerToCppTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerToCppTranslation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Cpp_2TranslateRegistration_8cpp_source.html#l00024">24</a> of file <a class="el" href="Cpp_2TranslateRegistration_8cpp_source.html">TranslateRegistration.cpp</a>.</p>

<p class="reference">References <a class="el" href="TranslateToCpp_8cpp_source.html#l01973">mlir::emitc::translateToCpp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllTranslations_8h_source.html#l00035">registerAllTranslations()</a>.</p>

</div>
</div>
<a id="a003d72c96a8bffacc207ba165212e2db" name="a003d72c96a8bffacc207ba165212e2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a003d72c96a8bffacc207ba165212e2db">&#9670;&#160;</a></span>registerToLLVMIRTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerToLLVMIRTranslation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertToLLVMIR_8cpp_source.html#l00025">25</a> of file <a class="el" href="ConvertToLLVMIR_8cpp_source.html">ConvertToLLVMIR.cpp</a>.</p>

<p class="reference">References <a class="el" href="All_8h_source.html#l00039">registerAllToLLVMIRTranslations()</a>, <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, and <a class="el" href="#a4eef291fcf02aee4a7125d0c6420fdad">translateModuleToLLVMIR()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllTranslations_8h_source.html#l00035">registerAllTranslations()</a>.</p>

</div>
</div>
<a id="a2e42cd6b5ac50f5a0ade0755e2622a18" name="a2e42cd6b5ac50f5a0ade0755e2622a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e42cd6b5ac50f5a0ade0755e2622a18">&#9670;&#160;</a></span>registerTopologicalSort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerTopologicalSort </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l02010">2010</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a56ab21a56a084aaa120dfca1e0683ced" name="a56ab21a56a084aaa120dfca1e0683ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ab21a56a084aaa120dfca1e0683ced">&#9670;&#160;</a></span>registerTopologicalSortPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerTopologicalSortPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l02017">2017</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a15b21db2ca02c947bb2f9ede2c57372f" name="a15b21db2ca02c947bb2f9ede2c57372f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15b21db2ca02c947bb2f9ede2c57372f">&#9670;&#160;</a></span>registerTosaToArithPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerTosaToArithPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08779">8779</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="abce41ada8e974a54209f8ea2fc239427" name="abce41ada8e974a54209f8ea2fc239427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce41ada8e974a54209f8ea2fc239427">&#9670;&#160;</a></span>registerTosaToArithPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerTosaToArithPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08786">8786</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a9583d40078499f2902dfab04892f79b2" name="a9583d40078499f2902dfab04892f79b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9583d40078499f2902dfab04892f79b2">&#9670;&#160;</a></span>registerTosaToLinalg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerTosaToLinalg </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08800">8800</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="ab991646e791f5ff68cca890be759b008" name="ab991646e791f5ff68cca890be759b008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab991646e791f5ff68cca890be759b008">&#9670;&#160;</a></span>registerTosaToLinalgNamed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerTosaToLinalgNamed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08821">8821</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="ae75ba1f975f7221c78757b9d7755e145" name="ae75ba1f975f7221c78757b9d7755e145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75ba1f975f7221c78757b9d7755e145">&#9670;&#160;</a></span>registerTosaToLinalgNamedPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerTosaToLinalgNamedPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08828">8828</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a38533581f768d495b197c5736b2a849f" name="a38533581f768d495b197c5736b2a849f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38533581f768d495b197c5736b2a849f">&#9670;&#160;</a></span>registerTosaToLinalgPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerTosaToLinalgPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08807">8807</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a2d25ca88f527ec8fe530bf4723470411" name="a2d25ca88f527ec8fe530bf4723470411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d25ca88f527ec8fe530bf4723470411">&#9670;&#160;</a></span>registerTosaToMLProgram()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerTosaToMLProgram </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08842">8842</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="afb94c162c525c572d6d3c1ea76ced0a2" name="afb94c162c525c572d6d3c1ea76ced0a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb94c162c525c572d6d3c1ea76ced0a2">&#9670;&#160;</a></span>registerTosaToMLProgramPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerTosaToMLProgramPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08849">8849</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a7e38cf638e9703a021cc635f9af19f5b" name="a7e38cf638e9703a021cc635f9af19f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e38cf638e9703a021cc635f9af19f5b">&#9670;&#160;</a></span>registerTosaToSCFPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerTosaToSCFPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08863">8863</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="aff772f2f6af356796cf1fef01e585d43" name="aff772f2f6af356796cf1fef01e585d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff772f2f6af356796cf1fef01e585d43">&#9670;&#160;</a></span>registerTosaToSCFPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerTosaToSCFPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08870">8870</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a7a539c2f41d67490719345dd74689ea7" name="a7a539c2f41d67490719345dd74689ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a539c2f41d67490719345dd74689ea7">&#9670;&#160;</a></span>registerTosaToTensorPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerTosaToTensorPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08884">8884</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a19fbeea61ad689edadedb9078ba59592" name="a19fbeea61ad689edadedb9078ba59592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19fbeea61ad689edadedb9078ba59592">&#9670;&#160;</a></span>registerTosaToTensorPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerTosaToTensorPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08891">8891</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="af7f5d34c37689ae9b05537a040d9e0a0" name="af7f5d34c37689ae9b05537a040d9e0a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f5d34c37689ae9b05537a040d9e0a0">&#9670;&#160;</a></span>registerToSPIRVTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerToSPIRVTranslation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00124">124</a> of file <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html">TranslateRegistration.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00083">serializeModule()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllTranslations_8h_source.html#l00035">registerAllTranslations()</a>.</p>

</div>
</div>
<a id="a8aa80526a38efe3ad444112c4f8a85c8" name="a8aa80526a38efe3ad444112c4f8a85c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa80526a38efe3ad444112c4f8a85c8">&#9670;&#160;</a></span>registerTransformsPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerTransformsPasses </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l02052">2052</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllPasses_8cpp_source.html#l00059">registerAllPasses()</a>.</p>

</div>
</div>
<a id="a3a41d372a37300e7b09f82fbd8b2d425" name="a3a41d372a37300e7b09f82fbd8b2d425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a41d372a37300e7b09f82fbd8b2d425">&#9670;&#160;</a></span>registerTranslationCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerTranslationCLOptions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register command-line options used by the translation registry. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8cpp_source.html#l00037">37</a> of file <a class="el" href="Translation_8cpp_source.html">Translation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DebugCounter_8cpp_source.html#l00040">clOptions</a>.</p>

</div>
</div>
<a id="a8c9b5f6af3d36238abb3ed7bbfeed717" name="a8c9b5f6af3d36238abb3ed7bbfeed717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9b5f6af3d36238abb3ed7bbfeed717">&#9670;&#160;</a></span>registerUBToLLVMConversionPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerUBToLLVMConversionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08905">8905</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a6c84fe5f1725615d8600cff4accaf9b0" name="a6c84fe5f1725615d8600cff4accaf9b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c84fe5f1725615d8600cff4accaf9b0">&#9670;&#160;</a></span>registerUBToLLVMConversionPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerUBToLLVMConversionPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08912">8912</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a88d1bdd28e28441cbbc55096672e6406" name="a88d1bdd28e28441cbbc55096672e6406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d1bdd28e28441cbbc55096672e6406">&#9670;&#160;</a></span>registerUBToSPIRVConversionPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerUBToSPIRVConversionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08926">8926</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a77368a0a2df5fa0348d0be45225f75dd" name="a77368a0a2df5fa0348d0be45225f75dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77368a0a2df5fa0348d0be45225f75dd">&#9670;&#160;</a></span>registerUBToSPIRVConversionPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerUBToSPIRVConversionPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8h_source.html#l08933">8933</a> of file <a class="el" href="ArmSMEToLLVM_8h_source.html">ArmSMEToLLVM.h</a>.</p>

</div>
</div>
<a id="a8ea099d5836b931b596ca22c70878760" name="a8ea099d5836b931b596ca22c70878760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea099d5836b931b596ca22c70878760">&#9670;&#160;</a></span>registerVCIXDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerVCIXDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the VCIX dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry. </p>

<p class="definition">Definition at line <a class="el" href="VCIXToLLVMIRTranslation_8cpp_source.html#l00076">76</a> of file <a class="el" href="VCIXToLLVMIRTranslation_8cpp_source.html">VCIXToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00152">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00039">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="VCIXToLLVMIRTranslation_8cpp_source.html#l00083">registerVCIXDialectTranslation()</a>.</p>

</div>
</div>
<a id="a134adbd787b504667bef30d219adfed8" name="a134adbd787b504667bef30d219adfed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134adbd787b504667bef30d219adfed8">&#9670;&#160;</a></span>registerVCIXDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerVCIXDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the VCIX dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="VCIXToLLVMIRTranslation_8cpp_source.html#l00083">83</a> of file <a class="el" href="VCIXToLLVMIRTranslation_8cpp_source.html">VCIXToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00416">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="VCIXToLLVMIRTranslation_8cpp_source.html#l00076">registerVCIXDialectTranslation()</a>.</p>

</div>
</div>
<a id="a196e2505c22020acd6ded246b84ee84a" name="a196e2505c22020acd6ded246b84ee84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a196e2505c22020acd6ded246b84ee84a">&#9670;&#160;</a></span>registerViewOpGraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerViewOpGraph </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l02031">2031</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a803c90f072df3c3e2dcaa56f4b89b486" name="a803c90f072df3c3e2dcaa56f4b89b486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803c90f072df3c3e2dcaa56f4b89b486">&#9670;&#160;</a></span>registerViewOpGraphPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerViewOpGraphPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transforms_2Passes_8h_source.html#l02038">2038</a> of file <a class="el" href="Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="aaa1eb668cf1f44410ce301800e747661" name="aaa1eb668cf1f44410ce301800e747661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa1eb668cf1f44410ce301800e747661">&#9670;&#160;</a></span>registerXeVMDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerXeVMDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">mlir::DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the XeVM dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00063">registerAllGPUToLLVMIRTranslations()</a>, and <a class="el" href="All_8h_source.html#l00039">registerAllToLLVMIRTranslations()</a>.</p>

</div>
</div>
<a id="a8fba154bf3c2388d815a405b00b85974" name="a8fba154bf3c2388d815a405b00b85974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fba154bf3c2388d815a405b00b85974">&#9670;&#160;</a></span>registerXeVMDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerXeVMDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">mlir::MLIRContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the XeVM dialect and the translation from it in the registry associated with the given context. </p>

</div>
</div>
<a id="a59ab8abadf1cca831e879d1f8058aecf" name="a59ab8abadf1cca831e879d1f8058aecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ab8abadf1cca831e879d1f8058aecf">&#9670;&#160;</a></span>reifyDimOfResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::reifyDimOfResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>resultIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00069">69</a> of file <a class="el" href="InferTypeOpInterface_8cpp_source.html">InferTypeOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>.</p>

</div>
</div>
<a id="a24aeba82a83b5f51bfe338ed5156887a" name="a24aeba82a83b5f51bfe338ed5156887a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24aeba82a83b5f51bfe338ed5156887a">&#9670;&#160;</a></span>reifyResultShapes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::reifyResultShapes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a676bc3fbf14bd5dba33f962b259d2034">ReifiedRankedShapedTypeDims</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>reifiedReturnShapes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reify the shape of the result of an operation (typically in terms of the shape of its operands). </p>

<p class="definition">Definition at line <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00027">27</a> of file <a class="el" href="InferTypeOpInterface_8cpp_source.html">InferTypeOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="IR_2Operation_8h_source.html#l00415">mlir::Operation::getResults()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00078">mlir::tensor::ExtractSliceFromCollapseHelper::create()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00075">mlir::tensor::getOrCreateDestination()</a>, <a class="el" href="ReifyResultShapes_8cpp_source.html#l00041">reifyOpResultShapes()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00158">reifyOrComputeDynamicSizes()</a>, <a class="el" href="PadTilingInterface_8cpp_source.html#l00266">mlir::linalg::rewriteAsPaddedOp()</a>, <a class="el" href="Padding_8cpp_source.html#l00244">mlir::linalg::rewriteAsPaddedOp()</a>, and <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00429">mlir::linalg::rewriteInDestinationPassingStyle()</a>.</p>

</div>
</div>
<a id="afa982da5f726a3b3bfd9b416ae933ea3" name="afa982da5f726a3b3bfd9b416ae933ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa982da5f726a3b3bfd9b416ae933ea3">&#9670;&#160;</a></span>reifyShapeOfResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt; mlir::reifyShapeOfResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>resultIndex</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00062">62</a> of file <a class="el" href="InferTypeOpInterface_8cpp_source.html">InferTypeOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>.</p>

</div>
</div>
<a id="a1fa0a7e84eb2af3d70c98d59fc9ccbd3" name="a1fa0a7e84eb2af3d70c98d59fc9ccbd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa0a7e84eb2af3d70c98d59fc9ccbd3">&#9670;&#160;</a></span>removeDuplicateExprs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::removeDuplicateExprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a map with the same dimension and symbol count as <span class="tt">map</span>, but whose results are the unique affine expressions of <span class="tt">map</span>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00776">776</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l02663">canonicalizeLoopBounds()</a>.</p>

</div>
</div>
<a id="a15a5d204dd78ac563241168e6b2e40eb" name="a15a5d204dd78ac563241168e6b2e40eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a5d204dd78ac563241168e6b2e40eb">&#9670;&#160;</a></span>replaceAllUsesInRegionWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::replaceAllUsesInRegionWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>orig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>replacement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>region</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all uses of <span class="tt">orig</span> within the given region with <span class="tt">replacement</span>. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00035">35</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00188">mlir::Value::getUses()</a>, <a class="el" href="IR_2Region_8h_source.html#l00222">mlir::Region::isAncestor()</a>, and <a class="el" href="LoopUtils_8cpp.html#af34d730a7920f1ae277f8c166146132d">replacement()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PassDetail_8cpp_source.html#l00020">mlir::async::cloneConstantsIntoTheRegion()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01069">collapseParallelLoops()</a>, <a class="el" href="OpenACCUtilsTiling_8cpp_source.html#l00119">moveOpsAndReplaceIVs()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00122">sinkOperationsIntoLaunchOp()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01529">stripmineSink()</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01242">stripmineSink()</a>.</p>

</div>
</div>
<a id="a210a664ca21b677121c83e0589945a86" name="a210a664ca21b677121c83e0589945a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210a664ca21b677121c83e0589945a86">&#9670;&#160;</a></span>replaceLoopNestWithNewYields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; scf::ForOp &gt; mlir::replaceLoopNestWithNewYields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; scf::ForOp &gt;</td>          <td class="paramname"><span class="paramname"><em>loopNest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>newIterOperands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a22fb6c3afa264f1726b430274179e011">NewYieldValuesFn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>newYieldValuesFn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>replaceIterOperandsUsesInLoop</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a perfectly nested loop nest to yield new values from the innermost loop and propagating it up through the loop nest. </p>
<p>This function</p><ul>
<li>Expects <span class="tt">loopNest</span> to be a perfectly nested loop with outer most loop first and innermost loop last.</li>
<li><span class="tt">newIterOperands</span> are the initialization values to be used for the outermost loop</li>
<li><span class="tt">newYielValueFn</span> is the callback that generates the new values to be yielded from within the innermost loop.</li>
<li>The original loops are not erased, but are left in a "no-op" state where the body of the loop just yields the basic block arguments that correspond to the initialization values of a loop. The original loops are dead after this method.</li>
<li>If <span class="tt">replaceIterOperandsUsesInLoop</span> is true, all uses of the <span class="tt">newIterOperands</span> within the generated new loop are replaced with the corresponding <span class="tt"><a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block.">BlockArgument</a></span> in the loop body. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00035">35</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00035">replaceLoopNestWithNewYields()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00035">replaceLoopNestWithNewYields()</a>.</p>

</div>
</div>
<a id="a9eb183dcb73d44f0e0aedb09b73c7fd7" name="a9eb183dcb73d44f0e0aedb09b73c7fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb183dcb73d44f0e0aedb09b73c7fd7">&#9670;&#160;</a></span>runRegionDCE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::runRegionDCE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>regions</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns success if any operations or arguments were deleted, failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00495">495</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="RegionUtils_8cpp_source.html#l00438">deleteDeadness()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l00388">propagateLiveness()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8cpp_source.html#l01069">simplifyRegions()</a>.</p>

</div>
</div>
<a id="a37afe16f80bc8bacb6914dd6f0b869c0" name="a37afe16f80bc8bacb6914dd6f0b869c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37afe16f80bc8bacb6914dd6f0b869c0">&#9670;&#160;</a></span>setupDebuggerExecutionContextHook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::setupDebuggerExecutionContextHook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1tracing_1_1ExecutionContext.html">tracing::ExecutionContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>executionContext</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DebuggerExecutionContextHook_8cpp_source.html#l00361">361</a> of file <a class="el" href="DebuggerExecutionContextHook_8cpp_source.html">DebuggerExecutionContextHook.cpp</a>.</p>

<p class="reference">References <a class="el" href="ExecutionContext_8h_source.html#l00114">mlir::tracing::ExecutionContext::addBreakpointManager()</a>, <a class="el" href="DebuggerExecutionContextHook_8cpp_source.html#l00331">debuggerCallBackFunction()</a>, <a class="el" href="DebuggerExecutionContextHook_8cpp_source.html#l00044">getGlobalDebuggerState()</a>, <a class="el" href="ExecutionContext_8cpp_source.html#l00051">mlir::tracing::ExecutionContext::registerObserver()</a>, and <a class="el" href="ExecutionContext_8h_source.html#l00080">mlir::tracing::ExecutionContext::setCallback()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CLOptionsSetup_8cpp_source.html#l00085">mlir::tracing::InstallDebugHandler::Impl::Impl()</a>.</p>

</div>
</div>
<a id="acbf369c69cfb613cd018ef4ce188809c" name="acbf369c69cfb613cd018ef4ce188809c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf369c69cfb613cd018ef4ce188809c">&#9670;&#160;</a></span>simplifyAffineExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::simplifyAffineExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numDims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numSymbols</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify an affine expression by flattening and some amount of simple analysis. </p>
<p>Simplify the affine expression by flattening it and reconstructing it.</p>
<p>This has complexity linear in the number of nodes in 'expr'. Returns the simplified expression, which is the same as the input expression if it can't be simplified. When <span class="tt">expr</span> is semi-affine, a simplified semi-affine expression is constructed in the sorted order of dimension and symbol positions. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01612">1612</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01090">getAffineExprFromFlatForm()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00031">mlir::AffineExpr::getContext()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01133">getSemiAffineExprFromFlatForm()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00210">mlir::AffineExpr::isPureAffine()</a>, <a class="el" href="AffineExprVisitor_8h_source.html#l00377">mlir::SimpleAffineExprFlattener::localExprs</a>, <a class="el" href="AffineExprVisitor_8h_source.html#l00362">mlir::SimpleAffineExprFlattener::operandExprStack</a>, and <a class="el" href="AffineExprVisitor_8h_source.html#l00150">mlir::AffineExprVisitor&lt; SubClass, RetTy &gt;::walkPostOrder()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00333">createPrivateMemRef()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00947">mlir::FlatLinearConstraints::getConstantBoundOnDimSize()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01798">getConstDifference()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00700">mlir::FlatLinearConstraints::getSliceBounds()</a>, <a class="el" href="BuiltinAttributeInterfaces_8cpp_source.html#l00161">getStridesAndOffset()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00855">makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00076">mlirSimplifyAffineExpr()</a>, <a class="el" href="DecomposeAffineOps_8cpp_source.html#l00041">mlir::affine::reorderOperandsByHoistability()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00977">mlir::MutableAffineMap::simplify()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00766">simplifyAffineMap()</a>.</p>

</div>
</div>
<a id="a014d8e82c51794d145267690b2b5bd58" name="a014d8e82c51794d145267690b2b5bd58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014d8e82c51794d145267690b2b5bd58">&#9670;&#160;</a></span>simplifyAffineMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::simplifyAffineMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplifies an affine map by simplifying its underlying <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> results. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00766">766</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01612">simplifyAffineExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00220">mlir::affine::FlatAffineValueConstraints::addBound()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01336">composeAffineMapAndOperands()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00036">mlir::affine::AffineValueMap::difference()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00508">mlir::affine::MemRefAccess::getAccessMap()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00045">getCleanupLoopLowerBound()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l00945">verifyOutputShape()</a>.</p>

</div>
</div>
<a id="ad38fea8480dfb78d9d3bd0736ccbfa2e" name="ad38fea8480dfb78d9d3bd0736ccbfa2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38fea8480dfb78d9d3bd0736ccbfa2e">&#9670;&#160;</a></span>simplifyRegions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::simplifyRegions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>regions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>mergeBlocks</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a set of structural simplifications over the given regions. </p>
<p>This includes transformations like unreachable block elimination, dead argument elimination, as well as some other DCE. This function returns success if any of the regions were simplified, failure otherwise. The provided rewriter is used to notify callers of operation and block deletion. Structurally similar blocks will be merged if the <span class="tt">mergeBlock</span> argument is true. Note this can lead to merged blocks with extra arguments.</p>
<p>This includes transformations like unreachable block elimination, dead argument elimination, as well as some other DCE. This function returns success if any of the regions were simplified, failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l01069">1069</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="RegionUtils_8cpp_source.html#l00957">dropRedundantArguments()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00186">eraseUnreachableBlocks()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00876">mergeIdenticalBlocks()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00495">runRegionDCE()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="aa6e007ae66428f560626d4ba3c58dfe2" name="aa6e007ae66428f560626d4ba3c58dfe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e007ae66428f560626d4ba3c58dfe2">&#9670;&#160;</a></span>sinkOperationsIntoLaunchOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::sinkOperationsIntoLaunchOp </td>
          <td>(</td>
          <td class="paramtype">gpu::LaunchOp</td>          <td class="paramname"><span class="paramname"><em>launchOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td>          <td class="paramname"><span class="paramname"><em>isSinkingBeneficiary</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sink operations into the <span class="tt">launchOp</span> to reduce the number of values that are used within the region of the operation, but defined outside of the region. </p>

<p class="definition">Definition at line <a class="el" href="KernelOutlining_8cpp_source.html#l00122">122</a> of file <a class="el" href="KernelOutlining_8cpp_source.html">KernelOutlining.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00562">mlir::OpBuilder::clone()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00091">extractBeneficiaryOps()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00415">mlir::Operation::getResults()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00070">getUsedValuesDefinedAbove()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00035">replaceAllUsesInRegionWith()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a35009cf90a73229f64f9090d4e5aa2b7" name="a35009cf90a73229f64f9090d4e5aa2b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35009cf90a73229f64f9090d4e5aa2b7">&#9670;&#160;</a></span>sortTopologically() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::sortTopologically </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td>          <td class="paramname"><span class="paramname"><em>isOperandReady</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a block, sort its operations in topological order, excluding its terminator if it has one. </p>
<p>This sort is stable. </p>

<p class="definition">Definition at line <a class="el" href="TopologicalSortUtils_8cpp_source.html#l00102">102</a> of file <a class="el" href="TopologicalSortUtils_8cpp_source.html">TopologicalSortUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="TopologicalSortUtils_8cpp_source.html#l00056">sortTopologically()</a>, and <a class="el" href="Block_8h_source.html#l00212">mlir::Block::without_terminator()</a>.</p>

</div>
</div>
<a id="adb95f9dc749d6a604340f83fd16b19f9" name="adb95f9dc749d6a604340f83fd16b19f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb95f9dc749d6a604340f83fd16b19f9">&#9670;&#160;</a></span>sortTopologically() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::sortTopologically </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>ops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td>          <td class="paramname"><span class="paramname"><em>isOperandReady</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a block, sort a range operations in said block in topological order. </p>
<p>The main purpose is readability of graph regions, potentially faster processing of certain transformations and analyses, or fixing the SSA dominance of blocks that require it after transformations. The function sorts the given operations such that, as much as possible, all users appear after their producers.</p>
<p>For example:</p>
<div class="fragment"><div class="line">%0 = test.foo</div>
<div class="line">%1 = test.bar %0, %2</div>
<div class="line">%2 = test.baz</div>
</div><!-- fragment --><p>Will become:</p>
<div class="fragment"><div class="line">%0 = test.foo</div>
<div class="line">%1 = test.baz</div>
<div class="line">%2 = test.bar %0, %1</div>
</div><!-- fragment --><p>The sort also works on operations with regions and implicit captures. For example:</p>
<div class="fragment"><div class="line">%0 = test.foo {</div>
<div class="line">  test.baz %1</div>
<div class="line">  %1 = test.bar %2</div>
<div class="line">}</div>
<div class="line">%2 = test.foo</div>
</div><!-- fragment --><p>Will become:</p>
<div class="fragment"><div class="line">%0 = test.foo</div>
<div class="line">%1 = test.foo {</div>
<div class="line">  test.baz %2</div>
<div class="line">  %2 = test.bar %0</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that the sort is not recursive on nested regions. This sort is stable; if the operations are already topologically sorted, nothing changes.</p>
<p>Operations that form cycles are moved to the end of the block in order. If the sort is left with only operations that form a cycle, it breaks the cycle by marking the first encountered operation as ready and moving on.</p>
<p>The function optionally accepts a callback that can be provided by users to virtually break cycles early. It is called on top-level operations in the block with value uses at or below those operations. The function should return true to mark that value as ready to be scheduled.</p>
<p>For example, if <span class="tt">isOperandReady</span> is set to always mark edges from <span class="tt">foo.A</span> to <span class="tt">foo.B</span> as ready, these operations:</p>
<div class="fragment"><div class="line">%0 = foo.B(%1)</div>
<div class="line">%1 = foo.C(%2)</div>
<div class="line">%2 = foo.A(%0)</div>
</div><!-- fragment --><p>Are sorted as:</p>
<div class="fragment"><div class="line">%0 = foo.A(%2)</div>
<div class="line">%1 = foo.C(%0)</div>
<div class="line">%2 = foo.B(%1)</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="TopologicalSortUtils_8cpp_source.html#l00056">56</a> of file <a class="el" href="TopologicalSortUtils_8cpp_source.html">TopologicalSortUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="TopologicalSortUtils_8cpp_source.html#l00020">isOpReady()</a>, and <a class="el" href="IR_2Operation_8cpp_source.html#l00550">mlir::Operation::moveBefore()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TopologicalSortUtils_8cpp_source.html#l00102">sortTopologically()</a>.</p>

</div>
</div>
<a id="a715b8c35aa2d5155832ef2f0c09db693" name="a715b8c35aa2d5155832ef2f0c09db693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a715b8c35aa2d5155832ef2f0c09db693">&#9670;&#160;</a></span>splitAndProcessBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::splitAndProcessBuffer </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; llvm::MemoryBuffer &gt;</td>          <td class="paramname"><span class="paramname"><em>originalBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9676bd96b41f931d8a8919d5bbb52e78">ChunkBufferHandler</a></td>          <td class="paramname"><span class="paramname"><em>processChunkBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef</td>          <td class="paramname"><span class="paramname"><em>inputSplitMarker</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a1349a176f4860c35697f441e414bf358">kDefaultSplitMarker</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef</td>          <td class="paramname"><span class="paramname"><em>outputSplitMarker</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits the specified buffer on a marker (<span class="tt">// -----</span> by default), processes each chunk independently according to the normal <span class="tt">processChunkBuffer</span> logic, and writes all results to <span class="tt">os</span>. </p>
<p>This is used to allow a large number of small independent tests to be put into a single file. The input split marker is configurable. If it is empty, merging is disabled, which allows for merging split and non-split code paths. Output split markers (<span class="tt">//-----</span> by default) followed by a new line character, respectively, are placed between each of the processed output chunks. (The new line character is inserted even if the split marker is empty.) </p>

<p class="reference">References <a class="el" href="#a1349a176f4860c35697f441e414bf358">kDefaultSplitMarker</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00735">MlirOptMain()</a>.</p>

</div>
</div>
<a id="a3f29fc9a815a5778fcb23ff4b3c224d6" name="a3f29fc9a815a5778fcb23ff4b3c224d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f29fc9a815a5778fcb23ff4b3c224d6">&#9670;&#160;</a></span>splitAndProcessBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::splitAndProcessBuffer </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; llvm::MemoryBuffer &gt;</td>          <td class="paramname"><span class="paramname"><em>originalBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8abaf89ab4e6fae5aca7471295fba915">NoSourceChunkBufferHandler</a></td>          <td class="paramname"><span class="paramname"><em>processChunkBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef</td>          <td class="paramname"><span class="paramname"><em>inputSplitMarker</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a1349a176f4860c35697f441e414bf358">kDefaultSplitMarker</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef</td>          <td class="paramname"><span class="paramname"><em>outputSplitMarker</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as above, but for case where the original buffer is not used while processing the chunk. </p>

<p class="reference">References <a class="el" href="#a1349a176f4860c35697f441e414bf358">kDefaultSplitMarker</a>.</p>

</div>
</div>
<a id="a1053fc52d14c30b033f053dd93383659" name="a1053fc52d14c30b033f053dd93383659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1053fc52d14c30b033f053dd93383659">&#9670;&#160;</a></span>storageClassToAddressSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::storageClassToAddressSpace </td>
          <td>(</td>
          <td class="paramtype">spirv::ClientAPI</td>          <td class="paramname"><span class="paramname"><em>clientAPI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spirv::StorageClass</td>          <td class="paramname"><span class="paramname"><em>storageClass</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRVCommon_2AttrToLLVMConverter_8cpp_source.html#l00051">51</a> of file <a class="el" href="SPIRVCommon_2AttrToLLVMConverter_8cpp_source.html">AttrToLLVMConverter.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00270">convertPointerType()</a>.</p>

</div>
</div>
<a id="a528c0559f393f6206d80cdb29394fa1c" name="a528c0559f393f6206d80cdb29394fa1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a528c0559f393f6206d80cdb29394fa1c">&#9670;&#160;</a></span>structFuncArgTypeConverter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::structFuncArgTypeConverter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to convert function argument types. </p>
<p>Give structFuncArgTypeConverter access to memref-specific functions.</p>
<p>It converts a MemRef function argument to a list of non-aggregate types containing descriptor information, and an UnrankedmemRef function argument to a list containing the rank and a pointer to a descriptor struct. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00801">801</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8cpp_source.html#l00486">mlir::LLVMTypeConverter::getMemRefDescriptorFields()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00554">mlir::LLVMTypeConverter::getUnrankedMemRefDescriptorFields()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="ae71592b6a57d95558cc2094b140ec445" name="ae71592b6a57d95558cc2094b140ec445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71592b6a57d95558cc2094b140ec445">&#9670;&#160;</a></span>TableGenLspServerMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::TableGenLspServerMain </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>argc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation for tools like <span class="tt">tblgen-lsp-server</span>. </p>

<p class="definition">Definition at line <a class="el" href="TableGenLspServerMain_8cpp_source.html#l00024">24</a> of file <a class="el" href="TableGenLspServerMain_8cpp_source.html">TableGenLspServerMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, and <a class="el" href="namespacemlir_1_1lsp.html#af3eee25b26477e2e1494c4fa031834f4">mlir::lsp::runTableGenLSPServer()</a>.</p>

</div>
</div>
<a id="aa109c04ae9443b1c88bd605dec0fa9b6" name="aa109c04ae9443b1c88bd605dec0fa9b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa109c04ae9443b1c88bd605dec0fa9b6">&#9670;&#160;</a></span>thread_safe_nulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::raw_ostream &amp; mlir::thread_safe_nulls </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a raw output stream that simply discards the output, but in a thread-safe manner. </p>
<p>Similar to llvm::nulls. </p>

<p class="definition">Definition at line <a class="el" href="RawOstreamExtras_8cpp_source.html#l00012">12</a> of file <a class="el" href="RawOstreamExtras_8cpp_source.html">RawOstreamExtras.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespacemlir_1_1linalg.html#afc247b3bd43d4462293e09845b698e7a">mlir::linalg::isaElemwiseSingleBinaryOpInterface()</a>.</p>

</div>
</div>
<a id="ab15bd4c107bb9ea52b7fcc11c283c129" name="ab15bd4c107bb9ea52b7fcc11c283c129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15bd4c107bb9ea52b7fcc11c283c129">&#9670;&#160;</a></span>tile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="#aed48aeaaa3484827b729cced4fb0dfb6">Loops</a>, 8 &gt; mlir::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt;</td>          <td class="paramname"><span class="paramname"><em>forOps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt;</td>          <td class="paramname"><span class="paramname"><em>targets</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs tiling fo imperfectly nested loops (with interchange) by strip-mining the <span class="tt">forOps</span> by <span class="tt">sizes</span> and sinking them, in their order of occurrence in <span class="tt">forOps</span>, under each of the <span class="tt">targets</span>. </p>
<p>Returns the new AffineForOps, one per each of (<span class="tt">forOps</span>, <span class="tt">targets</span>) pair, nested immediately under each of <span class="tt">targets</span>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01293">1293</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01242">stripmineSink()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgOps_8cpp_source.html#l05512">mlir::linalg::areTilesAndTiledDimsAllConstant()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l03100">convertOmpLoopNest()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01331">extractFixedOuterLoops()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l04989">mlir::linalg::getNewMixedTileSizes()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00463">mlir::linalg::pack()</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01306">tile()</a>.</p>

</div>
</div>
<a id="adb3ac25a4d763e0e5234f6b347c7f17a" name="adb3ac25a4d763e0e5234f6b347c7f17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb3ac25a4d763e0e5234f6b347c7f17a">&#9670;&#160;</a></span>tile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aed48aeaaa3484827b729cced4fb0dfb6">Loops</a> mlir::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt;</td>          <td class="paramname"><span class="paramname"><em>forOps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ForOp</td>          <td class="paramname"><span class="paramname"><em>target</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs tiling (with interchange) by strip-mining the <span class="tt">forOps</span> by <span class="tt">sizes</span> and sinking them, in their order of occurrence in <span class="tt">forOps</span>, under <span class="tt">target</span>. </p>
<p>Returns the new AffineForOps, one per <span class="tt">forOps</span>, nested immediately under <span class="tt">target</span>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01306">1306</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02100">target</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01293">tile()</a>.</p>

</div>
</div>
<a id="a76588ffa46e04caaa584360fa5cdde4c" name="a76588ffa46e04caaa584360fa5cdde4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76588ffa46e04caaa584360fa5cdde4c">&#9670;&#160;</a></span>tilePerfectlyNested()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aed48aeaaa3484827b729cced4fb0dfb6">Loops</a> mlir::tilePerfectlyNested </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp</td>          <td class="paramname"><span class="paramname"><em>rootForOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tile a nest of scf::ForOp loops rooted at <span class="tt">rootForOp</span> with the given (parametric) sizes. </p>
<p>Sizes are expected to be strictly positive values at runtime. If more sizes than loops are provided, discard the trailing values in sizes. Assumes the loop nest is permutable. Returns the newly created intra-tile loops. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01314">1314</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01227">getPerfectlyNestedLoopsImpl()</a>.</p>

</div>
</div>
<a id="afbb30909b4006046e7b4248b8d5a5a26" name="afbb30909b4006046e7b4248b8d5a5a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb30909b4006046e7b4248b8d5a5a26">&#9670;&#160;</a></span>topologicalSort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::topologicalSort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>toSort</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts all operations in <span class="tt">toSort</span> topologically while also considering region semantics. </p>
<p>Does not support multi-sets. </p>

<p class="definition">Definition at line <a class="el" href="TopologicalSortUtils_8cpp_source.html#l00275">275</a> of file <a class="el" href="TopologicalSortUtils_8cpp_source.html">TopologicalSortUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l00138">destructureSlot()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l01999">getConsumerFromLoopUses()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00343">getOpToConvert()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00206">getSlice()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l01145">moveValueDefinitions()</a>, and <a class="el" href="LoopFusionUtils_8cpp_source.html#l00357">promoteSingleIterReductionLoop()</a>.</p>

</div>
</div>
<a id="a23e5dd60111e86e0df4b52a7d3befd33" name="a23e5dd60111e86e0df4b52a7d3befd33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e5dd60111e86e0df4b52a7d3befd33">&#9670;&#160;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef mlir::toString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac84871bcca0aaa0176d43dbdbffe9a6c">AsmResourceEntryKind</a></td>          <td class="paramname"><span class="paramname"><em>kind</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l01863">1863</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

<p class="reference">References <a class="el" href="AsmState_8h_source.html#l00282">Blob</a>, <a class="el" href="AsmState_8h_source.html#l00284">Bool</a>, and <a class="el" href="AsmState_8h_source.html#l00286">String</a>.</p>

<p class="reference">Referenced by <a class="el" href="AsmParserImpl_8h_source.html#l00265">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseBase64Bytes()</a>, and <a class="el" href="BytecodeReader_8cpp_source.html#l01854">mlir::BytecodeReader::Impl::read()</a>.</p>

</div>
</div>
<a id="a7c9887613b4e793d34591b00a9732c03" name="a7c9887613b4e793d34591b00a9732c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9887613b4e793d34591b00a9732c03">&#9670;&#160;</a></span>transformCFGToSCF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classbool.html">bool</a> &gt; mlir::transformCFGToSCF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>region</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1CFGToSCFInterface.html">CFGToSCFInterface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>interface</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dominanceInfo</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transformation lifting any dialect implementing control flow graph operations to a dialect implementing structured control flow operations. </p>
<p><span class="tt">region</span> is the region that should be transformed. The implementation of <span class="tt">interface</span> is responsible for the conversion of the control flow operations to the structured control flow operations.</p>
<p>If the region contains only a single kind of return-like operation, all control flow graph operations will be converted successfully. Otherwise a single control flow graph operation branching to one block per return-like operation kind remains.</p>
<p>The transformation currently requires that all control flow graph operations have no side effects, implement the BranchOpInterface and does not have any operation produced successor operands. Returns failure if any of the preconditions are violated or if any of the methods of <span class="tt">interface</span> failed. The IR is left in an unspecified state.</p>
<p>Otherwise, returns true or false if any changes to the IR have been made. </p>

<p class="definition">Definition at line <a class="el" href="CFGToSCF_8cpp_source.html#l01273">1273</a> of file <a class="el" href="CFGToSCF_8cpp_source.html">CFGToSCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00240">mlir::OpBuilder::atBlockBegin()</a>, <a class="el" href="CFGToSCF_8cpp_source.html#l01226">checkTransformationPreconditions()</a>, <a class="el" href="CFGToSCF_8cpp_source.html#l01210">createSingleExitBlocksForReturnLike()</a>, <a class="el" href="IR_2Region_8h_source.html#l00060">mlir::Region::empty()</a>, <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="classmlir_1_1CFGToSCFInterface.html#a4e08775d01751ceca749ca511f67b628">mlir::CFGToSCFInterface::getCFGSwitchValue()</a>, <a class="el" href="IR_2Region_8cpp_source.html#l00031">mlir::Region::getLoc()</a>, <a class="el" href="Block_8cpp_source.html#l00027">mlir::Block::getParent()</a>, <a class="el" href="classmlir_1_1CFGToSCFInterface.html#a951d10ba77059063fb5bf916e5d1dc47">mlir::CFGToSCFInterface::getUndefValue()</a>, <a class="el" href="IR_2Region_8h_source.html#l00068">mlir::Region::hasOneBlock()</a>, <a class="el" href="LoopUtils_8cpp.html#ad077dc835cc07a8b6e9fd23f222b4ac6">inserted()</a>, <a class="el" href="Dominance_8cpp_source.html#l00037">mlir::detail::DominanceInfoBase&lt; IsPostDom &gt;::invalidate()</a>, <a class="el" href="CFGToSCF_8cpp_source.html#l00800">transformCyclesToSCFLoops()</a>, and <a class="el" href="CFGToSCF_8cpp_source.html#l00947">transformToStructuredCFBranches()</a>.</p>

</div>
</div>
<a id="a2f93379e5dbb5551bbe57170230a1d92" name="a2f93379e5dbb5551bbe57170230a1d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f93379e5dbb5551bbe57170230a1d92">&#9670;&#160;</a></span>translateDataLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataLayoutSpecInterface mlir::translateDataLayout </td>
          <td>(</td>
          <td class="paramtype">const llvm::DataLayout &amp;</td>          <td class="paramname"><span class="paramname"><em>dataLayout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate the given <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> data layout into an MLIR equivalent using the DLTI dialect. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutImporter_8cpp_source.html#l00404">404</a> of file <a class="el" href="DataLayoutImporter_8cpp_source.html">DataLayoutImporter.cpp</a>.</p>

<p class="reference">References <a class="el" href="DataLayoutImporter_8h_source.html#l00065">mlir::LLVM::detail::DataLayoutImporter::getDataLayoutSpec()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleTranslation_8cpp_source.html#l02331">prepareLLVMModule()</a>.</p>

</div>
</div>
<a id="ade5a695801255c4560465f9e494de6ed" name="ade5a695801255c4560465f9e494de6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5a695801255c4560465f9e494de6ed">&#9670;&#160;</a></span>translateLLVMIRToModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ModuleOp &gt; mlir::translateLLVMIRToModule </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; llvm::Module &gt;</td>          <td class="paramname"><span class="paramname"><em>llvmModule</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>emitExpensiveWarnings</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>dropDICompositeTypeElements</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>loadAllDialects</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>preferUnregisteredIntrinsics</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>importStructsAsLiterals</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translates the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> module into an MLIR module living in the given context. </p>
<p>The translation supports operations from any dialect that has a registered implementation of the <a class="el" href="classmlir_1_1LLVMImportDialectInterface.html" title="Base class for dialect interfaces used to import LLVM IR.">LLVMImportDialectInterface</a>. It returns nullptr if the translation fails and reports errors using the error handler registered with the MLIR context. The <span class="tt">emitExpensiveWarnings</span> option controls if expensive but uncritical diagnostics should be emitted. The <span class="tt">dropDICompositeTypeElements</span> option controls if DICompositeTypes should be imported without elements. If set, the option avoids the recursive traversal of composite type debug information, which can be expensive for adversarial inputs. The <span class="tt">loadAllDialects</span> flag (default on) will load all dialects in the context. The <span class="tt">preferUnregisteredIntrinsics</span> flag (default off) controls whether to import all intrinsics using <span class="tt">llvm.intrinsic_call</span> even if a dialect registered an explicit intrinsic operation. Warning: passes that rely on matching explicit intrinsic operations may not work properly if this flag is enabled. The <span class="tt">importStructsAsLiterals</span> flag (default off) ensures that all structs are imported as literal structs, even when they are named in the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> module. </p>

<p class="definition">Definition at line <a class="el" href="ModuleImport_8cpp_source.html#l03359">3359</a> of file <a class="el" href="ModuleImport_8cpp_source.html">ModuleImport.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleImport_8cpp_source.html#l01033">mlir::LLVM::ModuleImport::convertAliases()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01005">mlir::LLVM::ModuleImport::convertComdats()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01053">mlir::LLVM::ModuleImport::convertDataLayout()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01087">mlir::LLVM::ModuleImport::convertFunctions()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01015">mlir::LLVM::ModuleImport::convertGlobals()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01043">mlir::LLVM::ModuleImport::convertIFuncs()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00950">mlir::LLVM::ModuleImport::convertMetadata()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01075">mlir::LLVM::ModuleImport::convertModuleLevelAsm()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01069">mlir::LLVM::ModuleImport::convertTargetTriple()</a>, <a class="el" href="Location_8cpp_source.html#l00157">mlir::FileLineColLoc::get()</a>, <a class="el" href="OwningOpRef_8h_source.html#l00051">mlir::OwningOpRef&lt; OpTy &gt;::get()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00445">mlir::MLIRContext::getAvailableDialects()</a>, <a class="el" href="ModuleImport_8h_source.html#l00058">mlir::LLVM::ModuleImport::initializeImportInterface()</a>, and <a class="el" href="MLIRContext_8cpp_source.html#l00570">mlir::MLIRContext::loadAllAvailableDialects()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00027">registerFromLLVMIRTranslation()</a>.</p>

</div>
</div>
<a id="a4eef291fcf02aee4a7125d0c6420fdad" name="a4eef291fcf02aee4a7125d0c6420fdad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eef291fcf02aee4a7125d0c6420fdad">&#9670;&#160;</a></span>translateModuleToLLVMIR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; llvm::Module &gt; mlir::translateModuleToLLVMIR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>module</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em>llvmContext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef</td>          <td class="paramname"><span class="paramname"><em>name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;LLVMDialectModule&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>disableVerification</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translates a given <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect <span class="tt">module</span> into an <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR module living in the given context. </p>
<p>Operates on any operation from dialects that provide a registered implementation of the <a class="el" href="classmlir_1_1LLVMTranslationDialectInterface.html" title="Base class for dialect interfaces providing translation to LLVM IR.">LLVMTranslationDialectInterface</a>. Returns nullptr when the translation fails. Verifies the produced <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> module, except when <span class="tt">disableVerification</span> is set. </p>

<p class="reference">Referenced by <a class="el" href="ExecutionEngine_2ExecutionEngine_8cpp_source.html#l00231">mlir::ExecutionEngine::create()</a>, <a class="el" href="LLVMIR_8cpp_source.html#l00023">mlirTranslateModuleToLLVMIR()</a>, <a class="el" href="ConvertToLLVMIR_8cpp_source.html#l00025">registerToLLVMIRTranslation()</a>, and <a class="el" href="ModuleToObject_8cpp_source.html#l00145">mlir::LLVM::ModuleToObject::translateToLLVMIR()</a>.</p>

</div>
</div>
<a id="ad4695076b1d2f75930c85058c6b42084" name="ad4695076b1d2f75930c85058c6b42084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4695076b1d2f75930c85058c6b42084">&#9670;&#160;</a></span>tryToDestructureMemorySlots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::tryToDestructureMemorySlots </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; DestructurableAllocationOpInterface &gt;</td>          <td class="paramname"><span class="paramname"><em>allocators</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dataLayout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1SROAStatistics.html">SROAStatistics</a></td>          <td class="paramname"><span class="paramname"><em>statistics</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to destructure the slots of destructurable allocators. </p>
<p>Iteratively retries the destructuring of all slots as destructuring one slot might enable subsequent destructuring. Returns failure if no slot was destructured. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l00196">196</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SROA_8cpp_source.html#l00048">computeDestructuringInfo()</a>, <a class="el" href="SROA_8cpp_source.html#l00138">destructureSlot()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="ae2434626306ac343fdef7bf1e3c10459" name="ae2434626306ac343fdef7bf1e3c10459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2434626306ac343fdef7bf1e3c10459">&#9670;&#160;</a></span>tryToPromoteMemorySlots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::tryToPromoteMemorySlots </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; PromotableAllocationOpInterface &gt;</td>          <td class="paramname"><span class="paramname"><em>allocators</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dataLayout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dominance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Mem2RegStatistics.html">Mem2RegStatistics</a></td>          <td class="paramname"><span class="paramname"><em>statistics</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to promote the memory slots of the provided allocators. </p>
<p>Iteratively retries the promotion of all slots as promoting one slot might enable subsequent promotions. Succeeds if at least one memory slot was promoted. </p>

<p class="definition">Definition at line <a class="el" href="Mem2Reg_8cpp_source.html#l00644">644</a> of file <a class="el" href="Mem2Reg_8cpp_source.html">Mem2Reg.cpp</a>.</p>

<p class="reference">References <a class="el" href="MemorySlotInterfaces_8h_source.html#l00022">mlir::MemorySlot::ptr</a>, <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, and <a class="el" href="Value_8h_source.html#l00208">mlir::Value::use_empty()</a>.</p>

</div>
</div>
<a id="ae4b1ba650fd43b50351e92bbb75bd4c0" name="ae4b1ba650fd43b50351e92bbb75bd4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b1ba650fd43b50351e92bbb75bd4c0">&#9670;&#160;</a></span>verify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::verify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>verifyRecursively</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform (potentially expensive) checks of invariants, used to detect compiler bugs, on this operation and any nested operations. </p>
<p>On error, this reports the error through the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a> and returns failure. If <span class="tt">verifyRecursively</span> is false, this assumes that nested operations have already been properly verified, and does not recursively invoke the verifier on nested operations. </p>

<p class="definition">Definition at line <a class="el" href="Verifier_8cpp_source.html#l00423">423</a> of file <a class="el" href="Verifier_8cpp_source.html">Verifier.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l01030">applyOpPatternsGreedily()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00913">applyPatternsGreedily()</a>, <a class="el" href="MLIRGen_8cpp_source.html#l00624">mlir::pdll::codegenPDLLToMLIR()</a>, <a class="el" href="Tester_8cpp_source.html#l00027">mlir::Tester::isInteresting()</a>, <a class="el" href="Dialect_2Transform_2IR_2Utils_8cpp_source.html#l00080">mlir::transform::detail::mergeSymbolsInto()</a>, <a class="el" href="IR_8cpp_source.html#l00857">mlirOperationVerify()</a>, <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00088">mlir::transform::detail::parseTransformModuleFromFile()</a>, <a class="el" href="Translation_8cpp_source.html#l00075">registerTranslateToMLIRFunction()</a>, <a class="el" href="Query_8cpp_source.html#l00120">mlir::query::MatchQuery::run()</a>, <a class="el" href="ShardingPropagation_8cpp_source.html#l00363">ShardingPropagation::runOnOperation()</a>, <a class="el" href="ExtensibleDialect_8h_source.html#l00400">mlir::DynamicOpDefinition::setVerifyFn()</a>, <a class="el" href="ExtensibleDialect_8h_source.html#l00407">mlir::DynamicOpDefinition::setVerifyRegionFn()</a>, <a class="el" href="MlirOptMain_8h_source.html#l00200">mlir::MlirOptMainConfig::verifyDiagnostics()</a>, <a class="el" href="MlirOptMain_8h_source.html#l00222">mlir::MlirOptMainConfig::verifyOnParsing()</a>, <a class="el" href="MlirOptMain_8h_source.html#l00215">mlir::MlirOptMainConfig::verifyPasses()</a>, <a class="el" href="MlirOptMain_8h_source.html#l00229">mlir::MlirOptMainConfig::verifyRoundtrip()</a>, and <a class="el" href="WalkPatternRewriteDriver_8cpp_source.html#l00093">walkAndApplyPatterns()</a>.</p>

</div>
</div>
<a id="a961cf9926486f7d6e7160efa8f846d64" name="a961cf9926486f7d6e7160efa8f846d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961cf9926486f7d6e7160efa8f846d64">&#9670;&#160;</a></span>verifyCompatibleDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::verifyCompatibleDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>dims</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dimensions are compatible if all non-dynamic dims are equal. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00104">104</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeUtilities_8cpp_source.html#l00120">verifyCompatibleShapes()</a>.</p>

</div>
</div>
<a id="acb414ad1d507c2ab841305c273f4deb8" name="acb414ad1d507c2ab841305c273f4deb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb414ad1d507c2ab841305c273f4deb8">&#9670;&#160;</a></span>verifyCompatibleShape() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::verifyCompatibleShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>shape1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>shape2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns success if the given two shapes are compatible. </p>
<p>That is, they have the same size and each pair of the elements are equal or one of them is dynamic. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00058">58</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TosaOps_8cpp_source.html#l00906">errorIfTypeOrShapeMismatch()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00077">verifyCompatibleShape()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00095">verifyCompatibleShapes()</a>, and <a class="el" href="IR_2Operation_8cpp_source.html#l01100">mlir::OpTrait::impl::verifySameOperandsAndResultType()</a>.</p>

</div>
</div>
<a id="ac54e5e6c31f51ef648f7c03652a29ce6" name="ac54e5e6c31f51ef648f7c03652a29ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54e5e6c31f51ef648f7c03652a29ce6">&#9670;&#160;</a></span>verifyCompatibleShape() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::verifyCompatibleShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>type1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>type2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns success if the given two types have compatible shape. </p>
<p>That is, they are both scalars (not shaped), or they are both shaped types and at least one is unranked or they have compatible dimensions. Dimensions are compatible if at least one is dynamic or both are equal. The element type does not matter. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00077">77</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, and <a class="el" href="TypeUtilities_8cpp_source.html#l00058">verifyCompatibleShape()</a>.</p>

</div>
</div>
<a id="a132fff065736d8e977fe8179f2e7086c" name="a132fff065736d8e977fe8179f2e7086c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132fff065736d8e977fe8179f2e7086c">&#9670;&#160;</a></span>verifyCompatibleShapes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::verifyCompatibleShapes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a></td>          <td class="paramname"><span class="paramname"><em>types</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns success if all given types have compatible shapes. </p>
<p>That is, they are all scalars (not shaped), or they are all shaped types and any ranked shapes have compatible dimensions. The element type does not matter.</p>
<p>That is, they are all scalars (not shaped), or they are all shaped types and any ranked shapes have compatible dimensions. Dimensions are compatible if all non-dynamic dims are equal. The element type does not matter. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00120">120</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, and <a class="el" href="TypeUtilities_8cpp_source.html#l00104">verifyCompatibleDims()</a>.</p>

</div>
</div>
<a id="a2801a1733326688cf0c9bee8d633f234" name="a2801a1733326688cf0c9bee8d633f234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2801a1733326688cf0c9bee8d633f234">&#9670;&#160;</a></span>verifyCompatibleShapes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::verifyCompatibleShapes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a></td>          <td class="paramname"><span class="paramname"><em>types1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a></td>          <td class="paramname"><span class="paramname"><em>types2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns success if the given two arrays have the same number of elements and each pair wise entries have compatible shape. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00095">95</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, and <a class="el" href="TypeUtilities_8cpp_source.html#l00058">verifyCompatibleShape()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArithOps_8cpp_source.html#l01384">areValidCastInputsAndOutputs()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l01490">mayRequireBroadcast()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l01307">mlir::OpTrait::impl::verifyElementwise()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l01047">mlir::OpTrait::impl::verifySameOperandsAndResultShape()</a>, and <a class="el" href="IR_2Operation_8cpp_source.html#l01037">mlir::OpTrait::impl::verifySameOperandsShape()</a>.</p>

</div>
</div>
<a id="a31371cb9cd00eaf06ad3b6ee1bf08ca7" name="a31371cb9cd00eaf06ad3b6ee1bf08ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31371cb9cd00eaf06ad3b6ee1bf08ca7">&#9670;&#160;</a></span>verifyInBoundsSlice() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1SliceBoundsVerificationResult.html">SliceBoundsVerificationResult</a> mlir::verifyInBoundsSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>staticOffsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>staticSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>staticStrides</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>generateErrorMessage</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that the offsets/sizes/strides-style access into the given shape is in-bounds. </p>
<p>Only static values are verified. If <span class="tt">generateErrorMessage</span> is set to "true", an error message is produced that can be printed by the op verifier. </p>

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00037">37</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="ViewLikeInterface_8h_source.html#l00085">mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder&lt; OpType, ResultTypeFn, CastOpFunc &gt;::matchAndRewrite()</a>, and <a class="el" href="ViewLikeInterface_8cpp_source.html#l00075">verifyInBoundsSlice()</a>.</p>

</div>
</div>
<a id="a79ad2e2e2af3d995b2f49c0196b29c12" name="a79ad2e2e2af3d995b2f49c0196b29c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ad2e2e2af3d995b2f49c0196b29c12">&#9670;&#160;</a></span>verifyInBoundsSlice() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1SliceBoundsVerificationResult.html">SliceBoundsVerificationResult</a> mlir::verifyInBoundsSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>mixedOffsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>mixedSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>mixedStrides</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>generateErrorMessage</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00075">75</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ViewLikeInterface_8cpp_source.html#l00037">verifyInBoundsSlice()</a>.</p>

</div>
</div>
<a id="ad1a1c57fc94caa37e2b98499a48eea86" name="ad1a1c57fc94caa37e2b98499a48eea86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a1c57fc94caa37e2b98499a48eea86">&#9670;&#160;</a></span>verifyListOfOperandsOrIntegers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::verifyListOfOperandsOrIntegers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>expectedNumElements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>attr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that a the <span class="tt">values</span> has as many elements as the number of entries in <span class="tt">attr</span> for which <span class="tt">isDynamic</span> evaluates to true. </p>
<p>Include the definitions of the loop-like interfaces. </p>

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00020">20</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00268">mlir::Operation::emitError()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ViewLikeInterface_8cpp_source.html#l00096">mlir::detail::verifyOffsetSizeAndStrideOp()</a>.</p>

</div>
</div>
<a id="a036e7ce3c7c3bf73fc0a653cd98bb7c0" name="a036e7ce3c7c3bf73fc0a653cd98bb7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036e7ce3c7c3bf73fc0a653cd98bb7c0">&#9670;&#160;</a></span>visitUsedValuesDefinedAbove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::visitUsedValuesDefinedAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>regions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *)&gt;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls <span class="tt">callback</span> for each use of a value within any of the regions provided that was defined in one of the ancestors. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00064">64</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="RegionUtils_8cpp_source.html#l00043">visitUsedValuesDefinedAbove()</a>.</p>

</div>
</div>
<a id="ae644ec0854505ef60f12c23b96de595b" name="ae644ec0854505ef60f12c23b96de595b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae644ec0854505ef60f12c23b96de595b">&#9670;&#160;</a></span>visitUsedValuesDefinedAbove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::visitUsedValuesDefinedAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>region</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>limit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *)&gt;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls <span class="tt">callback</span> for each use of a value within <span class="tt">region</span> or its descendants that was defined at the ancestors of the <span class="tt">limit</span>. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00043">43</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00383">mlir::Operation::getOpOperands()</a>, <a class="el" href="IR_2Region_8cpp_source.html#l00045">mlir::Region::getParentRegion()</a>, <a class="el" href="IR_2Region_8h_source.html#l00222">mlir::Region::isAncestor()</a>, and <a class="el" href="IR_2Region_8h_source.html#l00285">mlir::Region::walk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8cpp_source.html#l00070">getUsedValuesDefinedAbove()</a>, <a class="el" href="SCFTransformOps_8cpp_source.html#l00501">isOpSibling()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l00064">visitUsedValuesDefinedAbove()</a>.</p>

</div>
</div>
<a id="ab84fd477538fb25ddc796e5cd7d85999" name="ab84fd477538fb25ddc796e5cd7d85999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab84fd477538fb25ddc796e5cd7d85999">&#9670;&#160;</a></span>walkAndApplyPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::walkAndApplyPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1RewriterBase_1_1Listener.html">RewriterBase::Listener</a> *</td>          <td class="paramname"><span class="paramname"><em>listener</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A fast walk-based pattern rewrite driver. </p>
<p>Rewrites ops nested under the given operation by walking it and applying the highest benefit patterns. This rewriter <em>does not</em> wait until a fixpoint is reached and <em>does not</em> visit modified or newly replaced ops. Also <em>does not</em> perform folding or dead-code elimination.</p>
<p>This is intended as the simplest and most lightweight pattern rewriter in cases when a simple walk gets the job done.</p>
<p>The driver will skip unreachable blocks.</p>
<p>Note: Does not apply patterns to the given operation itself. </p>

<p class="definition">Definition at line <a class="el" href="WalkPatternRewriteDriver_8cpp_source.html#l00093">93</a> of file <a class="el" href="WalkPatternRewriteDriver_8cpp_source.html">WalkPatternRewriteDriver.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternApplicator_8h_source.html#l00080">mlir::PatternApplicator::applyDefaultCostModel()</a>, <a class="el" href="IR_2Region_8h_source.html#l00055">mlir::Region::begin()</a>, <a class="el" href="IR_2Region_8h_source.html#l00056">mlir::Region::end()</a>, <a class="el" href="MLIRContext_8h_source.html#l00274">mlir::MLIRContext::executeAction()</a>, <a class="el" href="WalkPatternRewriteDriver_8cpp_source.html#l00032">findReachableBlocks()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00216">mlir::Operation::getContext()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00677">mlir::Operation::getRegions()</a>, <a class="el" href="PatternApplicator_8cpp_source.html#l00132">mlir::PatternApplicator::matchAndRewrite()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">patterns</a>, <a class="el" href="Builders_8h_source.html#l00316">mlir::OpBuilder::setListener()</a>, and <a class="el" href="Verifier_8cpp_source.html#l00423">verify()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FoldMemRefsOps_8cpp_source.html#l00024">mlir::amdgpu::AmdgpuFoldMemRefOpsPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="a95bf64684e4364416fb8d648c251d41b" name="a95bf64684e4364416fb8d648c251d41b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95bf64684e4364416fb8d648c251d41b">&#9670;&#160;</a></span>walkSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1WalkContinuation.html">WalkContinuation</a> mlir::walkSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">mlir::ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>rootValues</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#abd3021a9a0e882a2cd1061b4312a1698">WalkCallback</a></td>          <td class="paramname"><span class="paramname"><em>walkCallback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walks the slice starting from the <span class="tt">rootValues</span> using a depth-first traversal. </p>
<p>The walk calls the provided <span class="tt">walkCallback</span> for each value encountered in the slice and uses the returned walk continuation to determine how to proceed. </p>

<p class="definition">Definition at line <a class="el" href="SliceWalk_8cpp_source.html#l00006">6</a> of file <a class="el" href="SliceWalk_8cpp_source.html">SliceWalk.cpp</a>.</p>

<p class="reference">References <a class="el" href="SliceWalk_8h_source.html#l00069">mlir::WalkContinuation::getNextValues()</a>, <a class="el" href="SliceWalk_8h_source.html#l00055">mlir::WalkContinuation::skip()</a>, <a class="el" href="SliceWalk_8h_source.html#l00066">mlir::WalkContinuation::wasAdvancedTo()</a>, <a class="el" href="SliceWalk_8h_source.html#l00060">mlir::WalkContinuation::wasInterrupted()</a>, and <a class="el" href="SliceWalk_8h_source.html#l00063">mlir::WalkContinuation::wasSkipped()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InlinerInterfaceImpl_8cpp_source.html#l00233">getUnderlyingObjectSet()</a>.</p>

</div>
</div>
<a id="a655db45ed8c23d04d5ed5ee0abe041ad" name="a655db45ed8c23d04d5ed5ee0abe041ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655db45ed8c23d04d5ed5ee0abe041ad">&#9670;&#160;</a></span>wouldOpBeTriviallyDead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::wouldOpBeTriviallyDead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the given operation would be dead if unused, and has no side effects on memory that would prevent erasing. </p>
<p>This is equivalent to checking <span class="tt">isOpTriviallyDead</span> if <span class="tt">op</span> was unused.</p>
<p>Note: Terminators and symbols are never considered to be trivially dead. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00312">312</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00757">mlir::Operation::mightHaveTrait()</a>, and <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00043">wouldOpBeTriviallyDeadImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00035">isOpTriviallyDead()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00366">propagateLiveness()</a>, and <a class="el" href="SCCP_8cpp_source.html#l00067">rewrite()</a>.</p>

</div>
</div>
<a id="ae17b909cf0c32c717226432e6a65f61e" name="ae17b909cf0c32c717226432e6a65f61e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17b909cf0c32c717226432e6a65f61e">&#9670;&#160;</a></span>writeBytecodeToFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::writeBytecodeToFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1BytecodeWriterConfig.html">BytecodeWriterConfig</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>config</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the bytecode for the given operation to the provided output stream. </p>
<p>For streams where it matters, the given stream should be in "binary" mode. It only ever fails if setDesiredByteCodeVersion can't be honored. </p>

<p class="definition">Definition at line <a class="el" href="BytecodeWriter_8cpp_source.html#l01353">1353</a> of file <a class="el" href="BytecodeWriter_8cpp_source.html">BytecodeWriter.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00284">config</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00416">doVerifyRoundTrip()</a>, <a class="el" href="IR_8cpp_source.html#l00841">mlirOperationWriteBytecode()</a>, <a class="el" href="IR_8cpp_source.html#l00848">mlirOperationWriteBytecodeWithConfig()</a>, and <a class="el" href="MlirOptMain_8cpp_source.html#l00496">performActions()</a>.</p>

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="a1c6ebcdda896c9a0316c2367d2843775" name="a1c6ebcdda896c9a0316c2367d2843775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c6ebcdda896c9a0316c2367d2843775">&#9670;&#160;</a></span>changed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> <a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a> <a class="el" href="classbool.html">bool</a>* mlir::changed = <a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00285">285</a> of file <a class="el" href="GreedyPatternRewriteDriver_8h_source.html">GreedyPatternRewriteDriver.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l01030">applyOpPatternsGreedily()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00236">applyPatternsAndFoldGreedily()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00184">applyPatternsAndFoldGreedily()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00217">applyPatternsGreedily()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00913">applyPatternsGreedily()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01336">composeAffineMapAndOperands()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00879">mlir::FlatLinearConstraints::computeLocalVars()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00629">computeUnknownVars()</a>, <a class="el" href="Analysis_2Presburger_2Utils_8cpp_source.html#l00390">mlir::presburger::DivisionRepr::divValuesAt()</a>, <a class="el" href="CSE_8cpp_source.html#l00378">eliminateCommonSubExpressions()</a>, <a class="el" href="VectorOps_8cpp_source.html#l04995">foldTransferInBoundsAttribute()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01023">mlir::presburger::IntegerRelation::getLocalReprs()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00089">mlir::linalg::hoistRedundantVectorBroadcasts()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00198">mlir::linalg::hoistRedundantVectorTransfers()</a>, <a class="el" href="DataFlowFramework_8cpp_source.html#l00172">mlir::DataFlowAnalysis::propagateIfChanged()</a>, <a class="el" href="DataFlowFramework_8cpp_source.html#l00147">mlir::DataFlowSolver::propagateIfChanged()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l02442">mlir::presburger::IntegerRelation::removeDuplicateConstraints()</a>, <a class="el" href="AttrTypeSubElements_8cpp_source.html#l00086">mlir::detail::AttrTypeReplacerBase&lt; AttrTypeReplacer &gt;::replaceElementsIn()</a>, <a class="el" href="AttrTypeSubElements_8cpp_source.html#l00169">replaceSubElements()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01417">mlir::presburger::IntegerRelation::simplify()</a>, <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l00149">mlir::affine::simplifyAffineMinMaxOps()</a>, <a class="el" href="SparseReinterpretMap_8cpp_source.html#l00242">translateMap()</a>, <a class="el" href="IntegerRangeAnalysis_8cpp_source.html#l00140">mlir::dataflow::IntegerRangeAnalysis::visitNonControlFlowArguments()</a>, <a class="el" href="IntegerRangeAnalysis_8cpp_source.html#l00093">mlir::dataflow::IntegerRangeAnalysis::visitOperation()</a>, and <a class="el" href="StridedMetadataRangeAnalysis_8cpp_source.html#l00085">mlir::dataflow::StridedMetadataRangeAnalysis::visitOperation()</a>.</p>

</div>
</div>
<a id="a3ecea12db18ed347ea11d1d999237b24" name="a3ecea12db18ed347ea11d1d999237b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ecea12db18ed347ea11d1d999237b24">&#9670;&#160;</a></span>config</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> <a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a> mlir::config = <a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00284">284</a> of file <a class="el" href="GreedyPatternRewriteDriver_8h_source.html">GreedyPatternRewriteDriver.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8cpp_source.html#l04132">applyConversion()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l01030">applyOpPatternsGreedily()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00236">applyPatternsAndFoldGreedily()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00184">applyPatternsAndFoldGreedily()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00217">applyPatternsGreedily()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00913">applyPatternsGreedily()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l00809">mlir::transform::TransformState::applyTransform()</a>, <a class="el" href="PassCrashRecovery_8cpp_source.html#l00491">mlir::PassReproducerOptions::attachResourceParser()</a>, <a class="el" href="BytecodeReader_8cpp_source.html#l02774">mlir::BytecodeReader::BytecodeReader()</a>, <a class="el" href="BytecodeWriter_8cpp_source.html#l00070">mlir::BytecodeWriterConfig::BytecodeWriterConfig()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00181">compileAndExecute()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00274">compileAndExecuteSingleReturnFunction()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00222">compileAndExecuteVoidFunction()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03316">mlir::OperationConverter::convert()</a>, <a class="el" href="Canonicalizer_8cpp_source.html#l00080">createCanonicalizerPass()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00482">doVerifyRoundTrip()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00416">doVerifyRoundTrip()</a>, <a class="el" href="EmptyTensorElimination_8cpp_source.html#l00123">mlir::bufferization::eliminateEmptyTensors()</a>, <a class="el" href="IRPrinting_8cpp_source.html#l00354">mlir::PassManager::enableIRPrinting()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l02269">mlir::LLVM::ModuleTranslation::getOpenMPBuilder()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00470">hasEquivalentValueInReverseUseDefChain()</a>, <a class="el" href="CLOptionsSetup_8cpp_source.html#l00085">mlir::tracing::InstallDebugHandler::Impl::Impl()</a>, <a class="el" href="CLOptionsSetup_8cpp_source.html#l00150">mlir::tracing::InstallDebugHandler::InstallDebugHandler()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00308">JitRunnerMain()</a>, <a class="el" href="EliminateEmptyTensors_8cpp_source.html#l00039">mlir::linalg::linalgOpAnchoredEmptyTensorEliminationStep()</a>, <a class="el" href="IR_8cpp_source.html#l00252">mlirBytecodeWriterConfigDestroy()</a>, <a class="el" href="IR_8cpp_source.html#l00848">mlirOperationWriteBytecodeWithConfig()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00786">MlirOptMain()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00735">MlirOptMain()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03283">mlir::OperationConverter::OperationConverter()</a>, <a class="el" href="AffineParser_8cpp_source.html#l00762">parseAffineMapOrIntegerSet()</a>, <a class="el" href="AsmParser_2Parser_8cpp_source.html#l02918">parseAsmSourceFile()</a>, <a class="el" href="lib_2AsmParser_2Parser_8h_source.html#l00033">mlir::detail::Parser::Parser()</a>, <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00154">mlir::detail::parseSourceFile()</a>, <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00176">parseSourceFile()</a>, <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00186">parseSourceFile()</a>, <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00226">parseSourceFile()</a>, <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00214">parseSourceFile()</a>, <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00200">parseSourceFile()</a>, <a class="el" href="ParseUtilities_8h_source.html#l00027">parseSourceFileForTool()</a>, <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00244">parseSourceString()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00338">parseSymbol()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00496">performActions()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00631">processBuffer()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00401">processParallelLoop()</a>, <a class="el" href="BytecodeReader_8cpp_source.html#l02836">readBytecodeFile()</a>, <a class="el" href="BytecodeReader_8cpp_source.html#l02831">readBytecodeFile()</a>, <a class="el" href="BytecodeReader_8cpp_source.html#l02815">readBytecodeFileImpl()</a>, <a class="el" href="MlirOptMain_8h_source.html#l00083">mlir::MlirOptMainConfig::setDebugConfig()</a>, <a class="el" href="IRCore_8cpp_source.html#l01145">mlir::python::PyOperationBase::writeBytecode()</a>, and <a class="el" href="BytecodeWriter_8cpp_source.html#l01353">writeBytecodeToFile()</a>.</p>

</div>
</div>
<a id="a52f52f0c5e268decd5b4ff95c42ea054" name="a52f52f0c5e268decd5b4ff95c42ea054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f52f0c5e268decd5b4ff95c42ea054">&#9670;&#160;</a></span>has_sub_attr_or_type_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::has_sub_attr_or_type_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    (!llvm::is_detected&lt;detail::has_default_sub_element_handler_t, Ts&gt;::value ||</div>
<div class="line">     ...)</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="AttrTypeSubElements_8h_source.html#l00417">417</a> of file <a class="el" href="AttrTypeSubElements_8h_source.html">AttrTypeSubElements.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttrTypeSubElements_8h_source.html#l00557">mlir::detail::replaceImmediateSubElementsImpl()</a>, and <a class="el" href="AttrTypeSubElements_8h_source.html#l00518">mlir::detail::walkImmediateSubElementsImpl()</a>.</p>

</div>
</div>
<a id="a1349a176f4860c35697f441e414bf358" name="a1349a176f4860c35697f441e414bf358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1349a176f4860c35697f441e414bf358">&#9670;&#160;</a></span>kDefaultSplitMarker</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* const mlir::kDefaultSplitMarker = &quot;// -----&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8h_source.html#l00184">mlir::MlirOptMainConfig::outputSplitMarker()</a>, <a class="el" href="#a715b8c35aa2d5155832ef2f0c09db693">splitAndProcessBuffer()</a>, <a class="el" href="#a3f29fc9a815a5778fcb23ff4b3c224d6">splitAndProcessBuffer()</a>, and <a class="el" href="MlirOptMain_8h_source.html#l00175">mlir::MlirOptMainConfig::splitInputFile()</a>.</p>

</div>
</div>
<a id="a2887883f00b094c5ca61c631d7b093a0" name="a2887883f00b094c5ca61c631d7b093a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2887883f00b094c5ca61c631d7b093a0">&#9670;&#160;</a></span>kDeriveIndexBitwidthFromDataLayout</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::kDeriveIndexBitwidthFromDataLayout = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> to pass as bitwidth for the index type when the converter is expected to derive the bitwidth from the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> data layout. </p>

<p class="definition">Definition at line <a class="el" href="LoweringOptions_8h_source.html#l00026">26</a> of file <a class="el" href="LoweringOptions_8h_source.html">LoweringOptions.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoweringOptions_8h_source.html#l00059">mlir::LowerToLLVMOptions::overrideIndexBitwidth()</a>.</p>

</div>
</div>
<a id="a8789c71249b4fcc3059f4ba4a9d27f26" name="a8789c71249b4fcc3059f4ba4a9d27f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8789c71249b4fcc3059f4ba4a9d27f26">&#9670;&#160;</a></span>patterns</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a>&amp; mlir::patterns</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">283</a> of file <a class="el" href="GreedyPatternRewriteDriver_8h_source.html">GreedyPatternRewriteDriver.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpenMPToLLVM_8cpp_source.html#l00145">addOpenMPOpConversions()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00230">mlir::affine::affineForOpBodySkew()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l04132">applyConversion()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l01030">applyOpPatternsGreedily()</a>, <a class="el" href="ReductionTreePass_8cpp_source.html#l00038">applyPatterns()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00236">applyPatternsAndFoldGreedily()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00184">applyPatternsAndFoldGreedily()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00217">applyPatternsGreedily()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00913">applyPatternsGreedily()</a>, <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00125">mlir::impl::LowerSparseIterationToSCFBase&lt; DerivedT &gt;::classof()</a>, <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00193">mlir::impl::LowerSparseOpsToForeachBase&lt; DerivedT &gt;::classof()</a>, <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00337">mlir::impl::SparseAssemblerBase&lt; DerivedT &gt;::classof()</a>, <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00408">mlir::impl::SparseBufferRewriteBase&lt; DerivedT &gt;::classof()</a>, <a class="el" href="ExtendToSupportedTypes_8cpp_source.html#l00158">mlir::math::impl::MathExtendToSupportedTypesBase&lt; DerivedT &gt;::classof()</a>, <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00413">mlir::impl::SparseBufferRewriteBase&lt; DerivedT &gt;::clonePass()</a>, <a class="el" href="#a4e36f1b7aaec9319e5ba11077079aa4e">convertAffineLoopNestToGPULaunch()</a>, <a class="el" href="AsyncToLLVM_8cpp_source.html#l01050">mlir::impl::ConvertAsyncToLLVMPassBase&lt; DerivedT &gt;::ConvertAsyncToLLVMPassBase()</a>, <a class="el" href="classmlir_1_1impl_1_1ConvertAsyncToLLVMPassBase.html#ab349b3c2d496bb053c129e4b4b3f8a0b">mlir::impl::ConvertAsyncToLLVMPassBase&lt; DerivedT &gt;::ConvertAsyncToLLVMPassBase()</a>, <a class="el" href="MaskedloadToLoad_8cpp_source.html#l00249">mlir::amdgpu::impl::AmdgpuMaskedloadToLoadPassBase&lt; DerivedT &gt;::createAmdgpuMaskedloadToLoadPass</a>, <a class="el" href="EmulateUnsupportedFloats_8cpp_source.html#l00107">mlir::arith::createArithEmulateUnsupportedFloats()</a>, <a class="el" href="Loops_8cpp_source.html#l00319">mlir::impl::ConvertLinalgToParallelLoopsPassBase&lt; DerivedT &gt;::createConvertLinalgToParallelLoopsPass</a>, <a class="el" href="MemRef_2Transforms_2ExpandOps_8cpp_source.html#l00088">mlir::memref::createExpandOpsPass()</a>, <a class="el" href="NormalizeQuantTypes_8cpp_source.html#l00161">mlir::quant::createNormalizeQuantTypes()</a>, <a class="el" href="#ac113f2b89a3f2ad9abce500e0c48d9f4">createSparseAssembler()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00354">mlir::xegpu::doSCFStructuralTypeConversionWithTensorType()</a>, <a class="el" href="ReductionTreePass_8cpp_source.html#l00084">findOptimal()</a>, <a class="el" href="FlattenMemRefs_8cpp_source.html#l00286">mlir::memref::impl::FlattenMemrefsPassBase&lt; DerivedT &gt;::FlattenMemrefsPassBase()</a>, <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html#af5c3a6f0789085417bba8cc6c16c8938">mlir::FrozenRewritePatternSet::FrozenRewritePatternSet()</a>, <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html#a02589cc0c1f431b65ac47e06b933439a">mlir::FrozenRewritePatternSet::FrozenRewritePatternSet()</a>, <a class="el" href="FrozenRewritePatternSet_8cpp_source.html#l00062">mlir::FrozenRewritePatternSet::FrozenRewritePatternSet()</a>, <a class="el" href="BubbleDownMemorySpaceCasts_8cpp_source.html#l00060">mlir::impl::BubbleDownMemorySpaceCastsBase&lt; DerivedT &gt;::getArgument()</a>, <a class="el" href="ArmSMEToLLVM_8cpp_source.html#l00911">mlir::impl::ConvertArmSMEToLLVMBase&lt; DerivedT &gt;::getArgument()</a>, <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00114">mlir::impl::LowerSparseIterationToSCFBase&lt; DerivedT &gt;::getArgument()</a>, <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00182">mlir::impl::LowerSparseOpsToForeachBase&lt; DerivedT &gt;::getArgument()</a>, <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00256">mlir::impl::PreSparsificationRewriteBase&lt; DerivedT &gt;::getArgument()</a>, <a class="el" href="BubbleDownMemorySpaceCasts_8cpp_source.html#l00057">mlir::impl::BubbleDownMemorySpaceCastsBase&lt; DerivedT &gt;::getArgumentName()</a>, <a class="el" href="ArmSMEToLLVM_8cpp_source.html#l00908">mlir::impl::ConvertArmSMEToLLVMBase&lt; DerivedT &gt;::getArgumentName()</a>, <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00111">mlir::impl::LowerSparseIterationToSCFBase&lt; DerivedT &gt;::getArgumentName()</a>, <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00253">mlir::impl::PreSparsificationRewriteBase&lt; DerivedT &gt;::getArgumentName()</a>, <a class="el" href="ReductionTreePass_8cpp_source.html#l00149">mlir::impl::ReductionTreePassBase&lt; DerivedT &gt;::getArgumentName()</a>, <a class="el" href="FlattenMemRefs_8cpp_source.html#l00294">mlir::memref::impl::FlattenMemrefsPassBase&lt; DerivedT &gt;::getArgumentName()</a>, <a class="el" href="DecorateCompositeTypeLayoutPass_8cpp_source.html#l00119">mlir::spirv::impl::SPIRVCompositeTypeLayoutPassBase&lt; DerivedT &gt;::getArgumentName()</a>, <a class="el" href="ExpandRealloc_8cpp_source.html#l00153">mlir::memref::impl::ExpandReallocPassBase&lt; DerivedT &gt;::getDependentDialects()</a>, <a class="el" href="AsyncToLLVM_8cpp_source.html#l01063">mlir::impl::ConvertAsyncToLLVMPassBase&lt; DerivedT &gt;::getDescription()</a>, <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00184">mlir::impl::LowerSparseOpsToForeachBase&lt; DerivedT &gt;::getDescription()</a>, <a class="el" href="Tiling_8cpp_source.html#l00850">mlir::linalg::getLinalgTilingCanonicalizationPatterns()</a>, <a class="el" href="FormExpressions_8cpp_source.html#l00049">mlir::emitc::impl::FormExpressionsPassBase&lt; DerivedT &gt;::getName()</a>, <a class="el" href="BubbleDownMemorySpaceCasts_8cpp_source.html#l00068">mlir::impl::BubbleDownMemorySpaceCastsBase&lt; DerivedT &gt;::getName()</a>, <a class="el" href="AsyncToLLVM_8cpp_source.html#l01069">mlir::impl::ConvertAsyncToLLVMPassBase&lt; DerivedT &gt;::getName()</a>, <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00058">mlir::impl::LowerForeachToSCFBase&lt; DerivedT &gt;::getName()</a>, <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00122">mlir::impl::LowerSparseIterationToSCFBase&lt; DerivedT &gt;::getName()</a>, <a class="el" href="ReductionTreePass_8cpp_source.html#l00160">mlir::impl::ReductionTreePassBase&lt; DerivedT &gt;::getName()</a>, <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00334">mlir::impl::SparseAssemblerBase&lt; DerivedT &gt;::getName()</a>, <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00405">mlir::impl::SparseBufferRewriteBase&lt; DerivedT &gt;::getName()</a>, <a class="el" href="FormExpressions_8cpp_source.html#l00046">mlir::emitc::impl::FormExpressionsPassBase&lt; DerivedT &gt;::getPassName()</a>, <a class="el" href="CAPI_2Transforms_2Rewrite_8cpp_source.html#l00286">mlirApplyPatternsAndFoldGreedily()</a>, <a class="el" href="CAPI_2Transforms_2Rewrite_8cpp_source.html#l00293">mlirApplyPatternsAndFoldGreedilyWithOp()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03283">mlir::OperationConverter::OperationConverter()</a>, <a class="el" href="classmlir_1_1emitc_1_1impl_1_1WrapFuncInClassPassBase.html#a1d9cda162de56089b5d7c77221b0a48c">mlir::emitc::impl::WrapFuncInClassPassBase&lt; DerivedT &gt;::operator=()</a>, <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html#a875065e6d1adef0c78557a23665dc0c9">mlir::FrozenRewritePatternSet::operator=()</a>, <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html#a496add6f7399882a450d604149022376">mlir::FrozenRewritePatternSet::operator=()</a>, <a class="el" href="classmlir_1_1impl_1_1PreSparsificationRewriteBase.html#aa3b9a93fab22e1b58dfdce88995725d5">mlir::impl::PreSparsificationRewriteBase&lt; DerivedT &gt;::operator=()</a>, <a class="el" href="classmlir_1_1impl_1_1SparseAssemblerBase.html#ae11c86b2bfd71aec6a386bd7ec264326">mlir::impl::SparseAssemblerBase&lt; DerivedT &gt;::operator=()</a>, <a class="el" href="classmlir_1_1memref_1_1impl_1_1FlattenMemrefsPassBase.html#ab90621240b0e09b14f9e25c7b5d954a4">mlir::memref::impl::FlattenMemrefsPassBase&lt; DerivedT &gt;::operator=()</a>, <a class="el" href="AffineExpandIndexOpsAsAffine_8cpp_source.html#l00089">mlir::affine::populateAffineExpandIndexOpsAsAffinePatterns()</a>, <a class="el" href="AffineExpandIndexOps_8cpp_source.html#l00229">mlir::affine::populateAffineExpandIndexOpsPatterns()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00527">populateAffineToStdConversionPatterns()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00545">populateAffineToVectorConversionPatterns()</a>, <a class="el" href="Shard_2Transforms_2Transforms_8cpp_source.html#l00190">mlir::shard::populateAllOpLoweringPatterns()</a>, <a class="el" href="Simplifications_8h_source.html#l00040">mlir::shard::populateAllReduceEndomorphismSimplificationPatterns()</a>, <a class="el" href="Shard_2Transforms_2Transforms_8cpp_source.html#l00178">mlir::shard::populateAllSliceOpLoweringPatterns()</a>, <a class="el" href="EmulateAtomics_8cpp_source.html#l00166">mlir::amdgpu::populateAmdgpuEmulateAtomicsPatterns()</a>, <a class="el" href="FoldMemRefsOps_8cpp_source.html#l00110">mlir::amdgpu::populateAmdgpuFoldMemRefOpsPatterns()</a>, <a class="el" href="MaskedloadToLoad_8cpp_source.html#l00240">mlir::amdgpu::populateAmdgpuMaskedloadToLoadPatterns()</a>, <a class="el" href="ResolveStridedMetadata_8cpp_source.html#l00068">mlir::amdgpu::populateAmdgpuResolveStridedMetadataPatterns()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l03052">populateAMDGPUToROCDLConversionPatterns()</a>, <a class="el" href="AMX_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00041">populateAMXLegalizeForLLVMExportPatterns()</a>, <a class="el" href="Arith_2Transforms_2ExpandOps_8cpp_source.html#l00827">mlir::arith::populateArithExpandOpsPatterns()</a>, <a class="el" href="Arith_2Transforms_2EmulateNarrowType_8cpp_source.html#l00050">mlir::arith::populateArithNarrowTypeEmulationPatterns()</a>, <a class="el" href="ArithToAMDGPU_8cpp_source.html#l00687">mlir::arith::populateArithToAMDGPUConversionPatterns()</a>, <a class="el" href="ArithToArmSME_8cpp_source.html#l00102">mlir::arith::populateArithToArmSMEConversionPatterns()</a>, <a class="el" href="ArithToEmitC_8cpp_source.html#l00806">populateArithToEmitCPatterns()</a>, <a class="el" href="ArithToLLVM_8cpp_source.html#l00607">mlir::arith::populateArithToLLVMConversionPatterns()</a>, <a class="el" href="ArithToSPIRV_8cpp_source.html#l01349">mlir::arith::populateArithToSPIRVPatterns()</a>, <a class="el" href="Arith_2Transforms_2EmulateWideInt_8cpp_source.html#l01288">mlir::arith::populateArithWideIntEmulationPatterns()</a>, <a class="el" href="ArmSMEToLLVM_8cpp_source.html#l00973">populateArmSMEToLLVMConversionPatterns()</a>, <a class="el" href="ArmSMEToSCF_8cpp_source.html#l00403">populateArmSMEToSCFConversionPatterns()</a>, <a class="el" href="ArmSVE_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00187">populateArmSVELegalizeForLLVMExportPatterns()</a>, <a class="el" href="ControlFlowToLLVM_8cpp_source.html#l00247">mlir::cf::populateAssertToLLVMConversionPattern()</a>, <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00853">populateAsyncFuncToAsyncRuntimeConversionPatterns()</a>, <a class="el" href="AsyncParallelFor_8cpp_source.html#l00929">mlir::async::populateAsyncParallelForPatterns()</a>, <a class="el" href="AsyncToLLVM_8cpp_source.html#l01151">populateAsyncStructuralTypeConversionsAndLegality()</a>, <a class="el" href="BlockPackMatmul_8cpp_source.html#l00319">mlir::linalg::populateBlockPackMatmulPatterns()</a>, <a class="el" href="#a67ef267fd846574457641b3fc2ec2088">populateBranchOpInterfaceTypeConversionPattern()</a>, <a class="el" href="BubbleDownMemorySpaceCasts_8cpp_source.html#l00066">populateBubbleDownMemorySpaceCastPatterns()</a>, <a class="el" href="ReshapePatterns_8cpp_source.html#l00730">mlir::tensor::populateBubbleUpExpandShapePatterns()</a>, <a class="el" href="BubbleUpExtractSlice_8cpp_source.html#l00131">mlir::linalg::populateBubbleUpExtractSliceOpPatterns()</a>, <a class="el" href="ReshapePatterns_8cpp_source.html#l00735">mlir::tensor::populateBubbleUpExtractSliceOpPatterns()</a>, <a class="el" href="LowerDeallocations_8cpp_source.html#l00546">mlir::bufferization::populateBufferizationDeallocLoweringPattern()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l01717">populateBuiltinFuncToSPIRVPatterns()</a>, <a class="el" href="FuncConversions_8cpp_source.html#l00067">populateCallOpTypeConversionPattern()</a>, <a class="el" href="Arith_2Transforms_2ExpandOps_8cpp_source.html#l00799">mlir::arith::populateCeilFloorDivExpandOpsPatterns()</a>, <a class="el" href="ControlFlow_2Transforms_2StructuralTypeConversions_8cpp_source.html#l00151">mlir::cf::populateCFStructuralTypeConversions()</a>, <a class="el" href="ControlFlow_2Transforms_2StructuralTypeConversions_8cpp_source.html#l00164">mlir::cf::populateCFStructuralTypeConversionsAndLegality()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l02462">mlir::linalg::populateCollapseDimensions()</a>, <a class="el" href="CommutativityUtils_8cpp_source.html#l00311">populateCommutativityUtilsPatterns()</a>, <a class="el" href="ComplexToLibm_8cpp_source.html#l00099">populateComplexToLibmConversionPatterns()</a>, <a class="el" href="#a2587dd2d601cb5613d673f9eae76b615">populateComplexToLLVMConversionPatterns()</a>, <a class="el" href="ComplexToROCDLLibraryCalls_8cpp_source.html#l00109">populateComplexToROCDLLibraryCallsConversionPatterns()</a>, <a class="el" href="ComplexToSPIRV_8cpp_source.html#l00103">populateComplexToSPIRVPatterns()</a>, <a class="el" href="#a7561db931b79277cde554d85e85f2bc6">populateComplexToStandardConversionPatterns()</a>, <a class="el" href="ComposeSubView_8cpp_source.html#l00139">mlir::memref::populateComposeSubViewPatterns()</a>, <a class="el" href="ConstantFold_8cpp_source.html#l00304">mlir::linalg::populateConstantFoldLinalgOperations()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l01106">mlir::linalg::populateContractionOpRankReducingPatterns()</a>, <a class="el" href="ControlFlowToLLVM_8cpp_source.html#l00237">mlir::cf::populateControlFlowToLLVMConversionPatterns()</a>, <a class="el" href="ControlFlowToSPIRV_8cpp_source.html#l00108">mlir::cf::populateControlFlowToSPIRVPatterns()</a>, <a class="el" href="ToLLVMInterface_8cpp_source.html#l00015">populateConversionTargetFromOperation()</a>, <a class="el" href="#a93264171f98ba147ce9b57df5866b96a">populateConversionTargetFromOperation()</a>, <a class="el" href="ArmNeon2dToIntr_8cpp_source.html#l00068">populateConvertArmNeon2dToIntrPatterns()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00741">mlir::linalg::populateConvertConv2DToImg2ColPatterns()</a>, <a class="el" href="MathToEmitC_8cpp_source.html#l00060">populateConvertMathToEmitCPatterns()</a>, <a class="el" href="ConvertShapeConstraints_8cpp_source.html#l00042">populateConvertShapeConstraintsConversionPatterns()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00615">mlir::linalg::populateConvertToDestinationStylePatterns()</a>, <a class="el" href="classmlir_1_1ConvertToEmitCPatternInterface.html#ae6d29bff65d574ca7406fd7830907bc8">mlir::ConvertToEmitCPatternInterface::populateConvertToEmitCConversionPatterns()</a>, <a class="el" href="classmlir_1_1ConvertToLLVMPatternInterface.html#a3f8093f0b01dffeeb475055c948cd275">mlir::ConvertToLLVMPatternInterface::populateConvertToLLVMConversionPatterns()</a>, <a class="el" href="namespacemlir_1_1linalg.html#a891b8f2d145dcc3327ba55c7a49d44e4">mlir::linalg::populateConvolutionVectorizationPatterns()</a>, <a class="el" href="DataLayoutPropagation_8cpp_source.html#l01609">mlir::linalg::populateDataLayoutPropagationPatterns()</a>, <a class="el" href="BufferizationOps_8cpp_source.html#l01193">mlir::bufferization::populateDeallocOpCanonicalizationPatterns()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01650">mlir::linalg::populateDecomposeConvolutionPatterns()</a>, <a class="el" href="DecomposeLinalgOps_8cpp_source.html#l00384">mlir::linalg::populateDecomposeLinalgOpsPattern()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01671">mlir::linalg::populateDecomposePackUnpackPatterns()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01676">mlir::linalg::populateDecomposePadPatterns()</a>, <a class="el" href="DecomposeGenericByUnfoldingPermutation_8cpp_source.html#l00245">mlir::linalg::populateDecomposeProjectedPermutationPatterns()</a>, <a class="el" href="ConcatOpPatterns_8cpp_source.html#l00046">mlir::tensor::populateDecomposeTensorConcatPatterns()</a>, <a class="el" href="WinogradConv2D_8cpp_source.html#l01220">mlir::linalg::populateDecomposeWinogradOpsPatterns()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02372">mlir::vector::populateDropInnerMostUnitDimsXferOpPatterns()</a>, <a class="el" href="MergeConsecutiveInsertExtractSlicePatterns_8cpp_source.html#l00238">mlir::tensor::populateDropRedundantInsertSliceRankExpansionPatterns()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l02451">mlir::linalg::populateElementwiseOpsFusionPatterns()</a>, <a class="el" href="ElementwiseToLinalg_8cpp_source.html#l00155">mlir::linalg::populateElementwiseToLinalgConversionPatterns()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02407">mlir::vector::populateElementwiseToVectorOpsPatterns()</a>, <a class="el" href="EmptyTensorToAllocTensor_8cpp_source.html#l00051">mlir::bufferization::populateEmptyTensorToAllocTensorPattern()</a>, <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html#l00438">mlir::linalg::populateEraseUnnecessaryInputsPatterns()</a>, <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html#l00431">mlir::linalg::populateEraseUnusedOperandsAndResultsPatterns()</a>, <a class="el" href="Arith_2Transforms_2ExpandOps_8cpp_source.html#l00806">mlir::arith::populateExpandBFloat16Patterns()</a>, <a class="el" href="Arith_2Transforms_2ExpandOps_8cpp_source.html#l00811">mlir::arith::populateExpandF4E2M1Patterns()</a>, <a class="el" href="Arith_2Transforms_2ExpandOps_8cpp_source.html#l00816">mlir::arith::populateExpandF8E8M0Patterns()</a>, <a class="el" href="MemRef_2Transforms_2ExpandOps_8cpp_source.html#l00107">mlir::memref::populateExpandOpsPatterns()</a>, <a class="el" href="Arith_2Transforms_2ExpandOps_8cpp_source.html#l00821">mlir::arith::populateExpandScalingExtTruncPatterns()</a>, <a class="el" href="ExpandStridedMetadata_8cpp_source.html#l01116">mlir::memref::populateExpandStridedMetadataPatterns()</a>, <a class="el" href="Math_2Transforms_2ExpandOps_8cpp_source.html#l00678">mlir::math::populateExpansionPatterns()</a>, <a class="el" href="EmitC_2Transforms_2Transforms_8cpp_source.html#l00154">mlir::emitc::populateExpressionPatterns()</a>, <a class="el" href="ExtendToSupportedTypes_8cpp_source.html#l00116">mlir::math::populateExtendToSupportedTypesPatterns()</a>, <a class="el" href="ExtractAddressComputations_8cpp_source.html#l00282">mlir::memref::populateExtractAddressComputationsPatterns()</a>, <a class="el" href="DataLayoutPropagation_8cpp_source.html#l01621">mlir::linalg::populateExtractSliceSinkingPatterns()</a>, <a class="el" href="MemRefToLLVM_8cpp_source.html#l02038">populateFinalizeMemRefToLLVMConversionPatterns()</a>, <a class="el" href="FlattenMemRefs_8cpp_source.html#l00285">mlir::memref::populateFlattenMemrefOpsPatterns()</a>, <a class="el" href="FlattenMemRefs_8cpp_source.html#l00293">mlir::memref::populateFlattenMemrefsPatterns()</a>, <a class="el" href="FlattenMemRefs_8cpp_source.html#l00274">mlir::memref::populateFlattenVectorOpsOnMemrefPatterns()</a>, <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00589">populateFloatIntOpPatterns()</a>, <a class="el" href="FoldAddIntoDest_8cpp_source.html#l00147">mlir::linalg::populateFoldAddIntoDestPatterns()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02319">mlir::vector::populateFoldArithExtensionPatterns()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01437">mlir::tensor::populateFoldCollapseExtractPatterns()</a>, <a class="el" href="TensorOps_8cpp_source.html#l02694">mlir::tensor::populateFoldConstantExtractSlicePatterns()</a>, <a class="el" href="Simplifications_8cpp_source.html#l00114">mlir::shard::populateFoldingPatterns()</a>, <a class="el" href="PackAndUnpackPatterns_8cpp_source.html#l00609">mlir::linalg::populateFoldIntoPackAndUnpackPatterns()</a>, <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00671">mlir::memref::populateFoldMemRefAliasOpPatterns()</a>, <a class="el" href="PackAndUnpackPatterns_8cpp_source.html#l00624">mlir::linalg::populateFoldPackUnpackIntoTensorEmptyPatterns()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l02438">mlir::linalg::populateFoldReshapeOpsByCollapsingPatterns()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l02425">mlir::linalg::populateFoldReshapeOpsByExpansionPatterns()</a>, <a class="el" href="EmptyOpPatterns_8cpp_source.html#l00130">mlir::tensor::populateFoldTensorEmptyPatterns()</a>, <a class="el" href="FoldTensorSubsetOps_8cpp_source.html#l00254">mlir::tensor::populateFoldTensorSubsetIntoVectorTransferPatterns()</a>, <a class="el" href="FoldTensorSubsetOps_8cpp_source.html#l00247">mlir::tensor::populateFoldTensorSubsetOpPatterns()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00836">mlir::linalg::populateFoldUnitExtentDimsPatterns()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00803">populateFoldUnitExtentDimsViaReshapesPatterns()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00823">populateFoldUnitExtentDimsViaSlicesPatterns()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l01722">populateFuncOpVectorRewritePatterns()</a>, <a class="el" href="FuncToEmitC_8cpp_source.html#l00164">populateFuncToEmitCPatterns()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00791">populateFuncToLLVMConversionPatterns()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00785">populateFuncToLLVMFuncOpConversionPattern()</a>, <a class="el" href="FuncToSPIRV_8cpp_source.html#l00087">populateFuncToSPIRVPatterns()</a>, <a class="el" href="FusePadOpWithLinalgProducer_8cpp_source.html#l00120">mlir::linalg::populateFuseTensorPadWithProducerLinalgOpPatterns()</a>, <a class="el" href="AllReduceLowering_8cpp_source.html#l00377">populateGpuAllReducePatterns()</a>, <a class="el" href="SubgroupReduceLowering_8cpp_source.html#l00563">populateGpuBreakDownSubgroupReducePatterns()</a>, <a class="el" href="DecomposeMemRefs_8cpp_source.html#l00236">populateGpuDecomposeMemrefsPatterns()</a>, <a class="el" href="EliminateBarriers_8cpp_source.html#l00617">populateGpuEliminateBarriersPatterns()</a>, <a class="el" href="GlobalIdRewriter_8cpp_source.html#l00043">populateGpuGlobalIdPatterns()</a>, <a class="el" href="SubgroupReduceLowering_8cpp_source.html#l00579">populateGpuLowerClusteredSubgroupReduceToDPPPatterns()</a>, <a class="el" href="SubgroupReduceLowering_8cpp_source.html#l00595">populateGpuLowerClusteredSubgroupReduceToShufflePatterns()</a>, <a class="el" href="SubgroupReduceLowering_8cpp_source.html#l00571">populateGpuLowerSubgroupReduceToDPPPatterns()</a>, <a class="el" href="SubgroupReduceLowering_8cpp_source.html#l00587">populateGpuLowerSubgroupReduceToShufflePatterns()</a>, <a class="el" href="PromoteShuffleToAMDGPU_8cpp_source.html#l00101">populateGpuPromoteShuffleToAMDGPUPatterns()</a>, <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l00091">populateGpuRewritePatterns()</a>, <a class="el" href="ShuffleRewriter_8cpp_source.html#l00095">populateGpuShufflePatterns()</a>, <a class="el" href="SubgroupIdRewriter_8cpp_source.html#l00083">populateGpuSubgroupIdPatterns()</a>, <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00598">populateGpuSubgroupReduceOpLoweringPattern()</a>, <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l01790">populateGpuToLLVMConversionPatterns()</a>, <a class="el" href="GPUToLLVMSPV_8cpp_source.html#l00505">populateGpuToLLVMSPVConversionPatterns()</a>, <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00695">populateGpuToNVVMConversionPatterns()</a>, <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html#l00431">populateGpuToROCDLConversionPatterns()</a>, <a class="el" href="GPUToSPIRV_8cpp_source.html#l00830">populateGPUToSPIRVPatterns()</a>, <a class="el" href="WmmaOpsToNvvm_8cpp_source.html#l00423">populateGpuWMMAToNVVMConversionPatterns()</a>, <a class="el" href="WmmaOpsToSPIRV_8cpp_source.html#l00355">populateGpuWMMAToSPIRVCoopMatrixKHRConversionPatterns()</a>, <a class="el" href="IndexToLLVM_8cpp_source.html#l00294">mlir::index::populateIndexToLLVMConversionPatterns()</a>, <a class="el" href="IndexToSPIRV_8cpp_source.html#l00342">mlir::index::populateIndexToSPIRVPatterns()</a>, <a class="el" href="InlineScalarOperands_8cpp_source.html#l00098">mlir::linalg::populateInlineConstantOperandsPatterns()</a>, <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00580">populateIntOpPatterns()</a>, <a class="el" href="IntRangeOptimizations_8cpp_source.html#l00541">mlir::arith::populateIntRangeNarrowingPatterns()</a>, <a class="el" href="IntRangeOptimizations_8cpp_source.html#l00535">mlir::arith::populateIntRangeOptimizationsPatterns()</a>, <a class="el" href="LegalizeVectorStorage_8cpp_source.html#l00443">mlir::arm_sve::populateLegalizeVectorStoragePatterns()</a>, <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00604">populateLibDeviceConversionPatterns()</a>, <a class="el" href="FoldIntoElementwise_8cpp_source.html#l00084">mlir::linalg::populateLinalgFoldIntoElementwisePatterns()</a>, <a class="el" href="Specialize_8cpp_source.html#l00425">mlir::linalg::populateLinalgGenericOpsSpecializationPatterns()</a>, <a class="el" href="Generalization_8cpp_source.html#l00089">mlir::linalg::populateLinalgNamedOpsGeneralizationPatterns()</a>, <a class="el" href="NamedToElementwise_8cpp_source.html#l00073">mlir::linalg::populateLinalgNamedToElementwisePatterns()</a>, <a class="el" href="Tiling_8cpp_source.html#l00856">mlir::linalg::populateLinalgTilingCanonicalizationPatterns()</a>, <a class="el" href="LinalgToStandard_8cpp_source.html#l00126">mlir::linalg::populateLinalgToStandardConversionPatterns()</a>, <a class="el" href="LowerContractToNeonPatterns_8cpp_source.html#l00493">mlir::arm_neon::populateLowerContractionToNeonBFMMLAPatterns()</a>, <a class="el" href="LowerContractToNeonPatterns_8cpp_source.html#l00487">mlir::arm_neon::populateLowerContractionToNeonI8MMPatterns()</a>, <a class="el" href="LowerContractToSVEPatterns_8cpp_source.html#l00590">populateLowerContractionToSVEBFMMLAPatterns()</a>, <a class="el" href="LowerContractToSVEPatterns_8cpp_source.html#l00584">populateLowerContractionToSVEI8MMPatterns()</a>, <a class="el" href="SparseTensorRewriting_8cpp_source.html#l01595">populateLowerForeachToSCFPatterns()</a>, <a class="el" href="LowerQuantOps_8cpp_source.html#l00781">mlir::quant::populateLowerQuantOpsPatterns()</a>, <a class="el" href="SparseIterationToScf_8cpp_source.html#l00452">populateLowerSparseIterationToSCFPatterns()</a>, <a class="el" href="SparseTensorRewriting_8cpp_source.html#l01579">populateLowerSparseOpsToForeachPatterns()</a>, <a class="el" href="AlgebraicSimplification_8cpp_source.html#l00246">populateMathAlgebraicSimplificationPatterns()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l01785">populateMathF32ExpansionPattern()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l01793">populateMathF32ExpansionPatterns()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l01825">populateMathPolynomialApproximationPattern()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l01875">populateMathPolynomialApproximationPatterns()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l01833">populateMathPolynomialApproximationPatterns()</a>, <a class="el" href="MathToLibm_8cpp_source.html#l00163">populateMathToLibmConversionPatterns()</a>, <a class="el" href="MathToLLVM_8cpp_source.html#l00419">populateMathToLLVMConversionPatterns()</a>, <a class="el" href="MathToROCDL_8cpp_source.html#l00085">populateMathToROCDLConversionPatterns()</a>, <a class="el" href="MathToSPIRV_8cpp_source.html#l00488">populateMathToSPIRVPatterns()</a>, <a class="el" href="MathToXeVM_8cpp_source.html#l00122">populateMathToXeVMConversionPatterns()</a>, <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00602">mlir::memref::populateMemRefNarrowTypeEmulationPatterns()</a>, <a class="el" href="MemRefToEmitC_8cpp_source.html#l00407">populateMemRefToEmitCConversionPatterns()</a>, <a class="el" href="MemRefToSPIRV_8cpp_source.html#l01105">populateMemRefToSPIRVPatterns()</a>, <a class="el" href="MemRef_2Transforms_2EmulateWideInt_8cpp_source.html#l00140">mlir::memref::populateMemRefWideIntEmulationPatterns()</a>, <a class="el" href="MergeConsecutiveInsertExtractSlicePatterns_8cpp_source.html#l00230">mlir::tensor::populateMergeConsecutiveInsertExtractSlicePatterns()</a>, <a class="el" href="MmaSyncTF32Transform_8cpp_source.html#l00065">mlir::nvgpu::populateMmaSyncF32ToTF32Patterns()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00848">mlir::linalg::populateMoveInitOperandsToInputPattern()</a>, <a class="el" href="MPIToLLVM_8cpp_source.html#l00796">mlir::mpi::populateMPIToLLVMConversionPatterns()</a>, <a class="el" href="NVGPUToNVVM_8cpp_source.html#l01722">populateNVGPUToNVVMConversionPatterns()</a>, <a class="el" href="NVVMToLLVM_8cpp_source.html#l00112">populateNVVMToLLVMConversionPatterns()</a>, <a class="el" href="ToLLVMInterface_8cpp_source.html#l00033">populateOpConvertToLLVMConversionPatterns()</a>, <a class="el" href="OpenACCToSCF_8cpp_source.html#l00059">populateOpenACCToSCFConversionPatterns()</a>, <a class="el" href="OpenMPToLLVM_8cpp_source.html#l00150">populateOpenMPToLLVMConversionPatterns()</a>, <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00568">populateOpPatterns()</a>, <a class="el" href="MathToROCDL_8cpp_source.html#l00039">populateOpPatterns()</a>, <a class="el" href="OuterProductFusion_8cpp_source.html#l00534">mlir::arm_sme::populateOuterProductFusionPatterns()</a>, <a class="el" href="namespacemlir_1_1linalg.html#a43c2ef8a778a33a17885475c11b50bdd">mlir::linalg::populatePadOpVectorizationPatterns()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00770">populateParallelLoopToGPUPatterns()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l01778">populatePolynomialApproximateErfcPattern()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l01773">populatePolynomialApproximateErfPattern()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l01768">populatePolynomialApproximateTanhPattern()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l01229">populatePrepareVectorToMMAPatterns()</a>, <a class="el" href="SparseTensorRewriting_8cpp_source.html#l01572">populatePreSparsificationRewriting()</a>, <a class="el" href="Shard_2Transforms_2Transforms_8cpp_source.html#l00168">mlir::shard::populateProcessMultiIndexOpLoweringPatterns()</a>, <a class="el" href="PtrToLLVM_8cpp_source.html#l00399">mlir::ptr::populatePtrToLLVMConversionPatterns()</a>, <a class="el" href="ReshapePatterns_8cpp_source.html#l00719">mlir::tensor::populateReassociativeReshapeFoldingPatterns()</a>, <a class="el" href="classmlir_1_1DialectReductionPatternInterface.html#a5af27675673592be7f857d9d5781e9fd">mlir::DialectReductionPatternInterface::populateReductionPatterns()</a>, <a class="el" href="ReductionPatternInterface_8h_source.html#l00056">mlir::DialectReductionPatternInterface::populateReductionPatternsWithTester()</a>, <a class="el" href="RemoveShapeConstraints_8cpp_source.html#l00064">populateRemoveShapeConstraintsPatterns()</a>, <a class="el" href="ExpandStridedMetadata_8cpp_source.html#l01137">mlir::memref::populateResolveExtractStridedMetadataPatterns()</a>, <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html#l00181">mlir::memref::populateResolveRankedShapedTypeResultDimsPatterns()</a>, <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html#l00188">mlir::memref::populateResolveShapedTypeResultDimsPatterns()</a>, <a class="el" href="FuncConversions_8cpp_source.html#l00164">populateReturnOpTypeConversionPattern()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l01726">populateReturnOpVectorRewritePatterns()</a>, <a class="el" href="RewriteAsConstant_8cpp_source.html#l00211">mlir::tensor::populateRewriteAsConstantPatterns()</a>, <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l01148">mlir::vector::populateScalarVectorTransferLoweringPatterns()</a>, <a class="el" href="LoopCanonicalization_8cpp_source.html#l00176">mlir::scf::populateSCFForLoopCanonicalizationPatterns()</a>, <a class="el" href="LoopPipelining_8cpp_source.html#l00847">mlir::scf::populateSCFLoopPipeliningPatterns()</a>, <a class="el" href="RotateWhileLoop_8cpp_source.html#l00040">mlir::scf::populateSCFRotateWhileLoopPatterns()</a>, <a class="el" href="SCF_2Transforms_2StructuralTypeConversions_8cpp_source.html#l00243">mlir::scf::populateSCFStructuralTypeConversions()</a>, <a class="el" href="SCF_2Transforms_2StructuralTypeConversions_8cpp_source.html#l00267">mlir::scf::populateSCFStructuralTypeConversionsAndLegality()</a>, <a class="el" href="SCFToControlFlow_8cpp_source.html#l00723">populateSCFToControlFlowConversionPatterns()</a>, <a class="el" href="SCFToEmitC_8cpp_source.html#l00504">populateSCFToEmitCConversionPatterns()</a>, <a class="el" href="SCFToSPIRV_8cpp_source.html#l00448">populateSCFToSPIRVPatterns()</a>, <a class="el" href="ShapeToShapeLowering_8cpp_source.html#l00080">populateShapeRewritePatterns()</a>, <a class="el" href="ShapeToStandard_8cpp_source.html#l00708">populateShapeToStandardConversionPatterns()</a>, <a class="el" href="Simplifications_8cpp_source.html#l00023">mlir::shard::populateSimplificationPatterns()</a>, <a class="el" href="SimplifyDepthwiseConv_8cpp_source.html#l00161">mlir::linalg::populateSimplifyDepthwiseConvPatterns()</a>, <a class="el" href="PackAndUnpackPatterns_8cpp_source.html#l00619">mlir::linalg::populateSimplifyPackAndUnpackPatterns()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02379">mlir::vector::populateSinkVectorOpsPatterns()</a>, <a class="el" href="SinkVectorProducerOps_8cpp_source.html#l00144">mlir::x86vector::populateSinkVectorProducerOpsPatterns()</a>, <a class="el" href="SparseAssembler_8cpp_source.html#l00249">populateSparseAssembler()</a>, <a class="el" href="SparseBufferRewriting_8cpp_source.html#l01430">populateSparseBufferRewriting()</a>, <a class="el" href="SparseGPUCodegen_8cpp_source.html#l01334">populateSparseGPUCodegenPatterns()</a>, <a class="el" href="SparseGPUCodegen_8cpp_source.html#l01339">populateSparseGPULibgenPatterns()</a>, <a class="el" href="SparseReinterpretMap_8cpp_source.html#l00796">populateSparseReinterpretMap()</a>, <a class="el" href="SparseTensorCodegen_8cpp_source.html#l01615">populateSparseTensorCodegenPatterns()</a>, <a class="el" href="SparseTensorConversion_8cpp_source.html#l00914">populateSparseTensorConversionPatterns()</a>, <a class="el" href="namespacemlir_1_1linalg.html#a49366865f5ce183ae19888eceb6667e5">mlir::linalg::populateSparseTensorRewriting()</a>, <a class="el" href="SparseVectorization_8cpp_source.html#l00682">populateSparseVectorizationPatterns()</a>, <a class="el" href="Sparsification_8cpp_source.html#l01482">populateSparsificationPatterns()</a>, <a class="el" href="AVXTranspose_8cpp_source.html#l00287">mlir::x86vector::avx2::populateSpecializedTransposeLoweringPatterns()</a>, <a class="el" href="SPIRVWebGPUTransforms_8cpp_source.html#l00250">mlir::spirv::populateSPIRVExpandExtendedMultiplicationPatterns()</a>, <a class="el" href="SPIRVWebGPUTransforms_8cpp_source.html#l00258">mlir::spirv::populateSPIRVExpandNonFiniteArithmeticPatterns()</a>, <a class="el" href="DecorateCompositeTypeLayoutPass_8cpp_source.html#l00101">populateSPIRVLayoutInfoPatterns()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l01790">populateSPIRVToLLVMConversionPatterns()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l01956">populateSPIRVToLLVMFunctionConversionPatterns()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l01961">populateSPIRVToLLVMModuleConversionPatterns()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00448">mlir::linalg::populateSplitReductionPattern()</a>, <a class="el" href="StageSparseOperations_8cpp_source.html#l00070">populateStageSparseOperationsPatterns()</a>, <a class="el" href="SparseStorageSpecifierToLLVM_8cpp_source.html#l00353">populateStorageSpecifierToLLVMPatterns()</a>, <a class="el" href="SwapExtractSliceWithFillPatterns_8cpp_source.html#l00042">mlir::linalg::populateSwapExtractSliceWithFillPatterns()</a>, <a class="el" href="TensorToLinalg_8cpp_source.html#l00024">populateTensorToLinalgPatterns()</a>, <a class="el" href="TensorToSPIRV_8cpp_source.html#l00103">populateTensorToSPIRVPatterns()</a>, <a class="el" href="TosaFolders_8cpp_source.html#l00449">mlir::tosa::populateTosaConstantReduction()</a>, <a class="el" href="TosaDecomposeDepthwise_8cpp_source.html#l00198">mlir::tosa::populateTosaDecomposeDepthwise()</a>, <a class="el" href="TosaDecomposeTransposeConv_8cpp_source.html#l00345">mlir::tosa::populateTosaDecomposeTransposeConv()</a>, <a class="el" href="TosaFolders_8cpp_source.html#l00471">mlir::tosa::populateTosaFoldConstantReciprocalPatterns()</a>, <a class="el" href="TosaFolders_8cpp_source.html#l00466">mlir::tosa::populateTosaFoldConstantTransposePatterns()</a>, <a class="el" href="TosaToArith_8cpp_source.html#l00258">mlir::tosa::populateTosaRescaleToArithConversionPatterns()</a>, <a class="el" href="TosaToArith_8cpp_source.html#l00253">mlir::tosa::populateTosaToArithConversionPatterns()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l03023">mlir::tosa::populateTosaToLinalgConversionPatterns()</a>, <a class="el" href="TosaToLinalgNamed_8cpp_source.html#l01117">mlir::tosa::populateTosaToLinalgNamedConversionPatterns()</a>, <a class="el" href="TosaToMLProgram_8cpp_source.html#l00072">mlir::tosa::populateTosaToMLProgramConversionPatterns()</a>, <a class="el" href="TosaToSCF_8cpp_source.html#l00174">mlir::tosa::populateTosaToSCFConversionPatterns()</a>, <a class="el" href="TosaToTensor_8cpp_source.html#l00459">mlir::tosa::populateTosaToTensorConversionPatterns()</a>, <a class="el" href="TransposeConv2D_8cpp_source.html#l00134">mlir::linalg::populateTransposeConv2DPatterns()</a>, <a class="el" href="TransposeMatmul_8cpp_source.html#l00168">mlir::linalg::populateTransposeMatmulPatterns()</a>, <a class="el" href="UBToLLVM_8cpp_source.html#l00115">mlir::ub::populateUBToLLVMConversionPatterns()</a>, <a class="el" href="UBToSPIRV_8cpp_source.html#l00087">mlir::ub::populateUBToSPIRVConversionPatterns()</a>, <a class="el" href="UnsignedWhenEquivalent_8cpp_source.html#l00143">mlir::arith::populateUnsignedWhenEquivalentPatterns()</a>, <a class="el" href="UpliftToFMA_8cpp_source.html#l00076">populateUpliftToFMAPatterns()</a>, <a class="el" href="UpliftWhileToFor_8cpp_source.html#l00269">mlir::scf::populateUpliftWhileToForPatterns()</a>, <a class="el" href="LowerVectorBitCast_8cpp_source.html#l00087">mlir::vector::populateVectorBitCastLoweringPatterns()</a>, <a class="el" href="LowerVectorBroadcast_8cpp_source.html#l00145">mlir::vector::populateVectorBroadcastLoweringPatterns()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02357">mlir::vector::populateVectorContractCanonicalizeMatmulToMMT()</a>, <a class="el" href="LowerVectorContract_8cpp_source.html#l01222">mlir::vector::populateVectorContractLoweringPatterns()</a>, <a class="el" href="VectorContractToFMA_8cpp_source.html#l00140">mlir::x86vector::populateVectorContractToFMAPatterns()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l02187">mlir::vector::populateVectorContractToMatrixMultiply()</a>, <a class="el" href="VectorContractToPackedTypeDotProduct_8cpp_source.html#l00298">mlir::x86vector::populateVectorContractToPackedTypeDotProductPatterns()</a>, <a class="el" href="LowerVectorGather_8cpp_source.html#l00250">mlir::vector::populateVectorGatherLoweringPatterns()</a>, <a class="el" href="LowerVectorGather_8cpp_source.html#l00255">mlir::vector::populateVectorGatherToConditionalLoadPatterns()</a>, <a class="el" href="LowerVectorInterleave_8cpp_source.html#l00185">mlir::vector::populateVectorInterleaveLoweringPatterns()</a>, <a class="el" href="LowerVectorInterleave_8cpp_source.html#l00191">mlir::vector::populateVectorInterleaveToShufflePatterns()</a>, <a class="el" href="VectorEmulateMaskedLoadStore_8cpp_source.html#l00163">mlir::vector::populateVectorMaskedLoadStoreEmulationPatterns()</a>, <a class="el" href="LowerVectorMask_8cpp_source.html#l00304">mlir::vector::populateVectorMaskLoweringPatternsForSideEffectingOps()</a>, <a class="el" href="LowerVectorMask_8cpp_source.html#l00163">mlir::vector::populateVectorMaskOpLoweringPatterns()</a>, <a class="el" href="LowerVectorMultiReduction_8cpp_source.html#l00514">mlir::vector::populateVectorMultiReductionLoweringPatterns()</a>, <a class="el" href="LowerVectorContract_8cpp_source.html#l01232">mlir::vector::populateVectorOuterProductLoweringPatterns()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l02182">mlir::vector::populateVectorRankReducingFMAPattern()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02365">mlir::vector::populateVectorReductionToContractPatterns()</a>, <a class="el" href="VectorToSPIRV_8cpp_source.html#l01092">populateVectorReductionToSPIRVDotProductPatterns()</a>, <a class="el" href="LowerVectorScan_8cpp_source.html#l00191">mlir::vector::populateVectorScanLoweringPatterns()</a>, <a class="el" href="LowerVectorShapeCast_8cpp_source.html#l00472">mlir::vector::populateVectorShapeCastLoweringPatterns()</a>, <a class="el" href="LowerVectorShuffle_8cpp_source.html#l00107">mlir::vector::populateVectorShuffleLoweringPatterns()</a>, <a class="el" href="LowerVectorStep_8cpp_source.html#l00046">mlir::vector::populateVectorStepLoweringPatterns()</a>, <a class="el" href="VectorToAMX_8cpp_source.html#l00426">populateVectorToAMXConversionPatterns()</a>, <a class="el" href="VectorToArmSME_8cpp_source.html#l00736">populateVectorToArmSMEPatterns()</a>, <a class="el" href="LowerVectorToFromElementsToShuffleTree_8cpp_source.html#l00740">mlir::vector::populateVectorToFromElementsToShuffleTreePatterns()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l02199">populateVectorToLLVMConversionPatterns()</a>, <a class="el" href="VectorToSCF_8cpp_source.html#l01697">populateVectorToSCFConversionPatterns()</a>, <a class="el" href="VectorToSPIRV_8cpp_source.html#l01069">populateVectorToSPIRVPatterns()</a>, <a class="el" href="namespacemlir_1_1vector.html#a901dfffd46bc2f80e977fdea83adc180">mlir::vector::populateVectorToVectorCanonicalizationPatterns()</a>, <a class="el" href="VectorToXeGPU_8cpp_source.html#l00826">populateVectorToXeGPUConversionPatterns()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00661">mlir::vector::populateVectorTransferFullPartialPatterns()</a>, <a class="el" href="LowerVectorTransfer_8cpp_source.html#l00585">mlir::vector::populateVectorTransferLoweringPatterns()</a>, <a class="el" href="LowerVectorTransfer_8cpp_source.html#l00382">mlir::vector::populateVectorTransferPermutationMapLoweringPatterns()</a>, <a class="el" href="LowerVectorTranspose_8cpp_source.html#l00494">mlir::vector::populateVectorTransposeLoweringPatterns()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l02192">mlir::vector::populateVectorTransposeToFlatTranspose()</a>, <a class="el" href="VectorDistribute_8cpp_source.html#l02267">mlir::vector::populateWarpExecuteOnLane0OpToScfForPattern()</a>, <a class="el" href="WinogradConv2D_8cpp_source.html#l01213">mlir::linalg::populateWinogradConv2DPatterns()</a>, <a class="el" href="X86Vector_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00041">populateX86VectorLegalizeForLLVMExportPatterns()</a>, <a class="el" href="XeGPUFoldAliasOps_8cpp_source.html#l00063">mlir::xegpu::populateXeGPUFoldAliasOpsPatterns()</a>, <a class="el" href="XeGPUSubgroupDistribute_8cpp_source.html#l02045">mlir::xegpu::populateXeGPUMoveFuncBodyToWarpOpPatterns()</a>, <a class="el" href="XeGPUOptimizeBlockLoads_8cpp_source.html#l00421">mlir::xegpu::populateXeGPUOptimizeBlockLoadsPatterns()</a>, <a class="el" href="XeGPUSubgroupDistribute_8cpp_source.html#l02025">mlir::xegpu::populateXeGPUSubgroupDistributePatterns()</a>, <a class="el" href="XeGPUToXeVM_8cpp_source.html#l01267">populateXeGPUToXeVMConversionPatterns()</a>, <a class="el" href="XeGPUUnroll_8cpp_source.html#l01033">mlir::xegpu::populateXeGPUUnrollPatterns()</a>, <a class="el" href="XeGPUWgToSgDistribute_8cpp_source.html#l01366">mlir::xegpu::populateXeGPUWgToSgDistributePatterns()</a>, <a class="el" href="XeVMToLLVM_8cpp_source.html#l00910">populateXeVMToLLVMConversionPatterns()</a>, <a class="el" href="MathToROCDL_8cpp_source.html#l00178">ConvertMathToROCDLPass::runOnOperation()</a>, <a class="el" href="FoldMemRefsOps_8cpp_source.html#l00024">mlir::amdgpu::AmdgpuFoldMemRefOpsPass::runOnOperation()</a>, <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l00241">SimplifyAffineMinMaxPass::runOnOperation()</a>, <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l00149">mlir::affine::simplifyAffineMinMaxOps()</a>, <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00316">mlir::impl::SparseAssemblerBase&lt; DerivedT &gt;::SparseAssemblerBase()</a>, <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00358">mlir::impl::SparseAssemblerBase&lt; DerivedT &gt;::SparseAssemblerBase()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l01491">mlir::spirv::unrollVectorsInFuncBodies()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l01478">mlir::spirv::unrollVectorsInSignatures()</a>, <a class="el" href="WalkPatternRewriteDriver_8cpp_source.html#l00093">walkAndApplyPatterns()</a>, <a class="el" href="classmlir_1_1emitc_1_1impl_1_1WrapFuncInClassPassBase.html#af8707ac592dba195700dd73a0bc9ecac">mlir::emitc::impl::WrapFuncInClassPassBase&lt; DerivedT &gt;::WrapFuncInClassPassBase()</a>, <a class="el" href="classmlir_1_1impl_1_1ConvertAsyncToLLVMPassBase.html#a7807ffc40b651eb6344210efecdaf5ec">mlir::impl::ConvertAsyncToLLVMPassBase&lt; DerivedT &gt;::~ConvertAsyncToLLVMPassBase()</a>, <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html#a9bb010492ea72da20baf697dba0291d2">mlir::FrozenRewritePatternSet::~FrozenRewritePatternSet()</a>, <a class="el" href="classmlir_1_1impl_1_1PreSparsificationRewriteBase.html#a7d3f1f62b355c033dc114a6c305a0907">mlir::impl::PreSparsificationRewriteBase&lt; DerivedT &gt;::~PreSparsificationRewriteBase()</a>, and <a class="el" href="classmlir_1_1impl_1_1SparseAssemblerBase.html#a888b5c09a61465a1ef86c4086633ac4f">mlir::impl::SparseAssemblerBase&lt; DerivedT &gt;::~SparseAssemblerBase()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
