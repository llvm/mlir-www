<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::spirv Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1spirv.html">spirv</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">mlir::spirv Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir_1_1spirv_1_1AttrNames"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv_1_1AttrNames.html">AttrNames</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1spirv_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1MemorySpaceToStorageClassConverter.html">MemorySpaceToStorageClassConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> converter for converting numeric MemRef memory spaces into SPIR-V symbolic ones.  <a href="classmlir_1_1spirv_1_1MemorySpaceToStorageClassConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1InterfaceVarABIAttr.html">InterfaceVarABIAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that specifies the information regarding the interface variable: descriptor set, binding, storage class.  <a href="classmlir_1_1spirv_1_1InterfaceVarABIAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1VerCapExtAttr.html">VerCapExtAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that specifies the SPIR-V (version, capabilities, extensions) triple.  <a href="classmlir_1_1spirv_1_1VerCapExtAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">TargetEnvAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that specifies the target version, allowed extensions and capabilities, and resource limits.  <a href="classmlir_1_1spirv_1_1TargetEnvAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1SPIRVType.html">SPIRVType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1ScalarType.html">ScalarType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1CompositeType.html">CompositeType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1ArrayType.html">ArrayType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1ImageType.html">ImageType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1PointerType.html">PointerType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1RuntimeArrayType.html">RuntimeArrayType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1SampledImageType.html">SampledImageType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1StructType.html">StructType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPIR-V struct type.  <a href="classmlir_1_1spirv_1_1StructType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1CooperativeMatrixType.html">CooperativeMatrixType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1MatrixType.html">MatrixType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1TensorArmType.html">TensorArmType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPIR-V TensorARM <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a>.  <a href="classmlir_1_1spirv_1_1TensorArmType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1TargetEnv.html">TargetEnv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper class around a <a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html" title="An attribute that specifies the target version, allowed extensions and capabilities,...">spirv::TargetEnvAttr</a> to provide query methods for allowed version/capabilities/extensions.  <a href="classmlir_1_1spirv_1_1TargetEnv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1spirv_1_1DeserializationOptions.html">DeserializationOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1spirv_1_1SerializationOptions.html">SerializationOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1spirv_1_1ElementwiseOpPattern.html">ElementwiseOpPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts elementwise unary, binary and ternary standard operations to SPIR-V operations.  <a href="structmlir_1_1spirv_1_1ElementwiseOpPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1spirv_1_1BlockMergeInfo.html">BlockMergeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct for containing a header block's merge and continue targets.  <a href="structmlir_1_1spirv_1_1BlockMergeInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1spirv_1_1DebugLine.html">DebugLine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct for containing OpLine instruction information.  <a href="structmlir_1_1spirv_1_1DebugLine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1spirv_1_1DeferredStructTypeInfo.html">DeferredStructTypeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A "deferred struct type" is a struct type with one or more member types not known when the <a class="el" href="classmlir_1_1spirv_1_1Deserializer.html" title="A SPIR-V module serializer.">Deserializer</a> first encounters the struct.  <a href="structmlir_1_1spirv_1_1DeferredStructTypeInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1spirv_1_1SpecConstOperationMaterializationInfo.html">SpecConstOperationMaterializationInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct that collects the info needed to materialize/emit a SpecConstantOperation op.  <a href="structmlir_1_1spirv_1_1SpecConstOperationMaterializationInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1Deserializer.html">Deserializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A SPIR-V module serializer.  <a href="classmlir_1_1spirv_1_1Deserializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1Serializer.html">Serializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A SPIR-V module serializer.  <a href="classmlir_1_1spirv_1_1Serializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7cb656d582fcb330d69a180edc76b7a8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a7cb656d582fcb330d69a180edc76b7a8">MemorySpaceToStorageClassMap</a> = std::function&lt; std::optional&lt; spirv::StorageClass &gt;(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt;</td></tr>
<tr class="memdesc:a7cb656d582fcb330d69a180edc76b7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapping from numeric MemRef memory spaces into SPIR-V symbolic ones.  <a href="namespacemlir_1_1spirv.html#a7cb656d582fcb330d69a180edc76b7a8">More...</a><br /></td></tr>
<tr class="separator:a7cb656d582fcb330d69a180edc76b7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac1b5d87a905e6e58d061fca3c4b9c2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#acac1b5d87a905e6e58d061fca3c4b9c2">SymbolRenameListener</a> = <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(spirv::ModuleOp originalModule, StringRef oldSymbol, StringRef newSymbol)&gt;</td></tr>
<tr class="memdesc:acac1b5d87a905e6e58d061fca3c4b9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The listener function to receive symbol renaming events.  <a href="namespacemlir_1_1spirv.html#acac1b5d87a905e6e58d061fca3c4b9c2">More...</a><br /></td></tr>
<tr class="separator:acac1b5d87a905e6e58d061fca3c4b9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738af61310165c2eb21778ca20406b6a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a738af61310165c2eb21778ca20406b6a">GetTargetEnvFn</a> = std::function&lt; <a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">spirv::TargetEnvAttr</a>(spirv::ModuleOp)&gt;</td></tr>
<tr class="memdesc:a738af61310165c2eb21778ca20406b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an operation pass that unifies access of multiple aliased resources into access of one single resource.  <a href="namespacemlir_1_1spirv.html#a738af61310165c2eb21778ca20406b6a">More...</a><br /></td></tr>
<tr class="separator:a738af61310165c2eb21778ca20406b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd480fdd0d8fb515c1419293ce3c0e4c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#acd480fdd0d8fb515c1419293ce3c0e4c">BlockMergeInfoMap</a> = <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; <a class="el" href="classmlir_1_1Block.html">Block</a> *, <a class="el" href="structmlir_1_1spirv_1_1BlockMergeInfo.html">BlockMergeInfo</a> &gt;</td></tr>
<tr class="memdesc:acd480fdd0d8fb515c1419293ce3c0e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map from a selection/loop's header block to its merge (and continue) target.  <a href="namespacemlir_1_1spirv.html#acd480fdd0d8fb515c1419293ce3c0e4c">More...</a><br /></td></tr>
<tr class="separator:acd480fdd0d8fb515c1419293ce3c0e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aff7500a2bef54b9434232db13ff7fc0f"><td class="memItemLeft" align="right" valign="top">std::optional&lt; spirv::StorageClass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#aff7500a2bef54b9434232db13ff7fc0f">mapMemorySpaceToVulkanStorageClass</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)</td></tr>
<tr class="memdesc:aff7500a2bef54b9434232db13ff7fc0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps MemRef memory spaces to storage classes for Vulkan-flavored SPIR-V using the default rule.  <a href="namespacemlir_1_1spirv.html#aff7500a2bef54b9434232db13ff7fc0f">More...</a><br /></td></tr>
<tr class="separator:aff7500a2bef54b9434232db13ff7fc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4d73b5b3c59e88355cb3ca823a2f37"><td class="memItemLeft" align="right" valign="top">std::optional&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#acb4d73b5b3c59e88355cb3ca823a2f37">mapVulkanStorageClassToMemorySpace</a> (spirv::StorageClass)</td></tr>
<tr class="memdesc:acb4d73b5b3c59e88355cb3ca823a2f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps storage classes for Vulkan-flavored SPIR-V to MemRef memory spaces using the default rule.  <a href="namespacemlir_1_1spirv.html#acb4d73b5b3c59e88355cb3ca823a2f37">More...</a><br /></td></tr>
<tr class="separator:acb4d73b5b3c59e88355cb3ca823a2f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9d2054fc47779669c16a7b94c1d8f8"><td class="memItemLeft" align="right" valign="top">std::optional&lt; spirv::StorageClass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a8f9d2054fc47779669c16a7b94c1d8f8">mapMemorySpaceToOpenCLStorageClass</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)</td></tr>
<tr class="memdesc:a8f9d2054fc47779669c16a7b94c1d8f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps MemRef memory spaces to storage classes for OpenCL-flavored SPIR-V using the default rule.  <a href="namespacemlir_1_1spirv.html#a8f9d2054fc47779669c16a7b94c1d8f8">More...</a><br /></td></tr>
<tr class="separator:a8f9d2054fc47779669c16a7b94c1d8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2fa0e61a068deec7045f64b7b9d647b"><td class="memItemLeft" align="right" valign="top">std::optional&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#af2fa0e61a068deec7045f64b7b9d647b">mapOpenCLStorageClassToMemorySpace</a> (spirv::StorageClass)</td></tr>
<tr class="memdesc:af2fa0e61a068deec7045f64b7b9d647b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps storage classes for OpenCL-flavored SPIR-V to MemRef memory spaces using the default rule.  <a href="namespacemlir_1_1spirv.html#af2fa0e61a068deec7045f64b7b9d647b">More...</a><br /></td></tr>
<tr class="separator:af2fa0e61a068deec7045f64b7b9d647b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20da364acf11b2fc680395daeeca97fc"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a20da364acf11b2fc680395daeeca97fc">getMemorySpaceToStorageClassTarget</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;)</td></tr>
<tr class="memdesc:a20da364acf11b2fc680395daeeca97fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the target that populates legality of ops with MemRef types.  <a href="namespacemlir_1_1spirv.html#a20da364acf11b2fc680395daeeca97fc">More...</a><br /></td></tr>
<tr class="separator:a20da364acf11b2fc680395daeeca97fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9f6b211dd293640a9a09e34fb90c3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a7e9f6b211dd293640a9a09e34fb90c3b">convertMemRefTypesAndAttrs</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1spirv_1_1MemorySpaceToStorageClassConverter.html">MemorySpaceToStorageClassConverter</a> &amp;typeConverter)</td></tr>
<tr class="memdesc:a7e9f6b211dd293640a9a09e34fb90c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts all MemRef types and attributes in the op, as decided by the <code>typeConverter</code>.  <a href="namespacemlir_1_1spirv.html#a7e9f6b211dd293640a9a09e34fb90c3b">More...</a><br /></td></tr>
<tr class="separator:a7e9f6b211dd293640a9a09e34fb90c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebec54b6a40e0cb8f2c7d3640663be4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; Extension &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a2ebec54b6a40e0cb8f2c7d3640663be4">getImpliedExtensions</a> (Version version)</td></tr>
<tr class="memdesc:a2ebec54b6a40e0cb8f2c7d3640663be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the implied extensions for the given version.  <a href="namespacemlir_1_1spirv.html#a2ebec54b6a40e0cb8f2c7d3640663be4">More...</a><br /></td></tr>
<tr class="separator:a2ebec54b6a40e0cb8f2c7d3640663be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6686e4cb7cffae099e00c124e04d5420"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; Capability &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a6686e4cb7cffae099e00c124e04d5420">getDirectImpliedCapabilities</a> (Capability cap)</td></tr>
<tr class="memdesc:a6686e4cb7cffae099e00c124e04d5420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the directly implied capabilities for the given capability.  <a href="namespacemlir_1_1spirv.html#a6686e4cb7cffae099e00c124e04d5420">More...</a><br /></td></tr>
<tr class="separator:a6686e4cb7cffae099e00c124e04d5420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d09788a1496828ace197176ce75e3d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; Capability, 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a1d09788a1496828ace197176ce75e3d9">getRecursiveImpliedCapabilities</a> (Capability cap)</td></tr>
<tr class="memdesc:a1d09788a1496828ace197176ce75e3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the recursively implied capabilities for the given capability.  <a href="namespacemlir_1_1spirv.html#a1d09788a1496828ace197176ce75e3d9">More...</a><br /></td></tr>
<tr class="separator:a1d09788a1496828ace197176ce75e3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765253a5d5815369244e7a4918fa1b89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a765253a5d5815369244e7a4918fa1b89">populateSPIRVGLCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;results)</td></tr>
<tr class="memdesc:a765253a5d5815369244e7a4918fa1b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns to run canoncalization that involves GL ops.  <a href="namespacemlir_1_1spirv.html#a765253a5d5815369244e7a4918fa1b89">More...</a><br /></td></tr>
<tr class="separator:a765253a5d5815369244e7a4918fa1b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c084c603df48bd16083158d58760c9"><td class="memItemLeft" align="right" valign="top">llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a46c084c603df48bd16083158d58760c9">hash_value</a> (const <a class="el" href="structmlir_1_1spirv_1_1StructType_1_1MemberDecorationInfo.html">StructType::MemberDecorationInfo</a> &amp;memberDecorationInfo)</td></tr>
<tr class="separator:a46c084c603df48bd16083158d58760c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215deffc5609ff655292d919ab241d85"><td class="memItemLeft" align="right" valign="top">llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a215deffc5609ff655292d919ab241d85">hash_value</a> (const <a class="el" href="structmlir_1_1spirv_1_1StructType_1_1StructDecorationInfo.html">StructType::StructDecorationInfo</a> &amp;structDecorationInfo)</td></tr>
<tr class="separator:a215deffc5609ff655292d919ab241d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084723c4d96882caa7edd6bfc3dfe1d0"><td class="memItemLeft" align="right" valign="top">StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a084723c4d96882caa7edd6bfc3dfe1d0">getInterfaceVarABIAttrName</a> ()</td></tr>
<tr class="memdesc:a084723c4d96882caa7edd6bfc3dfe1d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the attribute name for specifying argument ABI information.  <a href="namespacemlir_1_1spirv.html#a084723c4d96882caa7edd6bfc3dfe1d0">More...</a><br /></td></tr>
<tr class="separator:a084723c4d96882caa7edd6bfc3dfe1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9e55893c038502a0f52cddddb6c95c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1spirv_1_1InterfaceVarABIAttr.html">InterfaceVarABIAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a2f9e55893c038502a0f52cddddb6c95c">getInterfaceVarABIAttr</a> (unsigned descriptorSet, unsigned binding, std::optional&lt; StorageClass &gt; storageClass, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a2f9e55893c038502a0f52cddddb6c95c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="classmlir_1_1spirv_1_1InterfaceVarABIAttr.html" title="An attribute that specifies the information regarding the interface variable: descriptor set,...">InterfaceVarABIAttr</a> given its fields.  <a href="namespacemlir_1_1spirv.html#a2f9e55893c038502a0f52cddddb6c95c">More...</a><br /></td></tr>
<tr class="separator:a2f9e55893c038502a0f52cddddb6c95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f116e5f53987bfcf7bfb81faba201e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a1f116e5f53987bfcf7bfb81faba201e3">needsInterfaceVarABIAttrs</a> (<a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">TargetEnvAttr</a> targetAttr)</td></tr>
<tr class="memdesc:a1f116e5f53987bfcf7bfb81faba201e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given SPIR-V target (described by <a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html" title="An attribute that specifies the target version, allowed extensions and capabilities,...">TargetEnvAttr</a>) needs ABI attributes for interface variables (spirv.interface_var_abi).  <a href="namespacemlir_1_1spirv.html#a1f116e5f53987bfcf7bfb81faba201e3">More...</a><br /></td></tr>
<tr class="separator:a1f116e5f53987bfcf7bfb81faba201e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecdb10932f9d700379ed74c9df04e530"><td class="memItemLeft" align="right" valign="top">StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#aecdb10932f9d700379ed74c9df04e530">getEntryPointABIAttrName</a> ()</td></tr>
<tr class="memdesc:aecdb10932f9d700379ed74c9df04e530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the attribute name for specifying entry point information.  <a href="namespacemlir_1_1spirv.html#aecdb10932f9d700379ed74c9df04e530">More...</a><br /></td></tr>
<tr class="separator:aecdb10932f9d700379ed74c9df04e530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f08251581a3ffe9f35ca3b355daf1a9"><td class="memItemLeft" align="right" valign="top">EntryPointABIAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a6f08251581a3ffe9f35ca3b355daf1a9">getEntryPointABIAttr</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int32_t &gt; workgroupSize={}, std::optional&lt; int &gt; subgroupSize={}, std::optional&lt; int &gt; targetWidth={})</td></tr>
<tr class="memdesc:a6f08251581a3ffe9f35ca3b355daf1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the EntryPointABIAttr given its fields.  <a href="namespacemlir_1_1spirv.html#a6f08251581a3ffe9f35ca3b355daf1a9">More...</a><br /></td></tr>
<tr class="separator:a6f08251581a3ffe9f35ca3b355daf1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a2cd4522a0c39add4adcd2db5fe8fc"><td class="memItemLeft" align="right" valign="top">EntryPointABIAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a56a2cd4522a0c39add4adcd2db5fe8fc">lookupEntryPointABI</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a56a2cd4522a0c39add4adcd2db5fe8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the entry point ABI on the nearest function-like op containing the given <code>op</code>.  <a href="namespacemlir_1_1spirv.html#a56a2cd4522a0c39add4adcd2db5fe8fc">More...</a><br /></td></tr>
<tr class="separator:a56a2cd4522a0c39add4adcd2db5fe8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f5018eaa55fce107cc068b85d9dbf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#ace9107ae5cb34fa1aa00e0fd1377ad89">DenseI32ArrayAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a86f5018eaa55fce107cc068b85d9dbf2">lookupLocalWorkGroupSize</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a86f5018eaa55fce107cc068b85d9dbf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the local workgroup size from entry point ABI on the nearest function-like op containing the given <code>op</code>.  <a href="namespacemlir_1_1spirv.html#a86f5018eaa55fce107cc068b85d9dbf2">More...</a><br /></td></tr>
<tr class="separator:a86f5018eaa55fce107cc068b85d9dbf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f2ff3fa9b623a0a6fa86ac75af3f4d"><td class="memItemLeft" align="right" valign="top">ResourceLimitsAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#ae1f2ff3fa9b623a0a6fa86ac75af3f4d">getDefaultResourceLimits</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ae1f2ff3fa9b623a0a6fa86ac75af3f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a default resource limits attribute that uses numbers from "Table 46. Required Limits" of the Vulkan spec.  <a href="namespacemlir_1_1spirv.html#ae1f2ff3fa9b623a0a6fa86ac75af3f4d">More...</a><br /></td></tr>
<tr class="separator:ae1f2ff3fa9b623a0a6fa86ac75af3f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7980ee0979f2d8550c4c1b941523f0c5"><td class="memItemLeft" align="right" valign="top">StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a7980ee0979f2d8550c4c1b941523f0c5">getTargetEnvAttrName</a> ()</td></tr>
<tr class="memdesc:a7980ee0979f2d8550c4c1b941523f0c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the attribute name for specifying SPIR-V target environment.  <a href="namespacemlir_1_1spirv.html#a7980ee0979f2d8550c4c1b941523f0c5">More...</a><br /></td></tr>
<tr class="separator:a7980ee0979f2d8550c4c1b941523f0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb49fbe2ae3a33a6f06fcc29a3698ac2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">TargetEnvAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#aeb49fbe2ae3a33a6f06fcc29a3698ac2">getDefaultTargetEnv</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:aeb49fbe2ae3a33a6f06fcc29a3698ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the default target environment: SPIR-V 1.0 with Shader capability and no extra extensions.  <a href="namespacemlir_1_1spirv.html#aeb49fbe2ae3a33a6f06fcc29a3698ac2">More...</a><br /></td></tr>
<tr class="separator:aeb49fbe2ae3a33a6f06fcc29a3698ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b51f6bb34187b8de569585d635a9eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">TargetEnvAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a78b51f6bb34187b8de569585d635a9eb">lookupTargetEnv</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a78b51f6bb34187b8de569585d635a9eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the target environment recursively from enclosing symbol table ops containing the given <code>op</code>.  <a href="namespacemlir_1_1spirv.html#a78b51f6bb34187b8de569585d635a9eb">More...</a><br /></td></tr>
<tr class="separator:a78b51f6bb34187b8de569585d635a9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae1ed3e62618274db5bad38955db408"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">TargetEnvAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a2ae1ed3e62618274db5bad38955db408">lookupTargetEnvOrDefault</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a2ae1ed3e62618274db5bad38955db408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the target environment recursively from enclosing symbol table ops containing the given <code>op</code> or returns the default target environment as returned by <a class="el" href="namespacemlir_1_1spirv.html#aeb49fbe2ae3a33a6f06fcc29a3698ac2" title="Returns the default target environment: SPIR-V 1.0 with Shader capability and no extra extensions.">getDefaultTargetEnv()</a> if not provided.  <a href="namespacemlir_1_1spirv.html#a2ae1ed3e62618274db5bad38955db408">More...</a><br /></td></tr>
<tr class="separator:a2ae1ed3e62618274db5bad38955db408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a30366862a8f8b0be559fa4a146303f"><td class="memItemLeft" align="right" valign="top">AddressingModel&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a9a30366862a8f8b0be559fa4a146303f">getAddressingModel</a> (<a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">TargetEnvAttr</a> targetAttr, bool use64bitAddress)</td></tr>
<tr class="memdesc:a9a30366862a8f8b0be559fa4a146303f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns addressing model selected based on target environment.  <a href="namespacemlir_1_1spirv.html#a9a30366862a8f8b0be559fa4a146303f">More...</a><br /></td></tr>
<tr class="separator:a9a30366862a8f8b0be559fa4a146303f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcd79b9cf8b161f54bf1ed72ee71887"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; ExecutionModel &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#abdcd79b9cf8b161f54bf1ed72ee71887">getExecutionModel</a> (<a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">TargetEnvAttr</a> targetAttr)</td></tr>
<tr class="memdesc:abdcd79b9cf8b161f54bf1ed72ee71887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns execution model selected based on target environment.  <a href="namespacemlir_1_1spirv.html#abdcd79b9cf8b161f54bf1ed72ee71887">More...</a><br /></td></tr>
<tr class="separator:abdcd79b9cf8b161f54bf1ed72ee71887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbfa30f0b7272297c6a305c0971a5fc9"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; MemoryModel &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#acbfa30f0b7272297c6a305c0971a5fc9">getMemoryModel</a> (<a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">TargetEnvAttr</a> targetAttr)</td></tr>
<tr class="memdesc:acbfa30f0b7272297c6a305c0971a5fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns memory model selected based on target environment.  <a href="namespacemlir_1_1spirv.html#acbfa30f0b7272297c6a305c0971a5fc9">More...</a><br /></td></tr>
<tr class="separator:acbfa30f0b7272297c6a305c0971a5fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b261512c278d63826166487f8ef08f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; spirv::ModuleOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#ac6b261512c278d63826166487f8ef08f">combine</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; spirv::ModuleOp &gt; inputModules, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;combinedModuleBuilder, <a class="el" href="namespacemlir_1_1spirv.html#acac1b5d87a905e6e58d061fca3c4b9c2">SymbolRenameListener</a> symRenameListener)</td></tr>
<tr class="memdesc:ac6b261512c278d63826166487f8ef08f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines a list of SPIR-V <code>inputModules</code> into one.  <a href="namespacemlir_1_1spirv.html#ac6b261512c278d63826166487f8ef08f">More...</a><br /></td></tr>
<tr class="separator:ac6b261512c278d63826166487f8ef08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532fea1d10bcd9e6077280b75e851845"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; spirv::ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a532fea1d10bcd9e6077280b75e851845">createUnifyAliasedResourcePass</a> (<a class="el" href="namespacemlir_1_1spirv.html#a738af61310165c2eb21778ca20406b6a">GetTargetEnvFn</a> getTargetEnv=nullptr)</td></tr>
<tr class="separator:a532fea1d10bcd9e6077280b75e851845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b978811716abbef69d507e684c3d01b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a4b978811716abbef69d507e684c3d01b">getBuiltinVariableValue</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, BuiltIn builtin, <a class="el" href="classmlir_1_1Type.html">Type</a> integerType, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, StringRef prefix=&quot;__builtin__&quot;, StringRef suffix=&quot;__&quot;)</td></tr>
<tr class="memdesc:a4b978811716abbef69d507e684c3d01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value for the given <code>builtin</code> variable.  <a href="namespacemlir_1_1spirv.html#a4b978811716abbef69d507e684c3d01b">More...</a><br /></td></tr>
<tr class="separator:a4b978811716abbef69d507e684c3d01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ced2ee0b51782190a208ff6d7266782"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a6ced2ee0b51782190a208ff6d7266782">getPushConstantValue</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, unsigned elementCount, unsigned offset, <a class="el" href="classmlir_1_1Type.html">Type</a> integerType, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="memdesc:a6ced2ee0b51782190a208ff6d7266782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value at the given <code>offset</code> of the push constant storage with a total of <code>elementCount</code> <code>integerType</code> integers.  <a href="namespacemlir_1_1spirv.html#a6ced2ee0b51782190a208ff6d7266782">More...</a><br /></td></tr>
<tr class="separator:a6ced2ee0b51782190a208ff6d7266782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e2e0e2f96602ed55862a37bee299b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#ab4e2e0e2f96602ed55862a37bee299b2">linearizeIndex</a> (<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> indices, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; strides, int64_t offset, <a class="el" href="classmlir_1_1Type.html">Type</a> integerType, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="memdesc:ab4e2e0e2f96602ed55862a37bee299b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates IR to perform index linearization with the given <code>indices</code> and their corresponding <code>strides</code>, adding an initial <code>offset</code>.  <a href="namespacemlir_1_1spirv.html#ab4e2e0e2f96602ed55862a37bee299b2">More...</a><br /></td></tr>
<tr class="separator:ab4e2e0e2f96602ed55862a37bee299b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf05661a1e8fc56bd5368e4de1e2cd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a5cf05661a1e8fc56bd5368e4de1e2cd3">getElementPtr</a> (const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, MemRefType baseType, <a class="el" href="classmlir_1_1Value.html">Value</a> basePtr, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> indices, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="memdesc:a5cf05661a1e8fc56bd5368e4de1e2cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the index computation to get to the element at <code>indices</code> of the memory pointed to by <code>basePtr</code>, using the layout map of <code>baseType</code>.  <a href="namespacemlir_1_1spirv.html#a5cf05661a1e8fc56bd5368e4de1e2cd3">More...</a><br /></td></tr>
<tr class="separator:a5cf05661a1e8fc56bd5368e4de1e2cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653a80ab59a80ccc192c23b29742f534"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a653a80ab59a80ccc192c23b29742f534">getOpenCLElementPtr</a> (const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, MemRefType baseType, <a class="el" href="classmlir_1_1Value.html">Value</a> basePtr, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> indices, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="separator:a653a80ab59a80ccc192c23b29742f534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67459a8b3f1eaf3e9d2d91d593cd0e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#ac67459a8b3f1eaf3e9d2d91d593cd0e8">getVulkanElementPtr</a> (const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, MemRefType baseType, <a class="el" href="classmlir_1_1Value.html">Value</a> basePtr, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> indices, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="separator:ac67459a8b3f1eaf3e9d2d91d593cd0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a5ec8ce145d966b3571e93c7f7eb00"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#ae8a5ec8ce145d966b3571e93c7f7eb00">getComputeVectorSize</a> (int64_t size)</td></tr>
<tr class="separator:ae8a5ec8ce145d966b3571e93c7f7eb00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf43ecc3cd2c5913409b890e2cb88ed6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#acf43ecc3cd2c5913409b890e2cb88ed6">getNativeVectorShapeImpl</a> (vector::ReductionOp op)</td></tr>
<tr class="separator:acf43ecc3cd2c5913409b890e2cb88ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13851586933739a9da459d59df4dfd44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a13851586933739a9da459d59df4dfd44">getNativeVectorShapeImpl</a> (vector::TransposeOp op)</td></tr>
<tr class="separator:a13851586933739a9da459d59df4dfd44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2e3a1319726930b55969f2639fb749"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a6f2e3a1319726930b55969f2639fb749">getNativeVectorShape</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a6f2e3a1319726930b55969f2639fb749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bf6d38272388b94f44941f6ef36f10"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#af1bf6d38272388b94f44941f6ef36f10">unrollVectorsInSignatures</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:af1bf6d38272388b94f44941f6ef36f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0b5460155168832e9ad08e3481e5b2"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#abe0b5460155168832e9ad08e3481e5b2">unrollVectorsInFuncBodies</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:abe0b5460155168832e9ad08e3481e5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d07c3e189c017279fdac530068fead3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a2d07c3e189c017279fdac530068fead3">populateSPIRVExpandExtendedMultiplicationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a2d07c3e189c017279fdac530068fead3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns to expand extended multiplication and adition ops into regular arithmetic ops.  <a href="namespacemlir_1_1spirv.html#a2d07c3e189c017279fdac530068fead3">More...</a><br /></td></tr>
<tr class="separator:a2d07c3e189c017279fdac530068fead3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236adaeb429ba6067346306ad1093b83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a236adaeb429ba6067346306ad1093b83">populateSPIRVExpandNonFiniteArithmeticPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a236adaeb429ba6067346306ad1093b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns to expand non-finite arithmetic ops <code>IsNan</code> and <code>IsInf</code>.  <a href="namespacemlir_1_1spirv.html#a236adaeb429ba6067346306ad1093b83">More...</a><br /></td></tr>
<tr class="separator:a236adaeb429ba6067346306ad1093b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c0e940b606942d911c5050bcc23135"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; spirv::ModuleOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a30c0e940b606942d911c5050bcc23135">deserialize</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt; binary, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, const <a class="el" href="structmlir_1_1spirv_1_1DeserializationOptions.html">DeserializationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>={})</td></tr>
<tr class="memdesc:a30c0e940b606942d911c5050bcc23135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes the given SPIR-V <code>binary</code> module and creates a MLIR ModuleOp in the given <code>context</code>.  <a href="namespacemlir_1_1spirv.html#a30c0e940b606942d911c5050bcc23135">More...</a><br /></td></tr>
<tr class="separator:a30c0e940b606942d911c5050bcc23135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764762951e6d168cda2fc62d3a4639ee"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a764762951e6d168cda2fc62d3a4639ee">serialize</a> (ModuleOp module, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; uint32_t &gt; &amp;binary, const <a class="el" href="structmlir_1_1spirv_1_1SerializationOptions.html">SerializationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>={})</td></tr>
<tr class="memdesc:a764762951e6d168cda2fc62d3a4639ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the given SPIR-V <code>module</code> and writes to <code>binary</code>.  <a href="namespacemlir_1_1spirv.html#a764762951e6d168cda2fc62d3a4639ee">More...</a><br /></td></tr>
<tr class="separator:a764762951e6d168cda2fc62d3a4639ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9286568f54e529177c6f19e1a05ead66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a9286568f54e529177c6f19e1a05ead66">appendModuleHeader</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; uint32_t &gt; &amp;header, spirv::Version version, uint32_t idBound)</td></tr>
<tr class="memdesc:a9286568f54e529177c6f19e1a05ead66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a SPRI-V module header to <code>header</code> with the given <code>version</code> and <code>idBound</code>.  <a href="namespacemlir_1_1spirv.html#a9286568f54e529177c6f19e1a05ead66">More...</a><br /></td></tr>
<tr class="separator:a9286568f54e529177c6f19e1a05ead66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6583bd4786f75b42698de079fe0bc892"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a6583bd4786f75b42698de079fe0bc892">getPrefixedOpcode</a> (uint32_t wordCount, spirv::Opcode opcode)</td></tr>
<tr class="memdesc:a6583bd4786f75b42698de079fe0bc892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the word-count-prefixed opcode for an SPIR-V instruction.  <a href="namespacemlir_1_1spirv.html#a6583bd4786f75b42698de079fe0bc892">More...</a><br /></td></tr>
<tr class="separator:a6583bd4786f75b42698de079fe0bc892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff3c223d2106f6d92a5772a9d0736c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a0ff3c223d2106f6d92a5772a9d0736c1">encodeStringLiteralInto</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; uint32_t &gt; &amp;binary, StringRef literal)</td></tr>
<tr class="memdesc:a0ff3c223d2106f6d92a5772a9d0736c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes an SPIR-V <code>literal</code> string into the given <code>binary</code> vector.  <a href="namespacemlir_1_1spirv.html#a0ff3c223d2106f6d92a5772a9d0736c1">More...</a><br /></td></tr>
<tr class="separator:a0ff3c223d2106f6d92a5772a9d0736c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ae92c06481ab5590c94261e73b6166"><td class="memItemLeft" align="right" valign="top">StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#ab3ae92c06481ab5590c94261e73b6166">decodeStringLiteral</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt; words, unsigned &amp;wordIndex)</td></tr>
<tr class="memdesc:ab3ae92c06481ab5590c94261e73b6166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes a string literal in <code>words</code> starting at <code>wordIndex</code>.  <a href="namespacemlir_1_1spirv.html#ab3ae92c06481ab5590c94261e73b6166">More...</a><br /></td></tr>
<tr class="separator:ab3ae92c06481ab5590c94261e73b6166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae31a2fb6ec2e05490681b0bbeac920"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a5ae31a2fb6ec2e05490681b0bbeac920">registerSPIRVTargetInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a5ae31a2fb6ec2e05490681b0bbeac920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the <code>TargetAttrInterface</code> for the <code>#spirv.target_env</code> attribute in the given registry.  <a href="namespacemlir_1_1spirv.html#a5ae31a2fb6ec2e05490681b0bbeac920">More...</a><br /></td></tr>
<tr class="separator:a5ae31a2fb6ec2e05490681b0bbeac920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a90ef73aefe4ec6694f07339c322541"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a4a90ef73aefe4ec6694f07339c322541">registerSPIRVTargetInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a4a90ef73aefe4ec6694f07339c322541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the <code>TargetAttrInterface</code> for the <code>#spirv.target_env</code> attribute in the registry associated with the given context.  <a href="namespacemlir_1_1spirv.html#a4a90ef73aefe4ec6694f07339c322541">More...</a><br /></td></tr>
<tr class="separator:a4a90ef73aefe4ec6694f07339c322541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02bdaa0cba7cda3298326df80cbbc968"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a02bdaa0cba7cda3298326df80cbbc968"><td class="memTemplItemLeft" align="right" valign="top">static StringRef&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a02bdaa0cba7cda3298326df80cbbc968">stringifyTypeName</a> ()</td></tr>
<tr class="separator:a02bdaa0cba7cda3298326df80cbbc968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b09d6dad552f1f08d9417a84281f3b"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ab7b09d6dad552f1f08d9417a84281f3b"><td class="memTemplItemLeft" align="right" valign="top">StringRef&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#ab7b09d6dad552f1f08d9417a84281f3b">stringifyTypeName&lt; IntegerType &gt;</a> ()</td></tr>
<tr class="separator:ab7b09d6dad552f1f08d9417a84281f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f43e0ee07a067cb499869873ad2669"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a90f43e0ee07a067cb499869873ad2669"><td class="memTemplItemLeft" align="right" valign="top">StringRef&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a90f43e0ee07a067cb499869873ad2669">stringifyTypeName&lt; FloatType &gt;</a> ()</td></tr>
<tr class="separator:a90f43e0ee07a067cb499869873ad2669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2921faf72b4b5fd1305b526fe9c433d"><td class="memTemplParams" colspan="2">template&lt;typename AtomicOpTy , typename ExpectedElementType &gt; </td></tr>
<tr class="memitem:af2921faf72b4b5fd1305b526fe9c433d"><td class="memTemplItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#af2921faf72b4b5fd1305b526fe9c433d">verifyAtomicUpdateOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:af2921faf72b4b5fd1305b526fe9c433d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c065d39df33da14559b2ff3c292bd6"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a62c065d39df33da14559b2ff3c292bd6">verifyCastOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, bool requireSameBitWidth=true, bool skipBitWidthCheck=false)</td></tr>
<tr class="separator:a62c065d39df33da14559b2ff3c292bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15884622a81b27f8389f600302472d0"><td class="memTemplParams" colspan="2">template&lt;typename EnumAttrClass , typename EnumClass &gt; </td></tr>
<tr class="memitem:aa15884622a81b27f8389f600302472d0"><td class="memTemplItemLeft" align="right" valign="top">static ParseResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#aa15884622a81b27f8389f600302472d0">parseControlAttribute</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;state, StringRef attrName=spirv::attributeName&lt; EnumClass &gt;())</td></tr>
<tr class="memdesc:aa15884622a81b27f8389f600302472d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses Function, Selection and Loop control attributes.  <a href="namespacemlir_1_1spirv.html#aa15884622a81b27f8389f600302472d0">More...</a><br /></td></tr>
<tr class="separator:aa15884622a81b27f8389f600302472d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b28c2f734f6425b815e5f9171ca3d0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a95b28c2f734f6425b815e5f9171ca3d0">hasOneBranchOpTo</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> &amp;srcBlock, <a class="el" href="classmlir_1_1Block.html">Block</a> &amp;dstBlock)</td></tr>
<tr class="memdesc:a95b28c2f734f6425b815e5f9171ca3d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given <code>srcBlock</code> contains only one <code>spirv.Branch</code> to the given <code>dstBlock</code>.  <a href="namespacemlir_1_1spirv.html#a95b28c2f734f6425b815e5f9171ca3d0">More...</a><br /></td></tr>
<tr class="separator:a95b28c2f734f6425b815e5f9171ca3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60bacfdcb016bfa3eb07c13bb8026ee"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#ac60bacfdcb016bfa3eb07c13bb8026ee">isMergeBlock</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> &amp;block)</td></tr>
<tr class="memdesc:ac60bacfdcb016bfa3eb07c13bb8026ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given <code>block</code> only contains one <code>spirv.mlir.merge</code> op.  <a href="namespacemlir_1_1spirv.html#ac60bacfdcb016bfa3eb07c13bb8026ee">More...</a><br /></td></tr>
<tr class="separator:ac60bacfdcb016bfa3eb07c13bb8026ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6f9f95b9b3574fe2aaab652cedd3e0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a7c6f9f95b9b3574fe2aaab652cedd3e0">hasOtherMerge</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region)</td></tr>
<tr class="memdesc:a7c6f9f95b9b3574fe2aaab652cedd3e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a <code>spirv.mlir.merge</code> op outside the merge block.  <a href="namespacemlir_1_1spirv.html#a7c6f9f95b9b3574fe2aaab652cedd3e0">More...</a><br /></td></tr>
<tr class="separator:a7c6f9f95b9b3574fe2aaab652cedd3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24785985e21b2fe5a33bca5c104b0ca8"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a24785985e21b2fe5a33bca5c104b0ca8">verifyCoopMatrixAccess</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Type.html">Type</a> pointer, <a class="el" href="classmlir_1_1Type.html">Type</a> coopMatrix, spirv::MemoryAccessAttr memoryOperand, IntegerAttr alignment)</td></tr>
<tr class="separator:a24785985e21b2fe5a33bca5c104b0ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8227007edef7398b270e9ff970c2e27"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; spirv::Version &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#ad8227007edef7398b270e9ff970c2e27">getDotProductMinVersion</a> ()</td></tr>
<tr class="separator:ad8227007edef7398b270e9ff970c2e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394632d97865e195ff8234c8d1c7e25d"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; spirv::Version &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a394632d97865e195ff8234c8d1c7e25d">getDotProductMaxVersion</a> ()</td></tr>
<tr class="separator:a394632d97865e195ff8234c8d1c7e25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5e50e9919aad12e5cb7df176501d68"><td class="memTemplParams" colspan="2">template&lt;typename IntegerDotProductOpTy &gt; </td></tr>
<tr class="memitem:a2c5e50e9919aad12e5cb7df176501d68"><td class="memTemplItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a2c5e50e9919aad12e5cb7df176501d68">verifyIntegerDotProduct</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a2c5e50e9919aad12e5cb7df176501d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae828f37a7d5ee7522312493ba336fc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; spirv::Extension &gt;, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#adae828f37a7d5ee7522312493ba336fc">getIntegerDotProductExtensions</a> ()</td></tr>
<tr class="separator:adae828f37a7d5ee7522312493ba336fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676476d2d440781f305e16af3eabf77e"><td class="memTemplParams" colspan="2">template&lt;typename IntegerDotProductOpTy &gt; </td></tr>
<tr class="memitem:a676476d2d440781f305e16af3eabf77e"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; spirv::Capability &gt;, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a676476d2d440781f305e16af3eabf77e">getIntegerDotProductCapabilities</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a676476d2d440781f305e16af3eabf77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23eb772725d05b1834b5ec9eb2c6ea33"><td class="memTemplParams" colspan="2">template&lt;typename OpTy &gt; </td></tr>
<tr class="memitem:a23eb772725d05b1834b5ec9eb2c6ea33"><td class="memTemplItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a23eb772725d05b1834b5ec9eb2c6ea33">verifyGroupNonUniformArithmeticOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *groupOp)</td></tr>
<tr class="separator:a23eb772725d05b1834b5ec9eb2c6ea33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69927bca9741cf0039df005f3c91b886"><td class="memTemplParams" colspan="2">template&lt;typename OpTy &gt; </td></tr>
<tr class="memitem:a69927bca9741cf0039df005f3c91b886"><td class="memTemplItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a69927bca9741cf0039df005f3c91b886">verifyGroupNonUniformShuffleOp</a> (OpTy op)</td></tr>
<tr class="separator:a69927bca9741cf0039df005f3c91b886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8027ad78793fb44ca1a47986f01852"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:a6f8027ad78793fb44ca1a47986f01852"><td class="memTemplItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a6f8027ad78793fb44ca1a47986f01852">verifyGroupOp</a> (<a class="el" href="classmlir_1_1Op.html">Op</a> op)</td></tr>
<tr class="separator:a6f8027ad78793fb44ca1a47986f01852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a43e19678538c6f1c665db936052836"><td class="memTemplParams" colspan="2">template&lt;typename MemoryOpTy &gt; </td></tr>
<tr class="memitem:a7a43e19678538c6f1c665db936052836"><td class="memTemplItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a7a43e19678538c6f1c665db936052836">parseMemoryAccessAttributes</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;state)</td></tr>
<tr class="memdesc:a7a43e19678538c6f1c665db936052836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses optional memory access (a.k.a.  <a href="namespacemlir_1_1spirv.html#a7a43e19678538c6f1c665db936052836">More...</a><br /></td></tr>
<tr class="separator:a7a43e19678538c6f1c665db936052836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9f02c02f26079c13d69e35c3111f2d"><td class="memTemplParams" colspan="2">template&lt;typename MemoryOpTy &gt; </td></tr>
<tr class="memitem:a1e9f02c02f26079c13d69e35c3111f2d"><td class="memTemplItemLeft" align="right" valign="top">static ParseResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a1e9f02c02f26079c13d69e35c3111f2d">parseSourceMemoryAccessAttributes</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;state)</td></tr>
<tr class="separator:a1e9f02c02f26079c13d69e35c3111f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb5cfcaf16ed861acbf2275d246c041"><td class="memTemplParams" colspan="2">template&lt;typename MemoryOpTy &gt; </td></tr>
<tr class="memitem:a6eb5cfcaf16ed861acbf2275d246c041"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a6eb5cfcaf16ed861acbf2275d246c041">printSourceMemoryAccessAttribute</a> (MemoryOpTy memoryOp, <a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;printer, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; StringRef &gt; &amp;elidedAttrs, std::optional&lt; spirv::MemoryAccess &gt; memoryAccessAtrrValue=std::nullopt, std::optional&lt; uint32_t &gt; alignmentAttrValue=std::nullopt)</td></tr>
<tr class="separator:a6eb5cfcaf16ed861acbf2275d246c041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc45631cfda7737423de425ba2335997"><td class="memTemplParams" colspan="2">template&lt;typename MemoryOpTy &gt; </td></tr>
<tr class="memitem:acc45631cfda7737423de425ba2335997"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#acc45631cfda7737423de425ba2335997">printMemoryAccessAttribute</a> (MemoryOpTy memoryOp, <a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;printer, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; StringRef &gt; &amp;elidedAttrs, std::optional&lt; spirv::MemoryAccess &gt; memoryAccessAtrrValue=std::nullopt, std::optional&lt; uint32_t &gt; alignmentAttrValue=std::nullopt)</td></tr>
<tr class="separator:acc45631cfda7737423de425ba2335997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de7be6ae36d7e1ebc1ff890dbf8eb41"><td class="memTemplParams" colspan="2">template&lt;typename LoadStoreOpTy &gt; </td></tr>
<tr class="memitem:a8de7be6ae36d7e1ebc1ff890dbf8eb41"><td class="memTemplItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a8de7be6ae36d7e1ebc1ff890dbf8eb41">verifyLoadStorePtrAndValTypes</a> (LoadStoreOpTy op, <a class="el" href="classmlir_1_1Value.html">Value</a> ptr, <a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="separator:a8de7be6ae36d7e1ebc1ff890dbf8eb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9401d09ba4d2cb0cd94706d498e41dc7"><td class="memTemplParams" colspan="2">template&lt;typename MemoryOpTy &gt; </td></tr>
<tr class="memitem:a9401d09ba4d2cb0cd94706d498e41dc7"><td class="memTemplItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a9401d09ba4d2cb0cd94706d498e41dc7">verifyMemoryAccessAttribute</a> (MemoryOpTy memoryOp)</td></tr>
<tr class="separator:a9401d09ba4d2cb0cd94706d498e41dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c428608324420fa151089c165625efd"><td class="memTemplParams" colspan="2">template&lt;typename MemoryOpTy &gt; </td></tr>
<tr class="memitem:a4c428608324420fa151089c165625efd"><td class="memTemplItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a4c428608324420fa151089c165625efd">verifySourceMemoryAccessAttribute</a> (MemoryOpTy memoryOp)</td></tr>
<tr class="separator:a4c428608324420fa151089c165625efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809d4956c103602772bfd32a209732ab"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a809d4956c103602772bfd32a209732ab">getElementPtrType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> indices, <a class="el" href="classmlir_1_1Location.html">Location</a> baseLoc)</td></tr>
<tr class="separator:a809d4956c103602772bfd32a209732ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ccbaebd40c40af4c17db768f22f80d"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:ab3ccbaebd40c40af4c17db768f22f80d"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#ab3ccbaebd40c40af4c17db768f22f80d">printAccessChain</a> (<a class="el" href="classmlir_1_1Op.html">Op</a> op, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> indices, <a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;printer)</td></tr>
<tr class="separator:ab3ccbaebd40c40af4c17db768f22f80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f367e15c232c8b4bb5bf32861a3fcf"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:af3f367e15c232c8b4bb5bf32861a3fcf"><td class="memTemplItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#af3f367e15c232c8b4bb5bf32861a3fcf">verifyAccessChain</a> (<a class="el" href="classmlir_1_1Op.html">Op</a> accessChainOp, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> indices)</td></tr>
<tr class="separator:af3f367e15c232c8b4bb5bf32861a3fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a67866a73d73caa33070def2e25a17f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a9a67866a73d73caa33070def2e25a17f">isNestedInFunctionOpInterface</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a9a67866a73d73caa33070def2e25a17f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given op is a function-like op or nested in a function-like op without a module-like op in the middle.  <a href="namespacemlir_1_1spirv.html#a9a67866a73d73caa33070def2e25a17f">More...</a><br /></td></tr>
<tr class="separator:a9a67866a73d73caa33070def2e25a17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39af790fb25338fbbf6b1fe7b6d01b7c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a39af790fb25338fbbf6b1fe7b6d01b7c">isDirectInModuleLikeOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a39af790fb25338fbbf6b1fe7b6d01b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given op is an module-like op that maintains a symbol table.  <a href="namespacemlir_1_1spirv.html#a39af790fb25338fbbf6b1fe7b6d01b7c">More...</a><br /></td></tr>
<tr class="separator:a39af790fb25338fbbf6b1fe7b6d01b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4757f048f03fff191afe22bc187ca3c7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a4757f048f03fff191afe22bc187ca3c7">getUnaryOpResultType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> operandType)</td></tr>
<tr class="memdesc:a4757f048f03fff191afe22bc187ca3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result of a logical op must be a scalar or vector of boolean type.  <a href="namespacemlir_1_1spirv.html#a4757f048f03fff191afe22bc187ca3c7">More...</a><br /></td></tr>
<tr class="separator:a4757f048f03fff191afe22bc187ca3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77905bf65935a368b3f4c0c8c0efc84"><td class="memItemLeft" align="right" valign="top">static ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#ac77905bf65935a368b3f4c0c8c0efc84">parseImageOperands</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, spirv::ImageOperandsAttr &amp;attr)</td></tr>
<tr class="separator:ac77905bf65935a368b3f4c0c8c0efc84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798ee89dcf100a9abd8e038c398be41f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a798ee89dcf100a9abd8e038c398be41f">printImageOperands</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;printer, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *imageOp, spirv::ImageOperandsAttr attr)</td></tr>
<tr class="separator:a798ee89dcf100a9abd8e038c398be41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a5bac4bd972f84e389a5cfb0c0910a"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#af8a5bac4bd972f84e389a5cfb0c0910a">getBitWidth</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="memdesc:af8a5bac4bd972f84e389a5cfb0c0910a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bit width of the <code>type</code>.  <a href="namespacemlir_1_1spirv.html#af8a5bac4bd972f84e389a5cfb0c0910a">More...</a><br /></td></tr>
<tr class="separator:af8a5bac4bd972f84e389a5cfb0c0910a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818b363cb52ee3d90e7a6495b9e829dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a818b363cb52ee3d90e7a6495b9e829dd">printVariableDecorations</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;printer, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; StringRef &gt; &amp;elidedAttrs)</td></tr>
<tr class="separator:a818b363cb52ee3d90e7a6495b9e829dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc08440c5e35416cc6e6fe9458ba0f7"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#acfc08440c5e35416cc6e6fe9458ba0f7">extractValueFromConstOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, int32_t &amp;value)</td></tr>
<tr class="separator:acfc08440c5e35416cc6e6fe9458ba0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe392ec323b3b094b994e9317e982ac"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a0fe392ec323b3b094b994e9317e982ac">verifyMemorySemantics</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, spirv::MemorySemantics memorySemantics)</td></tr>
<tr class="separator:a0fe392ec323b3b094b994e9317e982ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e1df0fca3178658be46872db50cc3b"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#ae0e1df0fca3178658be46872db50cc3b">parseVariableDecorations</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;state)</td></tr>
<tr class="separator:ae0e1df0fca3178658be46872db50cc3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac268d2b199ba1111315d3e1579bc0271"><td class="memTemplParams" colspan="2">template&lt;typename Ty &gt; </td></tr>
<tr class="memitem:ac268d2b199ba1111315d3e1579bc0271"><td class="memTemplItemLeft" align="right" valign="top">ArrayAttr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#ac268d2b199ba1111315d3e1579bc0271">getStrArrayAttrForEnumList</a> (<a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;builder, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; Ty &gt; enumValues, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; StringRef(Ty)&gt; stringifyFn)</td></tr>
<tr class="separator:ac268d2b199ba1111315d3e1579bc0271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d5aca268e56b3cf9554235e80804db"><td class="memTemplParams" colspan="2">template&lt;typename EnumClass , typename ParserType &gt; </td></tr>
<tr class="memitem:a78d5aca268e56b3cf9554235e80804db"><td class="memTemplItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a78d5aca268e56b3cf9554235e80804db">parseEnumKeywordAttr</a> (EnumClass &amp;value, ParserType &amp;parser, StringRef attrName=spirv::attributeName&lt; EnumClass &gt;())</td></tr>
<tr class="memdesc:a78d5aca268e56b3cf9554235e80804db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the next keyword in <code>parser</code> as an enumerant of the given <code>EnumClass</code>.  <a href="namespacemlir_1_1spirv.html#a78d5aca268e56b3cf9554235e80804db">More...</a><br /></td></tr>
<tr class="separator:a78d5aca268e56b3cf9554235e80804db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2981f77642487cfdbaae9b5429d8280b"><td class="memTemplParams" colspan="2">template&lt;typename EnumClass &gt; </td></tr>
<tr class="memitem:a2981f77642487cfdbaae9b5429d8280b"><td class="memTemplItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a2981f77642487cfdbaae9b5429d8280b">parseEnumStrAttr</a> (EnumClass &amp;value, <a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, StringRef attrName=spirv::attributeName&lt; EnumClass &gt;())</td></tr>
<tr class="memdesc:a2981f77642487cfdbaae9b5429d8280b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the next string attribute in <code>parser</code> as an enumerant of the given <code>EnumClass</code>.  <a href="namespacemlir_1_1spirv.html#a2981f77642487cfdbaae9b5429d8280b">More...</a><br /></td></tr>
<tr class="separator:a2981f77642487cfdbaae9b5429d8280b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c77d2389f3f8614e9f46d73220628b"><td class="memTemplParams" colspan="2">template&lt;typename EnumAttrClass , typename EnumClass  = typename EnumAttrClass::ValueType&gt; </td></tr>
<tr class="memitem:a34c77d2389f3f8614e9f46d73220628b"><td class="memTemplItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a34c77d2389f3f8614e9f46d73220628b">parseEnumStrAttr</a> (EnumClass &amp;value, <a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;state, StringRef attrName=spirv::attributeName&lt; EnumClass &gt;())</td></tr>
<tr class="memdesc:a34c77d2389f3f8614e9f46d73220628b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the next string attribute in <code>parser</code> as an enumerant of the given <code>EnumClass</code> and inserts the enumerant into <code>state</code> as an 32-bit integer attribute with the enum class's name as attribute name.  <a href="namespacemlir_1_1spirv.html#a34c77d2389f3f8614e9f46d73220628b">More...</a><br /></td></tr>
<tr class="separator:a34c77d2389f3f8614e9f46d73220628b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2e53b4f9b10e1b17ff9d68e53c431c"><td class="memTemplParams" colspan="2">template&lt;typename EnumAttrClass , typename EnumClass  = typename EnumAttrClass::ValueType&gt; </td></tr>
<tr class="memitem:aac2e53b4f9b10e1b17ff9d68e53c431c"><td class="memTemplItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#aac2e53b4f9b10e1b17ff9d68e53c431c">parseEnumKeywordAttr</a> (EnumClass &amp;value, <a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;state, StringRef attrName=spirv::attributeName&lt; EnumClass &gt;())</td></tr>
<tr class="memdesc:aac2e53b4f9b10e1b17ff9d68e53c431c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the next keyword in <code>parser</code> as an enumerant of the given <code>EnumClass</code> and inserts the enumerant into <code>state</code> as an 32-bit integer attribute with the enum class's name as attribute name.  <a href="namespacemlir_1_1spirv.html#aac2e53b4f9b10e1b17ff9d68e53c431c">More...</a><br /></td></tr>
<tr class="separator:aac2e53b4f9b10e1b17ff9d68e53c431c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3f67306af2bae665876607f6cda007"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a3a3f67306af2bae665876607f6cda007"><td class="memTemplItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a3a3f67306af2bae665876607f6cda007">Deserializer::processOp&lt; spirv::EntryPointOp &gt;</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt; words)</td></tr>
<tr class="separator:a3a3f67306af2bae665876607f6cda007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6e7f02b46ed0e63707dab1e129bb82"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:acf6e7f02b46ed0e63707dab1e129bb82"><td class="memTemplItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#acf6e7f02b46ed0e63707dab1e129bb82">Deserializer::processOp&lt; spirv::ExecutionModeOp &gt;</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt; words)</td></tr>
<tr class="separator:acf6e7f02b46ed0e63707dab1e129bb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009f0aa8f9f8655433f830b39d6c4ab6"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a009f0aa8f9f8655433f830b39d6c4ab6"><td class="memTemplItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a009f0aa8f9f8655433f830b39d6c4ab6">Deserializer::processOp&lt; spirv::FunctionCallOp &gt;</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt; operands)</td></tr>
<tr class="separator:a009f0aa8f9f8655433f830b39d6c4ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65663608696ea8ed3e771aa721401699"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a65663608696ea8ed3e771aa721401699"><td class="memTemplItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a65663608696ea8ed3e771aa721401699">Deserializer::processOp&lt; spirv::CopyMemoryOp &gt;</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt; words)</td></tr>
<tr class="separator:a65663608696ea8ed3e771aa721401699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1028b0abc35997e95aefa6b3d26adf79"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a1028b0abc35997e95aefa6b3d26adf79"><td class="memTemplItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a1028b0abc35997e95aefa6b3d26adf79">Deserializer::processOp&lt; spirv::GenericCastToPtrExplicitOp &gt;</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt; words)</td></tr>
<tr class="separator:a1028b0abc35997e95aefa6b3d26adf79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9360bb2d9fb5d7a6d16eaa1a17132f97"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a9360bb2d9fb5d7a6d16eaa1a17132f97"><td class="memTemplItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a9360bb2d9fb5d7a6d16eaa1a17132f97">Serializer::processOp&lt; spirv::EntryPointOp &gt;</a> (spirv::EntryPointOp op)</td></tr>
<tr class="separator:a9360bb2d9fb5d7a6d16eaa1a17132f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27df4c1b5396a8998d58603a044e5d0"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ad27df4c1b5396a8998d58603a044e5d0"><td class="memTemplItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#ad27df4c1b5396a8998d58603a044e5d0">Serializer::processOp&lt; spirv::ExecutionModeOp &gt;</a> (spirv::ExecutionModeOp op)</td></tr>
<tr class="separator:ad27df4c1b5396a8998d58603a044e5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8166d677987aab5a71255741c5b5a63b"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a8166d677987aab5a71255741c5b5a63b"><td class="memTemplItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a8166d677987aab5a71255741c5b5a63b">Serializer::processOp&lt; spirv::FunctionCallOp &gt;</a> (spirv::FunctionCallOp op)</td></tr>
<tr class="separator:a8166d677987aab5a71255741c5b5a63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02999329ba2aaf9d90c2154489e6ace"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ae02999329ba2aaf9d90c2154489e6ace"><td class="memTemplItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#ae02999329ba2aaf9d90c2154489e6ace">Serializer::processOp&lt; spirv::CopyMemoryOp &gt;</a> (spirv::CopyMemoryOp op)</td></tr>
<tr class="separator:ae02999329ba2aaf9d90c2154489e6ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30d7e3a8c376ff9d21825446fd0e6a2"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ae30d7e3a8c376ff9d21825446fd0e6a2"><td class="memTemplItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#ae30d7e3a8c376ff9d21825446fd0e6a2">Serializer::processOp&lt; spirv::GenericCastToPtrExplicitOp &gt;</a> (spirv::GenericCastToPtrExplicitOp op)</td></tr>
<tr class="separator:ae30d7e3a8c376ff9d21825446fd0e6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833133e74c83ef32f078b57244466d0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a833133e74c83ef32f078b57244466d0c">encodeInstructionInto</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; uint32_t &gt; &amp;binary, spirv::Opcode op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt; operands)</td></tr>
<tr class="memdesc:a833133e74c83ef32f078b57244466d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes an SPIR-V instruction with the given <code>opcode</code> and <code>operands</code> into the given <code>binary</code> vector.  <a href="namespacemlir_1_1spirv.html#a833133e74c83ef32f078b57244466d0c">More...</a><br /></td></tr>
<tr class="separator:a833133e74c83ef32f078b57244466d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f551011baf787c1ab494295dc46083"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#af3f551011baf787c1ab494295dc46083">getDecorationName</a> (StringRef attrName)</td></tr>
<tr class="separator:af3f551011baf787c1ab494295dc46083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c99a9b8928c873859c0ff2b7640e17"><td class="memTemplParams" colspan="2">template&lt;typename AttrTy , typename EmitF &gt; </td></tr>
<tr class="memitem:a62c99a9b8928c873859c0ff2b7640e17"><td class="memTemplItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a62c99a9b8928c873859c0ff2b7640e17">processDecorationList</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, Decoration decoration, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attrList, StringRef attrName, EmitF emitter)</td></tr>
<tr class="separator:a62c99a9b8928c873859c0ff2b7640e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0066624e2704755cca3404ab368dbcc3"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a0066624e2704755cca3404ab368dbcc3"><td class="memTemplItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a0066624e2704755cca3404ab368dbcc3">Serializer::processTypeDecoration&lt; spirv::ArrayType &gt;</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1spirv_1_1ArrayType.html">spirv::ArrayType</a> type, uint32_t resultID)</td></tr>
<tr class="separator:a0066624e2704755cca3404ab368dbcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97cd75646073d697112f7f8cc79c503"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ab97cd75646073d697112f7f8cc79c503"><td class="memTemplItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#ab97cd75646073d697112f7f8cc79c503">Serializer::processTypeDecoration&lt; spirv::RuntimeArrayType &gt;</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1spirv_1_1RuntimeArrayType.html">spirv::RuntimeArrayType</a> type, uint32_t resultID)</td></tr>
<tr class="separator:ab97cd75646073d697112f7f8cc79c503"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad26be4ada4901dc6598761977638338c"><td class="memItemLeft" align="right" valign="top">constexpr unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#ad26be4ada4901dc6598761977638338c">kHeaderWordCount</a> = 5</td></tr>
<tr class="memdesc:ad26be4ada4901dc6598761977638338c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPIR-V binary header word count.  <a href="namespacemlir_1_1spirv.html#ad26be4ada4901dc6598761977638338c">More...</a><br /></td></tr>
<tr class="separator:ad26be4ada4901dc6598761977638338c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5385336e089899ca7fcc7af2dbedf4e6"><td class="memItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a5385336e089899ca7fcc7af2dbedf4e6">kMagicNumber</a> = 0x07230203</td></tr>
<tr class="memdesc:a5385336e089899ca7fcc7af2dbedf4e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPIR-V magic number.  <a href="namespacemlir_1_1spirv.html#a5385336e089899ca7fcc7af2dbedf4e6">More...</a><br /></td></tr>
<tr class="separator:a5385336e089899ca7fcc7af2dbedf4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2478bd60cd2037a1d56b6ce17bd32bb4"><td class="memItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a2478bd60cd2037a1d56b6ce17bd32bb4">kGeneratorNumber</a> = 22</td></tr>
<tr class="memdesc:a2478bd60cd2037a1d56b6ce17bd32bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The serializer tool ID registered to the Khronos Group.  <a href="namespacemlir_1_1spirv.html#a2478bd60cd2037a1d56b6ce17bd32bb4">More...</a><br /></td></tr>
<tr class="separator:a2478bd60cd2037a1d56b6ce17bd32bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae805863eb10334039743fb3dfa148e"><td class="memItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a8ae805863eb10334039743fb3dfa148e">kMaxWordCount</a> = 65535</td></tr>
<tr class="memdesc:a8ae805863eb10334039743fb3dfa148e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max number of words <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_universal_limits">https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_universal_limits</a>.  <a href="namespacemlir_1_1spirv.html#a8ae805863eb10334039743fb3dfa148e">More...</a><br /></td></tr>
<tr class="separator:a8ae805863eb10334039743fb3dfa148e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ea4a2ae808ea92a1da4cffbdac2e2f"><td class="memItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a18ea4a2ae808ea92a1da4cffbdac2e2f">kMaxLiteralWordCount</a> = <a class="el" href="namespacemlir_1_1spirv.html#a8ae805863eb10334039743fb3dfa148e">kMaxWordCount</a> - 3</td></tr>
<tr class="memdesc:a18ea4a2ae808ea92a1da4cffbdac2e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max number of words for literal.  <a href="namespacemlir_1_1spirv.html#a18ea4a2ae808ea92a1da4cffbdac2e2f">More...</a><br /></td></tr>
<tr class="separator:a18ea4a2ae808ea92a1da4cffbdac2e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="acd480fdd0d8fb515c1419293ce3c0e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd480fdd0d8fb515c1419293ce3c0e4c">&#9670;&nbsp;</a></span>BlockMergeInfoMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1spirv.html#acd480fdd0d8fb515c1419293ce3c0e4c">mlir::spirv::BlockMergeInfoMap</a> = typedef <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt;<a class="el" href="classmlir_1_1Block.html">Block</a> *, <a class="el" href="structmlir_1_1spirv_1_1BlockMergeInfo.html">BlockMergeInfo</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map from a selection/loop's header block to its merge (and continue) target. </p>

<p class="definition">Definition at line <a class="el" href="Deserializer_8h_source.html#l00061">61</a> of file <a class="el" href="Deserializer_8h_source.html">Deserializer.h</a>.</p>

</div>
</div>
<a id="a738af61310165c2eb21778ca20406b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a738af61310165c2eb21778ca20406b6a">&#9670;&nbsp;</a></span>GetTargetEnvFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1spirv.html#a738af61310165c2eb21778ca20406b6a">mlir::spirv::GetTargetEnvFn</a> = typedef std::function&lt;<a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">spirv::TargetEnvAttr</a>(spirv::ModuleOp)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an operation pass that unifies access of multiple aliased resources into access of one single resource. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SPIRV_2Transforms_2Passes_8h_source.html#l00036">36</a> of file <a class="el" href="Dialect_2SPIRV_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a7cb656d582fcb330d69a180edc76b7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb656d582fcb330d69a180edc76b7a8">&#9670;&nbsp;</a></span>MemorySpaceToStorageClassMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1spirv.html#a7cb656d582fcb330d69a180edc76b7a8">mlir::spirv::MemorySpaceToStorageClassMap</a> = typedef std::function&lt;std::optional&lt;spirv::StorageClass&gt;(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mapping from numeric MemRef memory spaces into SPIR-V symbolic ones. </p>

<p class="definition">Definition at line <a class="el" href="MemRefToSPIRV_8h_source.html#l00025">25</a> of file <a class="el" href="MemRefToSPIRV_8h_source.html">MemRefToSPIRV.h</a>.</p>

</div>
</div>
<a id="acac1b5d87a905e6e58d061fca3c4b9c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac1b5d87a905e6e58d061fca3c4b9c2">&#9670;&nbsp;</a></span>SymbolRenameListener</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1spirv.html#acac1b5d87a905e6e58d061fca3c4b9c2">mlir::spirv::SymbolRenameListener</a> = typedef <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt;void( spirv::ModuleOp originalModule, StringRef oldSymbol, StringRef newSymbol)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The listener function to receive symbol renaming events. </p>
<p><code>originalModule</code> is the input spirv::ModuleOp that contains the renamed symbol. <code>oldSymbol</code> and <code>newSymbol</code> are the original and renamed symbol. Note that it's the responsibility of the caller to properly retain the storage underlying the passed StringRefs if the listener callback outlives this function call. </p>

<p class="definition">Definition at line <a class="el" href="ModuleCombiner_8h_source.html#l00032">32</a> of file <a class="el" href="ModuleCombiner_8h_source.html">ModuleCombiner.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9286568f54e529177c6f19e1a05ead66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9286568f54e529177c6f19e1a05ead66">&#9670;&nbsp;</a></span>appendModuleHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::spirv::appendModuleHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spirv::Version&#160;</td>
          <td class="paramname"><em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idBound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends a SPRI-V module header to <code>header</code> with the given <code>version</code> and <code>idBound</code>. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVBinaryUtils_8cpp_source.html#l00021">21</a> of file <a class="el" href="SPIRVBinaryUtils_8cpp_source.html">SPIRVBinaryUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVBinaryUtils_8h_source.html#l00031">kGeneratorNumber</a>, <a class="el" href="SPIRVBinaryUtils_8h_source.html#l00028">kMagicNumber</a>, and <a class="el" href="SPIRVBinaryUtils_8cpp.html#a689f1d4c6493b449baf3c637ceaed760">MIN_VERSION_CASE</a>.</p>

<p class="reference">Referenced by <a class="el" href="Serializer_8cpp_source.html#l00131">mlir::spirv::Serializer::collect()</a>.</p>

</div>
</div>
<a id="ac6b261512c278d63826166487f8ef08f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b261512c278d63826166487f8ef08f">&#9670;&nbsp;</a></span>combine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; spirv::ModuleOp &gt; mlir::spirv::combine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; spirv::ModuleOp &gt;&#160;</td>
          <td class="paramname"><em>inputModules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>combinedModuleBuilder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1spirv.html#acac1b5d87a905e6e58d061fca3c4b9c2">SymbolRenameListener</a>&#160;</td>
          <td class="paramname"><em>symRenameListener</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines a list of SPIR-V <code>inputModules</code> into one. </p>
<p>Returns the combined module on success; returns a null module otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputModules</td><td>the list of modules to combine. They won't be modified. </td></tr>
    <tr><td class="paramname">combinedMdouleBuilder</td><td>an <a class="el" href="classmlir_1_1OpBuilder.html" title="This class helps build Operations.">OpBuilder</a> for building the combined module. </td></tr>
    <tr><td class="paramname">symbRenameListener</td><td>a listener that gets called everytime a symbol in one of the input modules is renamed.</td></tr>
  </table>
  </dd>
</dl>
<p>To combine multiple SPIR-V modules, we move all the module-level ops from all the input modules into one big combined module. To that end, the combination process proceeds in 2 phases:</p>
<ol type="1">
<li>resolve conflicts between pairs of ops from different modules,</li>
<li>deduplicate equivalent ops/sub-ops in the merged module.</li>
</ol>
<p>For the conflict resolution phase, the following rules are employed to resolve such conflicts:</p>
<ul>
<li>If 2 spirv.func's have the same symbol name, then rename one of the functions.</li>
<li>If an spirv.func and another op have the same symbol name, then rename the other symbol.</li>
<li>If none of the 2 conflicting ops are spirv.func, then rename either.</li>
</ul>
<p>For deduplication, the following 3 cases are taken into consideration:</p>
<ul>
<li>If 2 spirv.GlobalVariable's have either the same descriptor set + binding or the same build_in attribute value, then replace one of them using the other.</li>
<li>If 2 spirv.SpecConstant's have the same spec_id attribute value, then replace one of them using the other.</li>
<li>Deduplicating functions are not supported right now.</li>
</ul>
<p>In all cases, the references to the updated symbol (whether renamed or deduplicated) are also updated to reflect the change. </p>

<p class="definition">Definition at line <a class="el" href="ModuleCombiner_8cpp_source.html#l00085">85</a> of file <a class="el" href="ModuleCombiner_8cpp_source.html">ModuleCombiner.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleCombiner_8cpp_source.html#l00072">computeHash()</a>, <a class="el" href="Builders_8cpp_source.html#l00416">mlir::OpBuilder::insert()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00927">mlir::SymbolTable::replaceAllSymbolUses()</a>, <a class="el" href="Builders_8h_source.html#l00429">mlir::OpBuilder::setInsertionPointToStart()</a>, and <a class="el" href="ModuleCombiner_8cpp_source.html#l00047">updateSymbolAndAllUses()</a>.</p>

</div>
</div>
<a id="a7e9f6b211dd293640a9a09e34fb90c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e9f6b211dd293640a9a09e34fb90c3b">&#9670;&nbsp;</a></span>convertMemRefTypesAndAttrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::spirv::convertMemRefTypesAndAttrs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1spirv_1_1MemorySpaceToStorageClassConverter.html">MemorySpaceToStorageClassConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts all MemRef types and attributes in the op, as decided by the <code>typeConverter</code>. </p>

<p class="definition">Definition at line <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html#l00249">249</a> of file <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html">MapMemRefStorageClassPass.cpp</a>.</p>

<p class="reference">References <a class="el" href="AttrTypeSubElements_8cpp_source.html#l00074">mlir::detail::AttrTypeReplacerBase&lt; Concrete &gt;::addReplacement()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03027">mlir::TypeConverter::convertType()</a>, and <a class="el" href="AttrTypeSubElements_8cpp_source.html#l00137">mlir::detail::AttrTypeReplacerBase&lt; Concrete &gt;::recursivelyReplaceElementsIn()</a>.</p>

</div>
</div>
<a id="a532fea1d10bcd9e6077280b75e851845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a532fea1d10bcd9e6077280b75e851845">&#9670;&nbsp;</a></span>createUnifyAliasedResourcePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; spirv::ModuleOp &gt; &gt; mlir::spirv::createUnifyAliasedResourcePass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1spirv.html#a738af61310165c2eb21778ca20406b6a">spirv::GetTargetEnvFn</a>&#160;</td>
          <td class="paramname"><em>getTargetEnv</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00623">623</a> of file <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html">UnifyAliasedResourcePass.cpp</a>.</p>

</div>
</div>
<a id="ab3ae92c06481ab5590c94261e73b6166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ae92c06481ab5590c94261e73b6166">&#9670;&nbsp;</a></span>decodeStringLiteral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StringRef mlir::spirv::decodeStringLiteral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>wordIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decodes a string literal in <code>words</code> starting at <code>wordIndex</code>. </p>
<p>Update the latter to point to the position in words after the string literal. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVBinaryUtils_8h_source.html#l00054">54</a> of file <a class="el" href="SPIRVBinaryUtils_8h_source.html">SPIRVBinaryUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="DeserializeOps_8cpp_source.html#l00350">Deserializer::processOp&lt; spirv::EntryPointOp &gt;()</a>.</p>

</div>
</div>
<a id="a30c0e940b606942d911c5050bcc23135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c0e940b606942d911c5050bcc23135">&#9670;&nbsp;</a></span>deserialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; spirv::ModuleOp &gt; mlir::spirv::deserialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>binary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1spirv_1_1DeserializationOptions.html">DeserializationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserializes the given SPIR-V <code>binary</code> module and creates a MLIR ModuleOp in the given <code>context</code>. </p>
<p>Returns the ModuleOp on success; otherwise, reports errors to the error handler registered with <code>context</code> and returns a null module. </p>

<p class="definition">Definition at line <a class="el" href="Deserialization_8cpp_source.html#l00016">16</a> of file <a class="el" href="Deserialization_8cpp_source.html">Deserialization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Deserializer_8cpp_source.html#l00102">mlir::spirv::Deserializer::collect()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00063">mlir::spirv::Deserializer::deserialize()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00036">deserializeModule()</a>, and <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00108">roundTripModule()</a>.</p>

</div>
</div>
<a id="a65663608696ea8ed3e771aa721401699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65663608696ea8ed3e771aa721401699">&#9670;&nbsp;</a></span>Deserializer::processOp&lt; spirv::CopyMemoryOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::spirv::Deserializer::processOp&lt; spirv::CopyMemoryOp &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>words</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DeserializeOps_8cpp_source.html#l00475">475</a> of file <a class="el" href="DeserializeOps_8cpp_source.html">DeserializeOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">mlir::emitError()</a>.</p>

</div>
</div>
<a id="a3a3f67306af2bae665876607f6cda007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a3f67306af2bae665876607f6cda007">&#9670;&nbsp;</a></span>Deserializer::processOp&lt; spirv::EntryPointOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::spirv::Deserializer::processOp&lt; spirv::EntryPointOp &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>words</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DeserializeOps_8cpp_source.html#l00349">349</a> of file <a class="el" href="DeserializeOps_8cpp_source.html">DeserializeOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVBinaryUtils_8h_source.html#l00054">decodeStringLiteral()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">mlir::emitError()</a>, and <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>.</p>

</div>
</div>
<a id="acf6e7f02b46ed0e63707dab1e129bb82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6e7f02b46ed0e63707dab1e129bb82">&#9670;&nbsp;</a></span>Deserializer::processOp&lt; spirv::ExecutionModeOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::spirv::Deserializer::processOp&lt; spirv::ExecutionModeOp &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>words</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DeserializeOps_8cpp_source.html#l00399">399</a> of file <a class="el" href="DeserializeOps_8cpp_source.html">DeserializeOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">mlir::emitError()</a>, and <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>.</p>

</div>
</div>
<a id="a009f0aa8f9f8655433f830b39d6c4ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a009f0aa8f9f8655433f830b39d6c4ab6">&#9670;&nbsp;</a></span>Deserializer::processOp&lt; spirv::FunctionCallOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::spirv::Deserializer::processOp&lt; spirv::FunctionCallOp &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>operands</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DeserializeOps_8cpp_source.html#l00433">433</a> of file <a class="el" href="DeserializeOps_8cpp_source.html">DeserializeOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">mlir::emitError()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, and <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00304">mlir::getType()</a>.</p>

</div>
</div>
<a id="a1028b0abc35997e95aefa6b3d26adf79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1028b0abc35997e95aefa6b3d26adf79">&#9670;&nbsp;</a></span>Deserializer::processOp&lt; spirv::GenericCastToPtrExplicitOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::spirv::Deserializer::processOp&lt; spirv::GenericCastToPtrExplicitOp &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>words</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DeserializeOps_8cpp_source.html#l00549">549</a> of file <a class="el" href="DeserializeOps_8cpp_source.html">DeserializeOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">mlir::emitError()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00407">mlir::Operation::getResult()</a>, and <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00304">mlir::getType()</a>.</p>

</div>
</div>
<a id="a833133e74c83ef32f078b57244466d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a833133e74c83ef32f078b57244466d0c">&#9670;&nbsp;</a></span>encodeInstructionInto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::spirv::encodeInstructionInto </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>binary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spirv::Opcode&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes an SPIR-V instruction with the given <code>opcode</code> and <code>operands</code> into the given <code>binary</code> vector. </p>

<p class="definition">Definition at line <a class="el" href="Serializer_8cpp_source.html#l00096">96</a> of file <a class="el" href="Serializer_8cpp_source.html">Serializer.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVBinaryUtils_8cpp_source.html#l00064">getPrefixedOpcode()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SerializeOps_8cpp_source.html#l00765">Serializer::processOp&lt; spirv::CopyMemoryOp &gt;()</a>, <a class="el" href="SerializeOps_8cpp_source.html#l00674">Serializer::processOp&lt; spirv::EntryPointOp &gt;()</a>, <a class="el" href="SerializeOps_8cpp_source.html#l00709">Serializer::processOp&lt; spirv::ExecutionModeOp &gt;()</a>, <a class="el" href="SerializeOps_8cpp_source.html#l00738">Serializer::processOp&lt; spirv::FunctionCallOp &gt;()</a>, and <a class="el" href="SerializeOps_8cpp_source.html#l00813">Serializer::processOp&lt; spirv::GenericCastToPtrExplicitOp &gt;()</a>.</p>

</div>
</div>
<a id="a0ff3c223d2106f6d92a5772a9d0736c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff3c223d2106f6d92a5772a9d0736c1">&#9670;&nbsp;</a></span>encodeStringLiteralInto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::spirv::encodeStringLiteralInto </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>binary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>literal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes an SPIR-V <code>literal</code> string into the given <code>binary</code> vector. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVBinaryUtils_8cpp_source.html#l00069">69</a> of file <a class="el" href="SPIRVBinaryUtils_8cpp_source.html">SPIRVBinaryUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVBinaryUtils_8h_source.html#l00038">kMaxLiteralWordCount</a>.</p>

<p class="reference">Referenced by <a class="el" href="SerializeOps_8cpp_source.html#l00674">Serializer::processOp&lt; spirv::EntryPointOp &gt;()</a>.</p>

</div>
</div>
<a id="acfc08440c5e35416cc6e6fe9458ba0f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfc08440c5e35416cc6e6fe9458ba0f7">&#9670;&nbsp;</a></span>extractValueFromConstOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::spirv::extractValueFromConstOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRVOps_8cpp_source.html#l00049">49</a> of file <a class="el" href="SPIRVOps_8cpp_source.html">SPIRVOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemoryOps_8cpp_source.html#l00263">getElementPtrType()</a>, and <a class="el" href="GroupOps_8cpp_source.html#l00024">verifyGroupNonUniformArithmeticOp()</a>.</p>

</div>
</div>
<a id="a9a30366862a8f8b0be559fa4a146303f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a30366862a8f8b0be559fa4a146303f">&#9670;&nbsp;</a></span>getAddressingModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spirv::AddressingModel mlir::spirv::getAddressingModel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">spirv::TargetEnvAttr</a>&#160;</td>
          <td class="paramname"><em>targetAttr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use64bitAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns addressing model selected based on target environment. </p>

<p class="definition">Definition at line <a class="el" href="TargetAndABI_8cpp_source.html#l00204">204</a> of file <a class="el" href="TargetAndABI_8cpp_source.html">TargetAndABI.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVAttributes_8cpp_source.html#l00317">mlir::spirv::TargetEnvAttr::getCapabilities()</a>.</p>

</div>
</div>
<a id="af8a5bac4bd972f84e389a5cfb0c0910a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a5bac4bd972f84e389a5cfb0c0910a">&#9670;&nbsp;</a></span>getBitWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::spirv::getBitWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the bit width of the <code>type</code>. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVOpUtils_8h_source.html#l00014">14</a> of file <a class="el" href="SPIRVOpUtils_8h_source.html">SPIRVOpUtils.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8cpp_source.html#l00122">mlir::Type::getIntOrFloatBitWidth()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00116">mlir::Type::isIntOrFloat()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DotProductOps_8cpp_source.html#l00067">verifyIntegerDotProduct()</a>.</p>

</div>
</div>
<a id="a4b978811716abbef69d507e684c3d01b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b978811716abbef69d507e684c3d01b">&#9670;&nbsp;</a></span>getBuiltinVariableValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::spirv::getBuiltinVariableValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BuiltIn&#160;</td>
          <td class="paramname"><em>builtin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>integerType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>&quot;__builtin__&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>suffix</em> = <code>&quot;__&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value for the given <code>builtin</code> variable. </p>
<p>This function gets or inserts the global variable associated for the builtin within the nearest symbol table enclosing <code>op</code>. Returns null <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> on error.</p>
<p>The global name being generated will be mangled using <code>preffix</code> and <code>suffix</code>. </p>

</div>
</div>
<a id="ae8a5ec8ce145d966b3571e93c7f7eb00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a5ec8ce145d966b3571e93c7f7eb00">&#9670;&nbsp;</a></span>getComputeVectorSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mlir::spirv::getComputeVectorSize </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRVConversion_8cpp_source.html#l01360">1360</a> of file <a class="el" href="SPIRVConversion_8cpp_source.html">SPIRVConversion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVConversion_8cpp_source.html#l01387">getNativeVectorShape()</a>, and <a class="el" href="SPIRVConversion_8cpp_source.html#l01369">getNativeVectorShapeImpl()</a>.</p>

</div>
</div>
<a id="af3f551011baf787c1ab494295dc46083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f551011baf787c1ab494295dc46083">&#9670;&nbsp;</a></span>getDecorationName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string mlir::spirv::getDecorationName </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>attrName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Serializer_8cpp_source.html#l00230">230</a> of file <a class="el" href="Serializer_8cpp_source.html">Serializer.cpp</a>.</p>

</div>
</div>
<a id="ae1f2ff3fa9b623a0a6fa86ac75af3f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f2ff3fa9b623a0a6fa86ac75af3f4d">&#9670;&nbsp;</a></span>getDefaultResourceLimits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spirv::ResourceLimitsAttr mlir::spirv::getDefaultResourceLimits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a default resource limits attribute that uses numbers from "Table 46. Required Limits" of the Vulkan spec. </p>

<p class="definition">Definition at line <a class="el" href="TargetAndABI_8cpp_source.html#l00152">152</a> of file <a class="el" href="TargetAndABI_8cpp_source.html">TargetAndABI.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, and <a class="el" href="Builders_8cpp_source.html#l00271">mlir::Builder::getI32ArrayAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetAndABI_8cpp_source.html#l00170">getDefaultTargetEnv()</a>.</p>

</div>
</div>
<a id="aeb49fbe2ae3a33a6f06fcc29a3698ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb49fbe2ae3a33a6f06fcc29a3698ac2">&#9670;&nbsp;</a></span>getDefaultTargetEnv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">spirv::TargetEnvAttr</a> mlir::spirv::getDefaultTargetEnv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the default target environment: SPIR-V 1.0 with Shader capability and no extra extensions. </p>

<p class="definition">Definition at line <a class="el" href="TargetAndABI_8cpp_source.html#l00170">170</a> of file <a class="el" href="TargetAndABI_8cpp_source.html">TargetAndABI.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVAttributes_8cpp_source.html#l00290">mlir::spirv::TargetEnvAttr::get()</a>, <a class="el" href="classmlir_1_1spirv_1_1VerCapExtAttr.html#a7d13aefc75fe19ec31af3a2abb800f2b">mlir::spirv::VerCapExtAttr::get()</a>, <a class="el" href="TargetAndABI_8cpp_source.html#l00152">getDefaultResourceLimits()</a>, and <a class="el" href="SPIRVAttributes_8h_source.html#l00148">mlir::spirv::TargetEnvAttr::kUnknownDeviceID</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetAndABI_8cpp_source.html#l00196">lookupTargetEnvOrDefault()</a>.</p>

</div>
</div>
<a id="a6686e4cb7cffae099e00c124e04d5420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6686e4cb7cffae099e00c124e04d5420">&#9670;&nbsp;</a></span>getDirectImpliedCapabilities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;Capability&gt; mlir::spirv::getDirectImpliedCapabilities </td>
          <td>(</td>
          <td class="paramtype">Capability&#160;</td>
          <td class="paramname"><em>cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the directly implied capabilities for the given capability. </p>
<p>These capabilities are implicitly declared by the given capability. </p>

</div>
</div>
<a id="a394632d97865e195ff8234c8d1c7e25d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394632d97865e195ff8234c8d1c7e25d">&#9670;&nbsp;</a></span>getDotProductMaxVersion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::optional&lt;spirv::Version&gt; mlir::spirv::getDotProductMaxVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DotProductOps_8cpp_source.html#l00032">32</a> of file <a class="el" href="DotProductOps_8cpp_source.html">DotProductOps.cpp</a>.</p>

</div>
</div>
<a id="ad8227007edef7398b270e9ff970c2e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8227007edef7398b270e9ff970c2e27">&#9670;&nbsp;</a></span>getDotProductMinVersion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::optional&lt;spirv::Version&gt; mlir::spirv::getDotProductMinVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DotProductOps_8cpp_source.html#l00028">28</a> of file <a class="el" href="DotProductOps_8cpp_source.html">DotProductOps.cpp</a>.</p>

</div>
</div>
<a id="a5cf05661a1e8fc56bd5368e4de1e2cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf05661a1e8fc56bd5368e4de1e2cd3">&#9670;&nbsp;</a></span>getElementPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::spirv::getElementPtr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>baseType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>basePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the index computation to get to the element at <code>indices</code> of the memory pointed to by <code>basePtr</code>, using the layout map of <code>baseType</code>. </p>
<p>Returns null if index computation cannot be performed. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVConversion_8cpp_source.html#l01342">1342</a> of file <a class="el" href="SPIRVConversion_8cpp_source.html">SPIRVConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVConversion_8cpp_source.html#l01540">mlir::SPIRVTypeConverter::allows()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l01307">getOpenCLElementPtr()</a>, and <a class="el" href="SPIRVConversion_8cpp_source.html#l01276">getVulkanElementPtr()</a>.</p>

</div>
</div>
<a id="a809d4956c103602772bfd32a209732ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a809d4956c103602772bfd32a209732ab">&#9670;&nbsp;</a></span>getElementPtrType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Type.html">Type</a> mlir::spirv::getElementPtrType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>baseLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryOps_8cpp_source.html#l00263">263</a> of file <a class="el" href="MemoryOps_8cpp_source.html">MemoryOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">mlir::emitError()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00049">extractValueFromConstOp()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00447">mlir::spirv::PointerType::get()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00119">mlir::Operation::getName()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemoryOps_8cpp_source.html#l00330">verifyAccessChain()</a>.</p>

</div>
</div>
<a id="a6f08251581a3ffe9f35ca3b355daf1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f08251581a3ffe9f35ca3b355daf1a9">&#9670;&nbsp;</a></span>getEntryPointABIAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spirv::EntryPointABIAttr mlir::spirv::getEntryPointABIAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int32_t &gt;&#160;</td>
          <td class="paramname"><em>workgroupSize</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; int &gt;&#160;</td>
          <td class="paramname"><em>subgroupSize</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; int &gt;&#160;</td>
          <td class="paramname"><em>targetWidth</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the EntryPointABIAttr given its fields. </p>
<p>targetWidth is used by several execution modes. It is the element width of floating-point operations. Refer to Execution Mode in SPIR-V specification. <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_execution_mode">https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_execution_mode</a> </p>

<p class="definition">Definition at line <a class="el" href="TargetAndABI_8cpp_source.html#l00119">119</a> of file <a class="el" href="TargetAndABI_8cpp_source.html">TargetAndABI.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00871">mlir::detail::DenseArrayAttrImpl&lt; int32_t &gt;::get()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, and <a class="el" href="XeGPUTargetInfo_8h_source.html#l00017">mlir::xegpu::targetinfo::subgroupSize</a>.</p>

</div>
</div>
<a id="aecdb10932f9d700379ed74c9df04e530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecdb10932f9d700379ed74c9df04e530">&#9670;&nbsp;</a></span>getEntryPointABIAttrName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef mlir::spirv::getEntryPointABIAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the attribute name for specifying entry point information. </p>

<p class="definition">Definition at line <a class="el" href="TargetAndABI_8cpp_source.html#l00117">117</a> of file <a class="el" href="TargetAndABI_8cpp_source.html">TargetAndABI.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetAndABI_8cpp_source.html#l00131">lookupEntryPointABI()</a>, <a class="el" href="GPUToSPIRV_8cpp_source.html#l00231">lowerAsEntryFunction()</a>, and <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00130">lowerEntryPointABIAttr()</a>.</p>

</div>
</div>
<a id="abdcd79b9cf8b161f54bf1ed72ee71887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdcd79b9cf8b161f54bf1ed72ee71887">&#9670;&nbsp;</a></span>getExecutionModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; spirv::ExecutionModel &gt; mlir::spirv::getExecutionModel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">spirv::TargetEnvAttr</a>&#160;</td>
          <td class="paramname"><em>targetAttr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns execution model selected based on target environment. </p>
<p>Returns failure if it cannot be selected. </p>

<p class="definition">Definition at line <a class="el" href="TargetAndABI_8cpp_source.html#l00221">221</a> of file <a class="el" href="TargetAndABI_8cpp_source.html">TargetAndABI.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVAttributes_8cpp_source.html#l00317">mlir::spirv::TargetEnvAttr::getCapabilities()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00130">lowerEntryPointABIAttr()</a>.</p>

</div>
</div>
<a id="a2ebec54b6a40e0cb8f2c7d3640663be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ebec54b6a40e0cb8f2c7d3640663be4">&#9670;&nbsp;</a></span>getImpliedExtensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;Extension&gt; mlir::spirv::getImpliedExtensions </td>
          <td>(</td>
          <td class="paramtype">Version&#160;</td>
          <td class="paramname"><em>version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the implied extensions for the given version. </p>
<p>These extensions are incorporated into the current version so they are implicitly declared when targeting the given version. </p>

<p class="reference">Referenced by <a class="el" href="TargetAndABI_8cpp_source.html#l00023">mlir::spirv::TargetEnv::TargetEnv()</a>.</p>

</div>
</div>
<a id="a676476d2d440781f305e16af3eabf77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676476d2d440781f305e16af3eabf77e">&#9670;&nbsp;</a></span>getIntegerDotProductCapabilities()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntegerDotProductOpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;spirv::Capability&gt;, 1&gt; mlir::spirv::getIntegerDotProductCapabilities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DotProductOps_8cpp_source.html#l00122">122</a> of file <a class="el" href="DotProductOps_8cpp_source.html">DotProductOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00534">mlir::Operation::getAttr()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00119">mlir::Operation::getName()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00350">mlir::Operation::getOperand()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="adae828f37a7d5ee7522312493ba336fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae828f37a7d5ee7522312493ba336fc">&#9670;&nbsp;</a></span>getIntegerDotProductExtensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;spirv::Extension&gt;, 1&gt; mlir::spirv::getIntegerDotProductExtensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DotProductOps_8cpp_source.html#l00113">113</a> of file <a class="el" href="DotProductOps_8cpp_source.html">DotProductOps.cpp</a>.</p>

</div>
</div>
<a id="a2f9e55893c038502a0f52cddddb6c95c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9e55893c038502a0f52cddddb6c95c">&#9670;&nbsp;</a></span>getInterfaceVarABIAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1spirv_1_1InterfaceVarABIAttr.html">InterfaceVarABIAttr</a> mlir::spirv::getInterfaceVarABIAttr </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>descriptorSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>binding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; StorageClass &gt;&#160;</td>
          <td class="paramname"><em>storageClass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the <a class="el" href="classmlir_1_1spirv_1_1InterfaceVarABIAttr.html" title="An attribute that specifies the information regarding the interface variable: descriptor set,...">InterfaceVarABIAttr</a> given its fields. </p>

<p class="reference">Referenced by <a class="el" href="GPUToSPIRV_8cpp_source.html#l00291">getDefaultABIAttrs()</a>.</p>

</div>
</div>
<a id="a084723c4d96882caa7edd6bfc3dfe1d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084723c4d96882caa7edd6bfc3dfe1d0">&#9670;&nbsp;</a></span>getInterfaceVarABIAttrName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef mlir::spirv::getInterfaceVarABIAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the attribute name for specifying argument ABI information. </p>

<p class="definition">Definition at line <a class="el" href="TargetAndABI_8cpp_source.html#l00095">95</a> of file <a class="el" href="TargetAndABI_8cpp_source.html">TargetAndABI.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="GPUToSPIRV_8cpp_source.html#l00291">getDefaultABIAttrs()</a>, <a class="el" href="GPUToSPIRV_8cpp_source.html#l00231">lowerAsEntryFunction()</a>, and <a class="el" href="SPIRVDialect_8cpp_source.html#l01028">verifyRegionAttribute()</a>.</p>

</div>
</div>
<a id="acbfa30f0b7272297c6a305c0971a5fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbfa30f0b7272297c6a305c0971a5fc9">&#9670;&nbsp;</a></span>getMemoryModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; spirv::MemoryModel &gt; mlir::spirv::getMemoryModel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">spirv::TargetEnvAttr</a>&#160;</td>
          <td class="paramname"><em>targetAttr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns memory model selected based on target environment. </p>
<p>Returns failure if it cannot be selected. </p>

<p class="definition">Definition at line <a class="el" href="TargetAndABI_8cpp_source.html#l00232">232</a> of file <a class="el" href="TargetAndABI_8cpp_source.html">TargetAndABI.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVAttributes_8cpp_source.html#l00317">mlir::spirv::TargetEnvAttr::getCapabilities()</a>, and <a class="el" href="Runtimes_8h_source.html#l00018">mlir::gpu::amd::OpenCL</a>.</p>

</div>
</div>
<a id="a20da364acf11b2fc680395daeeca97fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20da364acf11b2fc680395daeeca97fc">&#9670;&nbsp;</a></span>getMemorySpaceToStorageClassTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &gt; mlir::spirv::getMemorySpaceToStorageClassTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the target that populates legality of ops with MemRef types. </p>

<p class="definition">Definition at line <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html#l00243">243</a> of file <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html">MapMemRefStorageClassPass.cpp</a>.</p>

<p class="reference">References <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html#l00225">isLegalOp()</a>.</p>

</div>
</div>
<a id="a6f2e3a1319726930b55969f2639fb749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2e3a1319726930b55969f2639fb749">&#9670;&nbsp;</a></span>getNativeVectorShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; &gt; mlir::spirv::getNativeVectorShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRVConversion_8cpp_source.html#l01387">1387</a> of file <a class="el" href="SPIRVConversion_8cpp_source.html">SPIRVConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVConversion_8cpp_source.html#l01360">getComputeVectorSize()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l01369">getNativeVectorShapeImpl()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00404">mlir::Operation::getNumResults()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00428">mlir::Operation::getResultTypes()</a>, and <a class="el" href="IR_2Operation_8cpp_source.html#l01397">mlir::OpTrait::hasElementwiseMappableTraits()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVConversion_8cpp_source.html#l01416">unrollVectorsInFuncBodies()</a>.</p>

</div>
</div>
<a id="acf43ecc3cd2c5913409b890e2cb88ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf43ecc3cd2c5913409b890e2cb88ed6">&#9670;&nbsp;</a></span>getNativeVectorShapeImpl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; mlir::spirv::getNativeVectorShapeImpl </td>
          <td>(</td>
          <td class="paramtype">vector::ReductionOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRVConversion_8cpp_source.html#l01369">1369</a> of file <a class="el" href="SPIRVConversion_8cpp_source.html">SPIRVConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVConversion_8cpp_source.html#l01360">getComputeVectorSize()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVConversion_8cpp_source.html#l01387">getNativeVectorShape()</a>.</p>

</div>
</div>
<a id="a13851586933739a9da459d59df4dfd44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13851586933739a9da459d59df4dfd44">&#9670;&nbsp;</a></span>getNativeVectorShapeImpl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; mlir::spirv::getNativeVectorShapeImpl </td>
          <td>(</td>
          <td class="paramtype">vector::TransposeOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRVConversion_8cpp_source.html#l01378">1378</a> of file <a class="el" href="SPIRVConversion_8cpp_source.html">SPIRVConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVConversion_8cpp_source.html#l01360">getComputeVectorSize()</a>.</p>

</div>
</div>
<a id="a653a80ab59a80ccc192c23b29742f534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a653a80ab59a80ccc192c23b29742f534">&#9670;&nbsp;</a></span>getOpenCLElementPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::spirv::getOpenCLElementPtr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>baseType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>basePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRVConversion_8cpp_source.html#l01307">1307</a> of file <a class="el" href="SPIRVConversion_8cpp_source.html">SPIRVConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVConversion_8cpp_source.html#l01532">mlir::SPIRVTypeConverter::getIndexType()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="DecomposeLinalgOps_8cpp_source.html#l00132">getZero()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l02027">mlir::affine::linearizeIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVConversion_8cpp_source.html#l01342">getElementPtr()</a>.</p>

</div>
</div>
<a id="a6583bd4786f75b42698de079fe0bc892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6583bd4786f75b42698de079fe0bc892">&#9670;&nbsp;</a></span>getPrefixedOpcode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mlir::spirv::getPrefixedOpcode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wordCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spirv::Opcode&#160;</td>
          <td class="paramname"><em>opcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the word-count-prefixed opcode for an SPIR-V instruction. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVBinaryUtils_8cpp_source.html#l00064">64</a> of file <a class="el" href="SPIRVBinaryUtils_8cpp_source.html">SPIRVBinaryUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Serializer_8cpp_source.html#l00096">encodeInstructionInto()</a>.</p>

</div>
</div>
<a id="a6ced2ee0b51782190a208ff6d7266782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ced2ee0b51782190a208ff6d7266782">&#9670;&nbsp;</a></span>getPushConstantValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::spirv::getPushConstantValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>elementCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>integerType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the value at the given <code>offset</code> of the push constant storage with a total of <code>elementCount</code> <code>integerType</code> integers. </p>
<p>A global variable will be created in the nearest symbol table enclosing <code>op</code> for the push constant storage if not existing. Load ops will be created via the given <code>builder</code> to load values from the push constant. Returns null <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> on error. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVConversion_8cpp_source.html#l01225">1225</a> of file <a class="el" href="SPIRVConversion_8cpp_source.html">SPIRVConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00267">mlir::Operation::emitError()</a>, <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="Builders_8cpp_source.html#l00195">mlir::Builder::getI32IntegerAttr()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00336">mlir::SymbolTable::getNearestSymbolTable()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00686">mlir::Operation::getRegion()</a>, and <a class="el" href="DecomposeLinalgOps_8cpp_source.html#l00132">getZero()</a>.</p>

</div>
</div>
<a id="a1d09788a1496828ace197176ce75e3d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d09788a1496828ace197176ce75e3d9">&#9670;&nbsp;</a></span>getRecursiveImpliedCapabilities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;Capability, 0&gt; mlir::spirv::getRecursiveImpliedCapabilities </td>
          <td>(</td>
          <td class="paramtype">Capability&#160;</td>
          <td class="paramname"><em>cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the recursively implied capabilities for the given capability. </p>
<p>These capabilities are implicitly declared by the given capability. Compared to the above function, this function collects implied capabilities recursively: if an implicitly declared capability implicitly declares a third one, the third one will also be returned. </p>

<p class="reference">Referenced by <a class="el" href="TargetAndABI_8cpp_source.html#l00023">mlir::spirv::TargetEnv::TargetEnv()</a>.</p>

</div>
</div>
<a id="ac268d2b199ba1111315d3e1579bc0271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac268d2b199ba1111315d3e1579bc0271">&#9670;&nbsp;</a></span>getStrArrayAttrForEnumList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ty &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ArrayAttr mlir::spirv::getStrArrayAttrForEnumList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; Ty &gt;&#160;</td>
          <td class="paramname"><em>enumValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; StringRef(Ty)&gt;&#160;</td>
          <td class="paramname"><em>stringifyFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRVParsingUtils_8h_source.html#l00032">32</a> of file <a class="el" href="SPIRVParsingUtils_8h_source.html">SPIRVParsingUtils.h</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00301">mlir::Builder::getStrArrayAttr()</a>.</p>

</div>
</div>
<a id="a7980ee0979f2d8550c4c1b941523f0c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7980ee0979f2d8550c4c1b941523f0c5">&#9670;&nbsp;</a></span>getTargetEnvAttrName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef mlir::spirv::getTargetEnvAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the attribute name for specifying SPIR-V target environment. </p>

<p class="definition">Definition at line <a class="el" href="TargetAndABI_8cpp_source.html#l00168">168</a> of file <a class="el" href="TargetAndABI_8cpp_source.html">TargetAndABI.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetAndABI_8cpp_source.html#l00180">lookupTargetEnv()</a>.</p>

</div>
</div>
<a id="a4757f048f03fff191afe22bc187ca3c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4757f048f03fff191afe22bc187ca3c7">&#9670;&nbsp;</a></span>getUnaryOpResultType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Type.html">Type</a> mlir::spirv::getUnaryOpResultType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>operandType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Result of a logical op must be a scalar or vector of boolean type. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVOpDefinition_8cpp_source.html#l00041">41</a> of file <a class="el" href="SPIRVOpDefinition_8cpp_source.html">SPIRVOpDefinition.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00035">mlir::Type::getContext()</a>, and <a class="el" href="Builders_8cpp_source.html#l00066">mlir::Builder::getIntegerType()</a>.</p>

</div>
</div>
<a id="ac67459a8b3f1eaf3e9d2d91d593cd0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67459a8b3f1eaf3e9d2d91d593cd0e8">&#9670;&nbsp;</a></span>getVulkanElementPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::spirv::getVulkanElementPtr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>baseType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>basePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRVConversion_8cpp_source.html#l01276">1276</a> of file <a class="el" href="SPIRVConversion_8cpp_source.html">SPIRVConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVConversion_8cpp_source.html#l01532">mlir::SPIRVTypeConverter::getIndexType()</a>, <a class="el" href="DecomposeLinalgOps_8cpp_source.html#l00132">getZero()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l02027">mlir::affine::linearizeIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVConversion_8cpp_source.html#l01342">getElementPtr()</a>.</p>

</div>
</div>
<a id="a46c084c603df48bd16083158d58760c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c084c603df48bd16083158d58760c9">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::hash_code mlir::spirv::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1spirv_1_1StructType_1_1MemberDecorationInfo.html">StructType::MemberDecorationInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>memberDecorationInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRVTypes_8cpp_source.html#l01191">1191</a> of file <a class="el" href="SPIRVTypes_8cpp_source.html">SPIRVTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVTypes_8h_source.html#l00309">mlir::spirv::StructType::MemberDecorationInfo::decoration</a>, and <a class="el" href="SPIRVTypes_8h_source.html#l00308">mlir::spirv::StructType::MemberDecorationInfo::memberIndex</a>.</p>

<p class="reference">Referenced by <a class="el" href="Block_8h_source.html#l00435">llvm::DenseMapInfo&lt; mlir::Block::iterator &gt;::getHashValue()</a>, <a class="el" href="include_2mlir_2TableGen_2Pattern_8h_source.html#l00699">llvm::DenseMapInfo&lt; mlir::tblgen::DagLeaf &gt;::getHashValue()</a>, <a class="el" href="include_2mlir_2TableGen_2Pattern_8h_source.html#l00681">llvm::DenseMapInfo&lt; mlir::tblgen::DagNode &gt;::getHashValue()</a>, <a class="el" href="OpDefinition_8h_source.html#l02148">llvm::DenseMapInfo&lt; T, std::enable_if_t&lt; std::is_base_of&lt; mlir::OpState, T &gt;::value &amp;&amp;!mlir::detail::IsInterface&lt; T &gt;::value &gt; &gt;::getHashValue()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00086">mlir::detail::DenseIntOrFPElementsAttrStorage::getKey()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00240">mlir::detail::DenseStringElementsAttrStorage::getKey()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00131">mlir::detail::DenseIntOrFPElementsAttrStorage::getKeyForBoolData()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00163">mlir::detail::DenseIntOrFPElementsAttrStorage::getKeyForSplatBoolData()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l04901">getTargetEntryUniqueInfo()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l01197">hash_value()</a>, <a class="el" href="lib_2Conversion_2PDLToPDLInterp_2Predicate_8h_source.html#l00236">mlir::pdl_to_pdl_interp::OperandGroupPosition::hashKey()</a>, <a class="el" href="lib_2Conversion_2PDLToPDLInterp_2Predicate_8h_source.html#l00265">mlir::pdl_to_pdl_interp::OperationPosition::hashKey()</a>, <a class="el" href="lib_2Conversion_2PDLToPDLInterp_2Predicate_8h_source.html#l00342">mlir::pdl_to_pdl_interp::ResultGroupPosition::hashKey()</a>, <a class="el" href="lib_2Conversion_2PDLToPDLInterp_2Predicate_8h_source.html#l00398">mlir::pdl_to_pdl_interp::UsersPosition::hashKey()</a>, <a class="el" href="lib_2Conversion_2PDLToPDLInterp_2Predicate_8h_source.html#l00518">mlir::pdl_to_pdl_interp::ConstraintQuestion::hashKey()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00107">mlir::detail::DynamicTypeStorage::hashKey()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00224">mlir::detail::DynamicAttrStorage::hashKey()</a>, <a class="el" href="IR_2TypeDetail_8h_source.html#l00036">mlir::detail::IntegerTypeStorage::hashKey()</a>, and <a class="el" href="Support_8cpp_source.html#l00051">mlirTypeIDHashValue()</a>.</p>

</div>
</div>
<a id="a215deffc5609ff655292d919ab241d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215deffc5609ff655292d919ab241d85">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::hash_code mlir::spirv::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1spirv_1_1StructType_1_1StructDecorationInfo.html">StructType::StructDecorationInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>structDecorationInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRVTypes_8cpp_source.html#l01197">1197</a> of file <a class="el" href="SPIRVTypes_8cpp_source.html">SPIRVTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVTypes_8h_source.html#l00335">mlir::spirv::StructType::StructDecorationInfo::decoration</a>, and <a class="el" href="SPIRVTypes_8cpp_source.html#l01191">hash_value()</a>.</p>

</div>
</div>
<a id="a95b28c2f734f6425b815e5f9171ca3d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95b28c2f734f6425b815e5f9171ca3d0">&#9670;&nbsp;</a></span>hasOneBranchOpTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::spirv::hasOneBranchOpTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> &amp;&#160;</td>
          <td class="paramname"><em>srcBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> &amp;&#160;</td>
          <td class="paramname"><em>dstBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the given <code>srcBlock</code> contains only one <code>spirv.Branch</code> to the given <code>dstBlock</code>. </p>

<p class="definition">Definition at line <a class="el" href="SPIRV_2IR_2ControlFlowOps_8cpp_source.html#l00255">255</a> of file <a class="el" href="SPIRV_2IR_2ControlFlowOps_8cpp_source.html">ControlFlowOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00152">mlir::Block::back()</a>.</p>

</div>
</div>
<a id="a7c6f9f95b9b3574fe2aaab652cedd3e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c6f9f95b9b3574fe2aaab652cedd3e0">&#9670;&nbsp;</a></span>hasOtherMerge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::spirv::hasOtherMerge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if a <code>spirv.mlir.merge</code> op outside the merge block. </p>

<p class="definition">Definition at line <a class="el" href="SPIRV_2IR_2ControlFlowOps_8cpp_source.html#l00270">270</a> of file <a class="el" href="SPIRV_2IR_2ControlFlowOps_8cpp_source.html">ControlFlowOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00060">mlir::Region::empty()</a>, and <a class="el" href="IR_2Region_8h_source.html#l00172">mlir::Region::getOps()</a>.</p>

</div>
</div>
<a id="a39af790fb25338fbbf6b1fe7b6d01b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39af790fb25338fbbf6b1fe7b6d01b7c">&#9670;&nbsp;</a></span>isDirectInModuleLikeOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::spirv::isDirectInModuleLikeOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the given op is an module-like op that maintains a symbol table. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVOpDefinition_8cpp_source.html#l00036">36</a> of file <a class="el" href="SPIRVOpDefinition_8cpp_source.html">SPIRVOpDefinition.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00749">mlir::Operation::hasTrait()</a>.</p>

</div>
</div>
<a id="ac60bacfdcb016bfa3eb07c13bb8026ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60bacfdcb016bfa3eb07c13bb8026ee">&#9670;&nbsp;</a></span>isMergeBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::spirv::isMergeBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> &amp;&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the given <code>block</code> only contains one <code>spirv.mlir.merge</code> op. </p>

<p class="definition">Definition at line <a class="el" href="SPIRV_2IR_2ControlFlowOps_8cpp_source.html#l00265">265</a> of file <a class="el" href="SPIRV_2IR_2ControlFlowOps_8cpp_source.html">ControlFlowOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00153">mlir::Block::front()</a>.</p>

</div>
</div>
<a id="a9a67866a73d73caa33070def2e25a17f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a67866a73d73caa33070def2e25a17f">&#9670;&nbsp;</a></span>isNestedInFunctionOpInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::spirv::isNestedInFunctionOpInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the given op is a function-like op or nested in a function-like op without a module-like op in the middle. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVOpDefinition_8cpp_source.html#l00024">24</a> of file <a class="el" href="SPIRVOpDefinition_8cpp_source.html">SPIRVOpDefinition.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00749">mlir::Operation::hasTrait()</a>.</p>

</div>
</div>
<a id="ab4e2e0e2f96602ed55862a37bee299b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e2e0e2f96602ed55862a37bee299b2">&#9670;&nbsp;</a></span>linearizeIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::spirv::linearizeIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>integerType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates IR to perform index linearization with the given <code>indices</code> and their corresponding <code>strides</code>, adding an initial <code>offset</code>. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVConversion_8cpp_source.html#l01251">1251</a> of file <a class="el" href="SPIRVConversion_8cpp_source.html">SPIRVConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00517">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, and <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>.</p>

</div>
</div>
<a id="a56a2cd4522a0c39add4adcd2db5fe8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56a2cd4522a0c39add4adcd2db5fe8fc">&#9670;&nbsp;</a></span>lookupEntryPointABI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spirv::EntryPointABIAttr mlir::spirv::lookupEntryPointABI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries the entry point ABI on the nearest function-like op containing the given <code>op</code>. </p>
<p>Returns null attribute if not found. </p>

<p class="definition">Definition at line <a class="el" href="TargetAndABI_8cpp_source.html#l00131">131</a> of file <a class="el" href="TargetAndABI_8cpp_source.html">TargetAndABI.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00550">mlir::Operation::getAttrOfType()</a>, <a class="el" href="TargetAndABI_8cpp_source.html#l00117">getEntryPointABIAttrName()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetAndABI_8cpp_source.html#l00144">lookupLocalWorkGroupSize()</a>.</p>

</div>
</div>
<a id="a86f5018eaa55fce107cc068b85d9dbf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f5018eaa55fce107cc068b85d9dbf2">&#9670;&nbsp;</a></span>lookupLocalWorkGroupSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#ace9107ae5cb34fa1aa00e0fd1377ad89">DenseI32ArrayAttr</a> mlir::spirv::lookupLocalWorkGroupSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries the local workgroup size from entry point ABI on the nearest function-like op containing the given <code>op</code>. </p>
<p>Returns null attribute if not found. </p>

<p class="definition">Definition at line <a class="el" href="TargetAndABI_8cpp_source.html#l00144">144</a> of file <a class="el" href="TargetAndABI_8cpp_source.html">TargetAndABI.cpp</a>.</p>

<p class="reference">References <a class="el" href="TargetAndABI_8cpp_source.html#l00131">lookupEntryPointABI()</a>.</p>

</div>
</div>
<a id="a78b51f6bb34187b8de569585d635a9eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b51f6bb34187b8de569585d635a9eb">&#9670;&nbsp;</a></span>lookupTargetEnv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">spirv::TargetEnvAttr</a> mlir::spirv::lookupTargetEnv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries the target environment recursively from enclosing symbol table ops containing the given <code>op</code>. </p>

<p class="definition">Definition at line <a class="el" href="TargetAndABI_8cpp_source.html#l00180">180</a> of file <a class="el" href="TargetAndABI_8cpp_source.html">TargetAndABI.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00550">mlir::Operation::getAttrOfType()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00336">mlir::SymbolTable::getNearestSymbolTable()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>, and <a class="el" href="TargetAndABI_8cpp_source.html#l00168">getTargetEnvAttrName()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00091">getInterfaceVariables()</a>, <a class="el" href="TargetAndABI_8cpp_source.html#l00196">lookupTargetEnvOrDefault()</a>, and <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00130">lowerEntryPointABIAttr()</a>.</p>

</div>
</div>
<a id="a2ae1ed3e62618274db5bad38955db408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae1ed3e62618274db5bad38955db408">&#9670;&nbsp;</a></span>lookupTargetEnvOrDefault()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">spirv::TargetEnvAttr</a> mlir::spirv::lookupTargetEnvOrDefault </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries the target environment recursively from enclosing symbol table ops containing the given <code>op</code> or returns the default target environment as returned by <a class="el" href="namespacemlir_1_1spirv.html#aeb49fbe2ae3a33a6f06fcc29a3698ac2" title="Returns the default target environment: SPIR-V 1.0 with Shader capability and no extra extensions.">getDefaultTargetEnv()</a> if not provided. </p>

<p class="definition">Definition at line <a class="el" href="TargetAndABI_8cpp_source.html#l00196">196</a> of file <a class="el" href="TargetAndABI_8cpp_source.html">TargetAndABI.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00216">mlir::Operation::getContext()</a>, <a class="el" href="TargetAndABI_8cpp_source.html#l00170">getDefaultTargetEnv()</a>, and <a class="el" href="TargetAndABI_8cpp_source.html#l00180">lookupTargetEnv()</a>.</p>

</div>
</div>
<a id="a8f9d2054fc47779669c16a7b94c1d8f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9d2054fc47779669c16a7b94c1d8f8">&#9670;&nbsp;</a></span>mapMemorySpaceToOpenCLStorageClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; spirv::StorageClass &gt; mlir::spirv::mapMemorySpaceToOpenCLStorageClass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpaceAttr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps MemRef memory spaces to storage classes for OpenCL-flavored SPIR-V using the default rule. </p>
<p>Returns std::nullopt if the memory space is unknown. </p>

<p class="definition">Definition at line <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html#l00120">120</a> of file <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html">MapMemRefStorageClassPass.cpp</a>.</p>

<p class="reference">References <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html#l00110">OPENCL_STORAGE_SPACE_MAP_LIST</a>, and <a class="el" href="MapMemRefStorageClassPass_8cpp.html#a3d01385e94043fb63719e7abba469fd6">STORAGE_SPACE_MAP_FN</a>.</p>

</div>
</div>
<a id="aff7500a2bef54b9434232db13ff7fc0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff7500a2bef54b9434232db13ff7fc0f">&#9670;&nbsp;</a></span>mapMemorySpaceToVulkanStorageClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; spirv::StorageClass &gt; mlir::spirv::mapMemorySpaceToVulkanStorageClass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpaceAttr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps MemRef memory spaces to storage classes for Vulkan-flavored SPIR-V using the default rule. </p>
<p>Returns std::nullopt if the memory space is unknown. </p>

<p class="definition">Definition at line <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html#l00066">66</a> of file <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html">MapMemRefStorageClassPass.cpp</a>.</p>

<p class="reference">References <a class="el" href="MapMemRefStorageClassPass_8cpp.html#a3d01385e94043fb63719e7abba469fd6">STORAGE_SPACE_MAP_FN</a>, and <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html#l00051">VULKAN_STORAGE_SPACE_MAP_LIST</a>.</p>

</div>
</div>
<a id="af2fa0e61a068deec7045f64b7b9d647b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2fa0e61a068deec7045f64b7b9d647b">&#9670;&nbsp;</a></span>mapOpenCLStorageClassToMemorySpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; unsigned &gt; mlir::spirv::mapOpenCLStorageClassToMemorySpace </td>
          <td>(</td>
          <td class="paramtype">spirv::StorageClass&#160;</td>
          <td class="paramname"><em>storageClass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps storage classes for OpenCL-flavored SPIR-V to MemRef memory spaces using the default rule. </p>
<p>Returns std::nullopt if the storage class is unsupported. </p>

<p class="definition">Definition at line <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html#l00147">147</a> of file <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html">MapMemRefStorageClassPass.cpp</a>.</p>

<p class="reference">References <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html#l00110">OPENCL_STORAGE_SPACE_MAP_LIST</a>, and <a class="el" href="MapMemRefStorageClassPass_8cpp.html#a3d01385e94043fb63719e7abba469fd6">STORAGE_SPACE_MAP_FN</a>.</p>

</div>
</div>
<a id="acb4d73b5b3c59e88355cb3ca823a2f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb4d73b5b3c59e88355cb3ca823a2f37">&#9670;&nbsp;</a></span>mapVulkanStorageClassToMemorySpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; unsigned &gt; mlir::spirv::mapVulkanStorageClassToMemorySpace </td>
          <td>(</td>
          <td class="paramtype">spirv::StorageClass&#160;</td>
          <td class="paramname"><em>storageClass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps storage classes for Vulkan-flavored SPIR-V to MemRef memory spaces using the default rule. </p>
<p>Returns std::nullopt if the storage class is unsupported. </p>

<p class="definition">Definition at line <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html#l00093">93</a> of file <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html">MapMemRefStorageClassPass.cpp</a>.</p>

<p class="reference">References <a class="el" href="MapMemRefStorageClassPass_8cpp.html#a3d01385e94043fb63719e7abba469fd6">STORAGE_SPACE_MAP_FN</a>, and <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html#l00051">VULKAN_STORAGE_SPACE_MAP_LIST</a>.</p>

</div>
</div>
<a id="a1f116e5f53987bfcf7bfb81faba201e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f116e5f53987bfcf7bfb81faba201e3">&#9670;&nbsp;</a></span>needsInterfaceVarABIAttrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::spirv::needsInterfaceVarABIAttrs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">spirv::TargetEnvAttr</a>&#160;</td>
          <td class="paramname"><em>targetAttr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the given SPIR-V target (described by <a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html" title="An attribute that specifies the target version, allowed extensions and capabilities,...">TargetEnvAttr</a>) needs ABI attributes for interface variables (spirv.interface_var_abi). </p>

<p class="definition">Definition at line <a class="el" href="TargetAndABI_8cpp_source.html#l00107">107</a> of file <a class="el" href="TargetAndABI_8cpp_source.html">TargetAndABI.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVAttributes_8cpp_source.html#l00317">mlir::spirv::TargetEnvAttr::getCapabilities()</a>.</p>

<p class="reference">Referenced by <a class="el" href="GPUToSPIRV_8cpp_source.html#l00291">getDefaultABIAttrs()</a>.</p>

</div>
</div>
<a id="aa15884622a81b27f8389f600302472d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15884622a81b27f8389f600302472d0">&#9670;&nbsp;</a></span>parseControlAttribute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EnumAttrClass , typename EnumClass &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ParseResult mlir::spirv::parseControlAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>attrName</em> = <code>spirv::attributeName&lt;EnumClass&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses Function, Selection and Loop control attributes. </p>
<p>If no control is specified, "None" is used as a default. </p>

<p class="definition">Definition at line <a class="el" href="SPIRV_2IR_2ControlFlowOps_8cpp_source.html#l00031">31</a> of file <a class="el" href="SPIRV_2IR_2ControlFlowOps_8cpp_source.html">ControlFlowOps.cpp</a>.</p>

</div>
</div>
<a id="aac2e53b4f9b10e1b17ff9d68e53c431c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac2e53b4f9b10e1b17ff9d68e53c431c">&#9670;&nbsp;</a></span>parseEnumKeywordAttr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EnumAttrClass , typename EnumClass  = typename EnumAttrClass::ValueType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ParseResult mlir::spirv::parseEnumKeywordAttr </td>
          <td>(</td>
          <td class="paramtype">EnumClass &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>attrName</em> = <code>spirv::attributeName&lt;EnumClass&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the next keyword in <code>parser</code> as an enumerant of the given <code>EnumClass</code> and inserts the enumerant into <code>state</code> as an 32-bit integer attribute with the enum class's name as attribute name. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVParsingUtils_8h_source.html#l00112">112</a> of file <a class="el" href="SPIRVParsingUtils_8h_source.html">SPIRVParsingUtils.h</a>.</p>

</div>
</div>
<a id="a78d5aca268e56b3cf9554235e80804db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78d5aca268e56b3cf9554235e80804db">&#9670;&nbsp;</a></span>parseEnumKeywordAttr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EnumClass , typename ParserType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ParseResult mlir::spirv::parseEnumKeywordAttr </td>
          <td>(</td>
          <td class="paramtype">EnumClass &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParserType &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>attrName</em> = <code>spirv::attributeName&lt;EnumClass&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the next keyword in <code>parser</code> as an enumerant of the given <code>EnumClass</code>. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVParsingUtils_8h_source.html#l00049">49</a> of file <a class="el" href="SPIRVParsingUtils_8h_source.html">SPIRVParsingUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVDialect_8cpp_source.html#l00336">parseCooperativeMatrixType()</a>.</p>

</div>
</div>
<a id="a34c77d2389f3f8614e9f46d73220628b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c77d2389f3f8614e9f46d73220628b">&#9670;&nbsp;</a></span>parseEnumStrAttr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EnumAttrClass , typename EnumClass  = typename EnumAttrClass::ValueType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ParseResult mlir::spirv::parseEnumStrAttr </td>
          <td>(</td>
          <td class="paramtype">EnumClass &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>attrName</em> = <code>spirv::attributeName&lt;EnumClass&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the next string attribute in <code>parser</code> as an enumerant of the given <code>EnumClass</code> and inserts the enumerant into <code>state</code> as an 32-bit integer attribute with the enum class's name as attribute name. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVParsingUtils_8h_source.html#l00096">96</a> of file <a class="el" href="SPIRVParsingUtils_8h_source.html">SPIRVParsingUtils.h</a>.</p>

</div>
</div>
<a id="a2981f77642487cfdbaae9b5429d8280b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2981f77642487cfdbaae9b5429d8280b">&#9670;&nbsp;</a></span>parseEnumStrAttr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EnumClass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ParseResult mlir::spirv::parseEnumStrAttr </td>
          <td>(</td>
          <td class="paramtype">EnumClass &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>attrName</em> = <code>spirv::attributeName&lt;EnumClass&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the next string attribute in <code>parser</code> as an enumerant of the given <code>EnumClass</code>. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVParsingUtils_8h_source.html#l00069">69</a> of file <a class="el" href="SPIRVParsingUtils_8h_source.html">SPIRVParsingUtils.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1AsmParser.html#a33803273c4fc1a660d73cb91aceac30b">mlir::AsmParser::emitError()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2bf38020e304fa596401f15d1eb30e1d">mlir::AsmParser::getBuilder()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a7850fe0a2961f835384adb372758d58b">mlir::AsmParser::getCurrentLocation()</a>, <a class="el" href="Builders_8cpp_source.html#l00083">mlir::Builder::getNoneType()</a>, and <a class="el" href="classmlir_1_1AsmParser.html#afc30172e59d0a9e4a28d8ba7ddf1ac42">mlir::AsmParser::parseAttribute()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVOpDefinition_8cpp_source.html#l00049">parseImageOperands()</a>.</p>

</div>
</div>
<a id="ac77905bf65935a368b3f4c0c8c0efc84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77905bf65935a368b3f4c0c8c0efc84">&#9670;&nbsp;</a></span>parseImageOperands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ParseResult mlir::spirv::parseImageOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spirv::ImageOperandsAttr &amp;&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRVOpDefinition_8cpp_source.html#l00049">49</a> of file <a class="el" href="SPIRVOpDefinition_8cpp_source.html">SPIRVOpDefinition.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l00072">mlir::AsmParser::getContext()</a>, <a class="el" href="SPIRVParsingUtils_8h_source.html#l00069">parseEnumStrAttr()</a>, <a class="el" href="classmlir_1_1AsmParser.html#aed41da9f5ed12ea4b41136ef1b6239dd">mlir::AsmParser::parseOptionalLSquare()</a>, and <a class="el" href="classmlir_1_1AsmParser.html#a3a1446df423154a41d52374b062ee1ff">mlir::AsmParser::parseRSquare()</a>.</p>

</div>
</div>
<a id="a7a43e19678538c6f1c665db936052836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a43e19678538c6f1c665db936052836">&#9670;&nbsp;</a></span>parseMemoryAccessAttributes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemoryOpTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ParseResult mlir::spirv::parseMemoryAccessAttributes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses optional memory access (a.k.a. </p>
<p>memory operand) attributes attached to a memory access operand/pointer. Specifically, parses the following syntax: (<code>[</code> memory-access <code>]</code>)? where: memory-access ::= <code>"None"</code> | <code>"Volatile"</code> | <code>"Aligned",</code> integer-literal | <code>"NonTemporal"</code> </p>

<p class="definition">Definition at line <a class="el" href="MemoryOps_8cpp_source.html#l00035">35</a> of file <a class="el" href="MemoryOps_8cpp_source.html">MemoryOps.cpp</a>.</p>

</div>
</div>
<a id="a1e9f02c02f26079c13d69e35c3111f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9f02c02f26079c13d69e35c3111f2d">&#9670;&nbsp;</a></span>parseSourceMemoryAccessAttributes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemoryOpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ParseResult mlir::spirv::parseSourceMemoryAccessAttributes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryOps_8cpp_source.html#l00070">70</a> of file <a class="el" href="MemoryOps_8cpp_source.html">MemoryOps.cpp</a>.</p>

</div>
</div>
<a id="ae0e1df0fca3178658be46872db50cc3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e1df0fca3178658be46872db50cc3b">&#9670;&nbsp;</a></span>parseVariableDecorations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult mlir::spirv::parseVariableDecorations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRVParsingUtils_8cpp_source.html#l00021">21</a> of file <a class="el" href="SPIRVParsingUtils_8cpp_source.html">SPIRVParsingUtils.cpp</a>.</p>

</div>
</div>
<a id="a2d07c3e189c017279fdac530068fead3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d07c3e189c017279fdac530068fead3">&#9670;&nbsp;</a></span>populateSPIRVExpandExtendedMultiplicationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::spirv::populateSPIRVExpandExtendedMultiplicationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns to expand extended multiplication and adition ops into regular arithmetic ops. </p>
<p>Extended arithmetic ops are not supported by the WebGPU Shading Language (WGSL). </p>

<p class="definition">Definition at line <a class="el" href="SPIRVWebGPUTransforms_8cpp_source.html#l00250">250</a> of file <a class="el" href="SPIRVWebGPUTransforms_8cpp_source.html">SPIRVWebGPUTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a236adaeb429ba6067346306ad1093b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a236adaeb429ba6067346306ad1093b83">&#9670;&nbsp;</a></span>populateSPIRVExpandNonFiniteArithmeticPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::spirv::populateSPIRVExpandNonFiniteArithmeticPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns to expand non-finite arithmetic ops <code>IsNan</code> and <code>IsInf</code>. </p>
<p>These are not supported by the WebGPU Shading Language (WGSL). We follow fast math assumptions and assume that all floating point values are finite. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVWebGPUTransforms_8cpp_source.html#l00258">258</a> of file <a class="el" href="SPIRVWebGPUTransforms_8cpp_source.html">SPIRVWebGPUTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a765253a5d5815369244e7a4918fa1b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a765253a5d5815369244e7a4918fa1b89">&#9670;&nbsp;</a></span>populateSPIRVGLCanonicalizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::spirv::populateSPIRVGLCanonicalizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>results</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates patterns to run canoncalization that involves GL ops. </p>
<p>These patterns cannot be run in default canonicalization because GL ops aren't always available. So they should be involed specifically when needed. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVGLCanonicalization_8cpp_source.html#l00025">25</a> of file <a class="el" href="SPIRVGLCanonicalization_8cpp_source.html">SPIRVGLCanonicalization.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00845">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00821">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ab3ccbaebd40c40af4c17db768f22f80d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ccbaebd40c40af4c17db768f22f80d">&#9670;&nbsp;</a></span>printAccessChain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mlir::spirv::printAccessChain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Op.html">Op</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>printer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryOps_8cpp_source.html#l00324">324</a> of file <a class="el" href="MemoryOps_8cpp_source.html">MemoryOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1ValueRange.html#ab8f3a1aeea4da0acfaad1bc71b072017">mlir::ValueRange::getTypes()</a>.</p>

</div>
</div>
<a id="a798ee89dcf100a9abd8e038c398be41f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a798ee89dcf100a9abd8e038c398be41f">&#9670;&nbsp;</a></span>printImageOperands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mlir::spirv::printImageOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>printer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>imageOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spirv::ImageOperandsAttr&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRVOpDefinition_8cpp_source.html#l00064">64</a> of file <a class="el" href="SPIRVOpDefinition_8cpp_source.html">SPIRVOpDefinition.cpp</a>.</p>

</div>
</div>
<a id="acc45631cfda7737423de425ba2335997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc45631cfda7737423de425ba2335997">&#9670;&nbsp;</a></span>printMemoryAccessAttribute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemoryOpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mlir::spirv::printMemoryAccessAttribute </td>
          <td>(</td>
          <td class="paramtype">MemoryOpTy&#160;</td>
          <td class="paramname"><em>memoryOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>printer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; StringRef &gt; &amp;&#160;</td>
          <td class="paramname"><em>elidedAttrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; spirv::MemoryAccess &gt;&#160;</td>
          <td class="paramname"><em>memoryAccessAtrrValue</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>alignmentAttrValue</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryOps_8cpp_source.html#l00135">135</a> of file <a class="el" href="MemoryOps_8cpp_source.html">MemoryOps.cpp</a>.</p>

</div>
</div>
<a id="a6eb5cfcaf16ed861acbf2275d246c041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb5cfcaf16ed861acbf2275d246c041">&#9670;&nbsp;</a></span>printSourceMemoryAccessAttribute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemoryOpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mlir::spirv::printSourceMemoryAccessAttribute </td>
          <td>(</td>
          <td class="paramtype">MemoryOpTy&#160;</td>
          <td class="paramname"><em>memoryOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>printer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; StringRef &gt; &amp;&#160;</td>
          <td class="paramname"><em>elidedAttrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; spirv::MemoryAccess &gt;&#160;</td>
          <td class="paramname"><em>memoryAccessAtrrValue</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>alignmentAttrValue</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryOps_8cpp_source.html#l00106">106</a> of file <a class="el" href="MemoryOps_8cpp_source.html">MemoryOps.cpp</a>.</p>

</div>
</div>
<a id="a818b363cb52ee3d90e7a6495b9e829dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a818b363cb52ee3d90e7a6495b9e829dd">&#9670;&nbsp;</a></span>printVariableDecorations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::spirv::printVariableDecorations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>printer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; StringRef &gt; &amp;&#160;</td>
          <td class="paramname"><em>elidedAttrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRVOps_8cpp_source.html#l00093">93</a> of file <a class="el" href="SPIRVOps_8cpp_source.html">SPIRVOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00053">bindingName()</a>, <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00047">descriptorSetName()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00550">mlir::Operation::getAttrOfType()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00512">mlir::Operation::getAttrs()</a>, and <a class="el" href="classmlir_1_1OpAsmPrinter.html#a681280bde1406e824e1d4626fe257e1b">mlir::OpAsmPrinter::printOptionalAttrDict()</a>.</p>

</div>
</div>
<a id="a62c99a9b8928c873859c0ff2b7640e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62c99a9b8928c873859c0ff2b7640e17">&#9670;&nbsp;</a></span>processDecorationList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AttrTy , typename EmitF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::spirv::processDecorationList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decoration&#160;</td>
          <td class="paramname"><em>decoration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attrList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>attrName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EmitF&#160;</td>
          <td class="paramname"><em>emitter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Serializer_8cpp_source.html#l00248">248</a> of file <a class="el" href="Serializer_8cpp_source.html">Serializer.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">mlir::emitError()</a>.</p>

</div>
</div>
<a id="a5ae31a2fb6ec2e05490681b0bbeac920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae31a2fb6ec2e05490681b0bbeac920">&#9670;&nbsp;</a></span>registerSPIRVTargetInterfaceExternalModels() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::spirv::registerSPIRVTargetInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers the <code>TargetAttrInterface</code> for the <code>#spirv.target_env</code> attribute in the given registry. </p>

<p class="definition">Definition at line <a class="el" href="SPIRV_2Target_8cpp_source.html#l00044">44</a> of file <a class="el" href="SPIRV_2Target_8cpp_source.html">Target.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllDialects_8cpp_source.html#l00107">mlir::registerAllDialects()</a>, and <a class="el" href="SPIRV_2Target_8cpp_source.html#l00051">registerSPIRVTargetInterfaceExternalModels()</a>.</p>

</div>
</div>
<a id="a4a90ef73aefe4ec6694f07339c322541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a90ef73aefe4ec6694f07339c322541">&#9670;&nbsp;</a></span>registerSPIRVTargetInterfaceExternalModels() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::spirv::registerSPIRVTargetInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers the <code>TargetAttrInterface</code> for the <code>#spirv.target_env</code> attribute in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="SPIRV_2Target_8cpp_source.html#l00051">51</a> of file <a class="el" href="SPIRV_2Target_8cpp_source.html">Target.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00394">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="SPIRV_2Target_8cpp_source.html#l00044">registerSPIRVTargetInterfaceExternalModels()</a>.</p>

</div>
</div>
<a id="a764762951e6d168cda2fc62d3a4639ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764762951e6d168cda2fc62d3a4639ee">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::spirv::serialize </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>binary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1spirv_1_1SerializationOptions.html">SerializationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes the given SPIR-V <code>module</code> and writes to <code>binary</code>. </p>
<p>On failure, reports errors to the error handler registered with the MLIR context for <code>module</code>. </p>

<p class="reference">Referenced by <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00108">roundTripModule()</a>, and <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00079">serializeModule()</a>.</p>

</div>
</div>
<a id="ae02999329ba2aaf9d90c2154489e6ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae02999329ba2aaf9d90c2154489e6ace">&#9670;&nbsp;</a></span>Serializer::processOp&lt; spirv::CopyMemoryOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::spirv::Serializer::processOp&lt; spirv::CopyMemoryOp &gt; </td>
          <td>(</td>
          <td class="paramtype">spirv::CopyMemoryOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializeOps_8cpp_source.html#l00764">764</a> of file <a class="el" href="SerializeOps_8cpp_source.html">SerializeOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Serializer_8cpp_source.html#l00096">encodeInstructionInto()</a>.</p>

</div>
</div>
<a id="a9360bb2d9fb5d7a6d16eaa1a17132f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9360bb2d9fb5d7a6d16eaa1a17132f97">&#9670;&nbsp;</a></span>Serializer::processOp&lt; spirv::EntryPointOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::spirv::Serializer::processOp&lt; spirv::EntryPointOp &gt; </td>
          <td>(</td>
          <td class="paramtype">spirv::EntryPointOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializeOps_8cpp_source.html#l00673">673</a> of file <a class="el" href="SerializeOps_8cpp_source.html">SerializeOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Serializer_8cpp_source.html#l00096">encodeInstructionInto()</a>, and <a class="el" href="SPIRVBinaryUtils_8cpp_source.html#l00069">encodeStringLiteralInto()</a>.</p>

</div>
</div>
<a id="ad27df4c1b5396a8998d58603a044e5d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27df4c1b5396a8998d58603a044e5d0">&#9670;&nbsp;</a></span>Serializer::processOp&lt; spirv::ExecutionModeOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::spirv::Serializer::processOp&lt; spirv::ExecutionModeOp &gt; </td>
          <td>(</td>
          <td class="paramtype">spirv::ExecutionModeOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializeOps_8cpp_source.html#l00708">708</a> of file <a class="el" href="SerializeOps_8cpp_source.html">SerializeOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Serializer_8cpp_source.html#l00096">encodeInstructionInto()</a>.</p>

</div>
</div>
<a id="a8166d677987aab5a71255741c5b5a63b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8166d677987aab5a71255741c5b5a63b">&#9670;&nbsp;</a></span>Serializer::processOp&lt; spirv::FunctionCallOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::spirv::Serializer::processOp&lt; spirv::FunctionCallOp &gt; </td>
          <td>(</td>
          <td class="paramtype">spirv::FunctionCallOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializeOps_8cpp_source.html#l00737">737</a> of file <a class="el" href="SerializeOps_8cpp_source.html">SerializeOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Serializer_8cpp_source.html#l00096">encodeInstructionInto()</a>.</p>

</div>
</div>
<a id="ae30d7e3a8c376ff9d21825446fd0e6a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae30d7e3a8c376ff9d21825446fd0e6a2">&#9670;&nbsp;</a></span>Serializer::processOp&lt; spirv::GenericCastToPtrExplicitOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::spirv::Serializer::processOp&lt; spirv::GenericCastToPtrExplicitOp &gt; </td>
          <td>(</td>
          <td class="paramtype">spirv::GenericCastToPtrExplicitOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializeOps_8cpp_source.html#l00813">813</a> of file <a class="el" href="SerializeOps_8cpp_source.html">SerializeOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Serializer_8cpp_source.html#l00096">encodeInstructionInto()</a>.</p>

</div>
</div>
<a id="a0066624e2704755cca3404ab368dbcc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0066624e2704755cca3404ab368dbcc3">&#9670;&nbsp;</a></span>Serializer::processTypeDecoration&lt; spirv::ArrayType &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::spirv::Serializer::processTypeDecoration&lt; <a class="el" href="classmlir_1_1spirv_1_1ArrayType.html">spirv::ArrayType</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1spirv_1_1ArrayType.html">spirv::ArrayType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>resultID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Serializer_8cpp_source.html#l00403">403</a> of file <a class="el" href="Serializer_8cpp_source.html">Serializer.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVTypes_8cpp_source.html#l00066">mlir::spirv::ArrayType::getArrayStride()</a>.</p>

</div>
</div>
<a id="ab97cd75646073d697112f7f8cc79c503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97cd75646073d697112f7f8cc79c503">&#9670;&nbsp;</a></span>Serializer::processTypeDecoration&lt; spirv::RuntimeArrayType &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::spirv::Serializer::processTypeDecoration&lt; <a class="el" href="classmlir_1_1spirv_1_1RuntimeArrayType.html">spirv::RuntimeArrayType</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1spirv_1_1RuntimeArrayType.html">spirv::RuntimeArrayType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>resultID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Serializer_8cpp_source.html#l00413">413</a> of file <a class="el" href="Serializer_8cpp_source.html">Serializer.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVTypes_8cpp_source.html#l00514">mlir::spirv::RuntimeArrayType::getArrayStride()</a>.</p>

</div>
</div>
<a id="a02bdaa0cba7cda3298326df80cbbc968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02bdaa0cba7cda3298326df80cbbc968">&#9670;&nbsp;</a></span>stringifyTypeName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static StringRef mlir::spirv::stringifyTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a90f43e0ee07a067cb499869873ad2669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f43e0ee07a067cb499869873ad2669">&#9670;&nbsp;</a></span>stringifyTypeName&lt; FloatType &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">StringRef <a class="el" href="namespacemlir_1_1spirv.html#a02bdaa0cba7cda3298326df80cbbc968">mlir::spirv::stringifyTypeName</a>&lt; FloatType &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AtomicOps_8cpp_source.html#l00031">31</a> of file <a class="el" href="AtomicOps_8cpp_source.html">AtomicOps.cpp</a>.</p>

</div>
</div>
<a id="ab7b09d6dad552f1f08d9417a84281f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7b09d6dad552f1f08d9417a84281f3b">&#9670;&nbsp;</a></span>stringifyTypeName&lt; IntegerType &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">StringRef <a class="el" href="namespacemlir_1_1spirv.html#a02bdaa0cba7cda3298326df80cbbc968">mlir::spirv::stringifyTypeName</a>&lt; IntegerType &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AtomicOps_8cpp_source.html#l00026">26</a> of file <a class="el" href="AtomicOps_8cpp_source.html">AtomicOps.cpp</a>.</p>

</div>
</div>
<a id="abe0b5460155168832e9ad08e3481e5b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe0b5460155168832e9ad08e3481e5b2">&#9670;&nbsp;</a></span>unrollVectorsInFuncBodies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::spirv::unrollVectorsInFuncBodies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRVConversion_8cpp_source.html#l01416">1416</a> of file <a class="el" href="SPIRVConversion_8cpp_source.html">SPIRVConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00897">mlir::applyPatternsGreedily()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00216">mlir::Operation::getContext()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l01387">getNativeVectorShape()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>, <a class="el" href="LowerVectorShapeCast_8cpp_source.html#l00474">mlir::vector::populateVectorShapeCastLoweringPatterns()</a>, <a class="el" href="LowerVectorTranspose_8cpp_source.html#l00494">mlir::vector::populateVectorTransposeLoweringPatterns()</a>, and <a class="el" href="VectorRewritePatterns_8h_source.html#l00052">mlir::vector::UnrollVectorOptions::setNativeShapeFn()</a>.</p>

</div>
</div>
<a id="af1bf6d38272388b94f44941f6ef36f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1bf6d38272388b94f44941f6ef36f10">&#9670;&nbsp;</a></span>unrollVectorsInSignatures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::spirv::unrollVectorsInSignatures </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRVConversion_8cpp_source.html#l01403">1403</a> of file <a class="el" href="SPIRVConversion_8cpp_source.html">SPIRVConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00897">mlir::applyPatternsGreedily()</a>, <a class="el" href="namespacemlir.html#acbb0dcd5ae75936e3c6f177223c9d5eba475f4ba4004dc37c3764009114b6e69b">mlir::ExistingOps</a>, <a class="el" href="IR_2Operation_8h_source.html#l00216">mlir::Operation::getContext()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l01647">mlir::populateFuncOpVectorRewritePatterns()</a>, and <a class="el" href="SPIRVConversion_8cpp_source.html#l01651">mlir::populateReturnOpVectorRewritePatterns()</a>.</p>

</div>
</div>
<a id="af3f367e15c232c8b4bb5bf32861a3fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f367e15c232c8b4bb5bf32861a3fcf">&#9670;&nbsp;</a></span>verifyAccessChain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult mlir::spirv::verifyAccessChain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Op.html">Op</a>&#160;</td>
          <td class="paramname"><em>accessChainOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryOps_8cpp_source.html#l00330">330</a> of file <a class="el" href="MemoryOps_8cpp_source.html">MemoryOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00836">mlir::OpState::emitOpError()</a>, <a class="el" href="MemoryOps_8cpp_source.html#l00263">getElementPtrType()</a>, and <a class="el" href="OpDefinition_8h_source.html#l00129">mlir::OpState::getLoc()</a>.</p>

</div>
</div>
<a id="af2921faf72b4b5fd1305b526fe9c433d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2921faf72b4b5fd1305b526fe9c433d">&#9670;&nbsp;</a></span>verifyAtomicUpdateOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AtomicOpTy , typename ExpectedElementType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult mlir::spirv::verifyAtomicUpdateOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AtomicOps_8cpp_source.html#l00037">37</a> of file <a class="el" href="AtomicOps_8cpp_source.html">AtomicOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00672">mlir::Operation::emitOpError()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00550">mlir::Operation::getAttrOfType()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00119">mlir::Operation::getName()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00350">mlir::Operation::getOperand()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, and <a class="el" href="SPIRVOps_8cpp_source.html#l00069">verifyMemorySemantics()</a>.</p>

</div>
</div>
<a id="a62c065d39df33da14559b2ff3c292bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62c065d39df33da14559b2ff3c292bd6">&#9670;&nbsp;</a></span>verifyCastOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult mlir::spirv::verifyCastOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>requireSameBitWidth</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipBitWidthCheck</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CastOps_8cpp_source.html#l00024">24</a> of file <a class="el" href="CastOps_8cpp_source.html">CastOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00672">mlir::Operation::emitOpError()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00350">mlir::Operation::getOperand()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00407">mlir::Operation::getResult()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="a24785985e21b2fe5a33bca5c104b0ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24785985e21b2fe5a33bca5c104b0ca8">&#9670;&nbsp;</a></span>verifyCoopMatrixAccess()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult mlir::spirv::verifyCoopMatrixAccess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>coopMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spirv::MemoryAccessAttr&#160;</td>
          <td class="paramname"><em>memoryOperand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerAttr&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CooperativeMatrixOps_8cpp_source.html#l00024">24</a> of file <a class="el" href="CooperativeMatrixOps_8cpp_source.html">CooperativeMatrixOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00672">mlir::Operation::emitOpError()</a>.</p>

</div>
</div>
<a id="a23eb772725d05b1834b5ec9eb2c6ea33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23eb772725d05b1834b5ec9eb2c6ea33">&#9670;&nbsp;</a></span>verifyGroupNonUniformArithmeticOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult mlir::spirv::verifyGroupNonUniformArithmeticOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>groupOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GroupOps_8cpp_source.html#l00024">24</a> of file <a class="el" href="GroupOps_8cpp_source.html">GroupOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00672">mlir::Operation::emitOpError()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00049">extractValueFromConstOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00550">mlir::Operation::getAttrOfType()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00119">mlir::Operation::getName()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00346">mlir::Operation::getNumOperands()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00350">mlir::Operation::getOperand()</a>.</p>

</div>
</div>
<a id="a69927bca9741cf0039df005f3c91b886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69927bca9741cf0039df005f3c91b886">&#9670;&nbsp;</a></span>verifyGroupNonUniformShuffleOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult mlir::spirv::verifyGroupNonUniformShuffleOp </td>
          <td>(</td>
          <td class="paramtype">OpTy&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GroupOps_8cpp_source.html#l00143">143</a> of file <a class="el" href="GroupOps_8cpp_source.html">GroupOps.cpp</a>.</p>

</div>
</div>
<a id="a6f8027ad78793fb44ca1a47986f01852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8027ad78793fb44ca1a47986f01852">&#9670;&nbsp;</a></span>verifyGroupOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult mlir::spirv::verifyGroupOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Op.html">Op</a>&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GroupOps_8cpp_source.html#l00335">335</a> of file <a class="el" href="GroupOps_8cpp_source.html">GroupOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00836">mlir::OpState::emitOpError()</a>.</p>

</div>
</div>
<a id="a2c5e50e9919aad12e5cb7df176501d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5e50e9919aad12e5cb7df176501d68">&#9670;&nbsp;</a></span>verifyIntegerDotProduct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntegerDotProductOpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult mlir::spirv::verifyIntegerDotProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DotProductOps_8cpp_source.html#l00067">67</a> of file <a class="el" href="DotProductOps_8cpp_source.html">DotProductOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00672">mlir::Operation::emitOpError()</a>, <a class="el" href="TypeRange_8h_source.html#l00152">mlir::ValueTypeRange&lt; ValueRangeT &gt;::front()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00534">mlir::Operation::getAttr()</a>, <a class="el" href="SPIRVOpUtils_8h_source.html#l00014">getBitWidth()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00119">mlir::Operation::getName()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00346">mlir::Operation::getNumOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00404">mlir::Operation::getNumResults()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00350">mlir::Operation::getOperand()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00428">mlir::Operation::getResultTypes()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00560">mlir::Operation::hasAttr()</a>.</p>

</div>
</div>
<a id="a8de7be6ae36d7e1ebc1ff890dbf8eb41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de7be6ae36d7e1ebc1ff890dbf8eb41">&#9670;&nbsp;</a></span>verifyLoadStorePtrAndValTypes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LoadStoreOpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult mlir::spirv::verifyLoadStorePtrAndValTypes </td>
          <td>(</td>
          <td class="paramtype">LoadStoreOpTy&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryOps_8cpp_source.html#l00161">161</a> of file <a class="el" href="MemoryOps_8cpp_source.html">MemoryOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="a9401d09ba4d2cb0cd94706d498e41dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9401d09ba4d2cb0cd94706d498e41dc7">&#9670;&nbsp;</a></span>verifyMemoryAccessAttribute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemoryOpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult mlir::spirv::verifyMemoryAccessAttribute </td>
          <td>(</td>
          <td class="paramtype">MemoryOpTy&#160;</td>
          <td class="paramname"><em>memoryOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryOps_8cpp_source.html#l00176">176</a> of file <a class="el" href="MemoryOps_8cpp_source.html">MemoryOps.cpp</a>.</p>

</div>
</div>
<a id="a0fe392ec323b3b094b994e9317e982ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe392ec323b3b094b994e9317e982ac">&#9670;&nbsp;</a></span>verifyMemorySemantics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::spirv::verifyMemorySemantics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spirv::MemorySemantics&#160;</td>
          <td class="paramname"><em>memorySemantics</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRVOps_8cpp_source.html#l00069">69</a> of file <a class="el" href="SPIRVOps_8cpp_source.html">SPIRVOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00267">mlir::Operation::emitError()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AtomicOps_8cpp_source.html#l00037">verifyAtomicUpdateOp()</a>.</p>

</div>
</div>
<a id="a4c428608324420fa151089c165625efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c428608324420fa151089c165625efd">&#9670;&nbsp;</a></span>verifySourceMemoryAccessAttribute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemoryOpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult mlir::spirv::verifySourceMemoryAccessAttribute </td>
          <td>(</td>
          <td class="paramtype">MemoryOpTy&#160;</td>
          <td class="paramname"><em>memoryOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryOps_8cpp_source.html#l00220">220</a> of file <a class="el" href="MemoryOps_8cpp_source.html">MemoryOps.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a2478bd60cd2037a1d56b6ce17bd32bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2478bd60cd2037a1d56b6ce17bd32bb4">&#9670;&nbsp;</a></span>kGeneratorNumber</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t mlir::spirv::kGeneratorNumber = 22</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The serializer tool ID registered to the Khronos Group. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVBinaryUtils_8h_source.html#l00031">31</a> of file <a class="el" href="SPIRVBinaryUtils_8h_source.html">SPIRVBinaryUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVBinaryUtils_8cpp_source.html#l00021">appendModuleHeader()</a>.</p>

</div>
</div>
<a id="ad26be4ada4901dc6598761977638338c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26be4ada4901dc6598761977638338c">&#9670;&nbsp;</a></span>kHeaderWordCount</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned mlir::spirv::kHeaderWordCount = 5</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SPIR-V binary header word count. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVBinaryUtils_8h_source.html#l00025">25</a> of file <a class="el" href="SPIRVBinaryUtils_8h_source.html">SPIRVBinaryUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Serializer_8cpp_source.html#l00131">mlir::spirv::Serializer::collect()</a>.</p>

</div>
</div>
<a id="a5385336e089899ca7fcc7af2dbedf4e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5385336e089899ca7fcc7af2dbedf4e6">&#9670;&nbsp;</a></span>kMagicNumber</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t mlir::spirv::kMagicNumber = 0x07230203</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SPIR-V magic number. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVBinaryUtils_8h_source.html#l00028">28</a> of file <a class="el" href="SPIRVBinaryUtils_8h_source.html">SPIRVBinaryUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVBinaryUtils_8cpp_source.html#l00021">appendModuleHeader()</a>.</p>

</div>
</div>
<a id="a18ea4a2ae808ea92a1da4cffbdac2e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ea4a2ae808ea92a1da4cffbdac2e2f">&#9670;&nbsp;</a></span>kMaxLiteralWordCount</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t mlir::spirv::kMaxLiteralWordCount = <a class="el" href="namespacemlir_1_1spirv.html#a8ae805863eb10334039743fb3dfa148e">kMaxWordCount</a> - 3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Max number of words for literal. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVBinaryUtils_8h_source.html#l00038">38</a> of file <a class="el" href="SPIRVBinaryUtils_8h_source.html">SPIRVBinaryUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVBinaryUtils_8cpp_source.html#l00069">encodeStringLiteralInto()</a>.</p>

</div>
</div>
<a id="a8ae805863eb10334039743fb3dfa148e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae805863eb10334039743fb3dfa148e">&#9670;&nbsp;</a></span>kMaxWordCount</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t mlir::spirv::kMaxWordCount = 65535</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Max number of words <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_universal_limits">https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_universal_limits</a>. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVBinaryUtils_8h_source.html#l00035">35</a> of file <a class="el" href="SPIRVBinaryUtils_8h_source.html">SPIRVBinaryUtils.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 1 2025 16:33:32 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
