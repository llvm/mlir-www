<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: include/mlir/Dialect/Affine/Utils.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_5654f77406fb9ceec87e68ef828ceea2.html">mlir</a></li><li class="navelem"><a class="el" href="dir_d07a6fac82475a065a3b2953573f00a0.html">Dialect</a></li><li class="navelem"><a class="el" href="dir_166398e1f0020b3d916a929c669bf538.html">Affine</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Utils.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="AliasAnalysis_8h_source.html">mlir/Analysis/AliasAnalysis.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineAnalysis_8h_source.html">mlir/Dialect/Affine/Analysis/AffineAnalysis.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineOps_8h_source.html">mlir/Dialect/Affine/IR/AffineOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="OpDefinition_8h_source.html">mlir/IR/OpDefinition.h</a>&quot;</code><br />
<code>#include &lt;optional&gt;</code><br />
</div>
<p><a href="Dialect_2Affine_2Utils_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1VectorizationStrategy.html">mlir::affine::VectorizationStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds parameters to perform n-D vectorization on a single loop nest.  <a href="structmlir_1_1affine_1_1VectorizationStrategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1DivModValue.html">mlir::affine::DivModValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the result of (div a, b) and (mod a, b).  <a href="structmlir_1_1affine_1_1DivModValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1AffineValueExpr.html">mlir::affine::AffineValueExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1AffineBuilder.html">mlir::affine::AffineBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct to build simple AffineValueExprs with minimal type inference support.  <a href="structmlir_1_1affine_1_1AffineBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html">mlir</a></td></tr>
<tr class="memdesc:namespacemlir"><td class="mdescLeft">&#160;</td><td class="mdescRight">Include the generated interface declarations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1func"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1func.html">mlir::func</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1memref"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html">mlir::memref</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1affine"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html">mlir::affine</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac58a9af2e4bb4c811ad5329293609224"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ac58a9af2e4bb4c811ad5329293609224">mlir::affine::ReductionLoopMap</a> = DenseMap&lt; Operation *, SmallVector&lt; LoopReduction, 2 &gt; &gt;</td></tr>
<tr class="separator:ac58a9af2e4bb4c811ad5329293609224"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a65c46d8d3632fed8f99f96ea54bbbc0f"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a65c46d8d3632fed8f99f96ea54bbbc0f">mlir::affine::affineParallelize</a> (AffineForOp forOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1affine_1_1LoopReduction.html">LoopReduction</a> &gt; parallelReductions={}, AffineParallelOp *resOp=nullptr)</td></tr>
<tr class="memdesc:a65c46d8d3632fed8f99f96ea54bbbc0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces a parallel affine.for op with a 1-d affine.parallel op.  <a href="namespacemlir_1_1affine.html#a65c46d8d3632fed8f99f96ea54bbbc0f">More...</a><br /></td></tr>
<tr class="separator:a65c46d8d3632fed8f99f96ea54bbbc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee28320f76812321a98b8386c6cce7f8"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#aee28320f76812321a98b8386c6cce7f8">mlir::affine::hoistAffineIfOp</a> (AffineIfOp ifOp, bool *folded=nullptr)</td></tr>
<tr class="memdesc:aee28320f76812321a98b8386c6cce7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hoists out affine.if/else to as high as possible, i.e., past all invariant affine.fors/parallel's.  <a href="namespacemlir_1_1affine.html#aee28320f76812321a98b8386c6cce7f8">More...</a><br /></td></tr>
<tr class="separator:aee28320f76812321a98b8386c6cce7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135be62a111deaa1433882b8c0e43bfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a135be62a111deaa1433882b8c0e43bfd">mlir::affine::affineScalarReplace</a> (func::FuncOp f, <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;domInfo, <a class="el" href="classmlir_1_1PostDominanceInfo.html">PostDominanceInfo</a> &amp;postDomInfo, <a class="el" href="classmlir_1_1AliasAnalysis.html">AliasAnalysis</a> &amp;analysis)</td></tr>
<tr class="memdesc:a135be62a111deaa1433882b8c0e43bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace affine store and load accesses by scalars by forwarding stores to loads and eliminate invariant affine loads; consequently, eliminate dead allocs.  <a href="namespacemlir_1_1affine.html#a135be62a111deaa1433882b8c0e43bfd">More...</a><br /></td></tr>
<tr class="separator:a135be62a111deaa1433882b8c0e43bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781e38393998e11fee008649817f6ecb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a781e38393998e11fee008649817f6ecb">mlir::affine::vectorizeAffineLoops</a> (Operation *parentOp, <a class="el" href="classllvm_1_1DenseSet.html">llvm::DenseSet</a>&lt; Operation *, DenseMapInfo&lt; Operation * &gt;&gt; &amp;loops, ArrayRef&lt; int64_t &gt; vectorSizes, ArrayRef&lt; int64_t &gt; fastestVaryingPattern, const ReductionLoopMap &amp;reductionLoops=ReductionLoopMap())</td></tr>
<tr class="memdesc:a781e38393998e11fee008649817f6ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorizes affine loops in 'loops' using the n-D vectorization factors in 'vectorSizes'.  <a href="namespacemlir_1_1affine.html#a781e38393998e11fee008649817f6ecb">More...</a><br /></td></tr>
<tr class="separator:a781e38393998e11fee008649817f6ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb3d8b25c9ceb8db711a560be0992ff"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#afcb3d8b25c9ceb8db711a560be0992ff">mlir::affine::vectorizeAffineLoopNest</a> (std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 2 &gt;&gt; &amp;loops, const <a class="el" href="structmlir_1_1affine_1_1VectorizationStrategy.html">VectorizationStrategy</a> &amp;strategy)</td></tr>
<tr class="memdesc:afcb3d8b25c9ceb8db711a560be0992ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">External utility to vectorize affine loops from a single loop nest using an n-D vectorization strategy (see doc in <a class="el" href="structmlir_1_1affine_1_1VectorizationStrategy.html" title="Holds parameters to perform n-D vectorization on a single loop nest.">VectorizationStrategy</a> definition).  <a href="namespacemlir_1_1affine.html#afcb3d8b25c9ceb8db711a560be0992ff">More...</a><br /></td></tr>
<tr class="separator:afcb3d8b25c9ceb8db711a560be0992ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d95961bad8f337b39d93e8ed8e41280"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a3d95961bad8f337b39d93e8ed8e41280">mlir::affine::normalizeAffineParallel</a> (AffineParallelOp op)</td></tr>
<tr class="memdesc:a3d95961bad8f337b39d93e8ed8e41280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize a affine.parallel op so that lower bounds are 0 and steps are 1.  <a href="namespacemlir_1_1affine.html#a3d95961bad8f337b39d93e8ed8e41280">More...</a><br /></td></tr>
<tr class="separator:a3d95961bad8f337b39d93e8ed8e41280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ce32d4cf1dfe2e20a2ca373ef9181f"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a79ce32d4cf1dfe2e20a2ca373ef9181f">mlir::affine::normalizeAffineFor</a> (AffineForOp op, bool promoteSingleIter=false)</td></tr>
<tr class="memdesc:a79ce32d4cf1dfe2e20a2ca373ef9181f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize an affine.for op.  <a href="namespacemlir_1_1affine.html#a79ce32d4cf1dfe2e20a2ca373ef9181f">More...</a><br /></td></tr>
<tr class="separator:a79ce32d4cf1dfe2e20a2ca373ef9181f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23447702ca3f9e052eeb1cb2a7311e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#af23447702ca3f9e052eeb1cb2a7311e0">mlir::affine::substWithMin</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> e, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> dim, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> <a class="el" href="PolynomialApproximation_8cpp.html#af7cb11d1121f694b53c0981dc5e8ba9a">min</a>, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> <a class="el" href="PolynomialApproximation_8cpp.html#acbcaffd2f4cbc4dd948549fd577631eb">max</a>, bool positivePath=true)</td></tr>
<tr class="memdesc:af23447702ca3f9e052eeb1cb2a7311e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse <code>e</code> and return an <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> where all occurrences of <code>dim</code> have been replaced by either:  <a href="namespacemlir_1_1affine.html#af23447702ca3f9e052eeb1cb2a7311e0">More...</a><br /></td></tr>
<tr class="separator:af23447702ca3f9e052eeb1cb2a7311e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6656d7441cf1e9bb27a617d358b939"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#aef6656d7441cf1e9bb27a617d358b939">mlir::affine::replaceAllMemRefUsesWith</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> oldMemRef, <a class="el" href="classmlir_1_1Value.html">Value</a> newMemRef, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; extraIndices={}, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> indexRemap=<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>(), <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; extraOperands={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; symbolOperands={}, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; userFilterFn=nullptr, bool allowNonDereferencingOps=false, bool replaceInDeallocOp=false)</td></tr>
<tr class="memdesc:aef6656d7441cf1e9bb27a617d358b939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all "dereferencing" uses of <code>oldMemRef</code> with <code>newMemRef</code> while optionally remapping the old memref's indices using the supplied affine map, <code>indexRemap</code>.  <a href="namespacemlir_1_1affine.html#aef6656d7441cf1e9bb27a617d358b939">More...</a><br /></td></tr>
<tr class="separator:aef6656d7441cf1e9bb27a617d358b939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8950b81755c5434e4ec0e1c76cd968e"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ad8950b81755c5434e4ec0e1c76cd968e">mlir::affine::replaceAllMemRefUsesWith</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> oldMemRef, <a class="el" href="classmlir_1_1Value.html">Value</a> newMemRef, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; extraIndices={}, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> indexRemap=<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>(), <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; extraOperands={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; symbolOperands={}, bool allowNonDereferencingOps=false)</td></tr>
<tr class="memdesc:ad8950b81755c5434e4ec0e1c76cd968e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the same replacement as the other version above but only for the dereferencing uses of <code>oldMemRef</code> in <code>op</code>, except in cases where 'allowNonDereferencingOps' is set to true where we replace the non-dereferencing uses as well.  <a href="namespacemlir_1_1affine.html#ad8950b81755c5434e4ec0e1c76cd968e">More...</a><br /></td></tr>
<tr class="separator:ad8950b81755c5434e4ec0e1c76cd968e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc13f562d38271c0b1f3de346e6349ad"><td class="memTemplParams" colspan="2">template&lt;typename AllocLikeOp &gt; </td></tr>
<tr class="memitem:abc13f562d38271c0b1f3de346e6349ad"><td class="memTemplItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#abc13f562d38271c0b1f3de346e6349ad">mlir::affine::normalizeMemRef</a> (AllocLikeOp op)</td></tr>
<tr class="memdesc:abc13f562d38271c0b1f3de346e6349ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites the memref defined by alloc or reinterpret_cast op to have an identity layout map and updates all its indexing uses.  <a href="namespacemlir_1_1affine.html#abc13f562d38271c0b1f3de346e6349ad">More...</a><br /></td></tr>
<tr class="separator:abc13f562d38271c0b1f3de346e6349ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61b71ec2846f253a33b19eeb84b94cc"><td class="memItemLeft" align="right" valign="top">template LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ad61b71ec2846f253a33b19eeb84b94cc">mlir::affine::normalizeMemRef&lt; memref::AllocaOp &gt;</a> (memref::AllocaOp op)</td></tr>
<tr class="separator:ad61b71ec2846f253a33b19eeb84b94cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e44481392dfe5dec0ff89d8a545e79e"><td class="memItemLeft" align="right" valign="top">template LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a3e44481392dfe5dec0ff89d8a545e79e">mlir::affine::normalizeMemRef&lt; memref::AllocOp &gt;</a> (memref::AllocOp op)</td></tr>
<tr class="separator:a3e44481392dfe5dec0ff89d8a545e79e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ee1302fe0baab196d176bd1f9c3d44"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a31ee1302fe0baab196d176bd1f9c3d44">mlir::affine::normalizeMemRef</a> (memref::ReinterpretCastOp op)</td></tr>
<tr class="separator:a31ee1302fe0baab196d176bd1f9c3d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad958d8023230103fc9fa9632d423ae"><td class="memItemLeft" align="right" valign="top">MemRefType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#abad958d8023230103fc9fa9632d423ae">mlir::affine::normalizeMemRefType</a> (MemRefType memrefType)</td></tr>
<tr class="memdesc:abad958d8023230103fc9fa9632d423ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes <code>memrefType</code> so that the affine layout map of the memref is transformed to an identity map with a new shape being computed for the normalized memref type and returns it.  <a href="namespacemlir_1_1affine.html#abad958d8023230103fc9fa9632d423ae">More...</a><br /></td></tr>
<tr class="separator:abad958d8023230103fc9fa9632d423ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2beee19f97f40e2272e413432879ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#aea2beee19f97f40e2272e413432879ee">mlir::affine::createAffineComputationSlice</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *opInst, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineApplyOp &gt; *sliceOps)</td></tr>
<tr class="memdesc:aea2beee19f97f40e2272e413432879ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an operation, inserts one or more single result affine apply operations, results of which are exclusively used by this operation.  <a href="namespacemlir_1_1affine.html#aea2beee19f97f40e2272e413432879ee">More...</a><br /></td></tr>
<tr class="separator:aea2beee19f97f40e2272e413432879ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d426a50bbe0eea58b951870ad90c2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a39d426a50bbe0eea58b951870ad90c2c">mlir::affine::expandAffineExpr</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> dimValues, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> symbolValues)</td></tr>
<tr class="memdesc:a39d426a50bbe0eea58b951870ad90c2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit code that computes the given affine expression using standard arithmetic operations applied to the provided dimension and symbol values.  <a href="namespacemlir_1_1affine.html#a39d426a50bbe0eea58b951870ad90c2c">More...</a><br /></td></tr>
<tr class="separator:a39d426a50bbe0eea58b951870ad90c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002c2432c533d69bf56ba15a60176e43"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 8 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a002c2432c533d69bf56ba15a60176e43">mlir::affine::expandAffineMap</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> affineMap, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands)</td></tr>
<tr class="memdesc:a002c2432c533d69bf56ba15a60176e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sequence of operations that implement the <code>affineMap</code> applied to the given <code>operands</code> (as it it were an AffineApplyOp).  <a href="namespacemlir_1_1affine.html#a002c2432c533d69bf56ba15a60176e43">More...</a><br /></td></tr>
<tr class="separator:a002c2432c533d69bf56ba15a60176e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a9e39e3e6f042f6af0bc8cae9cd7c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1affine_1_1DivModValue.html">DivModValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ae1a9e39e3e6f042f6af0bc8cae9cd7c9">mlir::affine::getDivMod</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> lhs, <a class="el" href="classmlir_1_1Value.html">Value</a> rhs)</td></tr>
<tr class="memdesc:ae1a9e39e3e6f042f6af0bc8cae9cd7c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create IR to calculate (div lhs, rhs) and (mod lhs, rhs).  <a href="namespacemlir_1_1affine.html#ae1a9e39e3e6f042f6af0bc8cae9cd7c9">More...</a><br /></td></tr>
<tr class="separator:ae1a9e39e3e6f042f6af0bc8cae9cd7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac812769668034e906e1cceaa828acabe"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ac812769668034e906e1cceaa828acabe">mlir::affine::delinearizeIndex</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> linearIndex, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; basis, bool hasOuterBound=true)</td></tr>
<tr class="memdesc:ac812769668034e906e1cceaa828acabe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the IR to delinearize <code>linearIndex</code> given the <code>basis</code> and return the multi-index.  <a href="namespacemlir_1_1affine.html#ac812769668034e906e1cceaa828acabe">More...</a><br /></td></tr>
<tr class="separator:ac812769668034e906e1cceaa828acabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee5c3cc3b2ee66ab738f2b816c4184c"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a1ee5c3cc3b2ee66ab738f2b816c4184c">mlir::affine::delinearizeIndex</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> linearIndex, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; basis, bool hasOuterBound=true)</td></tr>
<tr class="separator:a1ee5c3cc3b2ee66ab738f2b816c4184c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c95c77cd7a7c28c38f17af0343d21f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ad2c95c77cd7a7c28c38f17af0343d21f">mlir::affine::linearizeIndex</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; multiIndex, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; basis, <a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html">ImplicitLocOpBuilder</a> &amp;builder)</td></tr>
<tr class="separator:ad2c95c77cd7a7c28c38f17af0343d21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ab039c6166be23a77c5eef5ec886b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a18ab039c6166be23a77c5eef5ec886b7">mlir::affine::linearizeIndex</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; multiIndex, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; basis)</td></tr>
<tr class="separator:a18ab039c6166be23a77c5eef5ec886b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae989950373589c5cc01381c0febcee4d"><td class="memTemplParams" colspan="2">template&lt;typename EffectType , typename T &gt; </td></tr>
<tr class="memitem:ae989950373589c5cc01381c0febcee4d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ae989950373589c5cc01381c0febcee4d">mlir::affine::hasNoInterveningEffect</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *start, T memOp, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt; <a class="el" href="EliminateBarriers_8cpp.html#ab14db090bfbe8dc17b8754213ae0512b">mayAlias</a>)</td></tr>
<tr class="memdesc:ae989950373589c5cc01381c0febcee4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that all operations that could be executed after <code>start</code> (noninclusive) and prior to <code>memOp</code> (e.g.  <a href="namespacemlir_1_1affine.html#ae989950373589c5cc01381c0febcee4d">More...</a><br /></td></tr>
<tr class="separator:ae989950373589c5cc01381c0febcee4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 1 2025 16:33:27 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
