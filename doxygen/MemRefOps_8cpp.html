<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/MemRef/IR/MemRefOps.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a class="el" href="dir_aa550efc2eb1acee4ac7619e105a3637.html">MemRef</a></li><li class="navelem"><a class="el" href="dir_bbff0bc417424c2f220526a400d79936.html">IR</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MemRefOps.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="mlir_2Dialect_2Arith_2IR_2Arith_8h_source.html">mlir/Dialect/Arith/IR/Arith.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Arith_2Utils_2Utils_8h_source.html">mlir/Dialect/Arith/Utils/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2MemRef_2IR_2MemRef_8h_source.html">mlir/Dialect/MemRef/IR/MemRef.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="StaticValueUtils_8h_source.html">mlir/Dialect/Utils/StaticValueUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2AffineMap_8h_source.html">mlir/IR/AffineMap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Builders_8h_source.html">mlir/IR/Builders.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html">mlir/IR/BuiltinTypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Matchers_8h_source.html">mlir/IR/Matchers.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="OpDefinition_8h_source.html">mlir/IR/OpDefinition.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PatternMatch_8h_source.html">mlir/IR/PatternMatch.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TypeUtilities_8h_source.html">mlir/IR/TypeUtilities.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="InferTypeOpInterface_8h_source.html">mlir/Interfaces/InferTypeOpInterface.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SideEffectInterfaces_8h_source.html">mlir/Interfaces/SideEffectInterfaces.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="InferIntRangeCommon_8h_source.html">mlir/Interfaces/Utils/InferIntRangeCommon.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ViewLikeInterface_8h_source.html">mlir/Interfaces/ViewLikeInterface.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/STLExtras.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallBitVector.h&quot;</code><br />
<code>#include &quot;mlir/Dialect/MemRef/IR/MemRefOps.cpp.inc&quot;</code><br />
</div>
<p><a href="MemRefOps_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAllocaScopeInliner.html">AllocaScopeInliner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline an AllocaScopeOp if either the direct parent is an allocation scope or it contains no allocation.  <a href="structAllocaScopeInliner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAllocaScopeHoister.html">AllocaScopeHoister</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move allocations into an allocation scope, if it is legal to move them (e.g.  <a href="structAllocaScopeHoister.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCollapseShapeOpMemRefCastFolder.html">CollapseShapeOpMemRefCastFolder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSubViewReturnTypeCanonicalizer.html">SubViewReturnTypeCanonicalizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the canonical type of the result of a subview.  <a href="structSubViewReturnTypeCanonicalizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSubViewCanonicalizer.html">SubViewCanonicalizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A canonicalizer wrapper to replace SubViewOps.  <a href="structSubViewCanonicalizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a52c883a38e577b8b12282ff70c95a16d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#a52c883a38e577b8b12282ff70c95a16d">GET_OP_CLASSES</a></td></tr>
<tr class="separator:a52c883a38e577b8b12282ff70c95a16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2394cb329305195dcd14ef7ef2975a7a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#a2394cb329305195dcd14ef7ef2975a7a">constifyIndexValues</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;values, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; constValues)</td></tr>
<tr class="memdesc:a2394cb329305195dcd14ef7ef2975a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that sets values[i] to constValues[i] if the latter is a static value, as indicated by ShapedType::kDynamic.  <a href="MemRefOps_8cpp.html#a2394cb329305195dcd14ef7ef2975a7a">More...</a><br /></td></tr>
<tr class="separator:a2394cb329305195dcd14ef7ef2975a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb10f259303d819184a4c81b159372a"><td class="memTemplParams" colspan="2">template&lt;typename AllocLikeOp &gt; </td></tr>
<tr class="memitem:afcb10f259303d819184a4c81b159372a"><td class="memTemplItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#afcb10f259303d819184a4c81b159372a">verifyAllocLikeOp</a> (AllocLikeOp op)</td></tr>
<tr class="separator:afcb10f259303d819184a4c81b159372a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2e419c24e30507c54a8d5942359751"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#a5a2e419c24e30507c54a8d5942359751">isGuaranteedAutomaticAllocation</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a5a2e419c24e30507c54a8d5942359751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an operation, return whether this op is guaranteed to allocate an AutomaticAllocationScopeResource.  <a href="MemRefOps_8cpp.html#a5a2e419c24e30507c54a8d5942359751">More...</a><br /></td></tr>
<tr class="separator:a5a2e419c24e30507c54a8d5942359751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4397b9a83c219ccae94d6fc4b14f6f32"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#a4397b9a83c219ccae94d6fc4b14f6f32">isOpItselfPotentialAutomaticAllocation</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a4397b9a83c219ccae94d6fc4b14f6f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an operation, return whether this op itself could allocate an AutomaticAllocationScopeResource.  <a href="MemRefOps_8cpp.html#a4397b9a83c219ccae94d6fc4b14f6f32">More...</a><br /></td></tr>
<tr class="separator:a4397b9a83c219ccae94d6fc4b14f6f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38e621303868d5773129812aaa74af7"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#ac38e621303868d5773129812aaa74af7">lastNonTerminatorInRegion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ac38e621303868d5773129812aaa74af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether this op is the last non terminating op in a region.  <a href="MemRefOps_8cpp.html#ac38e621303868d5773129812aaa74af7">More...</a><br /></td></tr>
<tr class="separator:ac38e621303868d5773129812aaa74af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9e9af5d54aded11c7a613fb49e1a46"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#a6f9e9af5d54aded11c7a613fb49e1a46">FoldCopyOfCast</a> (CopyOp op)</td></tr>
<tr class="memdesc:a6f9e9af5d54aded11c7a613fb49e1a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the source/target of a CopyOp is a CastOp that does not modify the shape and element type, the cast can be skipped.  <a href="MemRefOps_8cpp.html#a6f9e9af5d54aded11c7a613fb49e1a46">More...</a><br /></td></tr>
<tr class="separator:a6f9e9af5d54aded11c7a613fb49e1a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8ee1edd7328998d47a287dc8185d6a"><td class="memItemLeft" align="right" valign="top">static std::map&lt; int64_t, unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#adc8ee1edd7328998d47a287dc8185d6a">getNumOccurences</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; vals)</td></tr>
<tr class="memdesc:adc8ee1edd7328998d47a287dc8185d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a map with key being elements in <code>vals</code> and data being number of occurences of it.  <a href="MemRefOps_8cpp.html#adc8ee1edd7328998d47a287dc8185d6a">More...</a><br /></td></tr>
<tr class="separator:adc8ee1edd7328998d47a287dc8185d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d21cdb0c018fbf8ed4a788049f6c33"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; llvm::SmallBitVector &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#ac1d21cdb0c018fbf8ed4a788049f6c33">computeMemRefRankReductionMask</a> (MemRefType originalType, MemRefType reducedType, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizes)</td></tr>
<tr class="memdesc:ac1d21cdb0c018fbf8ed4a788049f6c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the <code>originalType</code> and a <code>candidateReducedType</code> whose shape is assumed to be a subset of <code>originalType</code> with some <code>1</code> entries erased, return the set of indices that specifies which of the entries of <code>originalShape</code> are dropped to obtain <code>reducedShape</code>.  <a href="MemRefOps_8cpp.html#ac1d21cdb0c018fbf8ed4a788049f6c33">More...</a><br /></td></tr>
<tr class="separator:ac1d21cdb0c018fbf8ed4a788049f6c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7679bb5932dec6a723a291c144e0f871"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a7679bb5932dec6a723a291c144e0f871"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#a7679bb5932dec6a723a291c144e0f871">replaceConstantUsesOf</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, Container values, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; maybeConstants)</td></tr>
<tr class="memdesc:a7679bb5932dec6a723a291c144e0f871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to perform the replacement of all constant uses of <code>values</code> by a materialized constant extracted from <code>maybeConstants</code>.  <a href="MemRefOps_8cpp.html#a7679bb5932dec6a723a291c144e0f871">More...</a><br /></td></tr>
<tr class="separator:a7679bb5932dec6a723a291c144e0f871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265e2c0706658d6b14273bba2445f3dc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#a265e2c0706658d6b14273bba2445f3dc">printGlobalMemrefOpTypeAndInitialValue</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, GlobalOp op, TypeAttr type, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> initialValue)</td></tr>
<tr class="separator:a265e2c0706658d6b14273bba2445f3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafdfa23b2974217feca58562d9915084"><td class="memItemLeft" align="right" valign="top">static ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#aafdfa23b2974217feca58562d9915084">parseGlobalMemrefOpTypeAndInitialValue</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, TypeAttr &amp;typeAttr, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &amp;initialValue)</td></tr>
<tr class="separator:aafdfa23b2974217feca58562d9915084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3211f00d69d9462b4103bba629b75337"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#a3211f00d69d9462b4103bba629b75337">verifyCollapsedShape</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; collapsedShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; expandedShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt; reassociation, bool allowMultipleDynamicDimsPerGroup)</td></tr>
<tr class="memdesc:a3211f00d69d9462b4103bba629b75337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for verifying the shape of ExpandShapeOp and ResultShapeOp result and operand.  <a href="MemRefOps_8cpp.html#a3211f00d69d9462b4103bba629b75337">More...</a><br /></td></tr>
<tr class="separator:a3211f00d69d9462b4103bba629b75337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74a2ddd3de03f1670d7743be51b0205"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; StridedLayoutAttr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#ae74a2ddd3de03f1670d7743be51b0205">computeExpandedLayoutMap</a> (MemRefType srcType, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; resultShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt; reassociation)</td></tr>
<tr class="memdesc:ae74a2ddd3de03f1670d7743be51b0205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the layout map after expanding a given source MemRef type with the specified reassociation indices.  <a href="MemRefOps_8cpp.html#ae74a2ddd3de03f1670d7743be51b0205">More...</a><br /></td></tr>
<tr class="separator:ae74a2ddd3de03f1670d7743be51b0205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1ae8369e10d64675d9ff2a5941a138"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; StridedLayoutAttr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#aeb1ae8369e10d64675d9ff2a5941a138">computeCollapsedLayoutMap</a> (MemRefType srcType, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt; reassociation, bool strict=false)</td></tr>
<tr class="memdesc:aeb1ae8369e10d64675d9ff2a5941a138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the layout map after collapsing a given source MemRef type with the specified reassociation indices.  <a href="MemRefOps_8cpp.html#aeb1ae8369e10d64675d9ff2a5941a138">More...</a><br /></td></tr>
<tr class="separator:aeb1ae8369e10d64675d9ff2a5941a138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6901e2de1f1e535ad6db31a96b7a0b1d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#a6901e2de1f1e535ad6db31a96b7a0b1d">haveCompatibleOffsets</a> (MemRefType t1, MemRefType t2)</td></tr>
<tr class="memdesc:a6901e2de1f1e535ad6db31a96b7a0b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <code>t1</code> and <code>t2</code> have equal offsets (both dynamic or of same static value).  <a href="MemRefOps_8cpp.html#a6901e2de1f1e535ad6db31a96b7a0b1d">More...</a><br /></td></tr>
<tr class="separator:a6901e2de1f1e535ad6db31a96b7a0b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4748b8f26c7f13766db887bbd5404bc"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#ad4748b8f26c7f13766db887bbd5404bc">haveCompatibleStrides</a> (MemRefType t1, MemRefType t2, const llvm::SmallBitVector &amp;droppedDims)</td></tr>
<tr class="memdesc:ad4748b8f26c7f13766db887bbd5404bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <code>t1</code> and <code>t2</code> have equal strides (both dynamic or of same static value).  <a href="MemRefOps_8cpp.html#ad4748b8f26c7f13766db887bbd5404bc">More...</a><br /></td></tr>
<tr class="separator:ad4748b8f26c7f13766db887bbd5404bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771eeaa57246ed965c05f9e93a3ba56b"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#a771eeaa57246ed965c05f9e93a3ba56b">produceSubViewErrorMsg</a> (<a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75">SliceVerificationResult</a> result, SubViewOp op, <a class="el" href="classmlir_1_1Type.html">Type</a> expectedType)</td></tr>
<tr class="separator:a771eeaa57246ed965c05f9e93a3ba56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902a21badb61387b3a01cf900a97e39e"><td class="memItemLeft" align="right" valign="top">static MemRefType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#a902a21badb61387b3a01cf900a97e39e">getCanonicalSubViewResultType</a> (MemRefType currentResultType, MemRefType currentSourceType, MemRefType sourceType, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mixedOffsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mixedSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mixedStrides)</td></tr>
<tr class="memdesc:a902a21badb61387b3a01cf900a97e39e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the canonical result type of a SubViewOp.  <a href="MemRefOps_8cpp.html#a902a21badb61387b3a01cf900a97e39e">More...</a><br /></td></tr>
<tr class="separator:a902a21badb61387b3a01cf900a97e39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac299274eab542658ab296d7ebcb24621"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#ac299274eab542658ab296d7ebcb24621">isTrivialSubViewOp</a> (SubViewOp subViewOp)</td></tr>
<tr class="memdesc:ac299274eab542658ab296d7ebcb24621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to check if a <code>subview</code> operation is trivially a no-op.  <a href="MemRefOps_8cpp.html#ac299274eab542658ab296d7ebcb24621">More...</a><br /></td></tr>
<tr class="separator:ac299274eab542658ab296d7ebcb24621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4da491ebeafb1a779b58a6bffa499c"><td class="memItemLeft" align="right" valign="top">static MemRefType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#a4c4da491ebeafb1a779b58a6bffa499c">inferTransposeResultType</a> (MemRefType memRefType, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> permutationMap)</td></tr>
<tr class="memdesc:a4c4da491ebeafb1a779b58a6bffa499c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a strided memref type by applying <code>permutationMap</code> to <code>memRefType</code>.  <a href="MemRefOps_8cpp.html#a4c4da491ebeafb1a779b58a6bffa499c">More...</a><br /></td></tr>
<tr class="separator:a4c4da491ebeafb1a779b58a6bffa499c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a52c883a38e577b8b12282ff70c95a16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c883a38e577b8b12282ff70c95a16d">&#9670;&nbsp;</a></span>GET_OP_CLASSES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GET_OP_CLASSES</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l03584">3584</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aeb1ae8369e10d64675d9ff2a5941a138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb1ae8369e10d64675d9ff2a5941a138">&#9670;&nbsp;</a></span>computeCollapsedLayoutMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FailureOr&lt;StridedLayoutAttr&gt; computeCollapsedLayoutMap </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>srcType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>reassociation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the layout map after collapsing a given source MemRef type with the specified reassociation indices. </p>
<p>Note: All collapsed dims in a reassociation group must be contiguous. It is not possible to check this by inspecting a MemRefType in the general case. If non-contiguity cannot be checked statically, the collapse is assumed to be valid (and thus accepted by this function) unless <code>strict = true</code>. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l02367">2367</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, and <a class="el" href="StaticValueUtils_8h_source.html#l00210">mlir::SaturatedInteger::wrap()</a>.</p>

</div>
</div>
<a id="ae74a2ddd3de03f1670d7743be51b0205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74a2ddd3de03f1670d7743be51b0205">&#9670;&nbsp;</a></span>computeExpandedLayoutMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FailureOr&lt;StridedLayoutAttr&gt; computeExpandedLayoutMap </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>srcType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>resultShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>reassociation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the layout map after expanding a given source MemRef type with the specified reassociation indices. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l02172">2172</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, and <a class="el" href="StaticValueUtils_8h_source.html#l00210">mlir::SaturatedInteger::wrap()</a>.</p>

</div>
</div>
<a id="ac1d21cdb0c018fbf8ed4a788049f6c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d21cdb0c018fbf8ed4a788049f6c33">&#9670;&nbsp;</a></span>computeMemRefRankReductionMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FailureOr&lt;llvm::SmallBitVector&gt; computeMemRefRankReductionMask </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>originalType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>reducedType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the <code>originalType</code> and a <code>candidateReducedType</code> whose shape is assumed to be a subset of <code>originalType</code> with some <code>1</code> entries erased, return the set of indices that specifies which of the entries of <code>originalShape</code> are dropped to obtain <code>reducedShape</code>. </p>
<p>This accounts for cases where there are multiple unit-dims, but only a subset of those are dropped. For MemRefTypes these can be disambiguated using the strides. If a dimension is dropped the stride must be dropped too. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00848">848</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, and <a class="el" href="MemRefOps_8cpp_source.html#l00833">getNumOccurences()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l03032">getCanonicalSubViewResultType()</a>.</p>

</div>
</div>
<a id="a2394cb329305195dcd14ef7ef2975a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2394cb329305195dcd14ef7ef2975a7a">&#9670;&nbsp;</a></span>constifyIndexValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void constifyIndexValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>constValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that sets values[i] to constValues[i] if the latter is a static value, as indicated by ShapedType::kDynamic. </p>
<p>If constValues[i] is dynamic, tries to extract a constant value from value[i] to allow for additional folding opportunities. Also convertes all existing attributes to index attributes. (They may be i64 attributes.) </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00096">96</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00115">mlir::getConstantIntValue()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00296">getContext()</a>, and <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>.</p>

</div>
</div>
<a id="a6f9e9af5d54aded11c7a613fb49e1a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9e9af5d54aded11c7a613fb49e1a46">&#9670;&nbsp;</a></span>FoldCopyOfCast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult FoldCopyOfCast </td>
          <td>(</td>
          <td class="paramtype">CopyOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the source/target of a CopyOp is a CastOp that does not modify the shape and element type, the cast can be skipped. </p>
<p>Such CastOps only cast the layout of the type. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00761">761</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="TensorOps_8cpp_source.html#l00322">mlir::tensor::canFoldIntoConsumerOp()</a>, and <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>.</p>

</div>
</div>
<a id="a902a21badb61387b3a01cf900a97e39e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a902a21badb61387b3a01cf900a97e39e">&#9670;&nbsp;</a></span>getCanonicalSubViewResultType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static MemRefType getCanonicalSubViewResultType </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>currentResultType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>currentSourceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>sourceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>mixedOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>mixedSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>mixedStrides</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the canonical result type of a SubViewOp. </p>
<p>Call <code>inferResultType</code> to deduce the result type for the given <code>sourceType</code>. Additionally, reduce the rank of the inferred result type if <code>currentResultType</code> is lower rank than <code>currentSourceType</code>. Use this signature if <code>sourceType</code> is updated together with the result type. In this case, it is important to compute the dropped dimensions using <code>currentSourceType</code> whose strides align with <code>currentResultType</code>. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l03032">3032</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="MemRefOps_8cpp_source.html#l00848">computeMemRefRankReductionMask()</a>, and <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>.</p>

</div>
</div>
<a id="adc8ee1edd7328998d47a287dc8185d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8ee1edd7328998d47a287dc8185d6a">&#9670;&nbsp;</a></span>getNumOccurences()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::map&lt;int64_t, unsigned&gt; getNumOccurences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>vals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a map with key being elements in <code>vals</code> and data being number of occurences of it. </p>
<p>Use std::map, since the <code>vals</code> here are strides and the dynamic stride value is the same as the tombstone value for <code>DenseMap&lt;int64_t&gt;</code>. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00833">833</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l00848">computeMemRefRankReductionMask()</a>.</p>

</div>
</div>
<a id="a6901e2de1f1e535ad6db31a96b7a0b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6901e2de1f1e535ad6db31a96b7a0b1d">&#9670;&nbsp;</a></span>haveCompatibleOffsets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool haveCompatibleOffsets </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if <code>t1</code> and <code>t2</code> have equal offsets (both dynamic or of same static value). </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l02861">2861</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

</div>
</div>
<a id="ad4748b8f26c7f13766db887bbd5404bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4748b8f26c7f13766db887bbd5404bc">&#9670;&nbsp;</a></span>haveCompatibleStrides()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool haveCompatibleStrides </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;&#160;</td>
          <td class="paramname"><em>droppedDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if <code>t1</code> and <code>t2</code> have equal strides (both dynamic or of same static value). </p>
<p>Dimensions of <code>t1</code> may be dropped in <code>t2</code>; these must be marked as dropped in <code>droppedDims</code>. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l02872">2872</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

</div>
</div>
<a id="a4c4da491ebeafb1a779b58a6bffa499c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c4da491ebeafb1a779b58a6bffa499c">&#9670;&nbsp;</a></span>inferTransposeResultType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static MemRefType inferTransposeResultType </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>memRefType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>permutationMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a strided memref type by applying <code>permutationMap</code> to <code>memRefType</code>. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l03303">3303</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00203">mlir::MemRefType::Builder::setLayout()</a>, and <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00193">mlir::MemRefType::Builder::setShape()</a>.</p>

</div>
</div>
<a id="a5a2e419c24e30507c54a8d5942359751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a2e419c24e30507c54a8d5942359751">&#9670;&nbsp;</a></span>isGuaranteedAutomaticAllocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isGuaranteedAutomaticAllocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an operation, return whether this op is guaranteed to allocate an AutomaticAllocationScopeResource. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00358">358</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00415">mlir::Operation::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l00451">AllocaScopeHoister::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a4397b9a83c219ccae94d6fc4b14f6f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4397b9a83c219ccae94d6fc4b14f6f32">&#9670;&nbsp;</a></span>isOpItselfPotentialAutomaticAllocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isOpItselfPotentialAutomaticAllocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an operation, return whether this op itself could allocate an AutomaticAllocationScopeResource. </p>
<p>Note that this will not check whether an operation contained within the op can allocate. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00377">377</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00415">mlir::Operation::getResults()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00749">mlir::Operation::hasTrait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l00411">AllocaScopeInliner::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="ac299274eab542658ab296d7ebcb24621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac299274eab542658ab296d7ebcb24621">&#9670;&nbsp;</a></span>isTrivialSubViewOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isTrivialSubViewOp </td>
          <td>(</td>
          <td class="paramtype">SubViewOp&#160;</td>
          <td class="paramname"><em>subViewOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper method to check if a <code>subview</code> operation is trivially a no-op. </p>
<p>This is the case if the all offsets are zero, all strides are 1, and the source shape is same as the size of the subview. In such cases, the subview can be folded into its source. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l03096">3096</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00115">mlir::getConstantIntValue()</a>.</p>

</div>
</div>
<a id="ac38e621303868d5773129812aaa74af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac38e621303868d5773129812aaa74af7">&#9670;&nbsp;</a></span>lastNonTerminatorInRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool lastNonTerminatorInRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether this op is the last non terminating op in a region. </p>
<p>That is to say, it is in a one-block region and is only followed by a terminator. This prevents extending the lifetime of allocations. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00400">400</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00230">mlir::Operation::getParentRegion()</a>, <a class="el" href="Block_8cpp_source.html#l00244">mlir::Block::getTerminator()</a>, <a class="el" href="IR_2Region_8h_source.html#l00068">mlir::Region::hasOneBlock()</a>, and <a class="el" href="Block_8cpp_source.html#l00250">mlir::Block::mightHaveTerminator()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l00411">AllocaScopeInliner::matchAndRewrite()</a>, and <a class="el" href="MemRefOps_8cpp_source.html#l00451">AllocaScopeHoister::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="aafdfa23b2974217feca58562d9915084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafdfa23b2974217feca58562d9915084">&#9670;&nbsp;</a></span>parseGlobalMemrefOpTypeAndInitialValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ParseResult parseGlobalMemrefOpTypeAndInitialValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeAttr &amp;&#160;</td>
          <td class="paramname"><em>typeAttr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &amp;&#160;</td>
          <td class="paramname"><em>initialValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l01485">1485</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1AsmParser.html#a33803273c4fc1a660d73cb91aceac30b">mlir::AsmParser::emitError()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l00072">mlir::AsmParser::getContext()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a8d00f93debeb1567ae8f7bbb76cdea37">mlir::AsmParser::getNameLoc()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00060">mlir::memref::getTensorTypeFromMemRefType()</a>, <a class="el" href="classmlir_1_1AsmParser.html#afc30172e59d0a9e4a28d8ba7ddf1ac42">mlir::AsmParser::parseAttribute()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2d725d47025c0e22ca8b2d44fce78ea7">mlir::AsmParser::parseOptionalEqual()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a305f6334c61eb92a164bd865851f55f4">mlir::AsmParser::parseOptionalKeyword()</a>, and <a class="el" href="classmlir_1_1AsmParser.html#ab85d23c93adf11e18d6507779bf95fad">mlir::AsmParser::parseType()</a>.</p>

</div>
</div>
<a id="a265e2c0706658d6b14273bba2445f3dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a265e2c0706658d6b14273bba2445f3dc">&#9670;&nbsp;</a></span>printGlobalMemrefOpTypeAndInitialValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void printGlobalMemrefOpTypeAndInitialValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GlobalOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeAttr&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>initialValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l01471">1471</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l02975">mlir::AsmPrinter::printAttributeWithoutType()</a>.</p>

</div>
</div>
<a id="a771eeaa57246ed965c05f9e93a3ba56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a771eeaa57246ed965c05f9e93a3ba56b">&#9670;&nbsp;</a></span>produceSubViewErrorMsg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult produceSubViewErrorMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75">SliceVerificationResult</a>&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SubViewOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>expectedType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l02894">2894</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a6341e1bfc09d56fa49bb1b9400459d8e">mlir::ElemTypeMismatch</a>, <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a36297823a9892f9936fba1805a1c52ca">mlir::LayoutMismatch</a>, <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a36a2220daadd84aaba239b031cf4cd23">mlir::MemSpaceMismatch</a>, <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a780dd32ee9af184442cea3f2a2a75271">mlir::RankTooLarge</a>, <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a87c69361ccd090c9c844e19d08432a26">mlir::SizeMismatch</a>, and <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a505a83f220c02df2f85c3810cd9ceb38">mlir::Success</a>.</p>

</div>
</div>
<a id="a7679bb5932dec6a723a291c144e0f871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7679bb5932dec6a723a291c144e0f871">&#9670;&nbsp;</a></span>replaceConstantUsesOf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool replaceConstantUsesOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Container&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>maybeConstants</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to perform the replacement of all constant uses of <code>values</code> by a materialized constant extracted from <code>maybeConstants</code>. </p>
<p><code>values</code> and <code>maybeConstants</code> are expected to have the same size. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l01308">1308</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00079">mlir::getAsOpFoldResult()</a>, and <a class="el" href="IR_2Operation_8cpp_source.html#l00226">mlir::Operation::replaceUsesOfWith()</a>.</p>

</div>
</div>
<a id="afcb10f259303d819184a4c81b159372a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb10f259303d819184a4c81b159372a">&#9670;&nbsp;</a></span>verifyAllocLikeOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocLikeOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult verifyAllocLikeOp </td>
          <td>(</td>
          <td class="paramtype">AllocLikeOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00129">129</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

</div>
</div>
<a id="a3211f00d69d9462b4103bba629b75337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3211f00d69d9462b4103bba629b75337">&#9670;&nbsp;</a></span>verifyCollapsedShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult verifyCollapsedShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>collapsedShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>expandedShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>reassociation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowMultipleDynamicDimsPerGroup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for verifying the shape of ExpandShapeOp and ResultShapeOp result and operand. </p>
<p>Layout maps are verified separately.</p>
<p>If <code>allowMultipleDynamicDimsPerGroup</code>, multiple dynamic dimensions are allowed in a reassocation group. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l02079">2079</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00672">mlir::Operation::emitOpError()</a>, and <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 1 2025 16:33:28 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
