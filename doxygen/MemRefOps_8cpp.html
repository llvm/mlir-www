<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/MemRef/IR/MemRefOps.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a href="dir_aa550efc2eb1acee4ac7619e105a3637.html">MemRef</a></li><li class="navelem"><a href="dir_bbff0bc417424c2f220526a400d79936.html">IR</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">MemRefOps.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="mlir_2Dialect_2Arith_2IR_2Arith_8h_source.html">mlir/Dialect/Arith/IR/Arith.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Arith_2Utils_2Utils_8h_source.html">mlir/Dialect/Arith/Utils/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2MemRef_2IR_2MemRef_8h_source.html">mlir/Dialect/MemRef/IR/MemRef.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="StaticValueUtils_8h_source.html">mlir/Dialect/Utils/StaticValueUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2AffineMap_8h_source.html">mlir/IR/AffineMap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Builders_8h_source.html">mlir/IR/Builders.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html">mlir/IR/BuiltinTypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Matchers_8h_source.html">mlir/IR/Matchers.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="OpDefinition_8h_source.html">mlir/IR/OpDefinition.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PatternMatch_8h_source.html">mlir/IR/PatternMatch.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TypeUtilities_8h_source.html">mlir/IR/TypeUtilities.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="InferTypeOpInterface_8h_source.html">mlir/Interfaces/InferTypeOpInterface.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SideEffectInterfaces_8h_source.html">mlir/Interfaces/SideEffectInterfaces.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="InferIntRangeCommon_8h_source.html">mlir/Interfaces/Utils/InferIntRangeCommon.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ViewLikeInterface_8h_source.html">mlir/Interfaces/ViewLikeInterface.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/STLExtras.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallBitVector.h&quot;</code><br />
<code>#include &quot;mlir/Dialect/MemRef/IR/MemRefOps.cpp.inc&quot;</code><br />
</div>
<p><a href="MemRefOps_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:AllocaScopeInliner" id="r_AllocaScopeInliner"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAllocaScopeInliner.html">AllocaScopeInliner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline an AllocaScopeOp if either the direct parent is an allocation scope or it contains no allocation.  <a href="structAllocaScopeInliner.html#details">More...</a><br /></td></tr>
<tr class="memitem:AllocaScopeHoister" id="r_AllocaScopeHoister"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAllocaScopeHoister.html">AllocaScopeHoister</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move allocations into an allocation scope, if it is legal to move them (e.g.  <a href="structAllocaScopeHoister.html#details">More...</a><br /></td></tr>
<tr class="memitem:CollapseShapeOpMemRefCastFolder" id="r_CollapseShapeOpMemRefCastFolder"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCollapseShapeOpMemRefCastFolder.html">CollapseShapeOpMemRefCastFolder</a></td></tr>
<tr class="memitem:SubViewReturnTypeCanonicalizer" id="r_SubViewReturnTypeCanonicalizer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSubViewReturnTypeCanonicalizer.html">SubViewReturnTypeCanonicalizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the canonical type of the result of a subview.  <a href="structSubViewReturnTypeCanonicalizer.html#details">More...</a><br /></td></tr>
<tr class="memitem:SubViewCanonicalizer" id="r_SubViewCanonicalizer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSubViewCanonicalizer.html">SubViewCanonicalizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A canonicalizer wrapper to replace SubViewOps.  <a href="structSubViewCanonicalizer.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a52c883a38e577b8b12282ff70c95a16d" id="r_a52c883a38e577b8b12282ff70c95a16d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52c883a38e577b8b12282ff70c95a16d">GET_OP_CLASSES</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2394cb329305195dcd14ef7ef2975a7a" id="r_a2394cb329305195dcd14ef7ef2975a7a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2394cb329305195dcd14ef7ef2975a7a">constifyIndexValues</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;values, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; constValues)</td></tr>
<tr class="memdesc:a2394cb329305195dcd14ef7ef2975a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that sets values[i] to constValues[i] if the latter is a static value, as indicated by ShapedType::kDynamic.  <br /></td></tr>
<tr class="memitem:ab035309530cf1b97699d6ad2a6ece0a7" id="r_ab035309530cf1b97699d6ad2a6ece0a7"><td class="memItemLeft" align="right" valign="top">static std::tuple&lt; MemorySpaceCastOpInterface, PtrLikeTypeInterface, <a class="el" href="classmlir_1_1Type.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab035309530cf1b97699d6ad2a6ece0a7">getMemorySpaceCastInfo</a> (<a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> resultTy, <a class="el" href="classmlir_1_1Value.html">Value</a> src)</td></tr>
<tr class="memdesc:ab035309530cf1b97699d6ad2a6ece0a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to retrieve a lossless memory-space cast, and the corresponding new result memref type.  <br /></td></tr>
<tr class="memitem:aed4f67e20d63bb5f10ddfa6e426dd09a" id="r_aed4f67e20d63bb5f10ddfa6e426dd09a"><td class="memTemplParams" colspan="2">template&lt;typename ConcreteOpTy&gt; </td></tr>
<tr class="memitem:aed4f67e20d63bb5f10ddfa6e426dd09a template"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed4f67e20d63bb5f10ddfa6e426dd09a">bubbleDownCastsPassthroughOpImpl</a> (ConcreteOpTy op, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;src)</td></tr>
<tr class="memdesc:aed4f67e20d63bb5f10ddfa6e426dd09a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <span class="tt">bubbleDownCasts</span> method for memref operations that return a single memref result.  <br /></td></tr>
<tr class="memitem:afcb10f259303d819184a4c81b159372a" id="r_afcb10f259303d819184a4c81b159372a"><td class="memTemplParams" colspan="2">template&lt;typename AllocLikeOp&gt; </td></tr>
<tr class="memitem:afcb10f259303d819184a4c81b159372a template"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcb10f259303d819184a4c81b159372a">verifyAllocLikeOp</a> (AllocLikeOp op)</td></tr>
<tr class="memitem:a5a2e419c24e30507c54a8d5942359751" id="r_a5a2e419c24e30507c54a8d5942359751"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a2e419c24e30507c54a8d5942359751">isGuaranteedAutomaticAllocation</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a5a2e419c24e30507c54a8d5942359751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an operation, return whether this op is guaranteed to allocate an AutomaticAllocationScopeResource.  <br /></td></tr>
<tr class="memitem:a4397b9a83c219ccae94d6fc4b14f6f32" id="r_a4397b9a83c219ccae94d6fc4b14f6f32"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4397b9a83c219ccae94d6fc4b14f6f32">isOpItselfPotentialAutomaticAllocation</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a4397b9a83c219ccae94d6fc4b14f6f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an operation, return whether this op itself could allocate an AutomaticAllocationScopeResource.  <br /></td></tr>
<tr class="memitem:ac38e621303868d5773129812aaa74af7" id="r_ac38e621303868d5773129812aaa74af7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac38e621303868d5773129812aaa74af7">lastNonTerminatorInRegion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ac38e621303868d5773129812aaa74af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether this op is the last non terminating op in a region.  <br /></td></tr>
<tr class="memitem:a6f9e9af5d54aded11c7a613fb49e1a46" id="r_a6f9e9af5d54aded11c7a613fb49e1a46"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f9e9af5d54aded11c7a613fb49e1a46">FoldCopyOfCast</a> (CopyOp op)</td></tr>
<tr class="memdesc:a6f9e9af5d54aded11c7a613fb49e1a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the source/target of a CopyOp is a CastOp that does not modify the shape and element type, the cast can be skipped.  <br /></td></tr>
<tr class="memitem:ad2a10ca01b83dc26986efa72d8d60488" id="r_ad2a10ca01b83dc26986efa72d8d60488"><td class="memItemLeft" align="right" valign="top">static std::map&lt; <a class="el" href="classint64__t.html">int64_t</a>, <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2a10ca01b83dc26986efa72d8d60488">getNumOccurences</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; vals)</td></tr>
<tr class="memdesc:ad2a10ca01b83dc26986efa72d8d60488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a map with key being elements in <span class="tt">vals</span> and data being number of occurences of it.  <br /></td></tr>
<tr class="memitem:ab1b9bd58ce283236ce1ac6af9dba377c" id="r_ab1b9bd58ce283236ce1ac6af9dba377c"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; llvm::SmallBitVector &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1b9bd58ce283236ce1ac6af9dba377c">computeMemRefRankReductionMask</a> (MemRefType originalType, MemRefType reducedType, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizes)</td></tr>
<tr class="memdesc:ab1b9bd58ce283236ce1ac6af9dba377c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the <span class="tt">originalType</span> and a <span class="tt">candidateReducedType</span> whose shape is assumed to be a subset of <span class="tt">originalType</span> with some <span class="tt">1</span> entries erased, return the set of indices that specifies which of the entries of <span class="tt">originalShape</span> are dropped to obtain <span class="tt">reducedShape</span>.  <br /></td></tr>
<tr class="memitem:a7679bb5932dec6a723a291c144e0f871" id="r_a7679bb5932dec6a723a291c144e0f871"><td class="memTemplParams" colspan="2">template&lt;typename Container&gt; </td></tr>
<tr class="memitem:a7679bb5932dec6a723a291c144e0f871 template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7679bb5932dec6a723a291c144e0f871">replaceConstantUsesOf</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, Container values, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; maybeConstants)</td></tr>
<tr class="memdesc:a7679bb5932dec6a723a291c144e0f871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to perform the replacement of all constant uses of <span class="tt">values</span> by a materialized constant extracted from <span class="tt">maybeConstants</span>.  <br /></td></tr>
<tr class="memitem:a265e2c0706658d6b14273bba2445f3dc" id="r_a265e2c0706658d6b14273bba2445f3dc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a265e2c0706658d6b14273bba2445f3dc">printGlobalMemrefOpTypeAndInitialValue</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, GlobalOp op, TypeAttr type, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> initialValue)</td></tr>
<tr class="memitem:aafdfa23b2974217feca58562d9915084" id="r_aafdfa23b2974217feca58562d9915084"><td class="memItemLeft" align="right" valign="top">static ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafdfa23b2974217feca58562d9915084">parseGlobalMemrefOpTypeAndInitialValue</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, TypeAttr &amp;typeAttr, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &amp;initialValue)</td></tr>
<tr class="memitem:a3211f00d69d9462b4103bba629b75337" id="r_a3211f00d69d9462b4103bba629b75337"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3211f00d69d9462b4103bba629b75337">verifyCollapsedShape</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; collapsedShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; expandedShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt; reassociation, <a class="el" href="classbool.html">bool</a> allowMultipleDynamicDimsPerGroup)</td></tr>
<tr class="memdesc:a3211f00d69d9462b4103bba629b75337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for verifying the shape of ExpandShapeOp and ResultShapeOp result and operand.  <br /></td></tr>
<tr class="memitem:a624577022cdec31fe4cf9ccc0decf7c4" id="r_a624577022cdec31fe4cf9ccc0decf7c4"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; StridedLayoutAttr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a624577022cdec31fe4cf9ccc0decf7c4">computeExpandedLayoutMap</a> (MemRefType srcType, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; resultShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt; reassociation)</td></tr>
<tr class="memdesc:a624577022cdec31fe4cf9ccc0decf7c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the layout map after expanding a given source MemRef type with the specified reassociation indices.  <br /></td></tr>
<tr class="memitem:adfda97e2009f6ada7f51dbb2b824f163" id="r_adfda97e2009f6ada7f51dbb2b824f163"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; StridedLayoutAttr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfda97e2009f6ada7f51dbb2b824f163">computeCollapsedLayoutMap</a> (MemRefType srcType, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt; reassociation, <a class="el" href="classbool.html">bool</a> strict=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:adfda97e2009f6ada7f51dbb2b824f163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the layout map after collapsing a given source MemRef type with the specified reassociation indices.  <br /></td></tr>
<tr class="memitem:a6901e2de1f1e535ad6db31a96b7a0b1d" id="r_a6901e2de1f1e535ad6db31a96b7a0b1d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6901e2de1f1e535ad6db31a96b7a0b1d">haveCompatibleOffsets</a> (MemRefType t1, MemRefType t2)</td></tr>
<tr class="memdesc:a6901e2de1f1e535ad6db31a96b7a0b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <span class="tt">t1</span> and <span class="tt">t2</span> have equal offsets (both dynamic or of same static value).  <br /></td></tr>
<tr class="memitem:ad4748b8f26c7f13766db887bbd5404bc" id="r_ad4748b8f26c7f13766db887bbd5404bc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4748b8f26c7f13766db887bbd5404bc">haveCompatibleStrides</a> (MemRefType t1, MemRefType t2, const llvm::SmallBitVector &amp;droppedDims)</td></tr>
<tr class="memdesc:ad4748b8f26c7f13766db887bbd5404bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <span class="tt">t1</span> and <span class="tt">t2</span> have equal strides (both dynamic or of same static value).  <br /></td></tr>
<tr class="memitem:a771eeaa57246ed965c05f9e93a3ba56b" id="r_a771eeaa57246ed965c05f9e93a3ba56b"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a771eeaa57246ed965c05f9e93a3ba56b">produceSubViewErrorMsg</a> (<a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75">SliceVerificationResult</a> <a class="el" href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a>, SubViewOp op, <a class="el" href="classmlir_1_1Type.html">Type</a> expectedType)</td></tr>
<tr class="memitem:a902a21badb61387b3a01cf900a97e39e" id="r_a902a21badb61387b3a01cf900a97e39e"><td class="memItemLeft" align="right" valign="top">static MemRefType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a902a21badb61387b3a01cf900a97e39e">getCanonicalSubViewResultType</a> (MemRefType currentResultType, MemRefType currentSourceType, MemRefType sourceType, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mixedOffsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mixedSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mixedStrides)</td></tr>
<tr class="memdesc:a902a21badb61387b3a01cf900a97e39e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the canonical result type of a SubViewOp.  <br /></td></tr>
<tr class="memitem:ac299274eab542658ab296d7ebcb24621" id="r_ac299274eab542658ab296d7ebcb24621"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac299274eab542658ab296d7ebcb24621">isTrivialSubViewOp</a> (SubViewOp subViewOp)</td></tr>
<tr class="memdesc:ac299274eab542658ab296d7ebcb24621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to check if a <span class="tt">subview</span> operation is trivially a no-op.  <br /></td></tr>
<tr class="memitem:a4c4da491ebeafb1a779b58a6bffa499c" id="r_a4c4da491ebeafb1a779b58a6bffa499c"><td class="memItemLeft" align="right" valign="top">static MemRefType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c4da491ebeafb1a779b58a6bffa499c">inferTransposeResultType</a> (MemRefType memRefType, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> permutationMap)</td></tr>
<tr class="memdesc:a4c4da491ebeafb1a779b58a6bffa499c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a strided memref type by applying <span class="tt">permutationMap</span> to <span class="tt">memRefType</span>.  <br /></td></tr>
</table>
<a name="doc-define-members" id="doc-define-members"></a><h2 id="header-doc-define-members" class="groupheader">Macro Definition Documentation</h2>
<a id="a52c883a38e577b8b12282ff70c95a16d" name="a52c883a38e577b8b12282ff70c95a16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c883a38e577b8b12282ff70c95a16d">&#9670;&#160;</a></span>GET_OP_CLASSES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GET_OP_CLASSES</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l03841">3841</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="aed4f67e20d63bb5f10ddfa6e426dd09a" name="aed4f67e20d63bb5f10ddfa6e426dd09a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4f67e20d63bb5f10ddfa6e426dd09a">&#9670;&#160;</a></span>bubbleDownCastsPassthroughOpImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteOpTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt; &gt; bubbleDownCastsPassthroughOpImpl </td>
          <td>(</td>
          <td class="paramtype">ConcreteOpTy</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of <span class="tt">bubbleDownCasts</span> method for memref operations that return a single memref result. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00148">148</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00117">getMemorySpaceCastInfo()</a>, <a class="el" href="Value_8cpp_source.html#l00226">mlir::OpOperand::getOperandNumber()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

</div>
</div>
<a id="adfda97e2009f6ada7f51dbb2b824f163" name="adfda97e2009f6ada7f51dbb2b824f163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfda97e2009f6ada7f51dbb2b824f163">&#9670;&#160;</a></span>computeCollapsedLayoutMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; StridedLayoutAttr &gt; computeCollapsedLayoutMap </td>
          <td>(</td>
          <td class="paramtype">MemRefType</td>          <td class="paramname"><span class="paramname"><em>srcType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>reassociation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>strict</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the layout map after collapsing a given source MemRef type with the specified reassociation indices. </p>
<p>Note: All collapsed dims in a reassociation group must be contiguous. It is not possible to check this by inspecting a MemRefType in the general case. If non-contiguity cannot be checked statically, the collapse is assumed to be valid (and thus accepted by this function) unless <span class="tt">strict = true</span>. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l02527">2527</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8h_source.html#l00231">mlir::SaturatedInteger::wrap()</a>.</p>

</div>
</div>
<a id="a624577022cdec31fe4cf9ccc0decf7c4" name="a624577022cdec31fe4cf9ccc0decf7c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624577022cdec31fe4cf9ccc0decf7c4">&#9670;&#160;</a></span>computeExpandedLayoutMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; StridedLayoutAttr &gt; computeExpandedLayoutMap </td>
          <td>(</td>
          <td class="paramtype">MemRefType</td>          <td class="paramname"><span class="paramname"><em>srcType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>resultShape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>reassociation</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the layout map after expanding a given source MemRef type with the specified reassociation indices. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l02327">2327</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8h_source.html#l00231">mlir::SaturatedInteger::wrap()</a>.</p>

</div>
</div>
<a id="ab1b9bd58ce283236ce1ac6af9dba377c" name="ab1b9bd58ce283236ce1ac6af9dba377c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1b9bd58ce283236ce1ac6af9dba377c">&#9670;&#160;</a></span>computeMemRefRankReductionMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; llvm::SmallBitVector &gt; computeMemRefRankReductionMask </td>
          <td>(</td>
          <td class="paramtype">MemRefType</td>          <td class="paramname"><span class="paramname"><em>originalType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType</td>          <td class="paramname"><span class="paramname"><em>reducedType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the <span class="tt">originalType</span> and a <span class="tt">candidateReducedType</span> whose shape is assumed to be a subset of <span class="tt">originalType</span> with some <span class="tt">1</span> entries erased, return the set of indices that specifies which of the entries of <span class="tt">originalShape</span> are dropped to obtain <span class="tt">reducedShape</span>. </p>
<p>This accounts for cases where there are multiple unit-dims, but only a subset of those are dropped. For MemRefTypes these can be disambiguated using the strides. If a dimension is dropped the stride must be dropped too. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00940">940</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="MemRefOps_8cpp_source.html#l00925">getNumOccurences()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l03208">getCanonicalSubViewResultType()</a>.</p>

</div>
</div>
<a id="a2394cb329305195dcd14ef7ef2975a7a" name="a2394cb329305195dcd14ef7ef2975a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2394cb329305195dcd14ef7ef2975a7a">&#9670;&#160;</a></span>constifyIndexValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> constifyIndexValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>constValues</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that sets values[i] to constValues[i] if the latter is a static value, as indicated by ShapedType::kDynamic. </p>
<p>If constValues[i] is dynamic, tries to extract a constant value from value[i] to allow for additional folding opportunities. Also convertes all existing attributes to index attributes. (They may be i64 attributes.) </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00096">96</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>, <a class="el" href="LoopUtils_8cpp.html#a420db562c84b0a026e92385cb33aaf6f">getContext()</a>, and <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>.</p>

</div>
</div>
<a id="a6f9e9af5d54aded11c7a613fb49e1a46" name="a6f9e9af5d54aded11c7a613fb49e1a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9e9af5d54aded11c7a613fb49e1a46">&#9670;&#160;</a></span>FoldCopyOfCast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult FoldCopyOfCast </td>
          <td>(</td>
          <td class="paramtype">CopyOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the source/target of a CopyOp is a CastOp that does not modify the shape and element type, the cast can be skipped. </p>
<p>Such CastOps only cast the layout of the type. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00853">853</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a902a21badb61387b3a01cf900a97e39e" name="a902a21badb61387b3a01cf900a97e39e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a902a21badb61387b3a01cf900a97e39e">&#9670;&#160;</a></span>getCanonicalSubViewResultType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MemRefType getCanonicalSubViewResultType </td>
          <td>(</td>
          <td class="paramtype">MemRefType</td>          <td class="paramname"><span class="paramname"><em>currentResultType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType</td>          <td class="paramname"><span class="paramname"><em>currentSourceType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType</td>          <td class="paramname"><span class="paramname"><em>sourceType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>mixedOffsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>mixedSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>mixedStrides</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the canonical result type of a SubViewOp. </p>
<p>Call <span class="tt">inferResultType</span> to deduce the result type for the given <span class="tt">sourceType</span>. Additionally, reduce the rank of the inferred result type if <span class="tt">currentResultType</span> is lower rank than <span class="tt">currentSourceType</span>. Use this signature if <span class="tt">sourceType</span> is updated together with the result type. In this case, it is important to compute the dropped dimensions using <span class="tt">currentSourceType</span> whose strides align with <span class="tt">currentResultType</span>. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l03208">3208</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="MemRefOps_8cpp_source.html#l00940">computeMemRefRankReductionMask()</a>.</p>

</div>
</div>
<a id="ab035309530cf1b97699d6ad2a6ece0a7" name="ab035309530cf1b97699d6ad2a6ece0a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab035309530cf1b97699d6ad2a6ece0a7">&#9670;&#160;</a></span>getMemorySpaceCastInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; MemorySpaceCastOpInterface, PtrLikeTypeInterface, <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; getMemorySpaceCastInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a></td>          <td class="paramname"><span class="paramname"><em>resultTy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to retrieve a lossless memory-space cast, and the corresponding new result memref type. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00117">117</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00417">mlir::BaseMemRefType::clonePtrWith()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l00148">bubbleDownCastsPassthroughOpImpl()</a>.</p>

</div>
</div>
<a id="ad2a10ca01b83dc26986efa72d8d60488" name="ad2a10ca01b83dc26986efa72d8d60488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2a10ca01b83dc26986efa72d8d60488">&#9670;&#160;</a></span>getNumOccurences()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; <a class="el" href="classint64__t.html">int64_t</a>, <a class="el" href="classunsigned.html">unsigned</a> &gt; getNumOccurences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>vals</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a map with key being elements in <span class="tt">vals</span> and data being number of occurences of it. </p>
<p>Use std::map, since the <span class="tt">vals</span> here are strides and the dynamic stride value is the same as the tombstone value for <span class="tt"><a class="el" href="namespacemlir.html#abde461319ad5039ddbf5b4e70f47618b">DenseMap</a>&lt;<a class="el" href="classint64__t.html">int64_t</a>&gt;</span>. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00925">925</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l00940">computeMemRefRankReductionMask()</a>.</p>

</div>
</div>
<a id="a6901e2de1f1e535ad6db31a96b7a0b1d" name="a6901e2de1f1e535ad6db31a96b7a0b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6901e2de1f1e535ad6db31a96b7a0b1d">&#9670;&#160;</a></span>haveCompatibleOffsets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> haveCompatibleOffsets </td>
          <td>(</td>
          <td class="paramtype">MemRefType</td>          <td class="paramname"><span class="paramname"><em>t1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType</td>          <td class="paramname"><span class="paramname"><em>t2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if <span class="tt">t1</span> and <span class="tt">t2</span> have equal offsets (both dynamic or of same static value). </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l03037">3037</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

</div>
</div>
<a id="ad4748b8f26c7f13766db887bbd5404bc" name="ad4748b8f26c7f13766db887bbd5404bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4748b8f26c7f13766db887bbd5404bc">&#9670;&#160;</a></span>haveCompatibleStrides()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> haveCompatibleStrides </td>
          <td>(</td>
          <td class="paramtype">MemRefType</td>          <td class="paramname"><span class="paramname"><em>t1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType</td>          <td class="paramname"><span class="paramname"><em>t2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;</td>          <td class="paramname"><span class="paramname"><em>droppedDims</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if <span class="tt">t1</span> and <span class="tt">t2</span> have equal strides (both dynamic or of same static value). </p>
<p>Dimensions of <span class="tt">t1</span> may be dropped in <span class="tt">t2</span>; these must be marked as dropped in <span class="tt">droppedDims</span>. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l03048">3048</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

</div>
</div>
<a id="a4c4da491ebeafb1a779b58a6bffa499c" name="a4c4da491ebeafb1a779b58a6bffa499c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c4da491ebeafb1a779b58a6bffa499c">&#9670;&#160;</a></span>inferTransposeResultType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MemRefType inferTransposeResultType </td>
          <td>(</td>
          <td class="paramtype">MemRefType</td>          <td class="paramname"><span class="paramname"><em>memRefType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>permutationMap</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a strided memref type by applying <span class="tt">permutationMap</span> to <span class="tt">memRefType</span>. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l03543">3543</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00675">mlir::applyPermutationMap()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00203">mlir::MemRefType::Builder::setLayout()</a>, and <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00193">mlir::MemRefType::Builder::setShape()</a>.</p>

</div>
</div>
<a id="a5a2e419c24e30507c54a8d5942359751" name="a5a2e419c24e30507c54a8d5942359751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a2e419c24e30507c54a8d5942359751">&#9670;&#160;</a></span>isGuaranteedAutomaticAllocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> isGuaranteedAutomaticAllocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an operation, return whether this op is guaranteed to allocate an AutomaticAllocationScopeResource. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00417">417</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00415">mlir::Operation::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l00510">AllocaScopeHoister::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a4397b9a83c219ccae94d6fc4b14f6f32" name="a4397b9a83c219ccae94d6fc4b14f6f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4397b9a83c219ccae94d6fc4b14f6f32">&#9670;&#160;</a></span>isOpItselfPotentialAutomaticAllocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> isOpItselfPotentialAutomaticAllocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an operation, return whether this op itself could allocate an AutomaticAllocationScopeResource. </p>
<p>Note that this will not check whether an operation contained within the op can allocate. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00436">436</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00415">mlir::Operation::getResults()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00749">mlir::Operation::hasTrait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l00470">AllocaScopeInliner::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="ac299274eab542658ab296d7ebcb24621" name="ac299274eab542658ab296d7ebcb24621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac299274eab542658ab296d7ebcb24621">&#9670;&#160;</a></span>isTrivialSubViewOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> isTrivialSubViewOp </td>
          <td>(</td>
          <td class="paramtype">SubViewOp</td>          <td class="paramname"><span class="paramname"><em>subViewOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper method to check if a <span class="tt">subview</span> operation is trivially a no-op. </p>
<p>This is the case if the all offsets are zero, all strides are 1, and the source shape is same as the size of the subview. In such cases, the subview can be folded into its source. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l03272">3272</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>.</p>

</div>
</div>
<a id="ac38e621303868d5773129812aaa74af7" name="ac38e621303868d5773129812aaa74af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac38e621303868d5773129812aaa74af7">&#9670;&#160;</a></span>lastNonTerminatorInRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> lastNonTerminatorInRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether this op is the last non terminating op in a region. </p>
<p>That is to say, it is in a one-block region and is only followed by a terminator. This prevents extending the lifetime of allocations. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00459">459</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00230">mlir::Operation::getParentRegion()</a>, <a class="el" href="Block_8cpp_source.html#l00244">mlir::Block::getTerminator()</a>, <a class="el" href="IR_2Region_8h_source.html#l00068">mlir::Region::hasOneBlock()</a>, and <a class="el" href="Block_8cpp_source.html#l00250">mlir::Block::mightHaveTerminator()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l00510">AllocaScopeHoister::matchAndRewrite()</a>, and <a class="el" href="MemRefOps_8cpp_source.html#l00470">AllocaScopeInliner::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="aafdfa23b2974217feca58562d9915084" name="aafdfa23b2974217feca58562d9915084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafdfa23b2974217feca58562d9915084">&#9670;&#160;</a></span>parseGlobalMemrefOpTypeAndInitialValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult parseGlobalMemrefOpTypeAndInitialValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeAttr &amp;</td>          <td class="paramname"><span class="paramname"><em>typeAttr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>initialValue</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l01577">1577</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1AsmParser.html#a33803273c4fc1a660d73cb91aceac30b">mlir::AsmParser::emitError()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l00072">mlir::AsmParser::getContext()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a8d00f93debeb1567ae8f7bbb76cdea37">mlir::AsmParser::getNameLoc()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00060">mlir::memref::getTensorTypeFromMemRefType()</a>, <a class="el" href="classmlir_1_1AsmParser.html#afc30172e59d0a9e4a28d8ba7ddf1ac42">mlir::AsmParser::parseAttribute()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2d725d47025c0e22ca8b2d44fce78ea7">mlir::AsmParser::parseOptionalEqual()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a305f6334c61eb92a164bd865851f55f4">mlir::AsmParser::parseOptionalKeyword()</a>, <a class="el" href="classmlir_1_1AsmParser.html#ab85d23c93adf11e18d6507779bf95fad">mlir::AsmParser::parseType()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a265e2c0706658d6b14273bba2445f3dc" name="a265e2c0706658d6b14273bba2445f3dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a265e2c0706658d6b14273bba2445f3dc">&#9670;&#160;</a></span>printGlobalMemrefOpTypeAndInitialValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> printGlobalMemrefOpTypeAndInitialValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GlobalOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeAttr</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td>          <td class="paramname"><span class="paramname"><em>initialValue</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l01563">1563</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l02987">mlir::AsmPrinter::printAttributeWithoutType()</a>.</p>

</div>
</div>
<a id="a771eeaa57246ed965c05f9e93a3ba56b" name="a771eeaa57246ed965c05f9e93a3ba56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a771eeaa57246ed965c05f9e93a3ba56b">&#9670;&#160;</a></span>produceSubViewErrorMsg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult produceSubViewErrorMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75">SliceVerificationResult</a></td>          <td class="paramname"><span class="paramname"><em>result</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SubViewOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>expectedType</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l03070">3070</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00360">mlir::ElemTypeMismatch</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00363">mlir::LayoutMismatch</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00362">mlir::MemSpaceMismatch</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00358">mlir::RankTooLarge</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00359">mlir::SizeMismatch</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00357">mlir::Success</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a7679bb5932dec6a723a291c144e0f871" name="a7679bb5932dec6a723a291c144e0f871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7679bb5932dec6a723a291c144e0f871">&#9670;&#160;</a></span>replaceConstantUsesOf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> replaceConstantUsesOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Container</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>maybeConstants</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to perform the replacement of all constant uses of <span class="tt">values</span> by a materialized constant extracted from <span class="tt">maybeConstants</span>. </p>
<p><span class="tt">values</span> and <span class="tt">maybeConstants</span> are expected to have the same size. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l01393">1393</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00081">mlir::getAsOpFoldResult()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00227">mlir::Operation::replaceUsesOfWith()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

</div>
</div>
<a id="afcb10f259303d819184a4c81b159372a" name="afcb10f259303d819184a4c81b159372a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb10f259303d819184a4c81b159372a">&#9670;&#160;</a></span>verifyAllocLikeOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocLikeOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult verifyAllocLikeOp </td>
          <td>(</td>
          <td class="paramtype">AllocLikeOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00188">188</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a3211f00d69d9462b4103bba629b75337" name="a3211f00d69d9462b4103bba629b75337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3211f00d69d9462b4103bba629b75337">&#9670;&#160;</a></span>verifyCollapsedShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult verifyCollapsedShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>collapsedShape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>expandedShape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>reassociation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>allowMultipleDynamicDimsPerGroup</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for verifying the shape of ExpandShapeOp and ResultShapeOp result and operand. </p>
<p>Layout maps are verified separately.</p>
<p>If <span class="tt">allowMultipleDynamicDimsPerGroup</span>, multiple dynamic dimensions are allowed in a reassocation group. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l02234">2234</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00668">mlir::Operation::emitOpError()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
