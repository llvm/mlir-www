<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::nvgpu Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="namespacemlir.html">mlir</a></li><li class="navelem"><a href="namespacemlir_1_1nvgpu.html">nvgpu</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">mlir::nvgpu Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:impl" id="r_impl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1nvgpu_1_1impl.html">impl</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:WarpMatrixInfo" id="r_WarpMatrixInfo"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1nvgpu_1_1WarpMatrixInfo.html">WarpMatrixInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects information about a warp-level matrix operand represented by a VectorType.  <a href="structmlir_1_1nvgpu_1_1WarpMatrixInfo.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2cd481d969335c7faee4833fd989f8ed" id="r_a2cd481d969335c7faee4833fd989f8ed"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cd481d969335c7faee4833fd989f8ed">MmaSyncF32Lowering</a> { <a class="el" href="#a2cd481d969335c7faee4833fd989f8eda7af37e98489130cf59da22f2f9b3c2d6">TF32</a> = 0
, <a class="el" href="#a2cd481d969335c7faee4833fd989f8edab0496676569bf2251989f4011ec01965">TF32x3</a> = 1
, <a class="el" href="#a2cd481d969335c7faee4833fd989f8eda777358f6554241fd6bb9110bf267b3ac">Unkown</a> = 2
 }</td></tr>
<tr class="memdesc:a2cd481d969335c7faee4833fd989f8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites patterns.  <a href="#a2cd481d969335c7faee4833fd989f8ed">More...</a><br /></td></tr>
<tr class="memitem:ae4c82fd5e3500e2d345d723829e09efe" id="r_ae4c82fd5e3500e2d345d723829e09efe"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4c82fd5e3500e2d345d723829e09efe">MatMulOperandRole</a> : int32_t { <a class="el" href="#ae4c82fd5e3500e2d345d723829e09efea7fc56270e7a70fa81a5935b72eacbe29">A</a> = 0
, <a class="el" href="#ae4c82fd5e3500e2d345d723829e09efea9d5ed678fe57bcca610140957afab571">B</a>
, <a class="el" href="#ae4c82fd5e3500e2d345d723829e09efea0d61f8370cad1d412f80b84d143e1257">C</a>
 }</td></tr>
<tr class="memdesc:ae4c82fd5e3500e2d345d723829e09efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the role of an operand in an MMA instruction: <span class="tt">result := matmul(A, B) + C</span>  <a href="#ae4c82fd5e3500e2d345d723829e09efe">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a68e2eb7a214f699ea849b6f2f25555ce" id="r_a68e2eb7a214f699ea849b6f2f25555ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68e2eb7a214f699ea849b6f2f25555ce">getMbarrierMemorySpace</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, MBarrierGroupType barrierType)</td></tr>
<tr class="memdesc:a68e2eb7a214f699ea849b6f2f25555ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the memory space attribute of the mbarrier object.  <br /></td></tr>
<tr class="memitem:a3e30fabfef9dd0964a957cbc3baa7b9c" id="r_a3e30fabfef9dd0964a957cbc3baa7b9c"><td class="memItemLeft" align="right" valign="top">MemRefType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e30fabfef9dd0964a957cbc3baa7b9c">getMBarrierMemrefType</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, MBarrierGroupType barrierType)</td></tr>
<tr class="memdesc:a3e30fabfef9dd0964a957cbc3baa7b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the memref type that can be used to represent an mbarrier object.  <br /></td></tr>
<tr class="memitem:ae64270d2058ef5fd99281df6e7de4464" id="r_ae64270d2058ef5fd99281df6e7de4464"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae64270d2058ef5fd99281df6e7de4464">registerTransformDialectExtension</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:a6783845748d4e0a1c685d19edbf53314" id="r_a6783845748d4e0a1c685d19edbf53314"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6783845748d4e0a1c685d19edbf53314">createOptimizeSharedMemoryPass</a> ()</td></tr>
<tr class="memdesc:a6783845748d4e0a1c685d19edbf53314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to optimize shared memory reads and writes.  <br /></td></tr>
<tr class="memitem:a481b33225aab10fb527d43e21693576c" id="r_a481b33225aab10fb527d43e21693576c"><td class="memItemLeft" align="right" valign="top">llvm::LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a481b33225aab10fb527d43e21693576c">optimizeSharedMemoryReadsAndWrites</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *parentOp, <a class="el" href="classmlir_1_1Value.html">Value</a> memrefValue)</td></tr>
<tr class="memdesc:a481b33225aab10fb527d43e21693576c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passes.  <br /></td></tr>
<tr class="memitem:a7d4c259957fcb36c77d32413688cd447" id="r_a7d4c259957fcb36c77d32413688cd447"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d4c259957fcb36c77d32413688cd447">populateMmaSyncF32ToTF32Patterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="#a2cd481d969335c7faee4833fd989f8ed">nvgpu::MmaSyncF32Lowering</a> precision=<a class="el" href="#a2cd481d969335c7faee4833fd989f8eda7af37e98489130cf59da22f2f9b3c2d6">nvgpu::MmaSyncF32Lowering::TF32</a>)</td></tr>
<tr class="memdesc:a7d4c259957fcb36c77d32413688cd447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect patterns to convert mma.sync on f32 input and rewrite to use tensor cores with user provided level of accuracy: (a) tf32 (1 mma.sync per warp-level matrix-multiply-accumulate) (b) tf32x3 (3 mma.sync per warp-level matrix-multiply-accumulate) Typically, tf32 tensor core acceleration comes at a cost of accuracy from missing precision bits.  <br /></td></tr>
<tr class="memitem:af0ddf8062abd0432231a7d36838e208a" id="r_af0ddf8062abd0432231a7d36838e208a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0ddf8062abd0432231a7d36838e208a">createAsyncGroups</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classbool.html">bool</a> bypassL1)</td></tr>
<tr class="memdesc:af0ddf8062abd0432231a7d36838e208a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert global-&gt;shared vector transfers to async device copies.  <br /></td></tr>
<tr class="memitem:ad59722c33205a25c3184235b9519c8bc" id="r_ad59722c33205a25c3184235b9519c8bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html#a8fc63f3d33e11994ab3330eb6e8990b9">Operation::operand_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad59722c33205a25c3184235b9519c8bc">getIndices</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ad59722c33205a25c3184235b9519c8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the indices that the given load/store operation is operating on.  <br /></td></tr>
<tr class="memitem:ab0258fd3dfe2db8a9b1c2c2206e6fb89" id="r_ab0258fd3dfe2db8a9b1c2c2206e6fb89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0258fd3dfe2db8a9b1c2c2206e6fb89">setIndices</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; <a class="el" href="AffineAnalysis_8cpp.html#a7b261d2d5f193015afc3427b0c0951ed">indices</a>)</td></tr>
<tr class="memdesc:ab0258fd3dfe2db8a9b1c2c2206e6fb89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the indices that the given load/store operation is operating on.  <br /></td></tr>
<tr class="memitem:ad3cfa52d974ad6a649c45c740364cf10" id="r_ad3cfa52d974ad6a649c45c740364cf10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3cfa52d974ad6a649c45c740364cf10">getValueStored</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ad3cfa52d974ad6a649c45c740364cf10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value that is stored by the given store operation.  <br /></td></tr>
<tr class="memitem:ab3cdfe05b617a4a8ad03a9aa649a740f" id="r_ab3cdfe05b617a4a8ad03a9aa649a740f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3cdfe05b617a4a8ad03a9aa649a740f">getMemrefOperand</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ab3cdfe05b617a4a8ad03a9aa649a740f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the memref that is loaded from/stored into by the given load/store operation.  <br /></td></tr>
<tr class="memitem:a5e5e9578e2fea736fe8b33cdbb846a75" id="r_a5e5e9578e2fea736fe8b33cdbb846a75"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; vector::ContractionOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e5e9578e2fea736fe8b33cdbb846a75">getUserContract</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a5e5e9578e2fea736fe8b33cdbb846a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first user of the <span class="tt">op</span> that is vector.contract.  <br /></td></tr>
<tr class="memitem:a833cda849d4c16ca9e572b561a3d7c8c" id="r_a833cda849d4c16ca9e572b561a3d7c8c"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1nvgpu_1_1WarpMatrixInfo.html">WarpMatrixInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a833cda849d4c16ca9e572b561a3d7c8c">getWarpMatrixInfo</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a833cda849d4c16ca9e572b561a3d7c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <span class="tt">op</span> is a <span class="tt">vector.transfer_write</span>, return the <span class="tt"><a class="el" href="structmlir_1_1nvgpu_1_1WarpMatrixInfo.html" title="Collects information about a warp-level matrix operand represented by a VectorType.">WarpMatrixInfo</a></span> for the vector operand.  <br /></td></tr>
<tr class="memitem:adf5434a8a66a6334b2c049e206356873" id="r_adf5434a8a66a6334b2c049e206356873"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf5434a8a66a6334b2c049e206356873">canLowerToWarpMatrixOperation</a> (vector::TransferWriteOp op)</td></tr>
<tr class="memdesc:adf5434a8a66a6334b2c049e206356873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bits in a single tile row.  <br /></td></tr>
<tr class="memitem:a5555adb663e26b8a6ee5726cb34d022e" id="r_a5555adb663e26b8a6ee5726cb34d022e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5555adb663e26b8a6ee5726cb34d022e">registerOptimizeSharedMemory</a> ()</td></tr>
<tr class="memitem:aa733fd75fc00ca43f90055a14a49b22f" id="r_aa733fd75fc00ca43f90055a14a49b22f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa733fd75fc00ca43f90055a14a49b22f">registerOptimizeSharedMemoryPass</a> ()</td></tr>
<tr class="memitem:a59a0af50bc6f7b95dea4911516dfb0f8" id="r_a59a0af50bc6f7b95dea4911516dfb0f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59a0af50bc6f7b95dea4911516dfb0f8">registerNVGPUPasses</a> ()</td></tr>
</table>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="ae4c82fd5e3500e2d345d723829e09efe" name="ae4c82fd5e3500e2d345d723829e09efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c82fd5e3500e2d345d723829e09efe">&#9670;&#160;</a></span>MatMulOperandRole</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ae4c82fd5e3500e2d345d723829e09efe">mlir::nvgpu::MatMulOperandRole</a> : int32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the role of an operand in an MMA instruction: <span class="tt">result := matmul(A, B) + C</span> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae4c82fd5e3500e2d345d723829e09efea7fc56270e7a70fa81a5935b72eacbe29" name="ae4c82fd5e3500e2d345d723829e09efea7fc56270e7a70fa81a5935b72eacbe29"></a>A&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae4c82fd5e3500e2d345d723829e09efea9d5ed678fe57bcca610140957afab571" name="ae4c82fd5e3500e2d345d723829e09efea9d5ed678fe57bcca610140957afab571"></a>B&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae4c82fd5e3500e2d345d723829e09efea0d61f8370cad1d412f80b84d143e1257" name="ae4c82fd5e3500e2d345d723829e09efea0d61f8370cad1d412f80b84d143e1257"></a>C&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="MMAUtils_8h_source.html#l00026">26</a> of file <a class="el" href="MMAUtils_8h_source.html">MMAUtils.h</a>.</p>

</div>
</div>
<a id="a2cd481d969335c7faee4833fd989f8ed" name="a2cd481d969335c7faee4833fd989f8ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd481d969335c7faee4833fd989f8ed">&#9670;&#160;</a></span>MmaSyncF32Lowering</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a2cd481d969335c7faee4833fd989f8ed">mlir::nvgpu::MmaSyncF32Lowering</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rewrites patterns. </p>
<p>Enum to control the lowering of <span class="tt">nvgpu.mmasync</span>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2cd481d969335c7faee4833fd989f8eda7af37e98489130cf59da22f2f9b3c2d6" name="a2cd481d969335c7faee4833fd989f8eda7af37e98489130cf59da22f2f9b3c2d6"></a>TF32&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2cd481d969335c7faee4833fd989f8edab0496676569bf2251989f4011ec01965" name="a2cd481d969335c7faee4833fd989f8edab0496676569bf2251989f4011ec01965"></a>TF32x3&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2cd481d969335c7faee4833fd989f8eda777358f6554241fd6bb9110bf267b3ac" name="a2cd481d969335c7faee4833fd989f8eda777358f6554241fd6bb9110bf267b3ac"></a>Unkown&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2NVGPU_2Transforms_2Transforms_8h_source.html#l00057">57</a> of file <a class="el" href="mlir_2Dialect_2NVGPU_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="adf5434a8a66a6334b2c049e206356873" name="adf5434a8a66a6334b2c049e206356873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf5434a8a66a6334b2c049e206356873">&#9670;&#160;</a></span>canLowerToWarpMatrixOperation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::nvgpu::canLowerToWarpMatrixOperation </td>
          <td>(</td>
          <td class="paramtype">vector::TransferWriteOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of bits in a single tile row. </p>
<p>It is either 128, 256, or 512 bits depending on the data type and` whether the operand is an / accumulator/result operand <a class="el" href="classint64__t.html">int64_t</a> inferTileWidthInBits(const WarpMatrixInfo &amp;type);</p>
<p>/ Specifies information about the registers which compose a matrix fragment / according to the PTX documentation. struct FragmentElementInfo { <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> registerLLVMType; <a class="el" href="classint64__t.html">int64_t</a> elementsPerRegister; <a class="el" href="classint64__t.html">int64_t</a> registerWidthBits; <a class="el" href="classint64__t.html">int64_t</a> numRegistersPerFragment; };</p>
<p>/ Returns a FragmentElementInfo struct describing the register types for the / given matrix fragment type. FailureOr&lt;FragmentElementInfo&gt; getMmaSyncRegisterType(const WarpMatrixInfo &amp;type);</p>
<p>/ Returns an <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> which maps a two dimensions representing (laneId, / logicalValueId) and returns two results representing offsets within a / matrix operand. The offsets point to the values the thread is responsible / for (AKA the matrix fragment values) during a warp-collective matrix / operation. For a visual reference of this LaneId -&gt; (row, col) mapping, / please see NVIDIA's PTX documentation: / <a href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#warp-level-matrix-instructions-for-mma">https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#warp-level-matrix-instructions-for-mma</a> FailureOr&lt;AffineMap&gt; getLaneIdAndValueIdToOperandCoord(OpBuilder &amp;builder, Location loc,
                                  const WarpMatrixInfo &amp;fragmentType);</p>
<p>/ Encapsulates the parameters needed to lower a <span class="tt">nvgpu.ldmatrix</span> operation to / <span class="tt">nvvm.ldmatrix</span>. struct LdMatrixParams { VectorType fragmentType; bool isAccum; <a class="el" href="classint64__t.html">int64_t</a> numTiles; vector::IteratorType contiguousDimType; NVVM::MMALayout targetLayout; };</p>
<p>/ Given <span class="tt">type</span> that contains info for a warp-matrix operand and whether or not / the load is a transposed load, return the LdMatrixParams. FailureOr&lt;LdMatrixParams&gt; getLdMatrixParams(const WarpMatrixInfo &amp;type,
                                            bool transpose); / Returns an <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> which maps a single dimension representing the laneId / to two results representing offsets within the matrix operand that should / be the pointer locations a thread should pass to the ldmatrix instruction. FailureOr&lt;AffineMap&gt; getLaneIdToLdMatrixMatrixCoord(OpBuilder &amp;builder, Location loc,
                               const LdMatrixParams &amp;params);</p>
<p>/ Returns whether the <span class="tt">vector.transfer_read</span> instruction can be interpreted / as a warp-level cooperative matrix load operation. This function is meant to / be used to establish whether <span class="tt">op</span> is part of a chain of such warp-level / operations. bool canLowerToWarpMatrixOperation(vector::TransferReadOp op);</p>
<p>/ Returns whether the <span class="tt">vector.transfer_write</span> instruction can be interpreted / as a warp-level cooperative matrix store operation. This function is meant / to be used to establish whether <span class="tt">op</span> is part of a chain of such warp-level operations. </p>

<p class="definition">Definition at line <a class="el" href="MMAUtils_8cpp_source.html#l00296">296</a> of file <a class="el" href="MMAUtils_8cpp_source.html">MMAUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorToGPU_8cpp_source.html#l00272">supportsMMaMatrixType()</a>.</p>

</div>
</div>
<a id="af0ddf8062abd0432231a7d36838e208a" name="af0ddf8062abd0432231a7d36838e208a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ddf8062abd0432231a7d36838e208a">&#9670;&#160;</a></span>createAsyncGroups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::nvgpu::createAsyncGroups </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>bypassL1</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert global-&gt;shared vector transfers to async device copies. </p>
<p>This function looks for suitable vector transfers within the specified op and converts them to "nvgpu.device_async_copy" ops. Consecutive copies are put into the same sync group. If <span class="tt">bypassL1</span> is set, the "bypassL1" attribute is set for suitable (i.e., transfer size 16 bytes) transfers. </p>

<p class="definition">Definition at line <a class="el" href="CreateAsyncGroups_8cpp_source.html#l00152">152</a> of file <a class="el" href="CreateAsyncGroups_8cpp_source.html">CreateAsyncGroups.cpp</a>.</p>

<p class="reference">References <a class="el" href="CreateAsyncGroups_8cpp_source.html#l00083">buildNumReadElements()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00155">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00216">mlir::Operation::getContext()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Dialect_2NVGPU_2Transforms_2Utils_8cpp_source.html#l00018">getIndices()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="CreateAsyncGroups_8cpp_source.html#l00058">getMaskOp()</a>, <a class="el" href="Dialect_2NVGPU_2Transforms_2Utils_8cpp_source.html#l00068">getMemrefOperand()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="Builders_8cpp_source.html#l00098">mlir::Builder::getUnitAttr()</a>, <a class="el" href="Dialect_2NVGPU_2Transforms_2Utils_8cpp_source.html#l00058">getValueStored()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00749">mlir::Operation::hasTrait()</a>, <a class="el" href="CreateAsyncGroups_8cpp_source.html#l00041">isContiguousRead()</a>, <a class="el" href="CreateAsyncGroups_8cpp_source.html#l00032">isContiguousStore()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00542">mlir::Operation::remove()</a>, <a class="el" href="CreateAsyncGroups_8cpp_source.html#l00126">resultsInSupportedAsyncCopy()</a>, <a class="el" href="Builders_8h_source.html#l00398">mlir::OpBuilder::setInsertionPoint()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00797">mlir::Operation::walk()</a>.</p>

</div>
</div>
<a id="a6783845748d4e0a1c685d19edbf53314" name="a6783845748d4e0a1c685d19edbf53314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6783845748d4e0a1c685d19edbf53314">&#9670;&#160;</a></span>createOptimizeSharedMemoryPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::nvgpu::createOptimizeSharedMemoryPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to optimize shared memory reads and writes. </p>

<p class="definition">Definition at line <a class="el" href="OptimizeSharedMemory_8cpp_source.html#l00245">245</a> of file <a class="el" href="OptimizeSharedMemory_8cpp_source.html">OptimizeSharedMemory.cpp</a>.</p>

</div>
</div>
<a id="ad59722c33205a25c3184235b9519c8bc" name="ad59722c33205a25c3184235b9519c8bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59722c33205a25c3184235b9519c8bc">&#9670;&#160;</a></span>getIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html#a8fc63f3d33e11994ab3330eb6e8990b9">Operation::operand_range</a> mlir::nvgpu::getIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the indices that the given load/store operation is operating on. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2NVGPU_2Transforms_2Utils_8cpp_source.html#l00018">18</a> of file <a class="el" href="Dialect_2NVGPU_2Transforms_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="CreateAsyncGroups_8cpp_source.html#l00152">createAsyncGroups()</a>, <a class="el" href="OptimizeSharedMemory_8cpp_source.html#l00113">getShmReadAndWriteOps()</a>, and <a class="el" href="OptimizeSharedMemory_8cpp_source.html#l00149">optimizeSharedMemoryReadsAndWrites()</a>.</p>

</div>
</div>
<a id="a68e2eb7a214f699ea849b6f2f25555ce" name="a68e2eb7a214f699ea849b6f2f25555ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e2eb7a214f699ea849b6f2f25555ce">&#9670;&#160;</a></span>getMbarrierMemorySpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::nvgpu::getMbarrierMemorySpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MBarrierGroupType</td>          <td class="paramname"><span class="paramname"><em>barrierType</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the memory space attribute of the mbarrier object. </p>

</div>
</div>
<a id="a3e30fabfef9dd0964a957cbc3baa7b9c" name="a3e30fabfef9dd0964a957cbc3baa7b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e30fabfef9dd0964a957cbc3baa7b9c">&#9670;&#160;</a></span>getMBarrierMemrefType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MemRefType mlir::nvgpu::getMBarrierMemrefType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MBarrierGroupType</td>          <td class="paramname"><span class="paramname"><em>barrierType</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the memref type that can be used to represent an mbarrier object. </p>

</div>
</div>
<a id="ab3cdfe05b617a4a8ad03a9aa649a740f" name="ab3cdfe05b617a4a8ad03a9aa649a740f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3cdfe05b617a4a8ad03a9aa649a740f">&#9670;&#160;</a></span>getMemrefOperand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::nvgpu::getMemrefOperand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the memref that is loaded from/stored into by the given load/store operation. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2NVGPU_2Transforms_2Utils_8cpp_source.html#l00068">68</a> of file <a class="el" href="Dialect_2NVGPU_2Transforms_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="CreateAsyncGroups_8cpp_source.html#l00152">createAsyncGroups()</a>, and <a class="el" href="CreateAsyncGroups_8cpp_source.html#l00023">isContiguousXferOp()</a>.</p>

</div>
</div>
<a id="a5e5e9578e2fea736fe8b33cdbb846a75" name="a5e5e9578e2fea736fe8b33cdbb846a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5e9578e2fea736fe8b33cdbb846a75">&#9670;&#160;</a></span>getUserContract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; vector::ContractionOp &gt; mlir::nvgpu::getUserContract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first user of the <span class="tt">op</span> that is vector.contract. </p>
<p>If no vector.contract user exists, return failure. </p>

<p class="definition">Definition at line <a class="el" href="MMAUtils_8cpp_source.html#l00048">48</a> of file <a class="el" href="MMAUtils_8cpp_source.html">MMAUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00873">mlir::Operation::getUsers()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorToGPU_8cpp_source.html#l00248">extractStridedSliceSupportsMMAMatrixType()</a>, and <a class="el" href="MMAUtils_8cpp_source.html#l00056">getWarpMatrixInfo()</a>.</p>

</div>
</div>
<a id="ad3cfa52d974ad6a649c45c740364cf10" name="ad3cfa52d974ad6a649c45c740364cf10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3cfa52d974ad6a649c45c740364cf10">&#9670;&#160;</a></span>getValueStored()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::nvgpu::getValueStored </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value that is stored by the given store operation. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2NVGPU_2Transforms_2Utils_8cpp_source.html#l00058">58</a> of file <a class="el" href="Dialect_2NVGPU_2Transforms_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="CreateAsyncGroups_8cpp_source.html#l00152">createAsyncGroups()</a>.</p>

</div>
</div>
<a id="a833cda849d4c16ca9e572b561a3d7c8c" name="a833cda849d4c16ca9e572b561a3d7c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a833cda849d4c16ca9e572b561a3d7c8c">&#9670;&#160;</a></span>getWarpMatrixInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1nvgpu_1_1WarpMatrixInfo.html">WarpMatrixInfo</a> &gt; mlir::nvgpu::getWarpMatrixInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <span class="tt">op</span> is a <span class="tt">vector.transfer_write</span>, return the <span class="tt"><a class="el" href="structmlir_1_1nvgpu_1_1WarpMatrixInfo.html" title="Collects information about a warp-level matrix operand represented by a VectorType.">WarpMatrixInfo</a></span> for the vector operand. </p>
<p>If op is a <span class="tt">vector.transfer_read</span>, <span class="tt">vector.contraction</span>, or <span class="tt">arith.constant</span>, return the <span class="tt"><a class="el" href="structmlir_1_1nvgpu_1_1WarpMatrixInfo.html" title="Collects information about a warp-level matrix operand represented by a VectorType.">WarpMatrixInfo</a></span> corresponding to the result. Otherwise, return failure. </p>

<p class="definition">Definition at line <a class="el" href="MMAUtils_8cpp_source.html#l00056">56</a> of file <a class="el" href="MMAUtils_8cpp_source.html">MMAUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MMAUtils_8h_source.html#l00026">A</a>, <a class="el" href="MMAUtils_8h_source.html#l00026">B</a>, <a class="el" href="MMAUtils_8h_source.html#l00026">C</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00268">mlir::Operation::emitError()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00407">mlir::Operation::getResult()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="MMAUtils_8cpp_source.html#l00048">getUserContract()</a>, <a class="el" href="MMAUtils_8h_source.html#l00036">mlir::nvgpu::WarpMatrixInfo::operandRole</a>, and <a class="el" href="MMAUtils_8h_source.html#l00035">mlir::nvgpu::WarpMatrixInfo::vectorType</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorToGPU_8cpp_source.html#l00638">convertConstantOpMmaSync()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00949">convertExtractStridedSlice()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00865">convertTransferReadToLoads()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00897">convertTransferWriteToStores()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00766">createNonLdMatrixLoads()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00705">creatLdMatrixCompatibleLoads()</a>, and <a class="el" href="VectorToGPU_8cpp_source.html#l00248">extractStridedSliceSupportsMMAMatrixType()</a>.</p>

</div>
</div>
<a id="a481b33225aab10fb527d43e21693576c" name="a481b33225aab10fb527d43e21693576c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481b33225aab10fb527d43e21693576c">&#9670;&#160;</a></span>optimizeSharedMemoryReadsAndWrites()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::LogicalResult mlir::nvgpu::optimizeSharedMemoryReadsAndWrites </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>parentOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>memrefValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Passes. </p>
<p>Optimizes vectorized accesses to a shared memory buffer specified by memrefValue. This transformation assumes the following: 1) All relevant accesses to <span class="tt">memrefValue</span> are contained with <span class="tt">parentOp</span>. 2) The function will fail precondition checks if any subviews are taken of <span class="tt">memrefValue</span>. All reads/writes to <span class="tt">memrefValue</span> should occur through <span class="tt">memrefValue</span> directly.</p>
<p>Shared memory bank conflicts occur when multiple threads attempt to read or write locations assigned to the same shared memory bank. For <span class="tt">2^N</span> byte vectorized accesses, we need to be concerned with conflicts among threads identified as <span class="tt">(tid) -&gt; tid.floordiv(2^{7-N})</span>. As such, this transformation changes any indexed memory access (vector.load, memref.load, nvgpu.ldmatrix, etc) such that the final dimension's index value is permuted such that <span class="tt">newColIndex = oldColIndex % vectorSize +
/ perm[rowIndex](oldColIndex/vectorSize, rowIndex)</span> where <span class="tt">rowIndex</span> is the index for the second-to last dimension and <span class="tt">perm[rowIndex]</span> is a permutation function that depends on the row Index. The permutation function is chosen to ensure that sequential distributed+vectorized reads/writes down a single dimension of the memref have minimal conflicts. </p>

<p class="definition">Definition at line <a class="el" href="OptimizeSharedMemory_8cpp_source.html#l00149">149</a> of file <a class="el" href="OptimizeSharedMemory_8cpp_source.html">OptimizeSharedMemory.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00216">mlir::Operation::getContext()</a>, <a class="el" href="Dialect_2NVGPU_2Transforms_2Utils_8cpp_source.html#l00018">getIndices()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="OptimizeSharedMemory_8cpp_source.html#l00113">getShmReadAndWriteOps()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00262">indices</a>, <a class="el" href="OptimizeSharedMemory_8cpp_source.html#l00039">kDefaultVectorSizeBits</a>, <a class="el" href="OptimizeSharedMemory_8cpp_source.html#l00036">kSharedMemoryLineSizeBytes</a>, <a class="el" href="Dialect_2NVGPU_2Transforms_2Utils_8cpp_source.html#l00038">setIndices()</a>, <a class="el" href="Builders_8h_source.html#l00398">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, <a class="el" href="OptimizeSharedMemory_8cpp_source.html#l00102">transformIndices()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00797">mlir::Operation::walk()</a>.</p>

</div>
</div>
<a id="a7d4c259957fcb36c77d32413688cd447" name="a7d4c259957fcb36c77d32413688cd447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4c259957fcb36c77d32413688cd447">&#9670;&#160;</a></span>populateMmaSyncF32ToTF32Patterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::nvgpu::populateMmaSyncF32ToTF32Patterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a2cd481d969335c7faee4833fd989f8ed">nvgpu::MmaSyncF32Lowering</a></td>          <td class="paramname"><span class="paramname"><em>precision</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a2cd481d969335c7faee4833fd989f8eda7af37e98489130cf59da22f2f9b3c2d6">nvgpu::MmaSyncF32Lowering::TF32</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect patterns to convert mma.sync on f32 input and rewrite to use tensor cores with user provided level of accuracy: (a) tf32 (1 mma.sync per warp-level matrix-multiply-accumulate) (b) tf32x3 (3 mma.sync per warp-level matrix-multiply-accumulate) Typically, tf32 tensor core acceleration comes at a cost of accuracy from missing precision bits. </p>
<p>While f32 has 23 precision bits, tf32 has only 10 precision bits. tf32x3 aims to recover the precision bits by spliting each operand into two tf32 values and issue three mma.sync tensor core operations. </p>

<p class="definition">Definition at line <a class="el" href="MmaSyncTF32Transform_8cpp_source.html#l00065">65</a> of file <a class="el" href="MmaSyncTF32Transform_8cpp_source.html">MmaSyncTF32Transform.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a59a0af50bc6f7b95dea4911516dfb0f8" name="a59a0af50bc6f7b95dea4911516dfb0f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a0af50bc6f7b95dea4911516dfb0f8">&#9670;&#160;</a></span>registerNVGPUPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::nvgpu::registerNVGPUPasses </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OptimizeSharedMemory_8cpp_source.html#l00103">103</a> of file <a class="el" href="OptimizeSharedMemory_8cpp_source.html">OptimizeSharedMemory.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00262">indices</a>, and <a class="el" href="OptimizeSharedMemory_8cpp_source.html#l00046">permuteVectorOffset()</a>.</p>

</div>
</div>
<a id="a5555adb663e26b8a6ee5726cb34d022e" name="a5555adb663e26b8a6ee5726cb34d022e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5555adb663e26b8a6ee5726cb34d022e">&#9670;&#160;</a></span>registerOptimizeSharedMemory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::nvgpu::registerOptimizeSharedMemory </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OptimizeSharedMemory_8cpp_source.html#l00082">82</a> of file <a class="el" href="OptimizeSharedMemory_8cpp_source.html">OptimizeSharedMemory.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>.</p>

</div>
</div>
<a id="aa733fd75fc00ca43f90055a14a49b22f" name="aa733fd75fc00ca43f90055a14a49b22f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa733fd75fc00ca43f90055a14a49b22f">&#9670;&#160;</a></span>registerOptimizeSharedMemoryPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::nvgpu::registerOptimizeSharedMemoryPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OptimizeSharedMemory_8cpp_source.html#l00089">89</a> of file <a class="el" href="OptimizeSharedMemory_8cpp_source.html">OptimizeSharedMemory.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>.</p>

</div>
</div>
<a id="ae64270d2058ef5fd99281df6e7de4464" name="ae64270d2058ef5fd99281df6e7de4464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64270d2058ef5fd99281df6e7de4464">&#9670;&#160;</a></span>registerTransformDialectExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::nvgpu::registerTransformDialectExtension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="RegisterAllExtensions_8cpp_source.html#l00072">mlir::registerAllExtensions()</a>.</p>

</div>
</div>
<a id="ab0258fd3dfe2db8a9b1c2c2206e6fb89" name="ab0258fd3dfe2db8a9b1c2c2206e6fb89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0258fd3dfe2db8a9b1c2c2206e6fb89">&#9670;&#160;</a></span>setIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::nvgpu::setIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the indices that the given load/store operation is operating on. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2NVGPU_2Transforms_2Utils_8cpp_source.html#l00038">38</a> of file <a class="el" href="Dialect_2NVGPU_2Transforms_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00262">indices</a>.</p>

<p class="reference">Referenced by <a class="el" href="OptimizeSharedMemory_8cpp_source.html#l00149">optimizeSharedMemoryReadsAndWrites()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
